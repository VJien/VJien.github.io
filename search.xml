<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI_MoveTo分析和扩展</title>
    <url>/2020/05/27/AI_MoveTo%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="UK2Node-AIMoveTo"><a href="#UK2Node-AIMoveTo" class="headerlink" title="UK2Node_AIMoveTo"></a>UK2Node_AIMoveTo</h2><p><img src="https://img.supervj.top/img/AIMoveTo/move_4.jpg"></p>
<blockquote>
<p>这是我们最熟悉的编辑器模式下的AI_MoveTo节点，也就是那个自带OnSuccess和OnFailed的异步节点，在蓝图中大多数时候使用起来都得心应手非常方便，但是它有个最大的缺点，异步节点意味着他有自己的生命周期，不能放到函数中使用，同样的，在代码中也没有此类节点，那么接下来我们尝试解决这一问题</p>
</blockquote>
<p>翻看此节点的代码，没几行代码,主要看如下</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UK2Node_AIMoveTo::<span class="built_in">UK2Node_AIMoveTo</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">	: <span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">	ProxyFactoryFunctionName = <span class="built_in">GET_FUNCTION_NAME_CHECKED</span>(UAIBlueprintHelperLibrary, CreateMoveToProxyObject);</span><br><span class="line">	ProxyFactoryClass = UAIBlueprintHelperLibrary::<span class="built_in">StaticClass</span>();</span><br><span class="line">	ProxyClass = UAIAsyncTaskBlueprintProxy::<span class="built_in">StaticClass</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现一个关键函数<code>CreateMoveToProxyObject</code>,找到该函数的原型 </p>
<p><code>UAIBlueprintHelperLibrary::CreateMoveToProxyObject</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> UAIAsyncTaskBlueprintProxy * <span class="title">CreateMoveToProxyObject</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    UObject * WorldContextObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    APawn * Pawn,</span></span></span><br><span class="line"><span class="params"><span class="function">    FVector Destination,</span></span></span><br><span class="line"><span class="params"><span class="function">    AActor * TargetActor,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">float</span> AcceptanceRadius,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span> bStopOnOverlap</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>熟悉的参数，就是我们调用AIMoveTo的参数，继续翻代码</p>
<h2 id="UAIBlueprintHelperLibrary-CreateMoveToProxyObject"><a href="#UAIBlueprintHelperLibrary-CreateMoveToProxyObject" class="headerlink" title="UAIBlueprintHelperLibrary::CreateMoveToProxyObject"></a>UAIBlueprintHelperLibrary::CreateMoveToProxyObject</h2><blockquote>
<p><code>UAIBlueprintHelperLibrary</code>函数库的一个方法，返回<code>UAIAsyncTaskBlueprintProxy</code>对象</p>
</blockquote>
<p>看关键代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UAIAsyncTaskBlueprintProxy* MyObj = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 这里需要注意一点，<code>UAIAsyncTaskBlueprintProxy</code>构造以后会存到<code>AISystem</code>内，防止GC销毁</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FAIMoveRequest MoveReq;</span><br><span class="line">		MoveReq.<span class="built_in">SetUsePathfinding</span>(<span class="literal">true</span>);</span><br><span class="line">		MoveReq.<span class="built_in">SetAcceptanceRadius</span>(AcceptanceRadius);</span><br><span class="line">		MoveReq.<span class="built_in">SetReachTestIncludesAgentRadius</span>(bStopOnOverlap);</span><br><span class="line">		<span class="keyword">if</span> (TargetActor)</span><br><span class="line">		&#123;</span><br><span class="line">			MoveReq.<span class="built_in">SetGoalActor</span>(TargetActor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			MoveReq.<span class="built_in">SetGoalLocation</span>(Destination);</span><br><span class="line">		&#125;</span><br><span class="line">		MoveReq.<span class="built_in">SetNavigationFilter</span>(AIController-&gt;<span class="built_in">GetDefaultNavigationFilterClass</span>());</span><br><span class="line">		</span><br><span class="line">		FPathFollowingRequestResult ResultData = AIController-&gt;<span class="built_in">MoveTo</span>(MoveReq);</span><br></pre></td></tr></table></figure>

<p>简单说就是，创建并设置了关键的结构体<code>FAIMoveRequest</code>，然后塞给<code>AIController-&gt;MoveTo(MoveReq);</code>至于<code>AIController</code>干了什么，我们后面再说</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FPathFollowingRequestResult ResultData = AIController-&gt;<span class="built_in">MoveTo</span>(MoveReq);</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (ResultData.Code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> EPathFollowingRequestResult::RequestSuccessful:</span><br><span class="line">	MyObj-&gt;AIController = AIController;</span><br><span class="line">	MyObj-&gt;AIController-&gt;ReceiveMoveCompleted.<span class="built_in">AddDynamic</span>(MyObj, &amp;UAIAsyncTaskBlueprintProxy::OnMoveCompleted);</span><br><span class="line">	MyObj-&gt;MoveRequestId = ResultData.MoveId;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EPathFollowingRequestResult::AlreadyAtGoal:</span><br><span class="line">	World-&gt;<span class="built_in">GetTimerManager</span>().<span class="built_in">SetTimer</span>(MyObj-&gt;TimerHandle_OnInstantFinish, MyObj, &amp;UAIAsyncTaskBlueprintProxy::OnAtGoal, <span class="number">0.1f</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EPathFollowingRequestResult::Failed:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	World-&gt;<span class="built_in">GetTimerManager</span>().<span class="built_in">SetTimer</span>(MyObj-&gt;TimerHandle_OnInstantFinish, MyObj, &amp;UAIAsyncTaskBlueprintProxy::OnNoPath, <span class="number">0.1f</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Controller </code>的<code>MoveTo</code>方法返回一个结果结构体<code>FPathFollowingRequestResult</code>,这里用到结构体内的<code>Code</code>参数，看申明类型是<code>TEnumAsByte&lt;EPathFollowingRequestResult::Type&gt; Code</code></p>
<p>看一下这个枚举</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">namespace</span> EPathFollowingRequestResult</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">Type</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		Failed,</span><br><span class="line">		AlreadyAtGoal,</span><br><span class="line">		RequestSuccessful</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就3个成员，分别是<code>失败/已经到达/请求成功</code></p>
<ul>
<li>对于3个结果分别绑定到本地3个函数<ul>
<li>请求成功：监听AIController内的<code>ReceiveMoveCompleted</code>，绑定到本地<code>OnMoveCompleted</code>,移动结果通过本地多播代理的<code>OnFail</code> 或者<code>OnSuccess</code>广播</li>
<li>失败：0.1秒后执行本地<code>OnNoPath</code>事件，广播<code>OnFail</code>，然后从<code>AISystem</code>移除</li>
<li>已经到达：0.1秒后执行本地事件<code>OnAtGoal</code>，广播<code>OnSuccess</code>，然后从<code>AISystem</code>移除</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结</p>
<p>创建一个代理类，通过<code>AIController</code>执行移动事件，绑定了<code>AIController</code>的移动结果回调事件，把结果通过此代理的2个代理广播</p>
<p>至于为什么用2个类型一样的代理，跟K2Node的使用有关系，理论上用1个代理可以实现一样的作用</p>
</blockquote>
<h2 id="封装蓝图方法"><a href="#封装蓝图方法" class="headerlink" title="封装蓝图方法"></a>封装蓝图方法</h2><h3 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h3><blockquote>
<p>我们先来创建一个<code>UObject</code>类，作为一个移动代理，毕竟移动有生命周期，必须要有个类来管理和监听</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UObject/NoExportTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Navigation/PathFollowingComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AIMoveProxy.generated.h&quot;</span></span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_DELEGATE_OneParam</span>(FMoveEnd, EPathFollowingResult::Type, MovementResult);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UAIAsyncTaskBlueprintProxy</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APawn</span>;</span></span><br><span class="line"><span class="built_in">UCLASS</span>(BlueprintType,Blueprintable)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">INPUTSYS_API</span> <span class="title">UAIMoveProxy</span> :</span> <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	UAIAsyncTaskBlueprintProxy* Proxy;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Proxy_AIMoveTo</span><span class="params">(APawn* Pawn,FVector Des,AActor* Target,<span class="keyword">const</span> FMoveEnd&amp; MoveResult,<span class="keyword">float</span> AcceptanceRadius=<span class="number">5.0</span>,<span class="keyword">bool</span> StopOnOverlap=<span class="literal">false</span>)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MoveEnd</span><span class="params">(EPathFollowingResult::Type Result)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FMoveEnd OnMoveEnd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AIMoveProxy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Blueprint/AIBlueprintHelperLibrary.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Blueprint/AIAsyncTaskBlueprintProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UAIMoveProxy::Proxy_AIMoveTo</span><span class="params">(APawn* Pawn, FVector Des, AActor* Target, <span class="keyword">const</span> FMoveEnd&amp; MoveResult, <span class="keyword">float</span> AcceptanceRadius<span class="comment">/*=5.0*/</span>, <span class="keyword">bool</span> StopOnOverlap<span class="comment">/*=false*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Pawn)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	OnMoveEnd = MoveResult;</span><br><span class="line">	Proxy = UAIBlueprintHelperLibrary::<span class="built_in">CreateMoveToProxyObject</span>(Pawn, Pawn, Des, Target, AcceptanceRadius, StopOnOverlap);</span><br><span class="line">	Proxy-&gt;OnFail.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>,&amp;UAIMoveProxy::MoveEnd);</span><br><span class="line">	Proxy-&gt;OnSuccess.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UAIMoveProxy::MoveEnd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAIMoveProxy::MoveEnd</span><span class="params">(EPathFollowingResult::Type Result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OnMoveEnd.<span class="built_in">ExecuteIfBound</span>(Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到蓝图实现如下图</p>
<p><img src="https://img.supervj.top/img/AIMoveTo/move_2.jpg"></p>
<h3 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h3><p>但是这样还是不是很方便，每次都要手动创建一个类，于是就封装到了函数库里</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Kismet/BlueprintFunctionLibrary.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AIMoveProxy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;FLib_AI.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>(Blueprintable,BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">INPUTSYS_API</span> <span class="title">UFLib_AI</span> :</span> <span class="keyword">public</span> UBlueprintFunctionLibrary</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">	<span class="function"><span class="keyword">static</span> UAIMoveProxy* <span class="title">V_AI_MoveTo</span><span class="params">(APawn* Pawn, FVector Des, AActor* Target, <span class="keyword">const</span> FMoveEnd&amp; MoveResult, <span class="keyword">float</span> AcceptanceRadius = <span class="number">5.0</span>, <span class="keyword">bool</span> StopOnOverlap = <span class="literal">false</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;FLib_AI.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">UAIMoveProxy* <span class="title">UFLib_AI::V_AI_MoveTo</span><span class="params">(APawn* Pawn, FVector Des, AActor* Target, <span class="keyword">const</span> FMoveEnd&amp; MoveResult, <span class="keyword">float</span> AcceptanceRadius, <span class="keyword">bool</span> StopOnOverlap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Pawn) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;;</span><br><span class="line">	UAIMoveProxy* p = NewObject&lt;UAIMoveProxy&gt;(Pawn);</span><br><span class="line">	p-&gt;<span class="built_in">Proxy_AIMoveTo</span>(Pawn, Des, Target, MoveResult, AcceptanceRadius, StopOnOverlap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下图</p>
<p><img src="https://img.supervj.top/img/AIMoveTo/move_3.jpg"></p>
<h2 id="简单剖析一下"><a href="#简单剖析一下" class="headerlink" title="简单剖析一下"></a>简单剖析一下</h2><h3 id="AIController"><a href="#AIController" class="headerlink" title="AIController"></a>AIController</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PathFollowingComponent-&gt;OnRequestFinished.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;AAIController::OnMoveCompleted);</span><br></pre></td></tr></table></figure>

<p>绑定了<code>UPathFollowingComponent</code>的完成事件，我们上面代理监听的事件是从这里来的</p>
<h4 id="MoveTo"><a href="#MoveTo" class="headerlink" title="MoveTo"></a>MoveTo</h4><blockquote>
<p>先贴代码配注释</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FPathFollowingRequestResult <span class="title">AAIController::MoveTo</span><span class="params">(<span class="keyword">const</span> FAIMoveRequest&amp; MoveRequest, FNavPathSharedPtr* OutPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// MoveToActor和MoveToLocation都可以从蓝图/脚本中调用，并且应仅同时保留单个移动请求。</span></span><br><span class="line">	<span class="comment">// 此功能是所有运动机制的切入点-请勿在此处中止操作，因为运动可能由支持堆叠的AITasks处理</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_MoveTo);</span><br><span class="line">	<span class="built_in">UE_VLOG</span>(<span class="keyword">this</span>, LogAINavigation, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;MoveTo: %s&quot;</span>), *MoveRequest.<span class="built_in">ToString</span>());</span><br><span class="line"></span><br><span class="line">	FPathFollowingRequestResult ResultData;</span><br><span class="line">	ResultData.Code = EPathFollowingRequestResult::Failed;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (MoveRequest.<span class="built_in">IsValid</span>() == <span class="literal">false</span>)<span class="comment">//判断请求是否有效，依据是有目标actor类或者不是移动到actor即坐标</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_VLOG</span>(<span class="keyword">this</span>, LogAINavigation, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;MoveTo request failed due MoveRequest not being valid. Most probably desireg Goal Actor not longer exists&quot;</span>), *MoveRequest.<span class="built_in">ToString</span>());</span><br><span class="line">		<span class="keyword">return</span> ResultData;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PathFollowingComponent == <span class="literal">nullptr</span>)<span class="comment">//判断Path组件，默认就有挂载</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_VLOG</span>(<span class="keyword">this</span>, LogAINavigation, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;MoveTo request failed due missing PathFollowingComponent&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> ResultData;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//确保有寻路过滤器</span></span><br><span class="line">	<span class="built_in">ensure</span>(MoveRequest.<span class="built_in">GetNavigationFilter</span>() || !DefaultNavigationFilterClass);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> bCanRequestMove = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">bool</span> bAlreadyAtGoal = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!MoveRequest.<span class="built_in">IsMoveToActorRequest</span>())<span class="comment">//移动到坐标点</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//确保没有垃圾值，以及点在AI系统的最大边界值之内</span></span><br><span class="line">		<span class="keyword">if</span> (MoveRequest.<span class="built_in">GetGoalLocation</span>().<span class="built_in">ContainsNaN</span>() || FAISystem::<span class="built_in">IsValidLocation</span>(MoveRequest.<span class="built_in">GetGoalLocation</span>()) == <span class="literal">false</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">UE_VLOG</span>(<span class="keyword">this</span>, LogAINavigation, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;AAIController::MoveTo: Destination is not valid! Goal(%s)&quot;</span>), <span class="built_in">TEXT_AI_LOCATION</span>(MoveRequest.<span class="built_in">GetGoalLocation</span>()));</span><br><span class="line">			bCanRequestMove = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//确保开启投射，这个参数在请求数据内可以通过set方法设置，默认开启</span></span><br><span class="line">		<span class="keyword">if</span> (bCanRequestMove &amp;&amp; MoveRequest.<span class="built_in">IsProjectingGoal</span>())</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//得到寻路系统</span></span><br><span class="line">			UNavigationSystemV1* NavSys = FNavigationSystem::GetCurrent&lt;UNavigationSystemV1&gt;(<span class="built_in">GetWorld</span>());</span><br><span class="line">            <span class="comment">//得到寻路数据，保存于NavMovementComponent内</span></span><br><span class="line">			<span class="keyword">const</span> FNavAgentProperties&amp; AgentProps = <span class="built_in">GetNavAgentPropertiesRef</span>();</span><br><span class="line">			FNavLocation ProjectedLocation;<span class="comment">//寻路位置，存一个位置和一个数据元素(uint64)</span></span><br><span class="line">			<span class="comment">//确保投射成功，这里给了一个无效extent，在内部有做判断，使用默认寻路数据的extent</span></span><br><span class="line">			<span class="keyword">if</span> (NavSys &amp;&amp; !NavSys-&gt;<span class="built_in">ProjectPointToNavigation</span>(MoveRequest.<span class="built_in">GetGoalLocation</span>(), ProjectedLocation, INVALID_NAVEXTENT, &amp;AgentProps))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">UE_VLOG_LOCATION</span>(<span class="keyword">this</span>, LogAINavigation, Error, MoveRequest.<span class="built_in">GetGoalLocation</span>(), <span class="number">30.f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;AAIController::MoveTo failed to project destination location to navmesh&quot;</span>));</span><br><span class="line">				bCanRequestMove = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//刷新目标点为寻路点</span></span><br><span class="line">			MoveRequest.<span class="built_in">UpdateGoalLocation</span>(ProjectedLocation.Location);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//判断是否到达，具体逻辑在UPathFollowingComponent内，稍复杂</span></span><br><span class="line">		bAlreadyAtGoal = bCanRequestMove &amp;&amp; PathFollowingComponent-&gt;<span class="built_in">HasReached</span>(MoveRequest);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		bAlreadyAtGoal = bCanRequestMove &amp;&amp; PathFollowingComponent-&gt;<span class="built_in">HasReached</span>(MoveRequest);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//如果已经到达就设置结果参数</span></span><br><span class="line">	<span class="keyword">if</span> (bAlreadyAtGoal)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_VLOG</span>(<span class="keyword">this</span>, LogAINavigation, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;MoveTo: already at goal!&quot;</span>));</span><br><span class="line">		ResultData.MoveId = PathFollowingComponent-&gt;<span class="built_in">RequestMoveWithImmediateFinish</span>(EPathFollowingResult::Success);</span><br><span class="line">		ResultData.Code = EPathFollowingRequestResult::AlreadyAtGoal;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//前面判断都过了，就得到建立寻路查询</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (bCanRequestMove)</span><br><span class="line">	&#123;</span><br><span class="line">		FPathFindingQuery PFQuery;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">bool</span> bValidQuery = <span class="built_in">BuildPathfindingQuery</span>(MoveRequest, PFQuery);</span><br><span class="line">		<span class="keyword">if</span> (bValidQuery)</span><br><span class="line">		&#123;</span><br><span class="line">			FNavPathSharedPtr Path;</span><br><span class="line">			<span class="built_in">FindPathForMoveRequest</span>(MoveRequest, PFQuery, Path);</span><br><span class="line"><span class="comment">//RequestMove方法来提交移动的请求</span></span><br><span class="line">			<span class="keyword">const</span> FAIRequestID RequestID = Path.<span class="built_in">IsValid</span>() ? <span class="built_in">RequestMove</span>(MoveRequest, Path) : FAIRequestID::InvalidRequest;</span><br><span class="line">			<span class="keyword">if</span> (RequestID.<span class="built_in">IsValid</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				bAllowStrafe = MoveRequest.<span class="built_in">CanStrafe</span>();</span><br><span class="line">				ResultData.MoveId = RequestID;</span><br><span class="line">				ResultData.Code = EPathFollowingRequestResult::RequestSuccessful;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (OutPath)</span><br><span class="line">				&#123;</span><br><span class="line">					*OutPath = Path;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ResultData.Code == EPathFollowingRequestResult::Failed)</span><br><span class="line">	&#123;</span><br><span class="line">		ResultData.MoveId = PathFollowingComponent-&gt;<span class="built_in">RequestMoveWithImmediateFinish</span>(EPathFollowingResult::Invalid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ResultData;</span><br></pre></td></tr></table></figure>

<p>上面的<code>MoveTo</code>完成了移动的请求即<code>RequestMove</code>，但是具体哪里在执行角色的移动呢，继续翻代码</p>
<h4 id="RequestMove"><a href="#RequestMove" class="headerlink" title="RequestMove"></a>RequestMove</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FAIRequestID <span class="title">AAIController::RequestMove</span><span class="params">(<span class="keyword">const</span> FAIMoveRequest&amp; MoveRequest, FNavPathSharedPtr Path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint32 RequestID = FAIRequestID::InvalidRequest;</span><br><span class="line">	<span class="keyword">if</span> (PathFollowingComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		RequestID = PathFollowingComponent-&gt;<span class="built_in">RequestMove</span>(MoveRequest, Path);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RequestID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PathFollowingComponent"><a href="#PathFollowingComponent" class="headerlink" title="PathFollowingComponent"></a>PathFollowingComponent</h3><p>一顿操作以后调用<code>UPathFollowingComponent::RequestMove</code></p>
<p>代码不贴全，茫茫多的判断以后来到关键的地方</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bIsUsingMetaPath &amp;&amp; Path.<span class="built_in">IsValid</span>() &amp;&amp; Path-&gt;<span class="built_in">IsValid</span>())</span><br><span class="line">&#123;</span><br><span class="line">	Status = EPathFollowingStatus::Moving;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// determine with path segment should be followed</span></span><br><span class="line">	<span class="keyword">const</span> uint32 CurrentSegment = <span class="built_in">DetermineStartingPathPoint</span>(InPath.<span class="built_in">Get</span>());</span><br><span class="line">	<span class="built_in">SetMoveSegment</span>(CurrentSegment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	Status = EPathFollowingStatus::Waiting;</span><br><span class="line">	<span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimerManager</span>().<span class="built_in">SetTimer</span>(WaitingForPathTimer, <span class="keyword">this</span>, &amp;UPathFollowingComponent::OnWaitingPathTimeout, WaitingTimeout);<span class="comment">//等待以后结束寻路移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>艰难通过前面几道判断(什么Idle,Paused等等我们先不管)以后，把状态参数<code>Status</code>改为<code>Moving</code></p>
<p>然后呢？然后这个函数就结束了，继续翻，发现内容就在<code>Tick</code>里面</p>
<h4 id="TickComponent"><a href="#TickComponent" class="headerlink" title="TickComponent"></a>TickComponent</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Status == EPathFollowingStatus::Moving)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 判断是否结束以及刷新分段</span></span><br><span class="line">		<span class="built_in">UpdatePathSegment</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Status == EPathFollowingStatus::Moving)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这个是执行移动的地方</span></span><br><span class="line">		<span class="built_in">FollowPathSegment</span>(DeltaTime);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很好奇，为什么同样一个if判断用2次？</p>
</blockquote>
<p>继续翻<code>FolowPathSegment</code></p>
<h4 id="FolowPathSegment"><a href="#FolowPathSegment" class="headerlink" title="FolowPathSegment"></a>FolowPathSegment</h4><p>完整代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UPathFollowingComponent::FollowPathSegment</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Path.<span class="built_in">IsValid</span>() || MovementComp == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> FVector CurrentLocation = MovementComp-&gt;<span class="built_in">GetActorFeetLocation</span>();</span><br><span class="line">	<span class="keyword">const</span> FVector CurrentTarget = <span class="built_in">GetCurrentTargetLocation</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// set to false by default, we will set set this back to true if appropriate</span></span><br><span class="line">	bIsDecelerating = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bAccelerationBased = MovementComp-&gt;<span class="built_in">UseAccelerationForPathFollowing</span>();</span><br><span class="line">	<span class="keyword">if</span> (bAccelerationBased)</span><br><span class="line">	&#123;</span><br><span class="line">		CurrentMoveInput = (CurrentTarget - CurrentLocation).<span class="built_in">GetSafeNormal</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (MoveSegmentStartIndex &gt;= DecelerationSegmentIndex)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> FVector PathEnd = Path-&gt;<span class="built_in">GetEndLocation</span>();</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">float</span> DistToEndSq = FVector::<span class="built_in">DistSquared</span>(CurrentLocation, PathEnd);</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bShouldDecelerate = DistToEndSq &lt; FMath::<span class="built_in">Square</span>(CachedBrakingDistance);</span><br><span class="line">			<span class="keyword">if</span> (bShouldDecelerate)</span><br><span class="line">			&#123;</span><br><span class="line">				bIsDecelerating = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">float</span> SpeedPct = FMath::<span class="built_in">Clamp</span>(FMath::<span class="built_in">Sqrt</span>(DistToEndSq) / CachedBrakingDistance, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">				CurrentMoveInput *= SpeedPct;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		PostProcessMove.<span class="built_in">ExecuteIfBound</span>(<span class="keyword">this</span>, CurrentMoveInput);</span><br><span class="line">		MovementComp-&gt;<span class="built_in">RequestPathMove</span>(CurrentMoveInput);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		FVector MoveVelocity = (CurrentTarget - CurrentLocation) / DeltaTime;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> int32 LastSegmentStartIndex = Path-&gt;<span class="built_in">GetPathPoints</span>().<span class="built_in">Num</span>() - <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">bool</span> bNotFollowingLastSegment = (MoveSegmentStartIndex &lt; LastSegmentStartIndex);</span><br><span class="line"></span><br><span class="line">		PostProcessMove.<span class="built_in">ExecuteIfBound</span>(<span class="keyword">this</span>, MoveVelocity);</span><br><span class="line">		MovementComp-&gt;<span class="built_in">RequestDirectMove</span>(MoveVelocity, bNotFollowingLastSegment);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就看2个函数<code>MovementComp-&gt;RequestPathMove(CurrentMoveInput);</code>和<code>MovementComp-&gt;RequestDirectMove(MoveVelocity, bNotFollowingLastSegment);</code></p>
<ul>
<li>前者点进去以后啥也没有，原因是基类不做实现，提示至少要从<code>PawnMovementComponent</code>开始才有实现</li>
</ul>
<p>看一下<code>PawnMovementComponent</code> 的实现</p>
<ul>
<li>后者简单设置了一下<code>Velocity</code>变量</li>
</ul>
<h4 id="OnPathFinished"><a href="#OnPathFinished" class="headerlink" title="OnPathFinished"></a>OnPathFinished</h4><p>计算寻路的时候各种判断，最后通过<code>OnRequestFinished</code>广播给监听者</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>AI_MoveTo</code>通过<code>AIController</code>调用<code>UPathFollowingComponent</code>的移动请求方法</p>
<p>在<code>AIController</code>的<code>UPathFollowingComponent</code>得到移动请求后，调用了<code>Pawn</code>内的<code>移动组件</code>的移动方法</p>
<h3 id="PawnMovementComponent"><a href="#PawnMovementComponent" class="headerlink" title="PawnMovementComponent"></a>PawnMovementComponent</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UPawnMovementComponent::RequestPathMove</span><span class="params">(<span class="keyword">const</span> FVector&amp; MoveInput)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (PawnOwner)</span><br><span class="line">	&#123;</span><br><span class="line">		PawnOwner-&gt;<span class="built_in">Internal_AddMovementInput</span>(MoveInput);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绕了一大圈结果<code>Pawn</code>就是通过<code>AddMovement</code>执行路径移动，关于<code>DirectMove</code>在<code>UPawnMovementComponent</code> 中没有实现</p>
<p>继续看看<code>UCharacterMovementComponent</code></p>
<h3 id="UCharacterMovementComponent"><a href="#UCharacterMovementComponent" class="headerlink" title="UCharacterMovementComponent"></a>UCharacterMovementComponent</h3><p>主要执行移动的函数在<code>PerformMovement</code>里，此函数在<code>TickComponent</code>中调用</p>
<p>另外无意中发现了跟其他内容有关系的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MovementMode == MOVE_None || UpdatedComponent-&gt;Mobility != EComponentMobility::Movable || UpdatedComponent-&gt;<span class="built_in">IsSimulatingPhysics</span>())</span><br></pre></td></tr></table></figure>

<p>如果<code>MovementMode</code>设置了<code>None</code> 或者开启物理模拟了就不能移动</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bHasRootMotionSources &amp;&amp; !CharacterOwner-&gt;bClientUpdating &amp;&amp; !CharacterOwner-&gt;bServerMoveIgnoreRootMotion)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( CharacterOwner-&gt;<span class="built_in">IsPlayingRootMotion</span>() &amp;&amp; CharacterOwner-&gt;<span class="built_in">GetMesh</span>() )</span><br><span class="line">			&#123;</span><br></pre></td></tr></table></figure>

<p><code>RootMotion</code>动画优先于移动</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bHasAuthority &amp;&amp; UNetDriver::<span class="built_in">IsAdaptiveNetUpdateFrequencyEnabled</span>() &amp;&amp; UpdatedComponent)</span><br></pre></td></tr></table></figure>

<p>只对权威角色开启移动效果</p>
<p>主要通过<code>MaybeUpdateBasedMovement</code>或者<code>MoveUpdatedComponent</code>方法（在rootmotion情况下）等方法最后调用到方法<code>MoveUpdatedComponentImpl</code>,然后调用<code> UpdatedComponent-&gt;MoveComponent</code></p>
<blockquote>
<p>另外</p>
<p>设置了当前的Velocity以及位置和旋转，也存储了Last和New2份</p>
<p>这个Velocity其实就是2帧渲染的位置插值</p>
</blockquote>
<h3 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h3><h4 id="AddMovement"><a href="#AddMovement" class="headerlink" title="AddMovement"></a>AddMovement</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Pawn.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Internal_AddMovementInput</span><span class="params">(FVector WorldAccel, <span class="keyword">bool</span> bForce = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************//</span></span><br><span class="line">ControlInputVector += WorldAccel;</span><br></pre></td></tr></table></figure>

<p>如果有<code>UCharacterMovementComponent</code>就调用组件里的方法（组件也是直接调用Pawn的内部方法）否则调用自身的内部方法<code>Internal_AddMovementInput</code></p>
<blockquote>
<p>同理用于Get方法</p>
</blockquote>
<p>改变的这个参数用于派生类计算速度值<code>Velocity</code>用于，例如<code>UFloatingPawnMovement::ApplyControlInputToVelocity</code></p>
<p>速度计算要通过<code>USceneComponent</code></p>
<h3 id="刷新位置顺序"><a href="#刷新位置顺序" class="headerlink" title="刷新位置顺序"></a>刷新位置顺序</h3><p>用上面的<strong>速度</strong>变量来刷新位置信息</p>
<p>先看调用顺序，从移动组件的<code>Tick</code>开始</p>
<ol>
<li><code>PerformMovement(DeltaTime)</code></li>
<li><code>MovementComponent::MoveUpdatedComponentImpl(const FVector&amp; Delta,...)</code></li>
<li><code>UpdatedComponent(MovementComponent的parent的rootcomp)-&gt;MoveComponent()</code></li>
<li><code>UpdatedComponent::MoveComponentImpl()</code></li>
<li><code>UpdateComponentToWorld()</code></li>
<li><code>UpdateComponentToWorldWithParent()</code></li>
<li><code>PropagateTransformUpdate()</code></li>
</ol>
<p>到这开始刷新根组件即parent的root的位置、渲染、体积、寻路等信息，同时也刷新子组件的信息，之后引擎的处理可以暂时参考<a href="">由SetActorLocation分析渲染流程</a></p>
<h3 id="其他移动方法"><a href="#其他移动方法" class="headerlink" title="其他移动方法"></a>其他移动方法</h3><ol>
<li><p>诸如<code>SimpleMoveToLocation</code>等<code>AIController</code>内的方法最后都是调用了<code>PathFollowingComponent::RequestMove</code> </p>
</li>
<li><p><strong>AI</strong>行为的<strong>Task</strong>节点，最终调用的也是<code>AIController</code>的<code>MoveTo</code>方法</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img.supervj.top/img/AIMoveTo/AI_MoveTo%E7%AE%80%E5%9B%BE.jpg"></p>
<h2 id="2020-12-31补充"><a href="#2020-12-31补充" class="headerlink" title="2020.12.31补充"></a>2020.12.31补充</h2><h3 id="玩家使用SimpleMoveTo的回调事件"><a href="#玩家使用SimpleMoveTo的回调事件" class="headerlink" title="玩家使用SimpleMoveTo的回调事件"></a>玩家使用SimpleMoveTo的回调事件</h3><p><code>AIMoveTo</code>不能作用于玩家, 关键在于<code>CreateMoveToProxyObject</code>函数中的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AAIController* AIController = Cast&lt;AAIController&gt;(Pawn-&gt;<span class="built_in">GetController</span>());</span><br></pre></td></tr></table></figure>

<p><code>Simple</code>版本可以作用给玩家, 例如<code>Topdown</code>模板内就用此来移动玩家, 但是<code>Simple</code>版本的2个函数没有回调事件, 如果想要得到回调事件如何做?</p>
<p>查看<code>SimpleMoveToActor()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UPathFollowingComponent* PFollowComp = <span class="built_in">InitNavigationControl</span>(*Controller);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UPathFollowingComponent* <span class="title">InitNavigationControl</span><span class="params">(AController&amp; Controller)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		AAIController* AsAIController = Cast&lt;AAIController&gt;(&amp;Controller);</span><br><span class="line">		UPathFollowingComponent* PathFollowingComp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (AsAIController)</span><br><span class="line">		&#123;</span><br><span class="line">			PathFollowingComp = AsAIController-&gt;<span class="built_in">GetPathFollowingComponent</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			PathFollowingComp = Controller.FindComponentByClass&lt;UPathFollowingComponent&gt;();</span><br><span class="line">			<span class="keyword">if</span> (PathFollowingComp == <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				PathFollowingComp = NewObject&lt;UPathFollowingComponent&gt;(&amp;Controller);</span><br><span class="line">				PathFollowingComp-&gt;<span class="built_in">RegisterComponentWithWorld</span>(Controller.<span class="built_in">GetWorld</span>());</span><br><span class="line">				PathFollowingComp-&gt;<span class="built_in">Initialize</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> PathFollowingComp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码看到如果不是<code>AIController</code>也可以, 所以我们玩家才可以使用<code>Simple</code>版本的移动</p>
<p>那么回调事件其实也在该组件内, 即我们需要一个<code>PathFollowingComp</code></p>
<p>在我们的<code>PlayerController</code>内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ASRPlayerController::<span class="built_in">ASRPlayerController</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer) :<span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">	PathFollowingComponent = CreateDefaultSubobject&lt;UPathFollowingComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;PathFollowingComponent&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PathFollowingComponent-&gt;OnRequestFinished.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;ASRPlayerController::MoveComplete);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ASRPlayerController::MoveComplete</span><span class="params">(FAIRequestID RequestID, <span class="keyword">const</span> FPathFollowingResult&amp; Result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Result.<span class="built_in">IsSuccess</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ReceiveMoveComplete</span>(<span class="literal">true</span>,CurrentMoveType);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ReceiveMoveComplete</span>(<span class="literal">false</span>, CurrentMoveType);</span><br><span class="line">	&#125;</span><br><span class="line">	CurrentMoveType = ESRMoveToType::None;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ASRPlayerController::ReceiveMoveComplete_Implementation</span><span class="params">(<span class="keyword">bool</span> bIsSuccess, ESRMoveToType MoveType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CurrentMoveType = ESRMoveToType::None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后蓝图就可以通过事件<code>ReceiveMoveComplete_Implementation</code>得到移动结束的消息, 当然有很多扩展方式, 你完全可以自己继承一个<code>PathFollowingComp</code>来做动态代理广播的方式</p>
<hr>
<h3 id="停止距离"><a href="#停止距离" class="headerlink" title="停止距离"></a>停止距离</h3><p>问题来了, <code>SimpleMoveToActor</code>没有类似<code>AIMoveTo</code>的停止距离, 也不方便</p>
<p>扩展</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;SR|Lib|Movement&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SimpleMoveToForAllController</span><span class="params">(AController* Controller, FVector Destination, AActor* Target, <span class="keyword">float</span> AcceptanceRadius = <span class="number">5.0f</span>, <span class="keyword">bool</span> StopOnOverlap= <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFlib_SRUtilities::SimpleMoveToForAllController</span><span class="params">(AController* Controller, FVector Destination, AActor* Target, <span class="keyword">float</span> AcceptanceRadius <span class="comment">/*= 5.0f*/</span>, <span class="keyword">bool</span> StopOnOverlap<span class="comment">/*= false*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UNavigationSystemV1* NavSys = Controller ? FNavigationSystem::GetCurrent&lt;UNavigationSystemV1&gt;(Controller-&gt;<span class="built_in">GetWorld</span>()) : <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (NavSys == <span class="literal">nullptr</span> || Controller == <span class="literal">nullptr</span> || Controller-&gt;<span class="built_in">GetPawn</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SRWARNING</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;SimpleMoveToForAllController [no NavSys or Controller or pawn]&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UPathFollowingComponent* PFollowComp = Controller-&gt;FindComponentByClass&lt;UPathFollowingComponent&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PFollowComp == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SRWARNING</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;SimpleMoveToForAllController [no UPathFollowingComponent]&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!PFollowComp-&gt;<span class="built_in">IsPathFollowingAllowed</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SRWARNING</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;SimpleMoveToForAllController [not IsPathFollowingAllowed()]&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> bAlreadyAtGoal = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (Target)</span><br><span class="line">	&#123;</span><br><span class="line">		bAlreadyAtGoal = PFollowComp-&gt;<span class="built_in">HasReached</span>(*Target, EPathFollowingReachMode::OverlapAgentAndGoal);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		bAlreadyAtGoal = PFollowComp-&gt;<span class="built_in">HasReached</span>(Destination, EPathFollowingReachMode::OverlapAgentAndGoal);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PFollowComp-&gt;<span class="built_in">GetStatus</span>() != EPathFollowingStatus::Idle)</span><br><span class="line">	&#123;</span><br><span class="line">		PFollowComp-&gt;<span class="built_in">AbortMove</span>(*NavSys, FPathFollowingResultFlags::ForcedScript | FPathFollowingResultFlags::NewRequest</span><br><span class="line">			, FAIRequestID::AnyRequest, bAlreadyAtGoal ? EPathFollowingVelocityMode::Reset : EPathFollowingVelocityMode::Keep);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bAlreadyAtGoal)</span><br><span class="line">	&#123;</span><br><span class="line">		PFollowComp-&gt;<span class="built_in">RequestMoveWithImmediateFinish</span>(EPathFollowingResult::Success);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> FVector AgentNavLocation = Controller-&gt;<span class="built_in">GetNavAgentLocation</span>();</span><br><span class="line">		<span class="keyword">const</span> ANavigationData* NavData = NavSys-&gt;<span class="built_in">GetNavDataForProps</span>(Controller-&gt;<span class="built_in">GetNavAgentPropertiesRef</span>(), AgentNavLocation);</span><br><span class="line">		<span class="keyword">if</span> (NavData)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="function">FPathFindingQuery <span class="title">Query</span><span class="params">(Controller, *NavData, AgentNavLocation, Target?Target-&gt;GetActorLocation():Destination)</span></span>;</span><br><span class="line">			FPathFindingResult Result = NavSys-&gt;<span class="built_in">FindPathSync</span>(Query);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (Result.<span class="built_in">IsSuccessful</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				Result.Path-&gt;<span class="built_in">SetGoalActorObservation</span>(*Target, AcceptanceRadius);</span><br><span class="line">				<span class="comment">//这里不同于Simple版本的方式</span></span><br><span class="line">				FAIMoveRequest MoveReq;</span><br><span class="line">				MoveReq.<span class="built_in">SetUsePathfinding</span>(<span class="literal">true</span>);</span><br><span class="line">				MoveReq.<span class="built_in">SetAcceptanceRadius</span>(AcceptanceRadius);</span><br><span class="line">				MoveReq.<span class="built_in">SetReachTestIncludesAgentRadius</span>(StopOnOverlap);</span><br><span class="line">				<span class="keyword">if</span> (Target)</span><br><span class="line">				&#123;</span><br><span class="line">					MoveReq.<span class="built_in">SetGoalActor</span>(Target);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					MoveReq.<span class="built_in">SetGoalLocation</span>(Destination);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				PFollowComp-&gt;<span class="built_in">RequestMove</span>(MoveReq, Result.Path);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (PFollowComp-&gt;<span class="built_in">GetStatus</span>() != EPathFollowingStatus::Idle)</span><br><span class="line">			&#123;</span><br><span class="line">				PFollowComp-&gt;<span class="built_in">RequestMoveWithImmediateFinish</span>(EPathFollowingResult::Invalid);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>AI_Perception</title>
    <url>/2023/02/01/AI_Percenption/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AI感知是UE自带的一个用于AI发现目标的功能, 使用起来不算麻烦,  本文简单记录一下此模块的内容, 并研究一部分源码看看是否有啥坑 /手动狗头</p>
<span id="more"></span>

<p>感知模块最核心的就是感知组件3个事件, 能返回检测到的Actor以及部分参数</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202141025532.png" alt="image-20230202141025532"></p>
<p>整个模块基本围绕着这一点展开</p>
<h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><ul>
<li>AISystem: AI系统的总管理者, 负责创建<code>UAIPerceptionSystem</code>和<code>UBehaviorTreeManager</code>等等一切AI相关的管理者(单例);</li>
<li>AIPerceptionSystem: AI感知的管理者, 保存了所有Source, Listener和一些重要数据, 另外是作为感知模块的Tick的发起者</li>
<li>AIScense: 感知逻辑的处理对象, 继承出来包括Sight,Hearing等等不同的感知类, 感知的核心逻辑处理都此类里</li>
<li>AISenseConfig: 作为数据配置的类, 主要服务于AIScense类</li>
<li>AIPerceptionStimuliSourceComponent: 用于注册<strong>Source</strong>的组件, 默认情况下Pawn类型的Actor会自动注册</li>
<li>AIPerceptionComponent: 感知组件, 通过<code>AISenseConfig</code>配置感知类型和对应参数, 挂载了此组件的类会自动注册为<strong>Listener</strong></li>
</ul>
<h2 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h2><ol>
<li>AISystem创建AIPerceptionSystem, 并且绑定了ActorSpawn事件,默认情况下如果是Pawn会自动将其注册为Source</li>
<li>在AIPerceptionSystem启动之前, 所有挂载AIPerceptionStimuliSourceComponent和AIPerceptionComponent对象会将自身注册到AIPerceptionSystem系统中</li>
<li>AIPerceptionSystem执行Tick<ol>
<li>遍历所有Sense对象处理对应的感知逻辑</li>
<li>遍历所有Listener(AIPerceptionComponent),  符合条件就广播告知感知目标信息变化</li>
</ol>
</li>
</ol>
<h2 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h2><p>在运行时, 按下标点符号的上引号键可以开启AI Debug, 按小键盘4可以开启Perception的调试</p>
<p>如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202105716134.png" alt="image-20230202105716134"></p>
<h3 id="Sight"><a href="#Sight" class="headerlink" title="Sight"></a>Sight</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202105443258.png" alt="image-20230202105443258"></p>
<p>最基础的视线检测, 比较容易理解, 在视锥体内符合条件的都会被检测到</p>
<p>过程全自动</p>
<ul>
<li>AutoSuccessRangeFromLastSeenLocation: 下面的<code>UAISense_Sight::Update()</code>中有详解</li>
<li>DetectionByAffilliation: 检测的阵营, 看下面的阵营判定</li>
</ul>
<p>检测事件的2个位置参数说明</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202114808869.png" alt="image-20230202114808869"></p>
<h3 id="Hearing"><a href="#Hearing" class="headerlink" title="Hearing"></a>Hearing</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202111011684.png" alt="image-20230202111011684"></p>
<p>听觉, 需要事件触发</p>
<p>Sence_Hearing类在update的时候会刷选所有收到的NoiseEvent, 符合条件的就观察成功</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202110945914.png" alt="image-20230202110945914"></p>
<ul>
<li>如果设置的MaxAge大于0 , 那么过一段时间后会自动遗忘掉这个Source目标</li>
<li>阵营判定同Sight</li>
</ul>
<p>位置数据类似Sight</p>
<h3 id="Damage"><a href="#Damage" class="headerlink" title="Damage"></a>Damage</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202111534938.png" alt="image-20230202111534938"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202111615498.png" alt="image-20230202111615498"></p>
<p>更直接粗暴, 通过事件直接触发, 类似Hearing, 但是没有距离限制</p>
<p>传递的2个FVector关系如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202114947819.png" alt="image-20230202114947819"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>前面三种是最常用的, 一般能够涵盖绝大多数需求, UE还给我们加了几种现成的但是不算很完整的检测</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202135339159.png" alt="image-20230202135339159"></p>
<p>蓝图没有任何API与此相关, cpp也查不到相关的使用, 看上去就是让我们自己扩展的</p>
<p>以Touch为例, 先看源码, 一般只需要去看Update方法内的实现即可</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202135500021.png" alt="image-20230202135500021"></p>
<p>比较简单, 就是需要我们手动的注册一个事件, 然后下一次Update的时候会通知到Listener</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202135558559.png" alt="image-20230202135558559"></p>
<p>封装一个蓝图函数库即可, 需要注意的是2个Actor变量的含义, <code>FAITouchEvent</code>中的<code>TouchReceiver</code>是AI感知组件的拥有者, <code>OtherActor</code>是最终被检测出来的Actor目标(有点奇怪), 所以如果Perception组件是放在AIcontroller上的, 那传递参数就是这样的</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202135741529.png" alt="image-20230202135741529"></p>
<hr>
<p>此外, 还可以用蓝图扩展, 分别是<code>UAISense_Blueprint</code>和<code>UAISenseConfig_Blueprint</code>两个类</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202140143995.png" alt="image-20230202140143995"></p>
<p>Config类里可以随便加变量</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202140423849.png" alt="image-20230202140423849"></p>
<p>同样的, 逻辑处理可以重写上述几个方法, 笔者没有具体尝试, 感觉应该少了一些API, 需要自己扩展</p>
<h2 id="部分代码细节拆分"><a href="#部分代码细节拆分" class="headerlink" title="部分代码细节拆分"></a>部分代码细节拆分</h2><h3 id="Source注册"><a href="#Source注册" class="headerlink" title="Source注册"></a>Source注册</h3><p>注册有几种方式, 之前有提到的Pawn可以自动注册, 还有就是挂载了AIPerceptionStimuliSourceComponent组件的对象, 可以手动调用组件的API注册或者让组件自动注册</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230201192027072.png" alt="image-20230201192027072"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230201192037906.png" alt="image-20230201192037906"></p>
<p>注册后会先存在<code>TArray&lt;FPerceptionSourceRegistration&gt; SourcesToRegister</code>中, 另外Source对应的SenceConfig配置也会新创建对应的Sense类保存在<code>TArray&lt;UAISense*&gt; Senses</code>中</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230201192526913.png" alt="image-20230201192526913"></p>
<h3 id="Listener注册"><a href="#Listener注册" class="headerlink" title="Listener注册"></a>Listener注册</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230201195939180.png" alt="image-20230201195939180"></p>
<p>在<code>AIPerceptionComponent</code>组件初始化的时候会先注册<code>SenseConfig</code>(同Source), 这一步默认是自动的</p>
<p>如果关闭了bStartEnabled, 那么需要手动调用<code>ConfigureSense()</code>重新设置config来启动</p>
<p>接下来刷新Subsystem中的Listener容器, 同样会通知到对应的Sense对象</p>
<h3 id="AIPerceptionSystem-Tick"><a href="#AIPerceptionSystem-Tick" class="headerlink" title="AIPerceptionSystem::Tick"></a>AIPerceptionSystem::Tick</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230201200056378.png" alt="image-20230201200056378"></p>
<p>首先会将Source注册进来的原始数据<code>TArray&lt;FPerceptionSourceRegistration&gt; SourcesToRegister</code>转换成</p>
<p><code>TMap&lt;const AActor*, FPerceptionStimuliSource&gt; RegisteredStimuliSources;</code>, 后续使用的都是后者</p>
<p>此过程中会绑定Actor销毁事件用于移除Source数据, </p>
<p>另外也执行了Sense类的虚函数<code>RegisterTarget()</code></p>
<p>目前<code>RegisterTarget()</code>函数只在Sight类型里实现</p>
<hr>
<p>然后推进所有Sense对象的时间线, 用于控制刷新频率</p>
<p>执行所有Sense对象的Tick, 最终会执行每个Sense对象的<code>Update()</code>虚函数</p>
<hr>
<p>最后是执行所有Listener对象的<code>UAIPerceptionComponent</code>组件的<code>ProcessStimuli()</code>函数</p>
<hr>
<h3 id="UAISense-Sight-RegisterSource"><a href="#UAISense-Sight-RegisterSource" class="headerlink" title="UAISense_Sight::RegisterSource"></a>UAISense_Sight::RegisterSource</h3><p>主要做了一件事, 初始化或者刷新保存的观察对象的重要性</p>
<p>这里发现这里获取了一下观察目标的队伍ID, 但是并没有使用</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230201164409501.png" alt="image-20230201164409501"></p>
<h3 id="UAISense-Sight-Update"><a href="#UAISense-Sight-Update" class="headerlink" title="UAISense_Sight::Update()"></a>UAISense_Sight::Update()</h3><p>首先遍历所有在实现内和实现外对象的Score</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230201165536739.png" alt="image-20230201165536739"></p>
<p>Score由注册时的重要性和Age决定, 下图大致看一下这些数据</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230201165811137.png" alt="image-20230201165811137"></p>
<p>然后开始检测逻辑</p>
<p>自上而下if/else</p>
<ul>
<li>自动检测</li>
</ul>
<p>如果AutoSuccessRangeFromLastSeenLocation的值大约0, 那么这一步会开启;</p>
<p>意思是如果当前目标在发现他的位置一定范围内, 那么就不会重新查找, 继续保持这个位置, 算是性能优化的一部分</p>
<p> 具体实现可以去看虚函数<code>ShouldAutomaticallySeeTarget()</code></p>
<ul>
<li>视锥检测</li>
</ul>
<p>顾名思义的AI的视锥范围检测, 这里有射线检测来判断是否有遮挡物的存在</p>
<blockquote>
<p>这里有一个扩展选项, 如果Source单位继承了<code>IAISightTargetInterface</code>接口可以重写一些视线检测方法</p>
</blockquote>
<ul>
<li>已经记住的目标</li>
</ul>
<p>之前的目标如果没有被遗忘, 那么继续把上一次的目标作为当前目标返回</p>
<hr>
<p>最后会让减少生命周期从而降低前面提到过的Score</p>
<h3 id="UAIPerceptionComponent-ProcessStimuli"><a href="#UAIPerceptionComponent-ProcessStimuli" class="headerlink" title="UAIPerceptionComponent::ProcessStimuli()"></a>UAIPerceptionComponent::ProcessStimuli()</h3><p>这里就是对前面传入的<code>StimuliToProcess</code>对象数组进行遍历处理, 把合适的数据广播出去, 重点不多,</p>
<p>主要是对检测生命周期的处理和判断, 然后广播对应事件以及处理Forgot对象</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230201201528268.png" alt="image-20230201201528268"></p>
<h3 id="阵营判定"><a href="#阵营判定" class="headerlink" title="阵营判定"></a>阵营判定</h3><p>阵营判定在几个地方有用到, 如在sight和hearing中有检测阵营的选项, 默认勾选了Enemies的检测, 如果什么都不做, 那么是只能检测到中立单位(查找目标也是中立, 所有source也是中立)</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230201205546756.png" alt="image-20230201205546756"></p>
<p>Sense类里的阵营判断就在上图中的2条, 在<code>RegisterTarget()</code>中会进行判定</p>
<p>仔细看源码会发现用了很多的位运算,  一眼看去还是不太容易理解</p>
<p>这个要结合几个地方一起看</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202093703946.png" alt="image-20230202093703946"></p>
<p>首先Source对象actor需要继承<code>IGenericTeamAgentInterface</code>, 否则都会被当做中立</p>
<p>然后重写其中的方法, 将TeamID传递进去, 如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202094305439.png" alt="image-20230202094305439"></p>
<p>然后需要关注<code>FGenericTeamId</code>中几个全局静态方法</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230202094158984.png" alt="image-20230202094158984"></p>
<p>可以看到有一个解算类,  如果不进行什么操作会使用默认的方法, 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ETeamAttitude::Type <span class="title">DefaultTeamAttitudeSolver</span><span class="params">(FGenericTeamId A, FGenericTeamId B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A != B ? ETeamAttitude::Hostile : ETeamAttitude::Friendly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意味着只要不相等,那都是敌对, 基本也符合, 那如果我们要把中立怪也当做非敌对关系, 就需要自己写一个方法再设置一下, 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">ETeamAttitude::Type <span class="title">NextTeamAttitudeSolver</span><span class="params">(FGenericTeamId A, FGenericTeamId B)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (A == B || A == ETeamAttitude::Neutral || B == ETeamAttitude::Neutral)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> ETeamAttitude::Friendly;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> ETeamAttitude::Hostile;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//return A == B ? ETeamAttitude::Friendly : ETeamAttitude::Hostile;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在合适的实际设置一下即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FGenericTeamId::<span class="built_in">SetAttitudeSolver</span>(&amp;NextTeamAttitudeSolver);</span><br></pre></td></tr></table></figure>

<p>这样Perception中的阵营判定就能正常的作用了</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>AdvanceLocomotionSystem总结</title>
    <url>/2021/10/08/AdvanceLocomotionSystem%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文再次对ALS进行一个总结, 重点看动画状态机部分, 数据结构和计算部分不重点关注</p>
<blockquote>
<p>本文含有大量动图, 加载比较慢</p>
</blockquote>
<img src="https://img.supervj.top/imgimage-20211009152453736.png" alt="image-20211009152453736" style="zoom:80%;" />



<span id="more"></span>



<h2 id="骨骼分层与动画叠加"><a href="#骨骼分层与动画叠加" class="headerlink" title="骨骼分层与动画叠加"></a>骨骼分层与动画叠加</h2><p>ALS的一大特色就是基于基础动作及Pose，通过叠加、混合等方式实现基础动作的复用和灵活的扩展, 同时用骨骼分层结合大量曲线来控制不同身体部位的混合情况</p>
<h3 id="一般的动画叠加"><a href="#一般的动画叠加" class="headerlink" title="一般的动画叠加"></a>一般的动画叠加</h3><p><img src="https://img.supervj.top/imgimage-20211009150617724.png" alt="image-20211009150617724"></p>
<p><img src="https://img.supervj.top/imgimage-20211009151142804.png" alt="image-20211009151142804"></p>
<p>上面就是多数情况我们使用的动画叠加方式</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_14_30_38_692.gif" alt="录制_2021_09_30_14_30_38_692" style="zoom:50%;" />  + <img src="https://img.supervj.top/imgimage-20211009150933899.png" alt="image-20211009150933899" style="zoom:150%;" /> =  <img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_09_09_06_45_546.gif" alt="录制_2021_10_09_09_06_45_546" style="zoom:80%;" /></p>
<p>如果按照上面所示简单暴力的叠加, 那么结果很奇葩, 下面我们看一下ALS的实现方案</p>
<h3 id="MakeDynamicAdditive"><a href="#MakeDynamicAdditive" class="headerlink" title="MakeDynamicAdditive"></a>MakeDynamicAdditive</h3><p>ALS并没有大量的把动画序列改成Additive模式，而是程序化的生成叠加数据， 这里保存了局部空间和模型空间的2个叠加数据缓存</p>
<p><img src="https://img.supervj.top/imgimage-20211008165102735.png" alt="image-20211008165102735"></p>
<p><img src="https://img.supervj.top/imgimage-20211008165120365.png" alt="image-20211008165120365"></p>
<h3 id="骨骼分层"><a href="#骨骼分层" class="headerlink" title="骨骼分层"></a>骨骼分层</h3><p><img src="https://img.supervj.top/imgimage-20211008165148667.png" alt="image-20211008165148667"></p>
<p><img src="https://img.supervj.top/imgimage-20211008165151805.png" alt="image-20211008165151805"></p>
<p>以左手臂举例<br>通过曲线<code>Layering_Arm_L</code>来选择是使用默认动画还是使用叠加动画（ALS里这条曲线非0即1）<br>再通过变量<code>ArmLAdd</code>（从曲线获取）来选择是使用单帧动作还是叠加上基础运动动画<br>上图两个几乎完全一样的节点区别是使用<strong>局部/模型旋转</strong></p>
<p>翻译成人话就是如下</p>
<p><img src="https://img.supervj.top/imgimage-20211009151343926.png" alt="image-20211009151343926"></p>
<p>看一下效果</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_09_09_32_24_117.gif" alt="录制_2021_10_09_09_32_24_117"></p>
<hr>
<p>当然, 如果按照传统的方式也能做出来, 只不过不论是逻辑还是资源方面都没啥优势</p>
<p><img src="https://img.supervj.top/imgimage-20211009151435478.png" alt="image-20211009151435478"></p>
<h3 id="再举个例"><a href="#再举个例" class="headerlink" title="再举个例"></a>再举个例</h3><p><img src="https://img.supervj.top/imgimage-20211008165304636.png" alt="image-20211008165304636" style="zoom:165%;" />+<img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_14_30_38_692.gif" alt="录制_2021_09_30_14_30_38_692" style="zoom:50%;" /> =<img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_14_31_49_884.gif" alt="录制_2021_09_30_14_31_49_884" style="zoom:50%;" /></p>
<p>上图所展示的是基础单帧Pose + 走路动作 = 最后的动作</p>
<hr>
<p><img src="https://img.supervj.top/img%E5%B1%8F%E5%B9%95%E6%8D%95%E8%8E%B7_2021_09_30_14_37_09_399.png" alt="屏幕捕获_2021_09_30_14_37_09_399" style="zoom:50%;" /> + <img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_14_30_38_692.gif" alt="录制_2021_09_30_14_30_38_692" style="zoom:50%;" /> = </p>
<img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_14_37_47_252.gif" alt="录制_2021_09_30_14_37_47_252" style="zoom:50%;" />



<p>上图所展示的是双手持手枪单帧Pose + 走路动作 = 最后的动作<br>什么变化？<br>我们看到手臂的颜色是白色的，这里代表着手臂使用了另外的方式参与了全身动画的实现</p>
<blockquote>
<p>颜色说明：<br>红色：完全叠加<br>白色：使用单帧动画<br>黑色：不使用分层动画（即使用基础层的动画，这里暂时没有)</p>
</blockquote>
<hr>
<p><img src="https://img.supervj.top/img%E5%B1%8F%E5%B9%95%E6%8D%95%E8%8E%B7_2021_09_30_15_25_01_128.png" alt="屏幕捕获_2021_09_30_15_25_01_128" style="zoom:50%;" />  + <img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_14_30_38_692.gif" alt="录制_2021_09_30_14_30_38_692" style="zoom:50%;" />  = <img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_15_16_40_582.gif" alt="录制_2021_09_30_15_16_40_582" style="zoom:50%;" /></p>
<p>上面所展示的是双手持步枪单帧Pose + 走路动作 = 最后的动作<br>什么变化？<br>左手是粉色的，意味着左手叠加了一部分基础动作</p>
<hr>
<p>下面我们来对比一下叠加与否的效果</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_15_17_32_569.gif" alt="录制_2021_09_30_15_17_32_569"></p>
<p>手臂使用单帧Pose动作，其余叠加上基础层的运动数据</p>
<hr>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_15_18_50_693.gif" alt="录制_2021_09_30_15_18_50_693"></p>
<p>右手叠加上基础层的运动数据</p>
<hr>
<img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_15_16_40_582.gif" alt="录制_2021_09_30_15_16_40_582" style="zoom:100%;" />



<p>ALS的方案，右手稍微叠加了一点运动数据</p>
<hr>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_15_44_16_235.gif" alt="录制_2021_09_30_15_44_16_235"></p>
<p>测试一下蒙太奇的播放,  ALS本身没有换弹动作，借用其他项目的动作测试（动作本身不匹配）</p>
<p>可以看到左手可以正常播放蒙太奇动画，但是无法正确保持Aim角度，这是因为ALS的<code>ArmSlot</code>在Aim处理的外层，这是问题</p>
<hr>
<h3 id="其他动画叠加测试"><a href="#其他动画叠加测试" class="headerlink" title="其他动画叠加测试"></a>其他动画叠加测试</h3><ul>
<li>Epic初始射击动画包</li>
</ul>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_09_13_40_24_582.gif" alt="录制_2021_10_09_13_40_24_582"></p>
<ul>
<li>Mage动画包</li>
</ul>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_09_14_53_31_277.gif" alt="录制_2021_10_09_14_53_31_277"></p>
<ul>
<li>TwoHandSword动画包</li>
</ul>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_09_14_53_54_271.gif" alt="录制_2021_10_09_14_53_54_271"></p>
<blockquote>
<p>ALS没有单独的上半身分层, 而是拆开了左右手臂,  有些时候反而不太方便, 如果有需要可以单独加一个上半身分层</p>
<p>另外Rootmotion动画播放时需要视情况在蒙太奇动画里设置相应的曲线, 可以参考ALS的Roll动画</p>
</blockquote>
<h2 id="分层状态机"><a href="#分层状态机" class="headerlink" title="分层状态机"></a>分层状态机</h2><p><img src="https://img.supervj.top/imgimage-20211008170135584.png" alt="image-20211008170135584"></p>
<ul>
<li>一张图概括所有状态机分层</li>
</ul>
<p><img src="https://img.supervj.top/imgimage-20211008170417614.png" alt="image-20211008170417614"></p>
<h3 id="Locomotion-Cycles层"><a href="#Locomotion-Cycles层" class="headerlink" title="Locomotion Cycles层"></a>Locomotion Cycles层</h3><p>实现了8方向的移动, 以及移动Lean效果的叠加</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_09_40_46_621.gif" alt="录制_2021_10_08_09_40_46_621"></p>
<p><strong>关注点</strong></p>
<ul>
<li>六变形的状态机</li>
<li>RB和LB实际上是过渡节点, 目的是完成pelvis的转向</li>
<li>ALS的一个小技巧: 45度的移动在刚开始使用了两个方向的混合动作, 但是逐步的会单独使用F/B的动画结合角色的旋转来实现</li>
</ul>
<p><strong>缺陷</strong></p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_09_53_55_267.gif" alt="录制_2021_10_08_09_53_55_267"></p>
<p>如上图, LF到B的过程, 因为没有单独的pelvis翻转动画, 导致腿部有明显的穿帮现象, 同样的也会出现在RF到B的过程</p>
<h3 id="Locomotion-Detail层"><a href="#Locomotion-Detail层" class="headerlink" title="Locomotion Detail层"></a>Locomotion Detail层</h3><p>实现起步的动画叠加效果</p>
<p><img src="https://img.supervj.top/imgimage-20211008170713506.png" alt="image-20211008170713506"></p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_10_11_58_328.gif" alt="录制_2021_10_08_10_11_58_328"></p>
<p>ALS没有起步动作, 即通过<strong>混合完成Idle-&gt;Run的过程</strong>, Walk -&gt; Run 的过渡中叠加了一个上图所示的动作 </p>
<p>对比一下叠加前后的区别</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_10_23_26_691.gif" alt="录制_2021_10_08_10_23_26_691"></p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_10_23_55_919.gif" alt="录制_2021_10_08_10_23_55_919"></p>
<h3 id="Locomotion-States层"><a href="#Locomotion-States层" class="headerlink" title="Locomotion States层"></a>Locomotion States层</h3><p>实现停步和循环转身动画, 这里我们重点讲一下停步</p>
<p><img src="https://img.supervj.top/imgimage-20211008170831251.png" alt="image-20211008170831251"></p>
<p>实现停步比较复杂, 需要关注下面几个技术点</p>
<ul>
<li>脚步曲线</li>
<li>IK锁脚</li>
<li>停步动画</li>
</ul>
<h4 id="脚步曲线"><a href="#脚步曲线" class="headerlink" title="脚步曲线"></a>脚步曲线</h4><p><img src="https://img.supervj.top/imgimage-20211008170903029.png" alt="image-20211008170903029"></p>
<p>ALS通过曲线设定是否有脚踩到地面, 或者哪只脚更靠近地面<br>有些简单的实现方案会使用动画通知来设定当前是哪只脚落地, 但并没有考虑两脚都腾空的情况</p>
<h4 id="IK锁脚"><a href="#IK锁脚" class="headerlink" title="IK锁脚"></a>IK锁脚</h4><p><img src="https://img.supervj.top/imgimage-20211008170930765.png" alt="image-20211008170930765"></p>
<p>IK锁脚需要根据脚步曲线来分2种情况</p>
<ol>
<li>有脚踩到地面</li>
<li>双脚腾空状态</li>
</ol>
<h4 id="停步动画"><a href="#停步动画" class="headerlink" title="停步动画"></a>停步动画</h4><p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_10_58_15_857.gif" alt="录制_2021_10_08_10_58_15_857"></p>
<p><img src="https://img.supervj.top/imgimage-20211008170958834.png" alt="image-20211008170958834"></p>
<p>如果右脚踩地<br>那么播放左图动画, 结合动画曲线来控制脚步IK  (ALS 脚步IK计算较为复杂,这里暂不具体展开)</p>
<hr>
<p><img src="https://img.supervj.top/imgimage-20211008171020411.png" alt="image-20211008171020411"></p>
<p>如果双脚腾空但是右脚靠近地面<br>那么同样播放右脚踩地动画, 同时右腿快速混合至左图的单帧动画</p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_11_10_54_97.gif" alt="录制_2021_10_08_11_10_54_97"></p>
<h3 id="Ground层"><a href="#Ground层" class="headerlink" title="Ground层"></a>Ground层</h3><p>Ground层主要做了一件事, 即 <strong>姿势切换</strong></p>
<p><img src="https://img.supervj.top/imgimage-20211008171124876.png" alt="image-20211008171124876"></p>
<p><strong>关注点</strong><br>状态切换中间加了管道保护，判定当前没有Action执行的时候才进行姿态跳转</p>
<p><img src="https://img.supervj.top/imgimage-20211008171136433.png" alt="image-20211008171136433"></p>
<h3 id="States层"><a href="#States层" class="headerlink" title="States层"></a>States层</h3><p>最外层的状态机，用于切换姿势，后期扩展游泳/攀爬等可以放到这里</p>
<p><img src="https://img.supervj.top/imgimage-20211008171157709.png" alt="image-20211008171157709"></p>
<ul>
<li>ALS用一个来自角色设置的bJump来判定是Falling还是Jump</li>
<li>落地以后根据速度和输入情况叠加了下蹲姿势</li>
</ul>
<p>对比一下</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_16_27_43_334.gif" alt="录制_2021_09_30_16_27_43_334"></p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_09_30_16_28_36_718.gif" alt="录制_2021_09_30_16_28_36_718"></p>
<h3 id="FootIK层"><a href="#FootIK层" class="headerlink" title="FootIK层"></a>FootIK层</h3><p><img src="https://img.supervj.top/imgimage-20211008171243884.png" alt="image-20211008171243884"></p>
<h4 id="虚拟骨骼"><a href="#虚拟骨骼" class="headerlink" title="虚拟骨骼"></a>虚拟骨骼</h4><p><img src="https://img.supervj.top/imgimage-20211008171254672.png" alt="image-20211008171254672"></p>
<ul>
<li>ALS使用了很多虚拟骨骼来辅助计算TwoBoneIK</li>
<li><code>ik_foot</code>骨骼用于锁脚</li>
<li><code>VB_foot_offset</code>作为TwoBoneIK的效应器</li>
<li><code>VB_foot_target</code>用于判断脚步是不是距离期望位置有偏差, 如有就播放单脚过渡动画(看上去像把这只脚收回来)</li>
<li>ALS的移动动画的<code>ik_foot</code>骨骼都有数据, IK效应器的位置计算依赖此骨骼的位置信息, 所以在此方案下无法使用UE4自带的移动动画, 理论上有替代方案, 额外的VB?  否则需要对动画制作提出要求</li>
</ul>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_15_23_41_720.gif" alt="录制_2021_10_08_15_23_41_720"></p>
<h4 id="设置FootIK"><a href="#设置FootIK" class="headerlink" title="设置FootIK"></a>设置FootIK</h4><p><img src="https://img.supervj.top/imgimage-20211008171354650.png" alt="image-20211008171354650"></p>
<p><img src="https://img.supervj.top/imgimage-20211008171359397.png" alt="image-20211008171359397"></p>
<p>ALS在Ground层直接通过<code>ModifyCurve</code>开启了FootIK, 部分动画比如攀爬动作通过曲线动态开启/关闭FootIk</p>
<h3 id="Ragdoll层"><a href="#Ragdoll层" class="headerlink" title="Ragdoll层"></a>Ragdoll层</h3><h4 id="进入Ragdoll"><a href="#进入Ragdoll" class="headerlink" title="进入Ragdoll"></a>进入Ragdoll</h4><p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_13_55_02_287.gif" alt="录制_2021_10_08_13_55_02_287"></p>
<p><strong>执行顺序</strong></p>
<ul>
<li>修改移动状态为None</li>
<li>状态机进入Ragdoll(播放Flail动画)</li>
<li>设置碰撞</li>
<li>SetAllBodiesBelowSimulatePhysics</li>
<li>停止当前蒙太奇</li>
<li>根据模型位置持续设置当前Actor的位置(图中的胶囊碰撞是渲染问题,真实的胶囊体跟随着角色)</li>
</ul>
<h4 id="退出Ragdoll"><a href="#退出Ragdoll" class="headerlink" title="退出Ragdoll"></a>退出Ragdoll</h4><p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_13_57_26_826.gif" alt="录制_2021_10_08_13_57_26_826"></p>
<ul>
<li>保存当前快照(SnapShot)</li>
<li>恢复移动状态</li>
<li>播放起身动画(根据pelvis朝向)</li>
<li>恢复碰撞</li>
<li>恢复物理效果</li>
<li>基于快照混合至其他动画层</li>
</ul>
<h2 id="攀爬"><a href="#攀爬" class="headerlink" title="攀爬"></a>攀爬</h2><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p><img src="https://img.supervj.top/imgimage-20211008171627452.png" alt="image-20211008171627452"></p>
<ul>
<li>向前射线检测，检查前方是否有角色无法直接走上去的障碍物</li>
<li>从上一个碰撞点上方向下进行射线检测，并确保该碰撞位置角色能行走</li>
<li>检查攀爬点是否有足够空间容纳胶囊体，如果有则将该位置设为目标变换(Target Transform)并且计算障碍物相对高度(Mantle Height)</li>
<li>通过当前的Movement State以及障碍物高度决定攀爬的类型</li>
<li>传递参数，开始攀爬(Mantle Start)</li>
</ul>
<h3 id="攀爬-1"><a href="#攀爬-1" class="headerlink" title="攀爬"></a>攀爬</h3><p><img src="https://img.supervj.top/imgimage-20211008171704410.png" alt="image-20211008171704410"></p>
<p><img src="https://img.supervj.top/imgimage-20211008171707898.png" alt="image-20211008171707898"></p>
<ul>
<li>将世界坐标系中的攀爬目标的Transform转换成以障碍物Component为基准的局部坐标系</li>
<li>初始化攀爬目标(Mantle Target)和攀爬实际偏差量(Mantle Actual Start Offset)</li>
<li>初始化攀爬动画偏差量(Mantle Animated Start Offset)</li>
<li>设置Timeline,关键是让Timeline的长度和曲线实际长度（曲线总长减去起点位置）相同, Timeline的PlayRate和动画的PlayRate也必须相同;设置完毕后，开启Timeline</li>
<li>从预设曲线中获取XYZ的Alpha值做插值计算(ALS这里用了4个lerp)</li>
</ul>
<h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_14_46_10_531.gif" alt="录制_2021_10_08_14_46_10_531"></p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_08_11_11_51_847.gif" alt="录制_2021_10_08_11_11_51_847"></p>
<h2 id="相机系统"><a href="#相机系统" class="headerlink" title="相机系统"></a>相机系统</h2><p>一个没有动画的动画蓝图</p>
<p>主要做了如下几件事</p>
<ul>
<li>自定义CameraManager代替默认第三人称模板的SpringArm+Camera的方式</li>
<li>重写BlueprintUpdateCamera</li>
<li>CameraManager挂载骨骼模型相机，创建动画蓝图，用曲线来控制相机位置信息</li>
</ul>
<p><img src="https://img.supervj.top/imgimage-20211008171832050.png" alt="image-20211008171832050"></p>
<p><img src="https://img.supervj.top/imgimage-20211008171842911.png" alt="image-20211008171842911"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://supervj.top/2020/10/26/AdvancedLocomotionSystem%E5%88%86%E6%9E%901_%E5%9F%BA%E7%A1%80%E7%A7%BB%E5%8A%A8%E5%92%8C%E8%84%9A%E6%AD%A5IK/?highlight=adva">我之前的旧文</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/399965941">知乎老王</a></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>AdvancedLocomotionSystemV4分析(二):攀爬系统</title>
    <url>/2020/10/27/AdvancedLocomotionSystem%E5%88%86%E6%9E%902_%E6%94%80%E7%88%AC%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>ALS系统的攀爬系统思路比较简单，播放蒙太奇配合位置的刷新。缺点是没有中间状态，意味着无法打断或者做平移等</p>
<p>后面我打算尝试改成加入中间过程的攀爬系统</p>
</blockquote>
<p><a href="https://supervj.top/2020/10/26/AdvancedLocomotionSystem%E5%88%86%E6%9E%901_%E5%9F%BA%E7%A1%80%E7%A7%BB%E5%8A%A8%E5%92%8C%E8%84%9A%E6%AD%A5IK/">AdvancedLocomotionSysemV4分析(一):移动和脚步IK</a></p>
<p><a href="https://supervj.top/2020/10/28/AdvancedLocomotionSystem%E5%88%86%E6%9E%903_%E5%8A%A8%E4%BD%9C%E5%8F%A0%E5%8A%A0/">AdvancedLocomotionSystemV4分析(三):动作叠加</a></p>
<p><a href="https://supervj.top/2020/10/29/AdvancedLocomotionSystem%E5%88%86%E6%9E%904_%E5%B8%83%E5%A8%83%E5%A8%83%E5%92%8C%E8%B5%B7%E8%BA%AB/">AdvancedLocomotionSystemV4分析(四):布娃娃和起身</a></p>
<p><a href="https://supervj.top/2020/10/31/AdvancedLocomotionSystem%E5%88%86%E6%9E%905_%E9%95%9C%E5%A4%B4/">AdvancedLocomotionSystemV4分析(五):镜头</a></p>
<span id="more"></span>

<h3 id="检测-ClimbCheck"><a href="#检测-ClimbCheck" class="headerlink" title="检测/ClimbCheck"></a>检测/ClimbCheck</h3><p>原工程里的<code>Climb</code>用的是<code>Mantle</code>，作为一个英文盲还是改成了自己看得懂的单词</p>
<p><img src="https://img.supervj.top/img/temp/image-20201028165706917.png" alt="image-20201028165706917"></p>
<p><img src="https://img.supervj.top/img/temp/image-20201028165823436.png" alt="image-20201028165823436"></p>
<p>先要从输入开始，起跳输入以后在状态改为<code>InAir</code>之前就做了一次检测，另外在<code>Tick</code>中有检测</p>
<ul>
<li>TraceSetting<ul>
<li>MaxLedgeHeight</li>
<li>MinLedgeHeight</li>
<li>ReachDistance</li>
<li>ForwardTraceRadius</li>
<li>DownwardTraceRadius</li>
</ul>
</li>
</ul>
<p>此数据结构是配置好的常量，分<code>Fall</code>、<code>Grounded</code>、<code>Automatic</code>三种配置</p>
<hr>
<ul>
<li>总览</li>
</ul>
<p><img src="https://img.supervj.top/img/temp/image-20201028170206771.png" alt="image-20201028170206771"></p>
<p>思路是比较简单，但是算法略复杂</p>
<ol>
<li>自身身体部位打一个胶囊体射线，射线始末点跟传入参数的最高/最低墙高度和ReachDistance有关系，得到墙体上的点和发现</li>
<li>从上往下打射线得到适合的落脚点位置</li>
<li>判断落脚点是否有足够的空间站人</li>
<li>根据所需要攀爬的高度来设置攀爬类型</li>
<li>开始攀爬</li>
</ol>
<h3 id="开始攀爬-ClimbStart"><a href="#开始攀爬-ClimbStart" class="headerlink" title="开始攀爬/ClimbStart"></a>开始攀爬/ClimbStart</h3><p><img src="https://img.supervj.top/img/temp/image-20201028170736835.png" alt="image-20201028170736835"></p>
<p>一切围绕两点</p>
<ol>
<li><p>算出播放的动画参数，包括动画蒙太奇以及播放速率等</p>
</li>
<li><p>算出播放动画时所需要更新的位置信息</p>
</li>
</ol>
<p>实现思路是</p>
<ol>
<li>根据攀爬类型和当前叠加的状态(目前还没有实现，可以理解为受伤或者拿某种武器的姿势下的不一样的动画参数)得到相应的动画参数<img src="https://img.supervj.top/img/temp/image-20201028171040513.png" alt="image-20201028171040513">上图即使默认的2米高度攀爬的参数</li>
<li>把<code>Climb Check</code>函数得到的墙体位置信息转化为墙体本地空间的位置信息</li>
<li>计算得到角色位置和墙体最后位置的世界空间偏差</li>
<li>计算得到动画位置偏差，这个可以理解为攀爬动作本身就有唯一，这个位置偏差就是动画本身会造成的偏差。这里我们的动画都是锁定根骨骼的，意味着我们手动计算位置而非用动画本身的RootMotion</li>
<li>设置运动模式</li>
<li>根据动画参数设置<code>TimeLine</code>以及启动<code>TimeLine</code></li>
<li>播放攀爬动画</li>
</ol>
<h3 id="刷新攀爬位置-ClimbUpdate"><a href="#刷新攀爬位置-ClimbUpdate" class="headerlink" title="刷新攀爬位置/ClimbUpdate"></a>刷新攀爬位置/ClimbUpdate</h3><p><img src="https://img.supervj.top/img/temp/%E5%BD%95%E5%88%B6_2020_10_29_09_25_36_526.gif" alt="录制_2020_10_29_09_25_36_526"></p>
<p>一张动图比较清楚的描述了位置的插值过程</p>
<p>从白色框到红色再到最终的蓝色，胶囊体的位移比动画早完成</p>
<p><img src="https://img.supervj.top/img/temp/image-20201029092848925.png" alt="image-20201029092848925"></p>
<h3 id="攀爬结束-ClimbEnd"><a href="#攀爬结束-ClimbEnd" class="headerlink" title="攀爬结束/ClimbEnd"></a>攀爬结束/ClimbEnd</h3><p>结束在Timeline结束的时候调用，就是把<code>MovementMode</code>改回<code>Walking</code></p>
<p>这里还有一个比较重要的事情要做，不然在爬上去以后马上移动的话，脚步还有lock效果会拉伸</p>
<p>于是在攀爬动作的后半段加上一个通知</p>
<p><img src="https://i.loli.net/2020/10/29/uVOJyfaG9di1Wpj.png" alt="image-20201029093133029"></p>
<p>目的就是检测在最后阶段是否有输入或者姿态切换，如果有就<code>MontageStop</code></p>
<p>原作这里需要指定当前的动画本身，我这里做了稍微简化</p>
<p><img src="https://i.loli.net/2020/10/29/EWjvQAIOVdP9tXs.png" alt="image-20201029093239908"></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>AdvancedLocomotionSystemV4分析(一):移动和脚步IK</title>
    <url>/2020/10/26/AdvancedLocomotionSystem%E5%88%86%E6%9E%901_%E5%9F%BA%E7%A1%80%E7%A7%BB%E5%8A%A8%E5%92%8C%E8%84%9A%E6%AD%A5IK/</url>
    <content><![CDATA[<blockquote>
<p>最近对UE4商城<code>AdvancedLocomotionSysemV4</code>进行了一波初步分析，感觉这个项目已经包含了大多数情况能用得到的动画表现，从移动表现中比较容易出问题的脚步问题到IK、攀爬、翻滚、布娃娃以及动作叠加等模块都有讲到</p>
<p>打算参考这个项目的思路重新实现一边动画逻辑，顺便对其中重要的模块和知识点记录一下</p>
<p>这一篇先从基础的移动逻辑，包括转身、起跳等，再顺带看一下脚步IK的实现</p>
</blockquote>
<p><a href="https://supervj.top/2020/10/27/AdvancedLocomotionSystem%E5%88%86%E6%9E%902_%E6%94%80%E7%88%AC%E7%B3%BB%E7%BB%9F/">AdvancedLocomotionSystem分析(二):攀爬系统</a></p>
<p><a href="https://supervj.top/2020/10/28/AdvancedLocomotionSystem%E5%88%86%E6%9E%903_%E5%8A%A8%E4%BD%9C%E5%8F%A0%E5%8A%A0/">AdvancedLocomotionSystemV4分析(三):动作叠加</a></p>
<p><a href="https://supervj.top/2020/10/29/AdvancedLocomotionSystem%E5%88%86%E6%9E%904_%E5%B8%83%E5%A8%83%E5%A8%83%E5%92%8C%E8%B5%B7%E8%BA%AB/">AdvancedLocomotionSystemV4分析(四):布娃娃和起身</a></p>
<p><a href="https://supervj.top/2020/10/31/AdvancedLocomotionSystem%E5%88%86%E6%9E%905_%E9%95%9C%E5%A4%B4/">AdvancedLocomotionSystemV4分析(五):镜头</a></p>
<span id="more"></span>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>首先先把移动和姿态相关的数据结构拎出来看一看，会用到很多枚举和结构体</p>
<h4 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h4><h5 id="MovementState-移动状态"><a href="#MovementState-移动状态" class="headerlink" title="MovementState/移动状态"></a>MovementState/移动状态</h5><ul>
<li>Grounded</li>
<li>InAir</li>
<li>Mantling(攀爬)</li>
<li>Ragdoll</li>
</ul>
<h5 id="MovementAction-移动行为"><a href="#MovementAction-移动行为" class="headerlink" title="MovementAction/移动行为"></a>MovementAction/移动行为</h5><ul>
<li>LowMantle</li>
<li>HighMantle</li>
<li>Rolling</li>
<li>GetUp</li>
</ul>
<h5 id="RotationMode"><a href="#RotationMode" class="headerlink" title="RotationMode"></a>RotationMode</h5><ul>
<li>LockingDirection</li>
<li>VelocityDirection</li>
<li>Aimming</li>
</ul>
<h5 id="Gait-步态"><a href="#Gait-步态" class="headerlink" title="Gait/步态"></a>Gait/步态</h5><ul>
<li>Walking</li>
<li>Running</li>
<li>Sprinting</li>
</ul>
<h5 id="ViewMode"><a href="#ViewMode" class="headerlink" title="ViewMode"></a>ViewMode</h5><ul>
<li>FirstPerson</li>
<li>ThirdPerson</li>
</ul>
<hr>
<h4 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h4><h5 id="FDynamicMontage"><a href="#FDynamicMontage" class="headerlink" title="FDynamicMontage"></a>FDynamicMontage</h5><p>用于动态播放蒙太奇，这个是鼠标拖动视角后的脚步的蒙太奇动画</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027150639437.png" alt="image-20201027150639437"></p>
<h5 id="FLean"><a href="#FLean" class="headerlink" title="FLean"></a>FLean</h5><p>倾斜参数</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027150817198.png" alt="image-20201027150817198"></p>
<h5 id="FMovementSetting"><a href="#FMovementSetting" class="headerlink" title="FMovementSetting"></a>FMovementSetting</h5><p>移动数据，配置各种移动速度和移动旋转相关的曲线参数</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027150903150.png" alt="image-20201027150903150"></p>
<p>这边还包括了2层，分别对应3种旋转模式和2种视角的数据</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027151004574.png" alt="image-20201027151004574"></p>
<p><img src="https://img.supervj.top/img/tempimage-20201027151010318.png" alt="image-20201027151010318"></p>
<p>然后到表格里配置3种形式的参数</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027151037012.png" alt="image-20201027151037012"></p>
<h5 id="FTurnInPlaceAssets"><a href="#FTurnInPlaceAssets" class="headerlink" title="FTurnInPlaceAssets"></a>FTurnInPlaceAssets</h5><p>转身参数，也是用于播放蒙太奇，这个是移动视角到一定角度以后的转身动作</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027151249527.png" alt="image-20201027151249527"></p>
<h5 id="FVelocityBlend"><a href="#FVelocityBlend" class="headerlink" title="FVelocityBlend"></a>FVelocityBlend</h5><p>4方向的权重值（混合值），非常不同于一般理解的用一个方向的概念，这里用了一4方向单独的浮点值来控制混合</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027151312094.png" alt="image-20201027151312094"></p>
<hr>
<h3 id="角色逻辑"><a href="#角色逻辑" class="headerlink" title="角色逻辑"></a>角色逻辑</h3><h4 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h4><p><img src="https://i.loli.net/2020/10/29/zrMiHFIQkCU7a4V.png" alt="image-20201027151612359"></p>
<p>现关的<code>tick</code>逻辑就以上几个</p>
<h5 id="设置必要参数-SetEssentialValue"><a href="#设置必要参数-SetEssentialValue" class="headerlink" title="设置必要参数/SetEssentialValue"></a>设置必要参数/SetEssentialValue</h5><p>这个函数主要目的是计算并设置一些动画蓝图必要的参数，比如加速度、速度等</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027151724768.png" alt="image-20201027151724768"></p>
<ul>
<li>加速度</li>
</ul>
<p>并非直接去移动组件拿实时加速度，而是自己计算2帧之间的速度差来计算加速度</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027151822567.png" alt="image-20201027151822567"></p>
<ul>
<li>速度</li>
</ul>
<p>这个比较简单</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027151856919.png" alt="image-20201027151856919"></p>
<ul>
<li>移动输入值</li>
</ul>
<p><img src="https://i.loli.net/2020/10/29/JuTa9dB1rFngwHP.png" alt="image-20201027151931872"></p>
<p>一个用当前加速度来设置的移动输入浮点值和布尔值，在动画蓝图里也是蛮重要的</p>
<ul>
<li>视口旋转速率</li>
</ul>
<p>2帧之间的朝向插值来得到的旋转速率</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027152033799.png" alt="image-20201027152033799"></p>
<h5 id="步态设置-UpdateMovement"><a href="#步态设置-UpdateMovement" class="headerlink" title="步态设置/UpdateMovement"></a>步态设置/UpdateMovement</h5><p>主要设置枚举<code>Gait</code>，这里需要提一下，按键得到的步态并不一定是最终的步态</p>
<p><code>DesiredGait</code>期望步态来自于事件输入，可以自定义</p>
<p><img src="https://i.loli.net/2020/10/29/WBDzSe24NwclhdI.png" alt="image-20201027152208555"></p>
<p><img src="https://img.supervj.top/img/tempimage-20201027175148982.png" alt="image-20201027152353930"></p>
<p>上图对不同姿态不同视口等做了一定约束/筛选，比如在<code>Aimming</code>姿势下不能出现<code>Sprint</code></p>
<p><img src="https://i.loli.net/2020/10/29/dMsYBrKSwTk1GX9.png" alt="image-20201027152515614"></p>
<p>上图种，根据实际速度来决定真实的步态，跟期望步态可能会不同，因为有加速减速的存在，直到这个过程到达所需的速度才真的设置步态</p>
<p><img src="https://i.loli.net/2020/10/29/dMsYBrKSwTk1GX9.png" alt="image-20201027152613123"></p>
<p>然后根据不同的情况设置不同的<strong>真正</strong>的速度、加速度、摩擦力等参数</p>
<h5 id="更新旋转-updateRotation"><a href="#更新旋转-updateRotation" class="headerlink" title="更新旋转/updateRotation"></a>更新旋转/updateRotation</h5><p>说到角色旋转，我们要看一下角色几个很关键的参数</p>
<ul>
<li>bUseControllerRotationYaw : false</li>
<li>CharacterMovement.bOrientRotationToMovement：false</li>
</ul>
<p>以上2个参数都是false，意味着我们角色的朝向全靠我们逻辑来控制了</p>
<p>先看一个简单的插值计算函数</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027153053725.png" alt="image-20201027153053725"></p>
<p>基本上大多数的角色旋转都是用这个函数实现的，做了2步插值计算</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027153221577.png" alt="image-20201027153221577"></p>
<p>然后对于地面的速度做了一个计算，读取了配置参数的曲线信息，我们任意打开一个曲线看一下</p>
<p><img src="https://i.loli.net/2020/10/29/Bx2Zzh8oKIHt4b3.png" alt="image-20201027153330854"></p>
<p>上图是不同状态下的旋转速率，0=5，3=20</p>
<blockquote>
<p>移动数据是BeginPlay的时候读表获取的</p>
</blockquote>
<p>然后根据不同视角、旋转模式等进行不同的插值计算</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027154624163.png" alt="image-20201027154624163"></p>
<p><img src="https://i.loli.net/2020/10/29/2Wn9KDv7Z5xLT6u.png" alt="image-20201027153809298"></p>
<hr>
<p>然后还有一种旋转方式稍微不容易理解一点，需要注意的是如果动画制作的时候不是用30帧的，下图中的30帧处需要替换为对应的帧数</p>
<p><img src="https://i.loli.net/2020/10/29/3zOMLZnAPpaXIlf.png" alt="image-20201027154033617"></p>
<p>从曲线等到值来动态设置旋转值</p>
<p>这个曲线挂在转身动画里面，比如右转90度的曲线</p>
<p><img src="https://i.loli.net/2020/10/29/f9R7gkF3v8jZOWw.png" alt="image-20201027154357794"></p>
<h6 id="动画修改器-添加根骨骼运动曲线"><a href="#动画修改器-添加根骨骼运动曲线" class="headerlink" title="动画修改器:添加根骨骼运动曲线"></a>动画修改器:添加根骨骼运动曲线</h6><p>根骨骼旋转信息的曲线我们用修改器来制作，思路就是对比2帧之间的旋转插值然后添加数据点</p>
<p><img src="https://i.loli.net/2020/10/29/79MDr1lR36Qstac.png" alt="image-20201023175214668"></p>
<h5 id="缓存数据-CacheValus"><a href="#缓存数据-CacheValus" class="headerlink" title="缓存数据/CacheValus"></a>缓存数据/CacheValus</h5><p>就是存一下2个旧的数据，上述逻辑中用到的对比2帧数据差的</p>
<p><img src="https://i.loli.net/2020/10/29/AeXJmYTbNM6Dpnd.png" alt="image-20201027154830956"></p>
<h5 id="数据接口"><a href="#数据接口" class="headerlink" title="数据接口"></a>数据接口</h5><p><img src="https://i.loli.net/2020/10/29/tVsNZgQHRr6hIyu.png" alt="image-20201027154851355"></p>
<p><img src="https://i.loli.net/2020/10/29/OHhZG63SI1jUYnK.png" alt="image-20201027154857475"></p>
<p>如图所示，把必要参数都通过接口得到</p>
<h3 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h3><h4 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h4><p>主要逻辑就是Tick和通知两部分</p>
<p>在Tick中主要是如下几个方法</p>
<h5 id="UpdateCharacterInfo"><a href="#UpdateCharacterInfo" class="headerlink" title="UpdateCharacterInfo"></a>UpdateCharacterInfo</h5><p>从角色要到必要的参数</p>
<p><img src="https://i.loli.net/2020/10/29/VNEPmuoLJrekdvC.png" alt="image-20201027161533966"></p>
<h5 id="UpdateMovementValues"><a href="#UpdateMovementValues" class="headerlink" title="UpdateMovementValues"></a>UpdateMovementValues</h5><p><img src="https://i.loli.net/2020/10/29/sURjtTcDxkw6VY5.png" alt="image-20201027161738837"></p>
<p>这里比较有用的是计算<code>VelocityBlend</code>的思路</p>
<p><img src="https://i.loli.net/2020/10/29/Vptef8HAE4GrNTd.png" alt="image-20201027161814570"></p>
<p><img src="https://i.loli.net/2020/10/29/ImV7sT5NuEokaWq.png" alt="image-20201027161826756"></p>
<p>如上图，重点是把世界速度转换成本地的归一化速度</p>
<hr>
<p>然后是计算本地加速度和倾斜角度，加速度直接决定了倾斜角度</p>
<p><img src="https://i.loli.net/2020/10/29/rcXyIL5bHY2suTn.png" alt="image-20201027162041292"></p>
<p><img src="https://i.loli.net/2020/10/29/AXUDuWM5BVs3JyG.png" alt="image-20201027162048573"></p>
<p>然后是计算步长，跟速度挂钩，从曲线中获取信息，下图中表示了曲线对应的大概的速度范围</p>
<p><img src="https://i.loli.net/2020/10/29/XK8lqpnd9T3IRsb.png" alt="image-20201027162222030"></p>
<p>计算站立动画播放速率：跟曲线<code>Weight_Gait</code>有关联，一般设置2为跑步，3为冲刺的速率</p>
<p><img src="https://i.loli.net/2020/10/29/vdaXK9YZkMLODrl.png" alt="image-20201027162326824"></p>
<h5 id="UpdateRotation"><a href="#UpdateRotation" class="headerlink" title="UpdateRotation"></a>UpdateRotation</h5><p>旋转相关的参数，下图所示比较简单</p>
<p><img src="https://i.loli.net/2020/10/29/v5sDWEwHQgBz78C.png" alt="image-20201027162423055"></p>
<p><img src="https://i.loli.net/2020/10/29/tBjdCSxi8UKFX71.png" alt="image-20201027162444761"></p>
<p><img src="https://i.loli.net/2020/10/29/X75lKRt1hYBJS8O.png" alt="image-20201027162457635"></p>
<blockquote>
<p> 后面还有关于转身的方法和通知，留到下面单独讲</p>
</blockquote>
<h4 id="动画视图"><a href="#动画视图" class="headerlink" title="动画视图"></a>动画视图</h4><p>先来看一下动画视图的跟移动和IK有关系的主视图，原版工程还有很多层级，现在先不拿进来</p>
<p><img src="https://i.loli.net/2020/10/29/HlIBdQcCS93Kxsg.png" alt="image-20201027162753661"></p>
<h4 id="BaseLayer"><a href="#BaseLayer" class="headerlink" title="BaseLayer"></a>BaseLayer</h4><p><img src="https://i.loli.net/2020/10/29/ayHSuLrlgEfP142.png" alt="image-20201027163331816"></p>
<h5 id="LocomotionCycles"><a href="#LocomotionCycles" class="headerlink" title="LocomotionCycles"></a>LocomotionCycles</h5><p><img src="https://i.loli.net/2020/10/29/QbUTAMaYzNytr3H.png" alt="image-20201027163407630"></p>
<p>这里就直接进入对应的动画层</p>
<p><img src="https://i.loli.net/2020/10/29/TZ3YyD4ol5hzOUk.png" alt="image-20201027163438437"></p>
<p>第一下有点难以理解，为什么要分6个，一般理解上要么4个要么8个</p>
<p>理性分析以后，我们需要考虑一个穿帮问题，拿我们一般用的单个混合空间，横竖轴分别对应移动方向和移动速度来说，经常在4个斜角中的2个斜角会出现脚步严重穿插问题，用过的应该都能理解，现在这个设计思路就是几乎完美的解决了这个问题</p>
<p>比如走路一共有6个动作</p>
<img src="https://i.loli.net/2020/10/29/M2WPZNsIHlYV7mz.png" alt="image-20201027163809113" style="zoom:100%;" />

<blockquote>
<p>我们如果的移动顺序是  前-&gt;右-&gt;后</p>
<p>那么动画的播放顺序是 F-&gt;RF-&gt;RB-&gt;B</p>
<p>如果是前-&gt;左-&gt;后</p>
<p>动画顺序是F-&gt;LF-&gt;LB-&gt;B</p>
</blockquote>
<p>我们再去看动画具体表现</p>
<p>LF和RB都是右脚在前左脚在后，如下图</p>
<p><img src="https://i.loli.net/2020/10/29/aNtJ7mBHYkV9Zrq.png" alt="image-20201027164541218"><img src="https://i.loli.net/2020/10/29/1tEQj8oqGLcaeuN.png" alt="image-20201027164555146"></p>
<p>RF和LR如下图</p>
<p><img src="https://i.loli.net/2020/10/29/Tgm6kq9pyoRDAnh.png" alt="image-20201027164629282"><img src="https://i.loli.net/2020/10/29/WVOL3YauJNhgiko.png" alt="image-20201027164640634"></p>
<p>而前和后都是正面朝向的就不贴图了</p>
<p>所以这种混合方式就避免了左右脚前后问题的混合，当然也意味着动画师得多做几份动画了</p>
<p><img src="https://i.loli.net/2020/10/29/sYptHKqJh7a9D3C.png" alt="image-20201028090323058"></p>
<p>上图是MoveRF的状态机，需要注意的是RF对立面混合的就是前面所说的，脚步前后一致的LB，当然一般情况下，<code>VelocityBlend</code>的R值和L值也不会同时大于0</p>
<hr>
<p>每个状态机的进入都有一个通知，直接设置了方向枚举，这个枚举变量用于<strong>停步</strong>的逻辑,后面细讲</p>
<p><img src="https://i.loli.net/2020/10/29/fMFNBZHzktX38wS.png" alt="image-20201027165201291"></p>
<p>在这个动画层还有一些逻辑，如下图所示比较容易理解</p>
<p><img src="https://i.loli.net/2020/10/29/UXON3fuwtrks5Lv.png" alt="image-20201027165436452"></p>
<h5 id="LocomotionDetail"><a href="#LocomotionDetail" class="headerlink" title="LocomotionDetail"></a>LocomotionDetail</h5><p><img src="https://i.loli.net/2020/10/29/veJY5KRwuNODIWy.png" alt="image-20201027170302476"></p>
<p><img src="https://img.supervj.top/img/temp/run%20add.gif" alt="run add"></p>
<p>主要叠加了走路到跑步或者冲刺的启动动画叠加，如上面的动图</p>
<p><img src="https://i.loli.net/2020/10/29/wVrFKc2x8mgjv4I.png" alt="image-20201027171642190"></p>
<p><img src="https://img.supervj.top/img/temp/image-20201027171649329.png" alt="image-20201027171649329"></p>
<p>2个类似的状态机区别主要就是直接从静态到跑步还是从完整的走路姿势切换到跑步，从叠加上区别就是<code>StartPostion</code>的不同</p>
<h5 id="LocomotionStates"><a href="#LocomotionStates" class="headerlink" title="LocomotionStates"></a>LocomotionStates</h5><p><img src="https://img.supervj.top/img/temp/image-20201027171904903.png" alt="image-20201027171904903"></p>
<p>这里主要实现了2部分内容</p>
<ol>
<li>原地/移动/停步的切换</li>
<li>原地转身动画</li>
</ol>
<ul>
<li>Stop</li>
</ul>
<p><img src="https://img.supervj.top/img/temp/image-20201027172526588.png" alt="image-20201027172526588"></p>
<p><img src="https://img.supervj.top/img/temp/image-20201027172418385.png" alt="image-20201027172418385"></p>
<p>用动画曲线来判定脚的位置，如下图</p>
<p><img src="https://img.supervj.top/img/temp/image-20201027172622022.png" alt="image-20201027172622022"></p>
<p>上图是跑步的位置曲线，重定向过来的曲线信息会有些许区别，比如直线变曲线，但是大致相同</p>
<p>基本上是右脚踩下=1，左脚踩下=-1</p>
<p>对于脚没有完全踩下的节点会复杂一些，先看一个全图</p>
<p><img src="https://img.supervj.top/img/temp/image-20201027173024455.png" alt="image-20201027173024455"></p>
<p>看一下骨骼分层</p>
<p><img src="https://img.supervj.top/img/temp/image-20201027173037908.png" alt="image-20201027173037908"></p>
<p>那么下面的混合大概思路就是根据不同的移动方向和不同的方向枚举，这2个变量之前都讲过，这里分别处理</p>
<p>混合的动作都是各个方向的走路动画的某个时间点的单帧动画</p>
<ul>
<li>转身</li>
</ul>
<p>转身动作是特殊情况的拖动，循环播放的形式</p>
<p><img src="https://img.supervj.top/img/temp/image-20201027173516992.png" alt="image-20201027173516992"></p>
<p>动画速率跟镜头旋转速度有关系</p>
<p>看一下具体的判定条件</p>
<p><img src="https://img.supervj.top/img/temp/image-20201027173619244.png" alt="image-20201027173619244"></p>
<p>言下之意就是瞄准方式或者第一人称的模式都是这样旋转的</p>
<h5 id="MainMovement"><a href="#MainMovement" class="headerlink" title="MainMovement"></a>MainMovement</h5><p>此状态机用来控制地面和空中的姿势切换</p>
<p><img src="https://img.supervj.top/img/temp/image-20201027173736606.png" alt="image-20201027173736606"></p>
<p>用<code>MovementState</code>和<code>Jumped</code>分别判断是主动起跳和是被动自由落体</p>
<p>逻辑上主动起跳是先修改布尔值再更新枚举值</p>
<p><img src="https://img.supervj.top/img/temp/image-20201027174004729.png" alt="image-20201027174004729"></p>
<ul>
<li>起跳</li>
</ul>
<p><img src="https://img.supervj.top/img/temp/image-20201028094937513.png" alt="image-20201028094937513"></p>
<p>几个必要的变量计算</p>
<p>思路是在下落过程中计算得到速度和地面预判值</p>
<p>预判值用射线检测得到，最后得到效果是落地的瞬间叠加了手臂上扬的动作</p>
<p><img src="https://img.supervj.top/img/temp/image-20201028093655072.png" alt="image-20201028093655072"></p>
<p><img src="https://img.supervj.top/img/temp/image-20201028094318721.png" alt="image-20201028094318721"></p>
<p><img src="https://img.supervj.top/img/temp/image-20201028094405280.png" alt="image-20201028094405280"></p>
<p>内部状态机如上图</p>
<p>根据起跳时脚的位置来决定起跳初始动画，即一般意义上的JumpStart的动作，此动作为过渡性动作，结束以后自动跳转到下一个状态机</p>
<p>下一个状态机是空中循环，虽然是循环播放，但是无条件跳转到<code>Flai</code>动作(一个手舞足蹈的下落动作)</p>
<h4 id="脚步IK"><a href="#脚步IK" class="headerlink" title="脚步IK"></a>脚步IK</h4><p>脚步IK和停步其实要放一起说，因为停步的时候也用到了IK的一部分功能用来把脚收回去</p>
<p><img src="https://img.supervj.top/img/tempimage-20201027174115844.png" alt="image-20201027174115844"></p>
<p>这里加了很多虚拟骨骼</p>
<ul>
<li>foot_target_r:用来判断跨步是否比较大</li>
<li>ik_foot_r_Offset：控制<code>TwoBoneIK</code>的<code>Effector</code>，即IK效果的主要控制节点</li>
<li>ik_knee_target_r:膝盖位置，<code>TwoBoneIK</code>的<code>Joint</code>节点，即IK效果的方向参考点</li>
</ul>
<p><img src="https://img.supervj.top/img/tempimage-20201027174459766.png" alt="image-20201027174459766"></p>
<hr>
<ul>
<li>IK动画视图</li>
</ul>
<p><img src="https://img.supervj.top/img/temp/image-20201027174715349.png" alt="image-20201027174715349"></p>
<p>动画视图比较简单，难点是计算方式</p>
<p>找到Tick逻辑里的<code>UpdateFootIK</code>方法</p>
<p>从里面一点点分析</p>
<h5 id="SetFootLocking"><a href="#SetFootLocking" class="headerlink" title="SetFootLocking"></a>SetFootLocking</h5><p><img src="https://img.supervj.top/img/tempimage-20201027174825245.png" alt="image-20201027174825245"></p>
<p><img src="https://img.supervj.top/img/tempimage-20201027174845182.png" alt="image-20201027174845182"></p>
<p>这里不细究了，思路就是得到当前动画的<code>FootLock</code>曲线信息，有权重就意味着需要锁定脚步位置，锁定的时候即抵消了<code>TwoBone IK</code>的<code>Effector</code>骨骼的影响</p>
<h5 id="SetFootOffset"><a href="#SetFootOffset" class="headerlink" title="SetFootOffset"></a>SetFootOffset</h5><p><img src="https://img.supervj.top/img/temp/image-20201027175052583.png" alt="image-20201027175052583"></p>
<p><img src="https://img.supervj.top/img/tempimage-20201027175148982.png" alt="image-20201027175148982"></p>
<p>这里会一直打射线计算地面点，得到具体的脚步的位置，然后插值计算放置跳帧</p>
<blockquote>
<p>脚步IK逻辑不是很多，但是我这里重新实现的时候发现了很多细节问题，效果很难到达预期，具体可以详细参考工程</p>
</blockquote>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>animation</tag>
      </tags>
  </entry>
  <entry>
    <title>AdvancedLocomotionSystemV4分析(三):动作叠加</title>
    <url>/2020/10/28/AdvancedLocomotionSystem%E5%88%86%E6%9E%903_%E5%8A%A8%E4%BD%9C%E5%8F%A0%E5%8A%A0/</url>
    <content><![CDATA[<p><a href="https://supervj.top/2020/10/26/AdvancedLocomotionSystem%E5%88%86%E6%9E%901_%E5%9F%BA%E7%A1%80%E7%A7%BB%E5%8A%A8%E5%92%8C%E8%84%9A%E6%AD%A5IK/">AdvancedLocomotionSysemV4分析(一):移动和脚步IK</a></p>
<p><a href="https://supervj.top/2020/10/27/AdvancedLocomotionSystem%E5%88%86%E6%9E%902_%E6%94%80%E7%88%AC%E7%B3%BB%E7%BB%9F/">AdvancedLocomotionSystem分析(二):攀爬系统</a></p>
<p><a href="https://supervj.top/2020/10/29/AdvancedLocomotionSystem%E5%88%86%E6%9E%904_%E5%B8%83%E5%A8%83%E5%A8%83%E5%92%8C%E8%B5%B7%E8%BA%AB/">AdvancedLocomotionSystemV4分析(四):布娃娃和起身</a></p>
<p><a href="https://supervj.top/2020/10/31/AdvancedLocomotionSystem%E5%88%86%E6%9E%905_%E9%95%9C%E5%A4%B4/">AdvancedLocomotionSystemV4分析(五):镜头</a></p>
<hr>
<blockquote>
<p>本片主要分析一下ALS项目的动作叠加部分，主要用到各类姿势的切换，如受伤状态、持枪、持弓状态等，另外一种一般项目会用到的<code>AnimOffset</code>在这里没有用到，头部转向用了另外一种方式制作</p>
</blockquote>
<p><img src="https://img.supervj.top/img/temp/%E5%BD%95%E5%88%B6_2020_10_29_16_42_10_43.gif" alt="录制_2020_10_29_16_42_10_43"></p>
<span id="more"></span>

<p>姿势的切换通过接口<code>BPI_Set_OverlayState</code>调用，无论是用<code>ALS</code>项目的UI切换或者其他方式都可以</p>
<p>在<code>ABP</code>中直接改变<code>OverlayState</code>变量也可以直接预览效果，比之前的模块都简单一些</p>
<p><img src="https://img.supervj.top/img/temp/image-20201029161903882.png" alt="image-20201029161903882"></p>
<p>如上图，<code>Overlay</code>单独做了一个动画层</p>
<p><img src="https://img.supervj.top/img/temp/image-20201029162011256.png" alt="image-20201029162011256"></p>
<p>我这边实现了部分动作，如上图，其实思路大同小异，性别/受伤等切换比较简单，弓箭/枪类等动作会有一个内部状态机切换动作，稍微会讲</p>
<p>判断类型基本是通过<code>OverlayState</code>来判定</p>
<h3 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h3><p>如果按照我们之前两篇文章的制作，到这里之前角色是静态的，因为之前的默认动作只是播放<code>ALS_N_Pose</code>的第一帧动作，但是加上目前这个逻辑以后就开始有了<code>IDLE</code>动作了，我们看<code>Default</code>状态机做了什么</p>
<p><img src="https://img.supervj.top/img/temp/image-20201029162347423.png" alt="image-20201029162347423"></p>
<p>文字描述一下就是</p>
<p>根据<strong>步态/站姿/是否在空中</strong>，来决定基础动作使用姿势动画的第几帧,这里名字带<code>Variation</code>的字样的都是单帧动画的集合，使用的都是某一帧的数据</p>
<p>然后叠加<code>次要运动</code>动画，这个动画是带起伏的<code>IDLE</code>动作，如下图</p>
<img src="https://img.supervj.top/img/temp/%E5%BD%95%E5%88%B6_2020_10_29_16_28_06_978.gif" alt="录制_2020_10_29_16_28_06_978" style="zoom:50%;" />

<p>所以所有姿势的起伏动作都是来源于这个动画，值得借鉴</p>
<h3 id="Bow"><a href="#Bow" class="headerlink" title="Bow"></a>Bow</h3><p>至于男女姿势其实跟默认的没啥逻辑上的区别就略过了，下面看看弓箭的动作，这个还是蛮实用的，我们实际开发中基本肯定会用到射击类的武器</p>
<p><img src="https://img.supervj.top/img/temp/image-20201029163239993.png" alt="image-20201029163239993"></p>
<p>上图就是整个弓箭的状态机，除了几个特殊动作，默认都用子状态机<code>Bow</code>，特殊动作比如<code>GetUp</code>用的就是基础弓箭动作的某一帧比如下图，而这个整形变量<code>OverlayStateCount</code>是通过动画通知修改的，容易理解</p>
<p><img src="https://img.supervj.top/img/temp/image-20201029163214826.png" alt="image-20201029163214826"></p>
<p><img src="https://i.loli.net/2020/10/29/pAfJreFWv5b6Klu.png" alt="image-20201029163523606"></p>
<p>我们看一下子状态机里面的内容，如上图</p>
<p>默认是一个松弛状态，然后有准备动作和瞄准动作</p>
<p>其实就是把之前的比如<code>Default</code>类型的姿势模仿一遍扔过来就可以了，无非就是换一个单帧混合动画而已</p>
<p><img src="https://img.supervj.top/img/temp/image-20201029163714887.png" alt="image-20201029163714887"></p>
<p>这里看到上面从<code>Ready</code>切换回<code>Released</code>会有3个<code>Contition</code>，理论上来讲不用这么多，当然他总有他的道理</p>
<p>3个分别解释一下是</p>
<ol>
<li><code>Bow</code>状态机持续超过3秒同时旋转值(RotationAmount)等于0</li>
<li><code>Bow</code>状态机持续超过3秒同时正在移动</li>
<li>冲刺状态或者空中状态</li>
</ol>
<p>其中上面第三个判定优先级是2</p>
<p>那么就凑成了一个完整的弓箭姿势叠加</p>
<h3 id="LayerBlending层"><a href="#LayerBlending层" class="headerlink" title="LayerBlending层"></a>LayerBlending层</h3><p>只看<code>Overlay</code>层还不够，因为最开始的一张图显示，还有一个<code>LayerBlending</code>层来混合3个另外的层</p>
<p><img src="https://img.supervj.top/img/temp/image-20201029164641087.png" alt="image-20201029164641087"></p>
<p>一眼望去很绝望的赶脚，确实做的非常细致</p>
<p>我们看几个代表性的</p>
<p><img src="https://img.supervj.top/img/temp/image-20201029164742536.png" alt="image-20201029164742536"></p>
<p><img src="https://i.loli.net/2020/10/29/vOE72zdfQtIAHey.png" alt="image-20201029171059067"></p>
<p><img src="https://i.loli.net/2020/10/29/y2O1PtaDFJ8pqiR.png" alt="image-20201029171216089"></p>
<p><code>BasePose</code>通过两种方式叠加<code>BaseLayer</code>缓存为Pose</p>
<p>后面根据各种<code>Layering</code>曲线的值来决定混合的动作和插槽</p>
<p>然后从脚步pose开始逐步骨骼分层</p>
<p><img src="https://i.loli.net/2020/10/29/gOLE469lzDSNcmY.png" alt="image-20201029172626602"></p>
<p>上图比较特殊，在最后部分用了2个特殊的骨骼分层，倒数第二个用了一个<code>root</code>创建的基于<code>root</code>的虚拟骨骼，暂时没发现什么具体作用；最后一个骨骼分层节点没有设置成员</p>
<p>按照注释解释是<strong>将两个图层中的动画曲线混合在一起，并覆盖上一层的干扰。</strong></p>
<p>好吧，此坑先留着，后面来挖</p>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>制作叠加的时候发现了一个坑，动作切换的时候，<code>Base_N_Pose</code>曲线的值会回到0，然后导致每次切换姿势回瞬间跳转到默认姿势再调准到期望姿势，产生了异常抖动效果。</p>
<p>按照正常情况站姿的情况下该值应该一直处于1才对，然后手动在基础动画层的最后节点之前手动<code>ModifyCurves</code>把此曲线值先设为1。</p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>animation</tag>
      </tags>
  </entry>
  <entry>
    <title>AdvancedLocomotionSystemV4分析(五):镜头</title>
    <url>/2020/10/31/AdvancedLocomotionSystem%E5%88%86%E6%9E%905_%E9%95%9C%E5%A4%B4/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/31/oGuy1Ex9ajNzfQg.gif" alt="录制_2020_10_31_14_52_47_579~2"></p>
<blockquote>
<p>上一篇留下了一个镜头抖动问题，实际上ALS项目是通过自定义<code>CameraManager</code>实现的，本篇就此来展开一下</p>
</blockquote>
<p><a href="https://supervj.top/2020/10/26/AdvancedLocomotionSystem%E5%88%86%E6%9E%901_%E5%9F%BA%E7%A1%80%E7%A7%BB%E5%8A%A8%E5%92%8C%E8%84%9A%E6%AD%A5IK/">AdvancedLocomotionSysemV4分析(一):移动和脚步IK</a></p>
<p><a href="https://supervj.top/2020/10/27/AdvancedLocomotionSystem%E5%88%86%E6%9E%902_%E6%94%80%E7%88%AC%E7%B3%BB%E7%BB%9F/">AdvancedLocomotionSystem分析(二):攀爬系统</a></p>
<p><a href="https://supervj.top/2020/10/28/AdvancedLocomotionSystem%E5%88%86%E6%9E%903_%E5%8A%A8%E4%BD%9C%E5%8F%A0%E5%8A%A0/">AdvancedLocomotionSystemV4分析(三):动作叠加</a></p>
<p><a href="https://supervj.top/2020/10/29/AdvancedLocomotionSystem%E5%88%86%E6%9E%904_%E5%B8%83%E5%A8%83%E5%A8%83%E5%92%8C%E8%B5%B7%E8%BA%AB/">AdvancedLocomotionSystemV4分析(四):布娃娃和起身</a></p>
<span id="more"></span>



<p>先大概简述一下<code>ALS</code>镜头控制的方法</p>
<ul>
<li>自定义<code>CameraManager</code>代替默认第三人称模板的<code>SpringArm</code>+<code>Camera</code>的方式</li>
<li>重写<code>BlueprintUpdateCamera</code></li>
<li><code>CameraManager</code>挂载骨骼模型相机，创建动画蓝图，用曲线来控制相机位置信息</li>
</ul>
<h3 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h3><p><code>ALS</code>巧妙的用动画蓝图来辅助相机位置的控制和切换，如何做到的？我们先来看一下这是个什么动画蓝图</p>
<p><img src="https://i.loli.net/2020/10/31/vQ1OTbzS7JmA435.png" alt="image-20201031141203030"></p>
<p>随便打开一个角落</p>
<p><img src="https://i.loli.net/2020/10/31/qZLflKyOBEITbDg.png" alt="image-20201031141249269"></p>
<p>所以说，动画蓝图没动画(lll￢ω￢)</p>
<p>完全是用动画蓝图的状态机来自然过渡各类曲线数据，所以显而易见的可以知道在其他地方会 用到这些曲线</p>
<blockquote>
<p>ps.相机的骨骼模型你完全可以用一个球代替，曲线都是手动加的，不用到三维软件加</p>
</blockquote>
<h3 id="CameraManager"><a href="#CameraManager" class="headerlink" title="CameraManager"></a>CameraManager</h3><p><img src="https://i.loli.net/2020/10/31/GOxWNeguVfl2Ehb.png" alt="image-20201031141505810"></p>
<p>先一个初始化方法把必要的参数给拿到，可以到<code>PlayerController</code>内初始化，毕竟<code>CamaraManager</code>本身就是配置在<code>PlayerController</code>内</p>
<p><img src="https://i.loli.net/2020/10/31/2KXOuLNdSFeUjpD.png" alt="image-20201031141559486"></p>
<p>然后重写<code>BlueprintUpdateCamera</code>方法，随意给一个判断，不满足就走默认的方式</p>
<p><img src="https://i.loli.net/2020/10/31/HZkM9N5LtmFYa3P.png" alt="image-20201031141650530"></p>
<p>在<code>CustomCameraBehavior</code>内有很多计算，我们逐一分析</p>
<p><img src="https://i.loli.net/2020/10/31/ykfTUYdMzprCI3D.png" alt="image-20201031141736699"></p>
<p>从角色内去获取必要的参数，<code>PivotTarget</code>是观察的目标点，<code>1PTarget</code>为第一人称的位置，第一人称会讲相机放到固定插槽位置，这里是眼睛的位置</p>
<p><img src="https://i.loli.net/2020/10/31/Gh4ui29epCf6oPO.png" alt="image-20201031142246941"></p>
<p>当前旋转向控制器旋转插值过去，速度由曲线<code>RotationLagSpeed</code>变量控制</p>
<p><img src="https://i.loli.net/2020/10/31/LjN2QKumEPFlTVI.png" alt="image-20201031142342258"></p>
<p><code>SmoothPivotTarget</code>其实是当前的相机变换信息，插值向第一条的目标点</p>
<p>关于<code>CalclateAxisIndependentLag</code>内部是经过插值计算把<code>CurrentLocation</code>向<code>TargetLocation</code>插值过渡</p>
<p>内部有一点不容易理解，如下图</p>
<p><img src="https://i.loli.net/2020/10/31/QMlYCAxi5cj32So.png" alt="image-20201031143027445"></p>
<p>位置先反向旋转最后又给转回来，如果觉得很难理解，其实可以不加这部操作，区别不大</p>
<p><img src="https://i.loli.net/2020/10/31/TIdpo7camu8DkyC.png" alt="image-20201031143300660"></p>
<p>然后再加上曲线<code>PivotOffset_*</code>的偏移后存为变量<code>PivotLocation</code>，简单粗暴</p>
<p><img src="https://i.loli.net/2020/10/31/yQrHnYlhoMUAB3G.png" alt="image-20201031143348227"></p>
<p>然后加上相机偏移曲线<code>CameraOffset_*</code>存为变量<code>TargetCameraLocation</code></p>
<blockquote>
<p>关于<code>CameraOffset</code>与<code>PivotOffset</code>的区别</p>
<p>前者是相机的位置，后者是目标点的位置，其实换到大家熟悉的<code>SpringArm</code>来说，前者就是<code>SocketOffset</code>，后者就是<code>TargetOffset</code>，不熟悉的可以自己去试一试</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/31/BwZD4tEi36c7Ydp.png" alt="image-20201031143540131"></p>
<p>第三人称下的射线检测，其实就是做了一个类似<code>SpringArm</code>的<code>DoTestCollision</code>的作用</p>
<p><img src="https://i.loli.net/2020/10/31/E9gxYbDcpBuATKl.png" alt="image-20201031143628977"></p>
<p>最后就是根据曲线返回第一人称还是第三人称的数据</p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>animation</tag>
        <tag>镜头</tag>
      </tags>
  </entry>
  <entry>
    <title>AnimationDebug:Insights</title>
    <url>/2021/12/31/AnimationDebug/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前的动画debug要么肉眼看动画蓝图, 要么用控制台来Show DebugAnimation搞得全屏幕的天书无从下手, 自从4.25以后动画模块有了一个非常友善的可视化Debug工具, 之前略有所知但是没有深入使用, 今天来研究一番看看这个工具可以干啥</p>
<p><img src="https://img.supervj.top/imgimage-20211231101038728.png" alt="image-20211231101038728"></p>
<p><img src="https://img.supervj.top/imgimage-20211231095620356.png" alt="image-20211231095620356"></p>
<span id="more"></span>

<p><a href="https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/PerformanceAndProfiling/UnrealInsights/AnimationInsights/">官方文档</a></p>
<h2 id="如何开启"><a href="#如何开启" class="headerlink" title="如何开启"></a>如何开启</h2><p>需要开启2个插件, 插件是4.25之后的版本才有的</p>
<p><img src="https://img.supervj.top/imgimage-20211230174831723.png" alt="image-20211230174831723"></p>
<p>UE5的编辑器布局略有改变, 启动位置在这里</p>
<p><img src="https://img.supervj.top/imgimage-20211230175013356.png" alt="image-20211230175013356"></p>
<p>然后首先需要设置一下过滤条件, 否则是无法抓取数据的.</p>
<p>目前UE5自动带有动画标签, 使用这个标签的过滤设置即可</p>
<p><img src="https://img.supervj.top/imgimage-20211230175148897.png" alt="image-20211230175148897"></p>
<p>然后启动Insights即可, 操作方式可以查看官方文档, 这里不细讲, 主要看看这个插件可以做什么</p>
<h2 id="观察对象"><a href="#观察对象" class="headerlink" title="观察对象"></a>观察对象</h2><p>UE5把这个观察对象改到了左上方的AllTracks里面, 默认会观察非常多的对象, 如果场景内动画对象多就比较麻烦了, 可以手动选择需要观察的对象</p>
<p><img src="https://img.supervj.top/imgimage-20211231094402478.png" alt="image-20211231094402478"></p>
<h2 id="重播"><a href="#重播" class="headerlink" title="重播"></a>重播</h2><p>个人感觉是最有用的一个Debug功能</p>
<p>这里有个前提, 需要借助动画蓝图来调试, 打开动画蓝图, 设置预览对象为 Insights</p>
<p><img src="https://img.supervj.top/imgimage-20211231092956730.png" alt="image-20211231092956730"></p>
<p>同时如果开启绘制actor, 那么在场景中会创建一个临时对象来模拟所有动画信息, 非常犀利</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_31_09_30_26_791.gif" alt="录制_2021_12_31_09_30_26_791"></p>
<p>也支持循环播放, 倒放等功能</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_31_09_53_18_636.gif" alt="录制_2021_12_31_09_53_18_636"></p>
<h2 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h2><p><img src="https://img.supervj.top/imgimage-20211231093346391.png" alt="image-20211231093346391"></p>
<p>右键点击动画蓝图试图这一行, 点击观察, 那么在右侧可以显示动画蓝图里所有状态机权重, 这个还是非常有用的</p>
<p><img src="https://img.supervj.top/imgimage-20211231093444732.png" alt="image-20211231093444732"></p>
<p>如果是ALS这种大型动画蓝图, 那么可以看到的数据就非常可观了</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_31_09_39_31_254.gif" alt="录制_2021_12_31_09_39_31_254"></p>
<h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>这个也是一个重头戏,  除了看轨道上的图形混合状态, 也可以右键观察混合权重轨道, 在右侧属性栏可以看到更具体的混合数据</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_31_09_50_23_735.gif" alt="录制_2021_12_31_09_50_23_735"></p>
<h2 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h2><p>找到曲线一行, 右键点击观察属性以后就可以看到所有曲线信息,  曲线本身debug就比较麻烦, 有了这个就非常方便了</p>
<p><img src="https://img.supervj.top/imgimage-20211231094202088.png" alt="image-20211231094202088"></p>
<p><img src="https://img.supervj.top/imgimage-20211231094215170.png" alt="image-20211231094215170"></p>
<h2 id="蒙太奇"><a href="#蒙太奇" class="headerlink" title="蒙太奇"></a>蒙太奇</h2><p>蒙太奇有单独的轨道来观察,  类似前面的, 也是点击观察以后可以看到单独的蒙太奇数据</p>
<p><img src="https://img.supervj.top/imgimage-20211231094544500.png" alt="image-20211231094544500"></p>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>通知也比较难debug的, 但是在这里可以非常方便的观察</p>
<p><img src="https://img.supervj.top/imgimage-20211231094851082.png" alt="image-20211231094851082"></p>
]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>AdvancedLocomotionSystemV4分析(四):布娃娃和起身</title>
    <url>/2020/10/29/AdvancedLocomotionSystem%E5%88%86%E6%9E%904_%E5%B8%83%E5%A8%83%E5%A8%83%E5%92%8C%E8%B5%B7%E8%BA%AB/</url>
    <content><![CDATA[<blockquote>
<p>  接下来就是布娃娃系统，对应的就有从布娃娃恢复成正常状态的起身动作。</p>
<p>这里还同时分析了一下站立和下蹲姿势的切换，因为起身动作会涉及到这一块</p>
</blockquote>
<p><a href="https://supervj.top/2020/10/26/AdvancedLocomotionSystem%E5%88%86%E6%9E%901_%E5%9F%BA%E7%A1%80%E7%A7%BB%E5%8A%A8%E5%92%8C%E8%84%9A%E6%AD%A5IK/">AdvancedLocomotionSysemV4分析(一):移动和脚步IK</a></p>
<p><a href="https://supervj.top/2020/10/27/AdvancedLocomotionSystem%E5%88%86%E6%9E%902_%E6%94%80%E7%88%AC%E7%B3%BB%E7%BB%9F/">AdvancedLocomotionSystem分析(二):攀爬系统</a></p>
<p><a href="https://supervj.top/2020/10/28/AdvancedLocomotionSystem%E5%88%86%E6%9E%903_%E5%8A%A8%E4%BD%9C%E5%8F%A0%E5%8A%A0/">AdvancedLocomotionSystemV4分析(三):动作叠加</a></p>
<span id="more"></span>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>站姿切换的输入比较简单粗暴，<code>ASL</code>项目用一个按键来实现姿势切换和翻滚，我这里方便测试就直接把这两个功能分开了，只需要设定一个按键直接调用<code>Crouch</code>和<code>UnCrouch</code>即可，然后在角色自带的时间<code>OnStartCrouch</code>和<code>OnEndCrouch</code>去调用方法<code>OnStanceChanged</code></p>
<p>然后是布娃娃的输入，直接按键以后调用<code>RagdollStart</code>即可，如果已经处于<code>Ragdoll</code>状态就调用<code>RagdollEnd</code>结束布娃娃状态</p>
<h3 id="布娃娃"><a href="#布娃娃" class="headerlink" title="布娃娃"></a>布娃娃</h3><h5 id="开始-进入布娃娃状态"><a href="#开始-进入布娃娃状态" class="headerlink" title="开始/进入布娃娃状态"></a>开始/进入布娃娃状态</h5><p><img src="https://img.supervj.top/img/temp/image-20201030105803687.png" alt="image-20201030105803687"></p>
<p>进入布娃娃状态我们分3步走</p>
<ol>
<li>设置移动状态为<code>None</code>，设置<code>MovementState</code>为<code>Ragdoll</code></li>
<li>关闭胶囊体碰撞，设置骨骼模型的碰撞为<code>PhysicsBody</code>，开启物理和检测效果，打开<code>pelvis</code>及以下的所有骨骼物理效果</li>
<li>停止当前蒙太奇动画</li>
</ol>
<p>这里有一个非常大的坑需要注意，第2条的开启骨骼物理效果需要修改默认的骨骼物理资产，见下图</p>
<p><img src="https://i.loli.net/2020/10/30/J5BqkUfN9OT6iwC.png" alt="image-20201030110213472"></p>
<p>需要注意几点</p>
<ol>
<li>给<code>root</code>添加一个碰撞体</li>
<li>修改碰撞体属性，<code>PhysicsType</code>设置为<code>Kinematic</code>，关闭碰撞检测</li>
<li>修改<code>root</code>与<code>pelvis</code>碰撞体之间的约束，线性约束全部设置为<code>free</code></li>
</ol>
<p>如果不做以上几点你就会发现起身以后位置的异常，是因为<code>pelvis</code>碰撞体如果最为最上层碰撞体必然会导致的异常位置缘故</p>
<hr>
<p>进入布娃娃以后我们也需要看一下动画蓝图中的内容</p>
<p><img src="https://i.loli.net/2020/10/30/yBKTroaSxOXpq1A.png" alt="image-20201030111405881"></p>
<p>在主动画视图里的最后节点混合了布娃娃状态机</p>
<p><img src="https://i.loli.net/2020/10/30/FCjpBRAJ6GuMlVE.png" alt="image-20201030111447376"></p>
<p>比较简单，2个状态机切换而已</p>
<p>刚进入布娃娃的时候使用动画<code>Flail</code>动画来过度</p>
<p><img src="https://i.loli.net/2020/10/30/OEUAsicdynKHXfl.png" alt="image-20201030111604063"></p>
<p>离开布娃娃时会使用离开布娃娃瞬间保存的<strong>快照动作</strong>来过度，很巧妙</p>
<h5 id="刷新布娃娃状态"><a href="#刷新布娃娃状态" class="headerlink" title="刷新布娃娃状态"></a>刷新布娃娃状态</h5><p><img src="https://i.loli.net/2020/10/30/M6uotmZCwDh3eE4.png" alt="image-20201030111139863"></p>
<p><img src="https://i.loli.net/2020/10/30/EGlQo1g3qYVsmKn.png" alt="image-20201030111151057"></p>
<p>图片上的注释已经说的比较详细了，用的方法比较传统，这个<strong>线速度</strong>保存着是为了在结束布娃娃状态的时候在特定时候需要继续使用</p>
<h5 id="结束布娃娃状态"><a href="#结束布娃娃状态" class="headerlink" title="结束布娃娃状态"></a>结束布娃娃状态</h5><p><img src="https://i.loli.net/2020/10/30/eVtYHkbiJg38AhQ.png" alt="image-20201030111753682"></p>
<p>需要稍微注意的是这里有一个方法<code>GetGetUpAnimation</code>来得到具体的起身蒙太奇动画，考虑到的主要就是动作叠加问题，其实动画序列来自于同一个，只是动画通知内容不一样</p>
<p><img src="https://i.loli.net/2020/10/30/KMrmGi8ba541VUh.png" alt="image-20201030112204582"></p>
<p>动画通知调用了接口设置角色的状态为<code>GettingUp</code></p>
<hr>
<p>到这里，整个布娃娃和起身逻辑基本上完成了，但是实现的时候还会发现一个问题，就是起身以后会异常抖动</p>
<p>原因是这套系统需要配合站立/下蹲的过度切换，如果不参用这个套路或者<strong>把起身动画里的下蹲权重=1的曲线<code>BasePose_CLF</code>删掉或设置为0</strong>都可以让角色直接成为站立状态，不需要下蹲姿势的过度，不过这个效果稍微差劲一点，看下图对比</p>
<p><img src="https://i.loli.net/2020/10/30/JpYtPrWhNVEjwb2.gif" alt="录制_2020_10_30_11_28_27_728"></p>
<p><img src="https://i.loli.net/2020/10/30/KZQO1R8egDhTXPH.gif" alt="录制_2020_10_30_11_29_12_605"></p>
<h5 id="站立-下蹲切换"><a href="#站立-下蹲切换" class="headerlink" title="站立/下蹲切换"></a>站立/下蹲切换</h5><p><img src="https://i.loli.net/2020/10/30/1IVeWwyZxJpT2K3.png" alt="image-20201030113156852"></p>
<p>下蹲在<code>Baselayer</code>层内也有类似站姿的2个状态机，实现内容也大同小异不过多讲述了</p>
<p><code>Cycles</code>内6方向混合，<code>States</code>内停止/移动切换，转身</p>
<p>重点看一下<code>MainGrounded</code>状态机内的姿势切换状态机</p>
<p><img src="https://i.loli.net/2020/10/30/EsPUB8oyIfOwcR6.png" alt="image-20201030113355979"></p>
<p>拿一张脑图来说明一下</p>
<p><img src="https://i.loli.net/2020/10/30/meMcgWJy7s6UlH3.png" alt="image-20201030115438341"></p>
<p>两个过渡状态机添加了通知<code>StopTransition</code></p>
<p>另外，目前阶段的切换站姿会导致视角抖动，因为UE4本身<code>Crouch</code>的瞬间会把胶囊体的大小缩放为<code>CrouchHalfHeight</code>的高度，解决方法是把相机独立出去，即不挂载在角色身上，后续分析</p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
  </entry>
  <entry>
    <title>AssetManager的使用</title>
    <url>/2020/12/29/AssetManager/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>AssetManager(下面简称AM)</code>是一个全局单例类，用于管理各种<code>primary assets</code>和<code>asset bundles</code>。</p>
<p>可以在运行时对<code>Primary Assets</code>进行加载和释放操作</p>
<p>补充官方文档对于<code>AssetManager</code>的介绍</p>
<blockquote>
<p>虚幻引擎 4 自动处理 <a href="https://docs.unrealengine.com/zh-CN/Basics/AssetsAndPackages/index.html">资源</a> 加载与卸载，开发者无需编写系统代码告知引擎具体所需的资源。然而，某些情况下开发者可能需要更精确地掌控资源发现、加载与审核的时机与方法。在这些情况下，<strong>资源管理器（Asset Manager）</strong> 便能大显身手。资源管理器是存在于编辑器和打包游戏中的独特全局对象，可根据不同项目进行覆盖和自定义。它提供了一个管理资源的框架，可将内容划分为数据块，对应项目的上下文，而同时保证虚幻引擎 4 <a href="https://docs.unrealengine.com/zh-CN/Basics/AssetsAndPackages/index.html">松散打包架构</a> 的优势。它同时提供了一套工具，协助审核硬盘和内存使用，提供所需信息，以优化资源组织，在部署游戏时进行 <a href="https://docs.unrealengine.com/zh-CN/SharingAndReleasing/Patching/GeneralPatching/CookingAndChunking/index.html">烘焙和数据块划分</a> 。</p>
</blockquote>
<p>我们可以在项目设置中自定义<code>AM</code>类</p>
<p><img src="https://img.supervj.top//img/image-20201228110451282.png" alt="image-20201228110451282"></p>
<p>或者修改<code>DefaultEngine.ini</code>文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[/Script/Engine.Engine] AssetManagerClassName=/Script/Module.UClassName 其中<span class="string">&quot;Module&quot;</span>代表项目的模块名，<span class="string">&quot;UClassName&quot;</span>则代表希望使用的 UClass 名。</span><br></pre></td></tr></table></figure>



<span id="more"></span>



<h2 id="关于资源和注册"><a href="#关于资源和注册" class="headerlink" title="关于资源和注册"></a>关于资源和注册</h2><h3 id="Asset-Registry"><a href="#Asset-Registry" class="headerlink" title="Asset Registry"></a>Asset Registry</h3><p>Asset Registry是Asset注册表，位于Project Settings——AssetManager中(Primany Asset Types To Scan)，其中存储了每个的asset的有用信息。这些信息会在asset被储存的时候进行更新。</p>
<blockquote>
<p>之前的文章<a href="https://supervj.top/2020/11/27/%E8%B5%84%E6%BA%90%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/?highlight=regis">资源注册</a>简单分析了<code>IAssetRegistry</code>模块的一些基础数据和功能;</p>
</blockquote>
<h3 id="Asset"><a href="#Asset" class="headerlink" title="Asset"></a>Asset</h3><p>我们在编辑器<code>ContentBrowser</code>内看到的都是<code>Asset</code>,初学者容易混淆场景中真正生成的对象与<code>Asset</code>的关系,我们一般的蓝图类都是类型<code>Blueprint</code>的<code>Asset</code></p>
<p>我们通过蓝图<code>IAssetRegistry</code>可以查找已经注册的<code>Asset</code>信息</p>
<p><img src="https://img.supervj.top//img/image-20201228104718787.png" alt="image-20201228104718787"></p>
<h2 id="主资源和次资源"><a href="#主资源和次资源" class="headerlink" title="主资源和次资源"></a>主资源和次资源</h2><p>UE4将所有资源分为两类：<strong>主资源</strong> 和 <strong>次资源</strong>, 即<code>PrimaryAsse</code>t和<code>SecondaryAsset</code></p>
<p>默认只有目录<code>Content/Maps/</code>内的 <code>UWorld</code> 资源（关卡）为主资源；</p>
<p>次资源不由资源管理器直接处理，但其被主资源引用或使用后引擎便会自动进行加载。</p>
<p>调用 <code>GetPrimaryAssetId</code> 即可获得资源的 ID。如需将<strong>次资源</strong>指定为<strong>主资源</strong>，需要覆盖 <code>GetPrimaryAssetId</code> 即可返回一个有效的 <code>FPrimaryAssetId</code> 结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FPrimaryAssetId <span class="title">USRItem::GetPrimaryAssetId</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">FPrimaryAssetId</span>(ItemType, <span class="built_in">GetFName</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="注册主资源"><a href="#注册主资源" class="headerlink" title="注册主资源"></a>注册主资源</h2><p>我们的主资源不仅需要重写<code>GetPrimaryAssetId()</code>方法, 还需要把对应<code>PrimaryAssetType</code>的字符串填写到项目设置中, 即<strong>用资源管理器注册主资源</strong>,如下图</p>
<p><img src="https://img.supervj.top//img/image-20201229172845276.png" alt="image-20201229172845276"></p>
<p>这样引擎就会自动扫描对应目录下的对应类型的主资源</p>
<p>在蓝图中可以用如下节点查看是否已经拥有该类型的标签</p>
<p><img src="https://img.supervj.top//img/image-20201229172959486.png" alt="image-20201229172959486"></p>
<p>这样我们就可以对资源进行加载和卸载操作了</p>
<blockquote>
<p>注意: 项目设置注册的类型名称与<code>GetPrimaryAssetId()</code>定义的名称必须一样, 不然找不到</p>
</blockquote>
<h2 id="PrimaryDataAsset"><a href="#PrimaryDataAsset" class="headerlink" title="PrimaryDataAsset"></a>PrimaryDataAsset</h2><p><code>PrimaryDataAsset</code>从 <code>UPrimaryDataAsset</code> 继承, 拥有加载和保存<a href="#%E8%B5%84%E6%BA%90%E6%9D%9F">资源束</a>的功能</p>
<p>接用<em>Fortnite</em>的话</p>
<blockquote>
<p>大多数的Primary Asset由于可能会直接被美术或策划直接修改，因此通常都会有一个在磁盘上的表现形式。常用的手法是将其继承自<code>UPrimaryDataAsset</code>。通过这种手法就可以直接在引擎中添加新的Primary Data Asset</p>
</blockquote>
<p>在<code>ActionRPG</code>项目中, 项目用<code>URPGItem</code>继承自 <code>PrimaryDataAsset</code>, 管理了所有道具类的数据, 包括技能,武器, 消耗品等</p>
<p>在<code>Item</code>基类里面可以设置一些通用的变量比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源类型, 需要匹配项目设置对应的名称</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = Item)</span><br><span class="line">		FPrimaryAssetType ItemType;</span><br><span class="line">	<span class="comment">//名称</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = Item)</span><br><span class="line">		FText ItemName;</span><br><span class="line">	<span class="comment">//描述</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = Item)</span><br><span class="line">		FText ItemDescription;</span><br><span class="line">	<span class="comment">//Icon</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = Item)</span><br><span class="line">		FSlateBrush ItemIcon;</span><br></pre></td></tr></table></figure>













<a name = "资源束">

<h2 id="资源束-AssetBundle"><a href="#资源束-AssetBundle" class="headerlink" title="资源束/AssetBundle"></a>资源束/AssetBundle</h2><p><code>AssetBundle</code>是一个<code>Asset</code>的列表，用于将一堆<code>Asset</code>在runtime的时候载入。</p>
<ul>
<li>FAssetBundleEntry</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 保存了Asset的资源束信息 ,对于全局捆绑包，或者在保存的捆绑包信息中，这是空的 */</span></span><br><span class="line">	FPrimaryAssetId BundleScope;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 这个bundle的特定的唯一名称*/</span></span><br><span class="line">	FName BundleName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 包含的资源软路径表 */</span></span><br><span class="line">	TArray&lt;FSoftObjectPath&gt; BundleAssets;</span><br></pre></td></tr></table></figure>

<ul>
<li>FAssetBundleData</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** FAssetBundleEntry 数组 */</span></span><br><span class="line">	TArray&lt;FAssetBundleEntry&gt; Bundles;</span><br></pre></td></tr></table></figure>

<p>举例几个方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/** Returns pointer to an entry with given Scope/Name */</span></span><br><span class="line">	<span class="function">FAssetBundleEntry* <span class="title">FindEntry</span><span class="params">(<span class="keyword">const</span> FPrimaryAssetId&amp; SearchScope, FName SearchName)</span></span>;</span><br><span class="line"><span class="comment">/** Adds or updates an entry with the given BundleName -&gt; Path. Scope is empty and will be filled in later */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddBundleAsset</span><span class="params">(FName BundleName, <span class="keyword">const</span> FSoftObjectPath&amp; AssetPath)</span></span>;</span><br><span class="line">..................</span><br></pre></td></tr></table></figure>



<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p>在cpp中, 可以在<code>AssetManager</code>中使用如下<code>API</code>使用资源</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * Loads a list of Primary Assets. This will start an async load of those assets, calling callback on completion.</span></span><br><span class="line"><span class="comment">	 * These assets will stay in memory until explicitly unloaded.</span></span><br><span class="line"><span class="comment">	 * You can wait on the returned streamable request or poll as needed.</span></span><br><span class="line"><span class="comment">	 * If there is no work to do, returned handle will be null and delegate will get called before function returns.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param AssetsToLoad		List of primary assets to load</span></span><br><span class="line"><span class="comment">	 * @param LoadBundles		List of bundles to load for those assets</span></span><br><span class="line"><span class="comment">	 * @param DelegateToCall	Delegate that will be called on completion, may be called before function returns if assets are already loaded</span></span><br><span class="line"><span class="comment">	 * @param Priority			Async loading priority for this request</span></span><br><span class="line"><span class="comment">	 * @return					Streamable Handle that can be used to poll or wait. You do not need to keep this handle to stop the assets from being unloaded</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;FStreamableHandle&gt; <span class="title">LoadPrimaryAssets</span><span class="params">(<span class="keyword">const</span> TArray&lt;FPrimaryAssetId&gt;&amp; AssetsToLoad, <span class="keyword">const</span> TArray&lt;FName&gt;&amp; LoadBundles = TArray&lt;FName&gt;(), FStreamableDelegate DelegateToCall = FStreamableDelegate(), TAsyncLoadPriority Priority = FStreamableManager::DefaultAsyncLoadPriority)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Single asset wrapper */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;FStreamableHandle&gt; <span class="title">LoadPrimaryAsset</span><span class="params">(<span class="keyword">const</span> FPrimaryAssetId&amp; AssetToLoad, <span class="keyword">const</span> TArray&lt;FName&gt;&amp; LoadBundles = TArray&lt;FName&gt;(), FStreamableDelegate DelegateToCall = FStreamableDelegate(), TAsyncLoadPriority Priority = FStreamableManager::DefaultAsyncLoadPriority)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Loads all assets of a given type, useful for cooking */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;FStreamableHandle&gt; <span class="title">LoadPrimaryAssetsWithType</span><span class="params">(FPrimaryAssetType PrimaryAssetType, <span class="keyword">const</span> TArray&lt;FName&gt;&amp; LoadBundles = TArray&lt;FName&gt;(), FStreamableDelegate DelegateToCall = FStreamableDelegate(), TAsyncLoadPriority Priority = FStreamableManager::DefaultAsyncLoadPriority)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * Unloads a list of Primary Assets that were previously Loaded.</span></span><br><span class="line"><span class="comment">	 * If the only thing keeping these assets in memory was a prior Load call, they will be freed.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param AssetsToUnload	List of primary assets to load</span></span><br><span class="line"><span class="comment">	 * @return					Number of assets unloaded</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> int32 <span class="title">UnloadPrimaryAssets</span><span class="params">(<span class="keyword">const</span> TArray&lt;FPrimaryAssetId&gt;&amp; AssetsToUnload)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Single asset wrapper */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> int32 <span class="title">UnloadPrimaryAsset</span><span class="params">(<span class="keyword">const</span> FPrimaryAssetId&amp; AssetToUnload)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Loads all assets of a given type, useful for cooking */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> int32 <span class="title">UnloadPrimaryAssetsWithType</span><span class="params">(FPrimaryAssetType PrimaryAssetType)</span></span>;</span><br></pre></td></tr></table></figure>





<p>在蓝图中, 使用下图所示方法</p>
<p><img src="https://img.supervj.top//img/image-20201229174245630.png" alt="image-20201229174245630"></p>
<h2 id="FPrimaryAssetData"><a href="#FPrimaryAssetData" class="headerlink" title="FPrimaryAssetData"></a>FPrimaryAssetData</h2><p>定义了资源的一般数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Path used to look up cached asset data in the asset registry. This will be missing the _C for blueprint classes */</span></span><br><span class="line">	FName AssetDataPath;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Path to this asset on disk */</span></span><br><span class="line">	FSoftObjectPtr AssetPtr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Current state of this asset */</span></span><br><span class="line">	FPrimaryAssetLoadState CurrentState;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Pending state of this asset, will be copied to CurrentState when load finishes */</span></span><br><span class="line">	FPrimaryAssetLoadState PendingState;</span><br></pre></td></tr></table></figure>






<p>​    </p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>模块分析</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11新特性</title>
    <url>/2020/07/07/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h5 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h5><ul>
<li>自动类型推导</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = vec.<span class="built_in">begin</span>(), i != vec.<span class="built_in">end</span>(), ++i)</span><br><span class="line">&#123;……&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义模板函数时，推到依赖模板函数的变量类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_typename _Tx, _typename _Ty&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> v = x * y;</span><br><span class="line">	std::cout&lt;&lt;v&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multipy</span><span class="params">(_Tx x, _Ty y)</span>-&gt;<span class="title">decltype</span><span class="params">(x * y)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">return</span> x * y</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a)</span>-&gt;<span class="keyword">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a=<span class="number">10</span>,b=<span class="number">11.0</span>;<span class="comment">//报错，初始化必须统一类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b =a;</span><br><span class="line"><span class="keyword">auto</span> c=b;<span class="comment">//c为int，去除&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;d=b;<span class="comment">//d为引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> e=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> f = e;<span class="comment">//去除const</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = e;<span class="comment">//用&amp;，不去除const</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> brr = arr;      <span class="comment">//brr 类型为int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;crr = arr; <span class="comment">//crr为数组，即crr=arr[3]</span></span><br></pre></td></tr></table></figure>

<h5 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h5><blockquote>
<p>从变量或者表达式获取类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; <span class="title">fx</span><span class="params">()</span></span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="keyword">double</span> x; &#125;</span><br><span class="line"><span class="keyword">const</span> A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(var);<span class="comment">//int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">fx</span>());<span class="comment">//const int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(a-&gt;x);<span class="comment">//double</span></span><br><span class="line"><span class="keyword">decltype</span>((a-&gt;x));<span class="comment">//const double&amp;,内部括号导致语句作为表达式而不是成员访问计算。由于a声明为 const指针，因此类型是对const double的引用。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于<code>decltype</code>所用的引用来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有所不同。如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。</p>
</blockquote>
<p>C++14可以使用不带尾随返回类型的 <code>decltype(auto)</code> 来声明其返回类型取决于其模板参数类型的模板函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">myFunc</span><span class="params">(T&amp;&amp; t, U&amp;&amp; u)</span> </span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> forward&lt;T&gt;(t) + forward&lt;U&gt;(u); &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="using"><a href="#using" class="headerlink" title="using"></a>using</h5><ul>
<li>命名空间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义别名，类似<code>typedef</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> itType=std::vector&lt;std::string&gt;::iterator;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>using与typedef的差别是 using可以用于模板部分具体化，但是typedef不能</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="keyword">using</span> arr12=std::array&lt;T,<span class="number">12</span>&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>当一个派生类私有继承基类时，基类的public和protected数据成员在派生类中是private的形式，如果想让这些继承而来的数据成员作为public或者protected成员，可以用using来重新声明。using声明语句中名字的访问权限由该using声明语句之前的访问说明符决定。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk</span> :</span> <span class="keyword">private</span> Basic&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> Basic::a;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">using</span> Basic::b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>关于重写重载函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A1&quot;</span>; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;cout&lt;&lt;a;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> :</span><span class="keyword">public</span> A1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A2&quot;</span>;&#125;;</span><br><span class="line">	<span class="keyword">using</span> A1::test;<span class="comment">//如果不加此行，A2将只保留test()部分，导致主函数内报错</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A2 a2;</span><br><span class="line">	a2.<span class="built_in">test</span>(<span class="number">11</span>);<span class="comment">//如果不用using，此行报错</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h5><p><code>nullptr</code>比0更安全</p>
<h5 id="枚举作用域"><a href="#枚举作用域" class="headerlink" title="枚举作用域"></a>枚举作用域</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	P1=<span class="number">0</span>,</span><br><span class="line">	P2=<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	P1,<span class="comment">//歧义，编译失败</span></span><br><span class="line">	P2<span class="comment">//歧义，编译失败</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EnumA e1=EnumA::P1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们需要设置枚举的作用域,这样才可以编译的过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">EnumA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	P1=<span class="number">0</span>,</span><br><span class="line">	P2=<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">struct</span> <span class="title">EnumB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	P1,</span><br><span class="line">	P2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EnumA e1=EnumA::P1;</span><br><span class="line">	EnumB e2=EnumB::P2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h5><p>其实lambda实现的方法是创建一个简略的类。**这个类重载了operator()**，所以表现的像个普通函数。一个lambda函数是这个类的实例。当这个类构造的时候，所有捕获的变量被传送到类中并保存为成员变量。</p>
<p>表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>几个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">// 隐式返回类型</span></span><br><span class="line">[](<span class="keyword">int</span>&amp; x) &#123; ++x; &#125;   <span class="comment">// 没有return语句 -&gt; lambda 函数的返回类型是&#x27;void&#x27;</span></span><br><span class="line">[]() &#123; ++global_x; &#125;  <span class="comment">// 没有参数,仅访问某个全局变量</span></span><br><span class="line">[]&#123; ++global_x; &#125;     <span class="comment">// 与上一个相同,省略了()</span></span><br><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">int</span> z = x + y; <span class="keyword">return</span> z; &#125;<span class="comment">//指示了返回值int</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关于<code>[]</code>的捕获信息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]        <span class="comment">//未定义变量.试图在Lambda内使用任何外部变量都是错误的.</span></span><br><span class="line">[x, &amp;y]   <span class="comment">//x 按值捕获, y 按引用捕获.</span></span><br><span class="line">[&amp;]       <span class="comment">//用到的任何外部变量都隐式按引用捕获</span></span><br><span class="line">[=]       <span class="comment">//用到的任何外部变量都隐式按值捕获</span></span><br><span class="line">[&amp;, x]    <span class="comment">//x显式地按值捕获. 其它变量按引用捕获</span></span><br><span class="line">[=, &amp;z]   <span class="comment">//z按引用捕获. 其它变量按值捕获</span></span><br><span class="line">[<span class="keyword">this</span>] <span class="comment">//截取当前类中的this指针。如果已经使用了&amp;或者=就默认添加此选项。</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A1* a1=<span class="keyword">new</span> <span class="built_in">A1</span>();</span><br><span class="line"><span class="keyword">int</span> a2=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda1=[&amp;a1,a2](<span class="keyword">int</span> v)&#123;a1-&gt;num=v;a2++;&#125;;<span class="comment">//错误，a2按值传递，不能修改</span></span><br><span class="line"><span class="keyword">auto</span> lambda1=[&amp;a1,a2](<span class="keyword">int</span> v)<span class="keyword">mutable</span> &#123;a2++;a1-&gt;num=v+a2;;&#125;;<span class="comment">//增加mutable后可以修改，但是对原数据无影响，输出结果a1-&gt;num : 15</span></span><br></pre></td></tr></table></figure>

<h5 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h5><p>显式转换，禁止单参数构造函数导致的自动转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">plebe</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">plebe</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">plebe</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plebe a,b;</span><br><span class="line">a=<span class="number">1</span>;<span class="comment">//隐式转换</span></span><br><span class="line">b=<span class="number">0.5</span>;<span class="comment">//错误</span></span><br><span class="line">b=<span class="built_in">plebe</span>(<span class="number">0.5</span>);<span class="comment">//显式转换</span></span><br></pre></td></tr></table></figure>

<h5 id="default-delete"><a href="#default-delete" class="headerlink" title="default,delete"></a>default,delete</h5><ul>
<li>default</li>
</ul>
<p>4类特殊函数可以用default，即默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符</p>
<blockquote>
<p>特殊情况，如果类内有指针成员，特殊函数都用default，以下情况会导致错误</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">testA</span>() =<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">testA</span>(<span class="keyword">const</span> testA&amp; t)=<span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">testA</span>()=<span class="keyword">default</span>;</span><br><span class="line">	testA&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> testA&amp; t)=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> *p=&amp;num;</span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line">testA *a1= <span class="keyword">new</span> <span class="built_in">testA</span>(<span class="number">1</span>);</span><br><span class="line">testA *a2 =a1;</span><br><span class="line"><span class="keyword">delete</span> a1;<span class="comment">//a2的p也被释放了</span></span><br><span class="line">cout&lt;&lt;*a2-&gt;p&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>delete</li>
</ul>
<h5 id="类内成员初始化"><a href="#类内成员初始化" class="headerlink" title="类内成员初始化"></a>类内成员初始化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">se</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1=<span class="number">10</span>;<span class="comment">//类内初始化</span></span><br><span class="line">    <span class="keyword">double</span> mem2&#123;<span class="number">123.65</span>&#125;;<span class="comment">//同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h5><ul>
<li>  左值、右值</li>
</ul>
<p>在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）</p>
<ul>
<li>右值、将亡值</li>
</ul>
<ol>
<li><p>C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。</p>
</li>
<li><p>将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。</p>
</li>
</ol>
<ul>
<li>左值引用、右值引用</li>
</ul>
<ol>
<li>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在</li>
<li>右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行<strong>初始化</strong></li>
<li>引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int &amp;a =2;//左值引用绑定右值，fail</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;<span class="comment">//非常量左值绑定右值，ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c=b;<span class="comment">//常量左值引用绑定非常量左值，ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;d=<span class="number">2</span>;<span class="comment">//常量左值引用绑定常量左值,ok</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; f=<span class="number">10</span>;<span class="comment">//右值引用绑定右值,ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;g=f;<span class="comment">//常量左值引用绑定右值引用,ok</span></span><br><span class="line"><span class="comment">//int &amp;&amp;h=b;//右值引用绑定非常量左值，fail</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;h=std::<span class="built_in">move</span>(b);<span class="comment">//move把左值转换为右值，ok</span></span><br><span class="line"><span class="comment">//int &amp;&amp;i=h;//变量是左值，h是左值,fail</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top/img/DX/image-20200707151813950.png" alt="image-20200707151813950"></p>
<h5 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h5><p>智能指针是用对象去管理一个资源指针，同时用一个计数器计算引用当前指针对象的个数，当管理指针的对象增加或减少时，计数器也相应加1或减1，当最后一个指针管理对象销毁时，计数器为1，此时在销毁指针管理对象的同时，也对指针管理对象所管理的指针进行delete操作。</p>
<ul>
<li>shared_ptr</li>
</ul>
<p>std::shared_ptr包装了new操作符动态分配的内存，可以自由拷贝复制，基本上是使用最多的一个智能指针类型。</p>
<blockquote>
<p>注意事项</p>
<p>我们尽量使用shared_ptr构造函数或者make_shared的方式创建shared_ptr，禁止使用裸指针赋值的方式，这样会shared_ptr难于管理指针的生命周期。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用裸指针赋值构造，不推荐，裸指针被释放后，shared_ptr就野了，不能完全控制裸指针的生命周期，失去了智能指针价值</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt;sp = p;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// sp将成为野指针，使用sp将crash</span></span><br><span class="line"><span class="comment">// 将裸指针作为匿名指针传入构造函数，一般做法，让shared_ptr接管裸指针的生命周期，更安全</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt;<span class="built_in">sp1</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>));</span><br><span class="line"><span class="comment">// 使用make_shared，推荐做法，更符合工厂模式，可以连代码中的所有new，更高效；方法的参数是用来初始化模板类</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt;sp2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>禁止使用指向shared_ptr的裸指针，也就是智能指针的指针，使用shared_ptr的指针指向一个shared_ptr时，<strong>引用计数并不会加一</strong>，操作shared_ptr的指针很容易就发生野指针异常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt;sp = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//输出1</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; *sp1 = &amp;sp;</span><br><span class="line">cout &lt;&lt; (*sp1).<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//输出依然是1</span></span><br><span class="line">(*sp1).<span class="built_in">reset</span>(); <span class="comment">//sp成为野指针</span></span><br><span class="line">cout &lt;&lt; *sp &lt;&lt; endl; <span class="comment">//crash</span></span><br></pre></td></tr></table></figure>





<ul>
<li>weak_ptr</li>
</ul>
<p>与std::shared_ptr最大的差别是在赋值的时候，不会引起智能指针计数增加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	shared_ptr&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	weak_ptr&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	shared_ptr&lt;A&gt; spa = make_shared&lt;A&gt;();</span><br><span class="line">	shared_ptr&lt;B&gt; spb = make_shared&lt;B&gt;();</span><br><span class="line">	spa-&gt;b = spb; <span class="comment">//spb强引用计数为2，弱引用计数为1</span></span><br><span class="line">	spb-&gt;a = spa; <span class="comment">//spa强引用计数为1，弱引用计数为2</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> weak_ptr的一些用法</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">weak_ptr&lt;T&gt; w;  <span class="comment">//空weak_ptr可以指向类型为T的对象</span></span><br><span class="line"><span class="function">weak_ptr&lt;T&gt; <span class="title">w</span><span class="params">(shared_ptr sp)</span></span>;   <span class="comment">//与sp指向相同对象的weak_ptr, T必须能转换为sp指向的类型</span></span><br><span class="line">w = p;  <span class="comment">//p可以是shared_ptr或者weak_ptr，赋值后w和p共享对象</span></span><br><span class="line">w.<span class="built_in">reset</span>();  <span class="comment">//weak_ptr置为空</span></span><br><span class="line">w.<span class="built_in">use_count</span>();  <span class="comment">//与w共享对象的shared_ptr的计数</span></span><br><span class="line">w.<span class="built_in">expired</span>();    <span class="comment">//w.use_count()为0则返回true，否则返回false</span></span><br><span class="line">w.<span class="built_in">lock</span>();   <span class="comment">//w.expired()为true，返回空的shared_ptr;否则返回指向w的shared_ptr</span></span><br></pre></td></tr></table></figure>



<ul>
<li>unique_ptr</li>
</ul>
<p>unique_ptr是auto_ptr的继承者，对于同一块内存只能有一个持有者，而unique_ptr和auto_ptr唯一区别就是unique_ptr不允许赋值操作，也就是不能放在等号的右边（函数的参数和返回值例外），这一定程度避免了一些误操作导致指针所有权转移，然而，unique_str依然有提供所有权转移的方法move，调用move后，原unique_ptr就会失效</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; p1=make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">11</span>);</span><br><span class="line">cout&lt;&lt;*p1&lt;&lt;endl;<span class="comment">//11</span></span><br><span class="line"><span class="keyword">auto</span> p2=<span class="built_in">move</span>(p1);</span><br><span class="line">cout&lt;&lt;*p1&lt;&lt;endl;<span class="comment">//访问空指针，崩溃</span></span><br></pre></td></tr></table></figure>







<h5 id="模板和STL方面的修改"><a href="#模板和STL方面的修改" class="headerlink" title="模板和STL方面的修改"></a>模板和STL方面的修改</h5><h6 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> price[<span class="number">5</span>]=&#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> x:prices)<span class="comment">//也可以使用auto来申明x，编译器将自动推断</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<h6 id="新的STL容器"><a href="#新的STL容器" class="headerlink" title="新的STL容器"></a>新的STL容器</h6><p>C++11新增的容器：forward_list,unordered_map,unordered_multimap,unordered_set,unordered_multiset</p>
<ul>
<li>关于unordered_map与map</li>
</ul>
<p>两者的接口差不多，基本可以互换。</p>
<p>一般来说unordered_map的综合性能比map要好，因此，通常我们可以使用unorderd_map代替map。</p>
<p>以下情况推荐使用map：</p>
<p>关键字类型的hash函数设计的很差， 或者==运算符的性能极差， 导致hash过程太耗时；<br>对内存使用有严格要求, 不能接受存储hash table的额外内存开销；<br>元素要求按顺序存储， 或者常常需要关联访问一个元素的上一个/下一个元素， 或者需要遍历整个map。</p>
<h6 id="新的STL方法"><a href="#新的STL方法" class="headerlink" title="新的STL方法"></a>新的STL方法</h6><p>新增了STL方法<code>cbegin()</code>和<code>cend()</code>，这些方法也返回一个迭代器，指向容器的第一个元素和最后一个元素的后面，因此可以用于指定包含全部元素的区间；这些新方法将元素视为const。类似的，crbegin()和crend()是rbegin()和rend()的const版本</p>
<h6 id="valarray升级"><a href="#valarray升级" class="headerlink" title="valarray升级"></a>valarray升级</h6><p>C++11添加了两个函数begin()和end()，都接受valarray作为参数并且返回迭代器</p>
<h6 id="摒弃export"><a href="#摒弃export" class="headerlink" title="摒弃export"></a>摒弃export</h6><p>C++98增加了关键字export，C++11摒弃了这个特性但是保留了关键字export</p>
<h6 id="尖括号"><a href="#尖括号" class="headerlink" title="尖括号"></a>尖括号</h6><p>为了避免与运算符&gt;&gt;混淆，C++要求在申明嵌套模板时使用空格将尖括号分开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;list&lt;<span class="keyword">int</span>&gt;&gt; vl;<span class="comment">//C++11开始不再强求空格</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>Control Rig:藤编植物</title>
    <url>/2024/12/06/Control%20Rig_%E8%97%A4%E7%BC%96%E6%A4%8D%E7%89%A9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用Control Rig为主来制作一个藤编植物的攻击行为</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205110725024.png" alt="image-20241205110725024"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205110835304.png" alt="image-20241205110835304"></p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a><strong>需求</strong></h2><ul>
<li><strong>攻击行为的时候需要需要动态的指定打击点</strong></li>
<li>特定时间段需要跟随玩家平滑旋转</li>
<li>是否可以增加物理动态效果？</li>
</ul>
<h2 id="攻击方案"><a href="#攻击方案" class="headerlink" title="攻击方案"></a>攻击方案</h2><ul>
<li>旋转骨骼</li>
<li>IK</li>
<li>其他</li>
</ul>
<h3 id="旋转骨骼"><a href="#旋转骨骼" class="headerlink" title="旋转骨骼"></a>旋转骨骼</h3><p><a href="https://www.youtube.com/watch?v=uuFWqFExlW4&amp;t=934s">https://www.youtube.com/watch?v=uuFWqFExlW4&amp;t=934s</a></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_05_10_20_30_946.gif" alt="录制_2024_12_05_10_20_30_946"></p>
<p>思路采取的是上面这个up的方式，通过旋转某根骨骼来对齐某个目标点</p>
<p>但是这个方法比较局限，只能在小范围内相对的对准某个点，即使上面的案例里，也只是对准，但是无法让拳头正好打中目标点</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_05_10_26_08_245~1.gif" alt="录制_2024_12_05_10_26_08_245~1"></p>
<p>如上图所示，追求准确性的话那么这个方式暂时放弃</p>
<h3 id="IK"><a href="#IK" class="headerlink" title="IK"></a>IK</h3><p>最容易实现的方案应该就是IK了</p>
<p>目前5.4中ABP中的IK方式有如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205111027501.png" alt="image-20241205111027501"></p>
<p>ControlRig中稍微多几个，如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205111041414.png" alt="image-20241205111041414"></p>
<h3 id="TwoBoneIK-BasicIK"><a href="#TwoBoneIK-BasicIK" class="headerlink" title="TwoBoneIK / BasicIK"></a>TwoBoneIK / BasicIK</h3><p>这俩差不多，是最常见的那种IK方式，因为怪物的脖子一共有18个关节，此方式不合适也无法实现</p>
<h3 id="Spline-IK"><a href="#Spline-IK" class="headerlink" title="Spline IK"></a>Spline IK</h3><p>这个是最容易想到的IK，但是结果差强人意，看下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205111102448.png" alt="image-20241205111102448"></p>
<p>SplineIK会覆盖动画效果，这个功能应用场景比较偏向于离线编辑或者程序化的动画</p>
<p>与我们的需求不符</p>
<p>类似的还有ControlRig中的SpringIK 和 几个Chain节点，比如</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205111114513.png" alt="image-20241205111114513"></p>
<h3 id="FABRIK-CCDIK"><a href="#FABRIK-CCDIK" class="headerlink" title="FABRIK / CCDIK"></a>FABRIK / CCDIK</h3><p>那么剩下的只有这俩选择了</p>
<p>这两个一起看，因为最终的效果是有相似之处的，只是实现方式不同</p>
<p>先放两张图简单解释一下2种IK</p>
<ul>
<li>FABRIK（前后延伸逆向动力学 Forward And Backward Reaching Inverse Kinematic）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205111132747.png" alt="image-20241205111132747"></p>
<ul>
<li>CCDIK 循环坐标下降逆向动力学（Cyclic Coordinate Descent IK）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205111149025.png" alt="image-20241205111149025"></p>
<p>最终的效果是前者比较好一点</p>
<p>这里为了效果更好可以做一个额外的处理</p>
<p>最开始的关节的旋转有点太不利于IK结算</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205111214136.png" alt="image-20241205111214136"></p>
<p>最终的效果比较理想</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_05_11_02_22_665.gif" alt="录制_2024_12_05_11_02_22_665"></p>
<h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><p>理论上可以用动画混合的方式来动态的控制落点， 先留个坑，资源问题不尝试</p>
<h2 id="旋转方案"><a href="#旋转方案" class="headerlink" title="旋转方案"></a>旋转方案</h2><ul>
<li>Body骨骼缓速跟随目标点旋转</li>
<li>头部骨骼快速跟随目标点旋转</li>
</ul>
<blockquote>
<p>需要注意的是， ControlRig种做多层骨骼旋转的 时候要先转根骨再转子骨骼，否则可能会造成子骨骼多次叠加旋转效果</p>
</blockquote>
<h3 id="身体旋转"><a href="#身体旋转" class="headerlink" title="身体旋转"></a>身体旋转</h3><p>Control Rig中最简单的方式就是用Aim节点</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_05_11_25_03_900.gif" alt="录制_2024_12_05_11_25_03_900"></p>
<p>在一般情况下效果很好，但是在目标点快速变化的时候，会有太快的旋转表现，属于有瑕疵</p>
<p>但是我们也无法对aim的计算方式进行修改</p>
<p>所以对于身体的旋转我们需要手动的计算旋转差值</p>
<p>方法是记录初始旋转，然后计算旋转差值的方式，感觉ControlRig里实现这个不如蓝图方便</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205113335637.png" alt="image-20241205113335637"></p>
<p>改善以后的效果</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_05_11_34_30_971.gif" alt="录制_2024_12_05_11_34_30_971"></p>
<h3 id="头部旋转"><a href="#头部旋转" class="headerlink" title="头部旋转"></a>头部旋转</h3><p>然后是头部</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205113550282.png" alt="image-20241205113550282"></p>
<p>使用多跟骨骼按不同权重朝向目标点</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_05_11_36_32_649.gif" alt="录制_2024_12_05_11_36_32_649"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>还可以再额外增加一点动态效果</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205114603458.png" alt="image-20241205114603458"></p>
<p>下图的黄点就是最终的效果，蓝色是添加动态之前的效果</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_05_11_44_11_546.gif" alt="录制_2024_12_05_11_44_11_546"></p>
<h2 id="物理效果"><a href="#物理效果" class="headerlink" title="物理效果"></a>物理效果</h2><p>因为这个是需要继承动画的，所以ABP里的用来模拟尾巴或者辫子的就先pass了</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205134600530.png" alt="image-20241205134600530"></p>
<p>那么就只有物理动画比较合适了</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_05_13_46_41_916.gif" alt="录制_2024_12_05_13_46_41_916"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205134749861.png" alt="image-20241205134749861"></p>
<p>编辑好碰撞，参数调大一点（因为需要继承较多的动画效果)</p>
<p>适当的调一下碰撞体的质量</p>
<p>物理效果跟IK是分离的，意味着在攻击打开IK之前需要慢慢的把物理动画关掉</p>
<p>IK关闭以后在逐步打开</p>
<blockquote>
<p>不可以瞬间打开，会导致快速的跳变</p>
</blockquote>
<p><strong><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241205140215355.png" alt="image-20241205140215355"></strong></p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_05_13_58_09_161.gif" alt="录制_2024_12_05_13_58_09_161"></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>DataTable优化方案</title>
    <url>/2025/01/14/DataTable%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250114182453643.png" alt="image-20250114182453643"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250114182516281.png" alt="image-20250114182516281"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250114182535643.png" alt="image-20250114182535643"></p>
<span id="more"></span>







<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>自动加载</li>
<li>更简单的方式查询数据</li>
<li>需要支持cpp和蓝图</li>
</ul>
<h2 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h2><p>创建一个Setting类存储所有需要加载的表格</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250114181143210.png" alt="image-20250114181143210"></p>
<p>用一个引擎子系统加载和保存所有表格</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250114181232265.png" alt="image-20250114181232265"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250114181434501.png" alt="image-20250114181434501"></p>
<p>核心其实是用数据类型的哈希作为键来保存到Map中，这样就可以用模板的方式查询</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250114181547907.png" alt="image-20250114181547907"></p>
<p>这里是包到了一个函数库中去，其实也可以直接放外面</p>
<h2 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h2><p>蓝图需要实现一个通过数据查询的方法麻烦很多</p>
<p>我们需要实现一个运行时的泛型函数，一个编辑器模式下的K2Node（类似GetDataTableRow)，因为需要动态的修改数据类型和Row的Pin，所有还需要一个Factory来定义这两个Pin</p>
<h3 id="蓝图函数"><a href="#蓝图函数" class="headerlink" title="蓝图函数"></a>蓝图函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable,CustomThunk,meta = (CustomStructureParam = <span class="string">&quot;OutRow&quot;</span>, BlueprintInternalUseOnly=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">static</span>  <span class="keyword">bool</span> <span class="title">TryGetTableRowData</span><span class="params">(UPARAM(meta=(GetOptions = <span class="string">&quot;GetAllTableStructs&quot;</span>))FName StructName,FName RowName, FTableRowBase&amp; OutRow)</span></span>&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span>  <span class="keyword">bool</span> <span class="title">Generic_TryGetTableRowData</span><span class="params">(FName StructName, FName RowName, <span class="keyword">void</span>* OutRowPtr)</span></span>;</span><br><span class="line">	<span class="built_in">DECLARE_FUNCTION</span>(execTryGetTableRowData)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">P_GET_PROPERTY</span>(FNameProperty, StructName);</span><br><span class="line">		<span class="built_in">P_GET_PROPERTY</span>(FNameProperty, RowName);</span><br><span class="line">		</span><br><span class="line">		Stack.MostRecentProperty = <span class="literal">nullptr</span>;</span><br><span class="line">		Stack.StepCompiledIn&lt;FStructProperty&gt;(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">void</span>* OutRowPtr = Stack.MostRecentPropertyAddress;</span><br><span class="line">		</span><br><span class="line">		P_FINISH;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">bool</span> bSuccess = <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		FStructProperty* StructProp = CastField&lt;FStructProperty&gt;(Stack.MostRecentProperty);</span><br><span class="line">		</span><br><span class="line">		UDataTable* Table = UDataTableUtility::<span class="built_in">FindTableByStructName</span>(StructName);</span><br><span class="line">		<span class="keyword">if</span> (!Table)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">FBlueprintExceptionInfo <span class="title">ExceptionInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">				EBlueprintExceptionType::AccessViolation,</span></span></span><br><span class="line"><span class="params"><span class="function">				NSLOCTEXT(<span class="string">&quot;TryGetTableRowData&quot;</span>, <span class="string">&quot;MissingStructInput&quot;</span>, <span class="string">&quot;Failed to resolve the table input. Be sure the DataTable is valid.&quot;</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">			)</span></span>;</span><br><span class="line">			FBlueprintCoreDelegates::<span class="built_in">ThrowScriptException</span>(P_THIS, Stack, ExceptionInfo);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(StructProp &amp;&amp; OutRowPtr)</span><br><span class="line">		&#123;</span><br><span class="line">			UScriptStruct* OutputType = StructProp-&gt;Struct;</span><br><span class="line">			<span class="keyword">const</span> UScriptStruct* TableType  = Table-&gt;<span class="built_in">GetRowStruct</span>();</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bCompatible = (OutputType == TableType) || </span><br><span class="line">				(OutputType-&gt;<span class="built_in">IsChildOf</span>(TableType) &amp;&amp; FStructUtils::<span class="built_in">TheSameLayout</span>(OutputType, TableType));</span><br><span class="line">			<span class="keyword">if</span> (bCompatible)</span><br><span class="line">			&#123;</span><br><span class="line">				P_NATIVE_BEGIN;</span><br><span class="line">				bSuccess = <span class="built_in">Generic_TryGetTableRowData</span>(StructName, RowName, OutRowPtr);</span><br><span class="line">				P_NATIVE_END;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				FBlueprintExceptionInfo <span class="built_in">ExceptionInfo</span>(</span><br><span class="line">					EBlueprintExceptionType::AccessViolation,</span><br><span class="line">					<span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;TryGetTableRowData&quot;</span>, <span class="string">&quot;IncompatibleProperty&quot;</span>, <span class="string">&quot;Incompatible output parameter; the data table&#x27;s type is not the same as the return type.&quot;</span>)</span><br><span class="line">					);</span><br><span class="line">				FBlueprintCoreDelegates::<span class="built_in">ThrowScriptException</span>(P_THIS, Stack, ExceptionInfo);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			FBlueprintExceptionInfo <span class="built_in">ExceptionInfo</span>(</span><br><span class="line">				EBlueprintExceptionType::AccessViolation,</span><br><span class="line">				<span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;TryGetTableRowData&quot;</span>, <span class="string">&quot;MissingOutputProperty&quot;</span>, <span class="string">&quot;Failed to resolve the output parameter for GetDataTableRow.&quot;</span>)</span><br><span class="line">			);</span><br><span class="line">			FBlueprintCoreDelegates::<span class="built_in">ThrowScriptException</span>(P_THIS, Stack, ExceptionInfo);</span><br><span class="line">		&#125;</span><br><span class="line">		*(<span class="keyword">bool</span>*)RESULT_PARAM = bSuccess;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>这个函数没有暴露给蓝图，即使暴露了也是不够的，因为数据结构是可以通过办法来制作下拉表，但是这个RowName没办法，所以只能靠K2Node</p>
<h3 id="K2Node"><a href="#K2Node" class="headerlink" title="K2Node"></a>K2Node</h3><p>可以先把K2Node_GetDataTableRow复制过来，因为区别就是他传递的是一个UObject，我们改成FName即可</p>
<p>，还需要一个工具函数通过Name去查询DataTable</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UDataTable* <span class="title">UDataTableUtility::FindTableByStructName</span><span class="params">(FName Name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除所有空格</span></span><br><span class="line">	FString StrName = Name.<span class="built_in">ToString</span>();</span><br><span class="line">	<span class="built_in">RemoveEmpty</span>(StrName);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">auto</span> Setting = GetMutableDefault&lt;UDataTableUtilitySettings&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Table : Setting-&gt;Tables)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!Table || Table.<span class="built_in">Get</span>()-&gt;<span class="built_in">GetRowStruct</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			FString StructName = Table.<span class="built_in">Get</span>()-&gt;<span class="built_in">GetRowStruct</span>()-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">			<span class="built_in">RemoveEmpty</span>(StructName);</span><br><span class="line">			<span class="comment">// FString DisplayName = Table.Get()-&gt;GetRowStruct()-&gt;GetName().ToString();</span></span><br><span class="line">			<span class="comment">// RemoveEmpty(DisplayName);</span></span><br><span class="line">			<span class="keyword">if</span> (Table.<span class="built_in">IsValid</span>() &amp;&amp; StructName == StrName <span class="comment">/*|| DisplayName == StrName)*/</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> Table.<span class="built_in">Get</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h3><p>这个对象的目的就是修改2个pin</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TSharedPtr&lt;SGraphPin&gt; <span class="title">FDataTableUtilityPinFactory::CreatePin</span><span class="params">(UEdGraphPin* InPin)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (InPin-&gt;PinType.PinCategory == UEdGraphSchema_K2::PC_Name )</span><br><span class="line">	&#123;</span><br><span class="line">		UObject* Outer = InPin-&gt;<span class="built_in">GetOuter</span>();</span><br><span class="line">		<span class="keyword">const</span> UEdGraphPin* DataTablePin = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">if</span> (Outer-&gt;<span class="built_in">IsA</span>(UK2Node_GetTableData::<span class="built_in">StaticClass</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//处理行号</span></span><br><span class="line">			<span class="keyword">if</span> (InPin-&gt;PinName == GetTableData::RowNamePinName)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">const</span> UK2Node_GetTableData* GetDataTableRowNode = CastChecked&lt;UK2Node_GetTableData&gt;(Outer);</span><br><span class="line">				DataTablePin = GetDataTableRowNode-&gt;<span class="built_in">GetDataTablePin</span>();</span><br><span class="line">				<span class="keyword">auto</span> FilterPin = GetDataTableRowNode-&gt;<span class="built_in">GetFilterPin</span>();</span><br><span class="line">				<span class="keyword">if</span> (DataTablePin)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (!DataTablePin-&gt;DefaultValue .<span class="built_in">IsEmpty</span>() &amp;&amp; DataTablePin-&gt;LinkedTo.<span class="built_in">Num</span>() == <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (<span class="keyword">auto</span> DataTable = UDataTableUtility::<span class="built_in">FindTableByStructName</span>(<span class="built_in">FName</span>(DataTablePin-&gt;DefaultValue)))</span><br><span class="line">						&#123;</span><br><span class="line">							TArray&lt;FName&gt; Names = DataTable-&gt;<span class="built_in">GetRowNames</span>();</span><br><span class="line">							<span class="keyword">if</span> (FilterPin)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="comment">// Filter the names</span></span><br><span class="line">								Names = Names.<span class="built_in">FilterByPredicate</span>([FilterPin](FName Name)</span><br><span class="line">								&#123;</span><br><span class="line">									<span class="keyword">return</span> Name.<span class="built_in">ToString</span>().<span class="built_in">Contains</span>(FilterPin-&gt;DefaultValue);</span><br><span class="line">								&#125;);</span><br><span class="line">							&#125;</span><br><span class="line">							TArray&lt;TSharedPtr&lt;FName&gt;&gt; RowNames;</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">auto</span> Name:Names)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="comment">/** Create a simple array of the row names */</span></span><br><span class="line">								TSharedPtr&lt;FName&gt; RowNameItem = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FName</span>(Name));</span><br><span class="line">								RowNames.<span class="built_in">Add</span>(RowNameItem);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">return</span> <span class="built_in">SNew</span>(SGraphPinNameList, InPin, RowNames);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (InPin-&gt;PinName == GetTableData::DataTablePinName)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">const</span> UK2Node_GetTableData* GetDataTableRowNode = CastChecked&lt;UK2Node_GetTableData&gt;(Outer);</span><br><span class="line">				DataTablePin = GetDataTableRowNode-&gt;<span class="built_in">GetDataTablePin</span>();</span><br><span class="line">				<span class="keyword">if</span> (DataTablePin)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">auto</span> Names = UDataTableUtility::<span class="built_in">GetAllTableStructs</span>();</span><br><span class="line">				</span><br><span class="line">					TArray&lt;TSharedPtr&lt;FName&gt;&gt; RowNames;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">auto</span> Name:Names)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">/** Create a simple array of the row names */</span></span><br><span class="line">						TSharedPtr&lt;FName&gt; RowNameItem = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FName</span>(Name));</span><br><span class="line">						RowNames.<span class="built_in">Add</span>(RowNameItem);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="built_in">SNew</span>(SGraphPinNameList, InPin, RowNames);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为加加一个名字筛选的Filter,不然遇到表格行数特别多的就炸了, 算是模拟一个搜索功能,有需要的话也可以加一个包含或者非包含2种条件</p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>DataTable</tag>
      </tags>
  </entry>
  <entry>
    <title>Google开源压缩库Draco</title>
    <url>/2021/03/15/Draco/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Draco是谷歌在2017年1月发布的一个3D图形开源压缩库，提供了多种算法进行压缩和解压缩。<br>对于encoder过程，Draco整体思路是将网格的连接信息和几何信息进行分别编码并进行存储。<br>其中，连接信息使用了edgebreaker等算法进行了编码压缩，几何信息对数据进行量化、预测压缩、熵编码。其中熵编码采用了rANS算法。<br>本文对Draco源码进行分析, 另外对其进行封装成UE插件</p>
<p><img src="https://img.supervj.top//img/image-20210316094313248.png" alt="image-20210316094313248"></p>
<span id="more"></span>





<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol>
<li>下载源码, 地址<a href="https://github.com/google/draco">GitHub</a></li>
<li>CMake编译(可以用GUI默认编译即可),官方文档有详细说明</li>
<li>draco.sln启动VS编译</li>
<li>Debug文件夹内即可以使用的<code>exe</code>工具文件</li>
</ol>
<p><img src="https://img.supervj.top//img/image-20210315160330326.png" alt="image-20210315160330326"></p>
<h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><p><code>Draco</code>支持模型文件后缀为<code>obj</code>和<code>ply</code></p>
<p>拿模型文件<code>source.obj</code>做实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./draco_encoder.exe -i 输入文件 -o 输出文件</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210315160712714.png" alt="image-20210315160712714"></p>
<p>常用参数可以用 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-qp #参数 (位置量化, 默认11)</span><br><span class="line">-cl #参数  (压缩级别, 默认7)</span><br></pre></td></tr></table></figure>



<p>反向操作可以把<code>*.drc</code>作为输入文件, 把<code>*.obj</code>作为输出文件即可</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>压缩和反压缩的入口文件分别是<code>draco_encoder.cc</code>和<code>draco_decoder.cc</code></p>
<p>我们已压缩做示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.........</span></span><br><span class="line"><span class="keyword">if</span> (options.pos_quantization_bits &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">&quot;Error: The maximum number of quantization bits for the position &quot;</span></span><br><span class="line">            <span class="string">&quot;attribute is 30.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;-qt&quot;</span>, argv[i]) &amp;&amp; i &lt; argc_check) &#123;</span><br><span class="line">      options.tex_coords_quantization_bits = <span class="built_in">StringToInt</span>(argv[++i]);</span><br><span class="line">      <span class="keyword">if</span> (options.tex_coords_quantization_bits &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">&quot;Error: The maximum number of quantization bits for the texture &quot;</span></span><br><span class="line">            <span class="string">&quot;coordinate attribute is 30.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;-qn&quot;</span>, argv[i]) &amp;&amp; i &lt; argc_check) &#123;</span><br><span class="line">      options.normals_quantization_bits = <span class="built_in">StringToInt</span>(argv[++i]);</span><br><span class="line">      <span class="keyword">if</span> (options.normals_quantization_bits &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">&quot;Error: The maximum number of quantization bits for the normal &quot;</span></span><br><span class="line">            <span class="string">&quot;attribute is 30.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;-qg&quot;</span>, argv[i]) &amp;&amp; i &lt; argc_check) &#123;</span><br><span class="line">      options.generic_quantization_bits = <span class="built_in">StringToInt</span>(argv[++i]);</span><br><span class="line">      <span class="keyword">if</span> (options.generic_quantization_bits &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">&quot;Error: The maximum number of quantization bits for generic &quot;</span></span><br><span class="line">            <span class="string">&quot;attributes is 30.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//..............</span></span><br></pre></td></tr></table></figure>

<p>开头部分拿到<code>args</code>参数以后判断几个可变参数,均是不能大于30</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;draco::PointCloud&gt; pc;</span><br><span class="line">  draco::Mesh *mesh = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!options.is_point_cloud) &#123;</span><br><span class="line">    <span class="keyword">auto</span> maybe_mesh =</span><br><span class="line">        draco::<span class="built_in">ReadMeshFromFile</span>(options.input, options.use_metadata);</span><br><span class="line">    <span class="keyword">if</span> (!maybe_mesh.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Failed loading the input mesh: %s.\n&quot;</span>,</span><br><span class="line">             maybe_mesh.<span class="built_in">status</span>().<span class="built_in">error_msg</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mesh = maybe_mesh.<span class="built_in">value</span>().<span class="built_in">get</span>();</span><br><span class="line">    pc = std::<span class="built_in">move</span>(maybe_mesh).<span class="built_in">value</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> maybe_pc = draco::<span class="built_in">ReadPointCloudFromFile</span>(options.input);</span><br><span class="line">    <span class="keyword">if</span> (!maybe_pc.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Failed loading the input point cloud: %s.\n&quot;</span>,</span><br><span class="line">             maybe_pc.<span class="built_in">status</span>().<span class="built_in">error_msg</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pc = std::<span class="built_in">move</span>(maybe_pc).<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码从文件获取<code>draco::mesh</code>变量, 封装UE插件在此处遇到了一个坑, <a href="#mesh%E8%8E%B7%E5%8F%96%E9%97%AE%E9%A2%98">传送门</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> input_is_mesh = mesh &amp;&amp; mesh-&gt;<span class="built_in">num_faces</span>() &gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (input_is_mesh)</span><br><span class="line">    ret = <span class="built_in">EncodeMeshToFile</span>(*mesh, options.output, &amp;encoder);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ret = <span class="built_in">EncodePointCloudToFile</span>(*pc.<span class="built_in">get</span>(), options.output, &amp;encoder);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret != <span class="number">-1</span> &amp;&amp; options.compression_level &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;For better compression, increase the compression level up to &#x27;-cl 10&#x27; &quot;</span></span><br><span class="line">        <span class="string">&quot;.\n\n&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>后面就是写入到<code>*.drc</code>文件中, 实则是先写入到中间文件<code> draco::EncoderBuffer buffer</code>中, 然后在通过</p>
<p><code>draco::WriteBufferToFile</code>写入文件</p>
<h2 id="封装UE插件"><a href="#封装UE插件" class="headerlink" title="封装UE插件"></a>封装UE插件</h2><p><a href="https://github.com/VJien/UnrealDraco">github地址</a></p>
<p>首先把<code>Draco</code>源码作为第三方库包含到插件内</p>
<p>![image-20210315164146758](E:\OneDrive\OneDrive - shu.edu.cn\笔记\UE4\图片\Draco\image-20210315164146758.png)</p>
<p>声明一个结构体, 方便设置压缩参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FOptions</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">		<span class="built_in">FOptions</span>() :<span class="built_in">is_point_cloud</span>(<span class="literal">false</span>),</span><br><span class="line">		<span class="built_in">pos_quantization_bits</span>(<span class="number">11</span>),</span><br><span class="line">		<span class="built_in">tex_coords_quantization_bits</span>(<span class="number">10</span>),</span><br><span class="line">		<span class="built_in">tex_coords_deleted</span>(<span class="literal">false</span>),</span><br><span class="line">		<span class="built_in">normals_quantization_bits</span>(<span class="number">8</span>),</span><br><span class="line">		<span class="built_in">normals_deleted</span>(<span class="literal">false</span>),</span><br><span class="line">		<span class="built_in">generic_quantization_bits</span>(<span class="number">8</span>),</span><br><span class="line">		<span class="built_in">generic_deleted</span>(<span class="literal">false</span>),</span><br><span class="line">		<span class="built_in">compression_level</span>(<span class="number">7</span>),</span><br><span class="line">		<span class="built_in">use_metadata</span>(<span class="literal">false</span>) </span><br><span class="line">		&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">bool</span> is_point_cloud;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">int</span> pos_quantization_bits;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">int</span> tex_coords_quantization_bits;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">bool</span> tex_coords_deleted;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">int</span> normals_quantization_bits;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">bool</span> normals_deleted;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">int</span> generic_quantization_bits;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">bool</span> generic_deleted;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">int</span> compression_level;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">bool</span> use_metadata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>两个蓝图库函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = UnrealDraco)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">EncoderFromFile</span><span class="params">(<span class="keyword">const</span> FString&amp; inFileName,  <span class="keyword">const</span> FString&amp; outFileName, FOptions options)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = UnrealDraco)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">DecoderToFile</span><span class="params">(<span class="keyword">const</span> FString&amp; inFileName, <span class="keyword">const</span> FString&amp; outFileName)</span></span>;</span><br></pre></td></tr></table></figure>

<a  name = #mesh获取问题>

<p>逻辑部分基本是参考了源码<code>main</code>函数内的内容, 但是抄完发现无法从模型文件导入数据, 报错位置在</p>
<p><code>file_reader_factory.cc</code>L41 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;FileReaderInterface&gt; <span class="title">FileReaderFactory::OpenReader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::string &amp;file_name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> open_function : *<span class="built_in">GetFileReaderOpenFunctions</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> reader = <span class="built_in">open_function</span>(file_name);</span><br><span class="line">    <span class="keyword">if</span> (reader == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reader;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FILEREADER_LOG_ERROR</span>(<span class="string">&quot;No file reader able to open input&quot;</span>); <span class="comment">//报错位置</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这个<code>open_function</code>需要注册, 猜测默认没有注册, 于是就自定义一个类来完成这一步骤</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UD_FileReader</span> :</span> <span class="keyword">public</span> FileReaderInterface &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Creates and returns a UD_FileReader that reads from |file_name|.</span></span><br><span class="line">  <span class="comment">// Returns nullptr when the file does not exist or cannot be read.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> std::unique_ptr&lt;FileReaderInterface&gt; <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> std::string &amp;file_name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">UD_FileReader</span>() = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">UD_FileReader</span>(<span class="keyword">const</span> UD_FileReader &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  UD_FileReader &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> UD_FileReader &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">UD_FileReader</span>(UD_FileReader &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  UD_FileReader &amp;<span class="keyword">operator</span>=(UD_FileReader &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Closes |file_|.</span></span><br><span class="line">  ~<span class="built_in">UD_FileReader</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reads the entire contents of the input file into |buffer| and returns true.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ReadFileToBuffer</span><span class="params">(std::vector&lt;<span class="keyword">char</span>&gt; *buffer)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ReadFileToBuffer</span><span class="params">(std::vector&lt;<span class="keyword">uint8_t</span>&gt; *buffer)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the size of the file.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">GetFileSize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">UD_FileReader</span>(FILE *file) : <span class="built_in">file_</span>(file) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  FILE *file_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> registered_in_factory_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;FileReaderInterface&gt; <span class="title">UD_FileReader::Open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::string &amp;file_name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (file_name.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FILE *raw_file_ptr = <span class="built_in">fopen</span>(file_name.<span class="built_in">c_str</span>(), <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (raw_file_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;FileReaderInterface&gt; <span class="title">file</span><span class="params">(<span class="keyword">new</span> (std::nothrow) UD_FileReader(raw_file_ptr))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (file == <span class="literal">nullptr</span>) </span><br><span class="line">  &#123;</span><br><span class="line">	<span class="built_in">UDWARNING</span>(<span class="string">&quot;Out of memory&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(raw_file_ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UD_FileReader::ReadFileToBuffer</span><span class="params">(std::vector&lt;<span class="keyword">char</span>&gt; *buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (buffer == <span class="literal">nullptr</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  buffer-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> file_size = <span class="built_in">GetFileSize</span>();</span><br><span class="line">  <span class="keyword">if</span> (file_size == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">UDWARNING</span>(<span class="string">&quot;Unable to obtain file size or file empty&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buffer-&gt;<span class="built_in">resize</span>(file_size);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fread</span>(buffer-&gt;<span class="built_in">data</span>(), <span class="number">1</span>, file_size, file_) == file_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UD_FileReader::ReadFileToBuffer</span><span class="params">(std::vector&lt;<span class="keyword">uint8_t</span>&gt; *buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (buffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  buffer-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> file_size = <span class="built_in">GetFileSize</span>();</span><br><span class="line">  <span class="keyword">if</span> (file_size == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">UDWARNING</span>(<span class="string">&quot;Unable to obtain file size or file empty&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buffer-&gt;<span class="built_in">resize</span>(file_size);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fread</span>(buffer-&gt;<span class="built_in">data</span>(), <span class="number">1</span>, file_size, file_) == file_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码就是上面的<code>open()</code>和<code>ReadFileToBuffer()</code></p>
<p>然后在模块启动时注册</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FUnrealDracoModule::StartupModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	draco::FileReaderFactory::<span class="built_in">RegisterReader</span>(draco::UD_FileReader::Open);</span><br><span class="line">	draco::FileWriterFactory::<span class="built_in">RegisterWriter</span>(draco::UD_FileWriter::Open);<span class="comment">//写入版本,类似读取</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就能正确从文件获取<code>Mesh</code>数据了</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://img.supervj.top//img/image-20210315165824923.png" alt="image-20210315165824923"></p>
<p>max随意创建一个模型, 导出为obj格式文件<code>TT1.obj</code>,随意放于目录<code>C:\Users\Administrator\Desktop\1\</code>内</p>
<p>执行如下节点</p>
<p><img src="https://img.supervj.top//img/image-20210315170028882.png" alt="image-20210315170028882"></p>
<p>源文件大小25kb, 生成<code>drc</code>文件大小为 2kb, 反向解压出来文件<code>TT1_New.obj</code>放入max测试</p>
<p><img src="https://img.supervj.top//img/image-20210315170340133.png" alt="image-20210315170340133"></p>
<p><img src="https://img.supervj.top//img/image-20210315170408079.png" alt="image-20210315170408079"></p>
<p>4边面变为3边面, 平滑组感觉有些许不同, 其余正常</p>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>draco</tag>
        <tag>压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>UE导入导出FBX的打组问题</title>
    <url>/2022/09/10/FBX%E6%A8%A1%E5%9E%8B%E6%89%93%E7%BB%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已知UE导出FBX模型以后, 会将Mesh和Joints打成一个组, 如下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104449336.png" alt="image-20220916104449336"></p>
<span id="more"></span>

<p>这个组的存在会影响美术工作, K动画时是需要将这个组给删掉的, 也就是模型和骨架与组接触父子关系, 如果组有相对变换, 那么这个时候模型可能还会发生旋转</p>
<p>比如下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104502022.png" alt="image-20220916104502022"></p>
<p>所以现在的问题是如何有效的解决这个问题?</p>
<p>先大概看一下源码</p>
<h2 id="导出流程"><a href="#导出流程" class="headerlink" title="导出流程"></a>导出流程</h2><p>主要流程就从这里开始</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104516310.png" alt="image-20220916104516310"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104522723.png" alt="image-20220916104522723"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104530115.png" alt="image-20220916104530115"></p>
<p>第一步就会创建一个MeshNode, 用模型本身命名,然后把这个Node作为Root, 到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExportSkeletalMeshToFbx 中去创建MeshNode和SkeletonNode</span><br></pre></td></tr></table></figure>

<p>那么导出流程如果要改成不打组, 那么很简单, 在最前面把Scene的RootNode作为Mesh和Skeleton的Root传递过去就可以了</p>
<p>如下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104540593.png" alt="image-20220916104540593"></p>
<p>可以直接在导出数据配置中加一个选项, 方便选择</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104551623.png" alt="image-20220916104551623"></p>
<h2 id="导入流程"><a href="#导入流程" class="headerlink" title="导入流程"></a><strong>导入流程</strong></h2><p>导入流程稍微复杂一点, 看一下调用栈</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104614807.png" alt="image-20220916104614807"></p>
<p><strong>以下图的模型为例</strong></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104627907.png" alt="image-20220916104627907"></p>
<p><strong>会递归的查找整个树, 找到最后的Root节点, 这里大概梳理一下FbxSdk中 这个模型的层级关系,</strong></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104638504.png" alt="image-20220916104638504"></p>
<p>**<br>每个FbxNode都拥有一个FbxNodeAttribute**</p>
<p><strong>可以用此来定义是什么类型的Node, 所以这里引擎有个规则</strong></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104648546.png" alt="image-20220916104648546"></p>
<p><strong>简单看就是要一直找到当前节点的ParentNode等于Scene的RootNode为止</strong></p>
<p><strong>所以需要改动的就是这里判断一下最上面的节点是不是</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FbxNodeAttribute::eSkeleton</span><br></pre></td></tr></table></figure>

<p><strong>如果不是骨骼那么就不当做骨架创建</strong></p>
<p><strong>简单修改如下</strong></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104657470.png" alt="image-20220916104657470"></p>
<p><strong>因为要公开参数, 这里折腾了一段时间</strong></p>
<p>**<br>**</p>
<p><strong>首先需要在我们获取的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FBXImportOptions</span><br></pre></td></tr></table></figure>

<p><strong>中添加一个变量, 这个变量要从ImportUI类中获取, 这个类就是弹出来的Slate界面的Object对象</strong></p>
<p><strong>因为上面获取RootNode的时候获取不到UI类, 只能通过Options类获取参数, 所以需要在两者内都定义一个变量</strong></p>
<p><strong>最简单的方法就是在读完配置真正导入File之前读取一下UI的配置</strong></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104748061.png" alt="image-20220916104748061"></p>
<p><strong>另外还可以在</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ApplyImportUIToImportOptions(UFbxImportUI* ImportUI, FBXImportOptions&amp; InOutImportOptions)</span><br><span class="line">中去添加一条属性赋值的操作, 看着引擎自己是这么干的, 看上去比较符合规矩</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916104806935.png" alt="image-20220916104806935"></p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a><strong>最终效果</strong></h2><p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2022_09_02_11_32_03_558.gif" alt="录制_2022_09_02_11_32_03_558"></p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>模型</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayAbilitySystem入门与实战(一):初始化</title>
    <url>/2020/12/19/GameplayAbilitySystem%E5%88%86%E6%9E%90(%E4%B8%80)_%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>引用官网的一段话介绍一下<code>GAS</code>系统</p>
<blockquote>
<p>Gameplay技能系统 是一个高度灵活的框架，可用于构建你可能会在RPG或MOBA游戏中看到的技能和属性类型。你可以构建可供游戏中的角色使用的动作或被动技能，使这些动作导致各种属性累积或损耗的状态效果，实现约束这些动作使用的”冷却”计时器或资源消耗，更改技能等级及每个技能等级的技能效果，激活粒子或音效，等等。简单来说，此系统可帮助你在任何现代RPG或MOBA游戏中设计、实现及高效关联各种游戏中的技能，既包括跳跃等简单技能，也包括你喜欢的角色的复杂技能集。</p>
</blockquote>
<blockquote>
<p>此篇为<code>GameplayAbilitySystem入门</code>文档的开篇,</p>
<p>此系列文档会从零开始记录用UE4 <code>GAS</code>插件为基础, 尝试开发一个简单的ARPG游戏的案例</p>
</blockquote>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>创建C++工程<code>SuperRoad</code>(也可以先创建蓝图工程,然后添加任意c++类), 目前引擎已经升级到4.26.0, 就以此版本为基础开发</li>
<li>暂不导入美术资源, 使用默认<code>TopDown</code>模板的基础资源</li>
<li>打开引擎插件, 开启<code>GameplayAbilities</code>并重启项目</li>
</ul>
<p>打开项目<code>Build.cs</code></p>
<p>暂添加如下模块</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">PrivateDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="built_in">string</span>[] &#123;</span><br><span class="line">            <span class="string">&quot;GameplayAbilities&quot;</span>,</span><br><span class="line">            <span class="string">&quot;GameplayTags&quot;</span>,</span><br><span class="line">            <span class="string">&quot;GameplayTasks&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<!-- more -->





<h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><p><code>GAS</code>系统必须使用<code>c++</code>, 这个是目前逃不掉的规则, 后续可以考虑部分扩展成蓝图来更直观的<code>连连看</code>,</p>
<h3 id="创建各种类"><a href="#创建各种类" class="headerlink" title="创建各种类"></a>创建各种类</h3><p>创建各种必要的基类和<code>GAS</code>相关类, 因为其中部分类初始化必须需要用到,下图仅供参考</p>
<p><img src="https://img.supervj.top//img/image-20201209110513636.png" alt="image-20201209110513636"></p>
<p>此项目多数类以<code>SR</code>为前缀</p>
<h3 id="TargetData"><a href="#TargetData" class="headerlink" title="TargetData"></a>TargetData</h3><p>首先为了使用<code>TargetData</code>必须找一个地方在尽量早的时机执行<code>UAbilitySystemGlobals::InitGlobalData()</code>,可以自定义一个<code>SubsystemEngine</code>或者如<code>ActionRPG</code>自定义一个<code>AssetManager</code>到这个类里面执行</p>
<h3 id="ASC"><a href="#ASC" class="headerlink" title="ASC"></a>ASC</h3><p><code>ASC</code>即<code>AbilitySystemComponent</code>, <code>GAS</code>系统的核心关键, 使用<code>GAS</code>的各类功能都是围绕这个组件展开的</p>
<p>一般流行的方法中关于<code>ASC</code>的创建会放到<code>PlayerState(PS)</code>或者<code>Character/Pawn</code>中,两种方式都可以,初始化略有区别, 但是都是围绕着一点 <em>在客户端和服务端都在合适的时机调用初始化方法</em></p>
<p>这里有一点需要注意</p>
<blockquote>
<p>如果<code>ASC</code>在<code>PS</code>上，那么必须增加<code>NetUpdateFrequency</code>的值,因为默认情况下PS的优先级不高，会导致技能延迟</p>
</blockquote>
<p>还有一个规则</p>
<p>如果组件的<code>OwnerActor</code>和作用目标不是同一个，那么必须实现<code>IAbilitySystemInterface</code>接口，同时必须重写里面的唯一的方法<code>GetAbilitySystemComponent</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UAbilitySystemComponent * <span class="title">ASRCharacterBase::GetAbilitySystemComponent</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> AbilitySystemComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然<code>ASC</code>需要在服务端和客户端都进行初始化，对于<code>Pawn</code>来说，可以在服务端用<code>PossessedBy</code>,在客户端用<code>PlayerController</code>的<code>AcknowledgePawn</code>初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ASRCharacterBase::PossessedBy</span><span class="params">(AController * NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SetOwner</span>(NewController);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ASRPlayerControllerBase::AcknowledgePossession</span><span class="params">(APawn* P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">AcknowledgePossession</span>(P);</span><br><span class="line"></span><br><span class="line">	AVGCharacterBase* CharacterBase = Cast&lt;ASRCharacterBase&gt;(P);</span><br><span class="line">	<span class="keyword">if</span> (CharacterBase)</span><br><span class="line">	&#123;</span><br><span class="line">		CharacterBase-&gt;<span class="built_in">GetAbilitySystemComponent</span>()-&gt;<span class="built_in">InitAbilityActorInfo</span>(CharacterBase, CharacterBase);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>ASC</code>在<code>PS</code>中创建的，可以在客户端用<code>Pawn</code>的<code>OnRep_PlayerState</code>内初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server only</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AHeroCharacter::PossessedBy</span><span class="params">(AController * NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line">	AGDPlayerState* PS = GetPlayerState&lt;AGDPlayerState&gt;();</span><br><span class="line">	<span class="keyword">if</span> (PS)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		AbilitySystemComponent = Cast&lt;UGDAbilitySystemComponent&gt;(PS-&gt;<span class="built_in">GetAbilitySystemComponent</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		PS-&gt;<span class="built_in">GetAbilitySystemComponent</span>()-&gt;<span class="built_in">InitAbilityActorInfo</span>(PS, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client only</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AHeroCharacter::OnRep_PlayerState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">OnRep_PlayerState</span>();</span><br><span class="line"></span><br><span class="line">	AGDPlayerState* PS = GetPlayerState&lt;AGDPlayerState&gt;();</span><br><span class="line">	<span class="keyword">if</span> (PS)</span><br><span class="line">	&#123;</span><br><span class="line">		AbilitySystemComponent = Cast&lt;UGDAbilitySystemComponent&gt;(PS-&gt;<span class="built_in">GetAbilitySystemComponent</span>());</span><br><span class="line">		AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(PS, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>因为考虑怪物也需要释放技能, 那么我就干脆直接把<code>ASC</code>创建到基础角色中,即<code>SRCharacterBase</code>中</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ASRCharacterBase::<span class="built_in">ASRCharacterBase</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer):<span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">	AbilitySystemComponent = CreateDefaultSubobject&lt;USRAbilitySystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AbilityComponent&quot;</span>));</span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);</span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">SetReplicationMode</span>(EGameplayEffectReplicationMode::Mixed);</span><br><span class="line"></span><br><span class="line">	AttributeSet = CreateDefaultSubobject&lt;USRAttributeSetBase&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AttributeSet&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就按照之前所说的, 在<code>PossessedBy</code>和<code>Controller</code>中的<code>AcknowledgePossession</code>中初始化<code>ASC</code></p>
<h3 id="添加技能-初始化属性"><a href="#添加技能-初始化属性" class="headerlink" title="添加技能/初始化属性"></a>添加技能/初始化属性</h3><p>因为我们需要使用技能, 而技能必须被添加到<code>ASC</code>中, 可以理解为注册技能, 我们这里给<code>SRCharacterBase</code>加入几个初始化方法;</p>
<p>也别忘了给角色添加几个变量来设置初始内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//角色技能</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;SR | Abilities&quot;</span>)</span><br><span class="line">	TArray&lt;TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">USRGameplayAbilityBase</span>&gt;</span>&gt; CharacterAbilities;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始效果,用来初始化属性</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;SR | Abilities&quot;</span>)</span><br><span class="line">	TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">UGameplayEffect</span>&gt;</span> DefaultAttributeEffect;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始应用的GE效果,例如魔法回复</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;SR | Abilities&quot;</span>)</span><br><span class="line">	TArray&lt;TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">UGameplayEffect</span>&gt;</span>&gt; StartupEffects;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InitAttributes</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//添加初始技能</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddCharacterStartupAbilities</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//添加初始效果</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddStartUpEffects</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>分别实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ASRCharacterBase::InitAttributes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!AbilitySystemComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(SRLog, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;InitAttributes failed [no ASC]  !!&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!DefaultAttributeEffect)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(SRLog, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;InitAttributes failed [no DefaultAttributeEffect]  !!&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FGameplayEffectContextHandle EffectContextHandle = AbilitySystemComponent-&gt;<span class="built_in">MakeEffectContext</span>();</span><br><span class="line">	EffectContextHandle.<span class="built_in">AddSourceObject</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	FGameplayEffectSpecHandle SpecHandle = AbilitySystemComponent-&gt;<span class="built_in">MakeOutgoingSpec</span>(DefaultAttributeEffect, <span class="built_in">GetCharacterLevel</span>(), EffectContextHandle);</span><br><span class="line">	<span class="keyword">if</span> (SpecHandle.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent-&gt;<span class="built_in">ApplyGameplayEffectSpecToTarget</span>(*SpecHandle.Data.<span class="built_in">Get</span>(), AbilitySystemComponent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ASRCharacterBase::AddCharacterStartupAbilities</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetLocalRole</span>() != ROLE_Authority || !AbilitySystemComponent || AbilitySystemComponent-&gt;bHasGiveCharacterAbilities)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> ga : CharacterAbilities)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		FGameplayAbilitySpec spec = <span class="built_in">FGameplayAbilitySpec</span>(ga, <span class="built_in">GetAbilityLevel</span>(ga.<span class="built_in">GetDefaultObject</span>()-&gt;AbilityName), <span class="keyword">static_cast</span>&lt;int32&gt;(ga.<span class="built_in">GetDefaultObject</span>()-&gt;InputID), <span class="keyword">this</span>);</span><br><span class="line">		AbilitySystemComponent-&gt;<span class="built_in">GiveAbility</span>(spec);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	AbilitySystemComponent-&gt;bHasGiveCharacterAbilities = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ASRCharacterBase::AddStartUpEffects</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetLocalRole</span>() != ROLE_Authority || !AbilitySystemComponent || AbilitySystemComponent-&gt;bHasApplyStartupEffects)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(SRLog, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Add Startup Effects failed&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FGameplayEffectContextHandle EffectContextHandle = AbilitySystemComponent-&gt;<span class="built_in">MakeEffectContext</span>();</span><br><span class="line">	EffectContextHandle.<span class="built_in">AddSourceObject</span>(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> ge : StartupEffects)</span><br><span class="line">	&#123;</span><br><span class="line">		FGameplayEffectSpecHandle SpecHandle = AbilitySystemComponent-&gt;<span class="built_in">MakeOutgoingSpec</span>(ge, <span class="built_in">GetCharacterLevel</span>(), EffectContextHandle);</span><br><span class="line">		<span class="keyword">if</span> (SpecHandle.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent-&gt;<span class="built_in">ApplyGameplayEffectSpecToTarget</span>(*SpecHandle.Data.<span class="built_in">Get</span>(), AbilitySystemComponent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	AbilitySystemComponent-&gt;bHasApplyStartupEffects = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面初始化属性实际上也是激活了一次<code>GameplayAbilityEffect</code>效果, 这个关于<code>GA</code>和<code>GE</code>之类的内容在后续展开</p>
<p>我们现在随意创建一个<code>GA</code>和一个<code>GE</code></p>
<p>为了防止重复调用, 上述代码中会有两个bool变量(<code>bHasApplyStartupEffects</code>,<code>bHasGiveCharacterAbilities</code>)需要稍微注意, 当然不是必须的</p>
<p>关于调用时机, 我们把他们放在了服务端的函数 <code>PossessedBy</code>中,关于客户端是否需要调用后续看需求跟进.</p>
<p>此函数目前状态</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ASRCharacterBase::PossessedBy</span><span class="params">(AController* NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line">	<span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">InitAttributes</span>();</span><br><span class="line">	<span class="built_in">AddCharacterStartupAbilities</span>();</span><br><span class="line">	<span class="built_in">AddStartUpEffects</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="按键绑定"><a href="#按键绑定" class="headerlink" title="按键绑定"></a>按键绑定</h3><p><code>ASC</code>有一个非常快捷的按键绑定方式,即调用方法<code>BindAbilityActivationToInputComponent(...)</code></p>
<p>传入参数第二个参数<code>FGameplayAbilityInputBinds</code>非常有意思,先看一下构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">FGameplayAbilityInputBinds</span>(FString InConfirmTargetCommand, FString InCancelTargetCommand, FString InEnumName, int32 InConfirmTargetInputID = INDEX_NONE, int32 InCancelTargetInputID = INDEX_NONE)</span><br><span class="line">		: <span class="built_in">ConfirmTargetCommand</span>(InConfirmTargetCommand)</span><br><span class="line">		, <span class="built_in">CancelTargetCommand</span>(InCancelTargetCommand)</span><br><span class="line">		, <span class="built_in">EnumName</span>(InEnumName)</span><br><span class="line">		, <span class="built_in">ConfirmTargetInputID</span>(InConfirmTargetInputID)</span><br><span class="line">		, <span class="built_in">CancelTargetInputID</span>(InCancelTargetInputID)</span><br><span class="line">	&#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>InEnumName</li>
</ul>
<p>我们先看这个参数, 他需要你定义一个枚举变量, 此枚举成员变量的名字就需要对应到游戏项目设置里的<code> Input</code>栏内的<code>Action</code>名称,当然有两个例外,后面讲, 先定义一个枚举</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">ESRAbilityInputID</span> :</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">	NONE,</span><br><span class="line">	CONFIRM,</span><br><span class="line">	CANCEL,</span><br><span class="line">	ABILITY1,</span><br><span class="line">	ABILITY2,</span><br><span class="line">	ABILITY3,</span><br><span class="line">	ABILITY4,</span><br><span class="line">	ABILITY5,</span><br><span class="line">	ABILITY6,</span><br><span class="line">	ABILITY7,</span><br><span class="line">	ABILITY8,</span><br><span class="line">	ABILITY9,</span><br><span class="line">	ABILITY10,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>InConfirmTargetCommand/InCancelTargetCommand</li>
</ul>
<p>这俩参数是<strong>确认</strong>和<strong>取消</strong>命令的<code>Action</code>名称, 即你打开你游戏项目设置里的<code> Input</code>栏内的<code>Action</code>名称</p>
<p>如果输入为空,就使用之前枚举里定义的两个对应的枚举名称;如果设置了其他名称, 那么你<code>Action</code>内的这俩功能的名称可以改成你设置的;</p>
<ul>
<li>ConfirmTargetInputID/CancelTargetInputID</li>
</ul>
<p>这俩是具体枚举里面的对应<strong>确认</strong>和<strong>取消</strong>命令的成员变量</p>
<p>最后实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ASRHero::BindASCInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!bHasBindInput &amp;&amp; AbilitySystemComponent &amp;&amp; InputComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		AbilitySystemComponent-&gt;<span class="built_in">BindAbilityActivationToInputComponent</span>(InputComponent, <span class="built_in">FGameplayAbilityInputBinds</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;CONFIRM&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;CANCEL&quot;</span>),</span><br><span class="line">			<span class="built_in">TEXT</span>(<span class="string">&quot;ESRAbilityInputID&quot;</span>), <span class="keyword">static_cast</span>&lt;int32&gt;(ESRAbilityInputID::CONFIRM), <span class="keyword">static_cast</span>&lt;int32&gt;(ESRAbilityInputID::CANCEL)));</span><br><span class="line">		bHasBindInput = <span class="literal">true</span>; <span class="comment">//防止多次绑定</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>实测发现, 自定义的<code>Confirm</code>和<code>Cancel</code>会调用到<code>ASC</code>的虚函数<code>virtual void LocalInputConfirm(); 和    virtual void LocalInputCancel();</code></p>
<p>而并不能成功调用已经注册的例如<code>InputID</code>=<code>CF</code>的技能</p>
<p>当然理论上可以绕一圈重写上面方法来调用到对应技能</p>
</blockquote>
<blockquote>
<p>所以建议还是<code>BindAbilityActivationToInputComponent</code>的前两个参数设置成对应的<code>Confirm</code>和<code>Cancel</code>的名称或者直接设置成空也是可以映射到枚举的</p>
</blockquote>
<p>然后就是函数执行时机问题,这里有个问题需要考虑, 你调用此函数的时候需要确保或者尽量保证<code>InputComponent</code>已经存在了,服务端没什么问题, 在服务端在<code>SetupPlayerInputComponent</code>中执行绑定函数;</p>
<p>关键就是客户端, 客户端通过<code>PlayerController::ClientRestart()</code>函数然后创建的<code>InputComponent</code>,我们重写了<code>OnRep_PlayerState</code>来执行客户端事件, 也调用绑定事件, 因为有<code>bool</code>变量来防止多次绑定, 那么此举也是为了保险起见(<code>GASDoc</code>项目是这么建议的)</p>
<h3 id="自定义GA类"><a href="#自定义GA类" class="headerlink" title="自定义GA类"></a>自定义GA类</h3><p>上面添加技能的方法中有一条语句是我们自定义的<code>GA</code>类的内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FGameplayAbilitySpec spec = <span class="built_in">FGameplayAbilitySpec</span>(ga, <span class="built_in">GetAbilityLevel</span>(ga.<span class="built_in">GetDefaultObject</span>()-&gt;AbilityName), <span class="keyword">static_cast</span>&lt;int32&gt;(ga.<span class="built_in">GetDefaultObject</span>()-&gt;InputID), <span class="keyword">this</span>);</span><br><span class="line">		AbilitySystemComponent-&gt;<span class="built_in">GiveAbility</span>(spec);</span><br></pre></td></tr></table></figure>

<p>这里有两个参数<code>InputID</code>和<code>AbilityName</code>;</p>
<p>我们创建<code>USRGameplayAbilityBase</code> 继承自 <code>UGameplayAbility</code></p>
<p>新建如下变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Ability&quot;</span>)</span><br><span class="line">	FString AbilityName;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Ability&quot;</span>)</span><br><span class="line">	ESRAbilityInputID InputID = ESRAbilityInputID::NONE;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Ability&quot;</span>)</span><br><span class="line">	<span class="keyword">bool</span> bAutoActivate = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>重写方法<code>OnAvatarSet</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRGameplayAbilityBase::OnAvatarSet</span><span class="params">(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">OnAvatarSet</span>(ActorInfo, Spec);</span><br><span class="line">	<span class="keyword">if</span> (bAutoActivate)</span><br><span class="line">	&#123;</span><br><span class="line">		ActorInfo-&gt;AbilitySystemComponent-&gt;<span class="built_in">TryActivateAbility</span>(Spec.Handle, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目的是如果是自动释放的技能就直接释放;</p>
<p>至此我们技能的与按键就对应起来了</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试之前我们创建几个测试性的<code>GA</code>和<code>GE</code>, 这里我已经把初始化属性也做了, 但这是后续内容, 这里不展开; 我们先测试能否正确触发技能</p>
<p>创建<code>GA_Test</code>,内容如下</p>
<p><img src="https://img.supervj.top//img/image-20201210104931838.png" alt="image-20201210104931838"></p>
<p>蒙太奇动画是一个跳跃动作(别忘记给默认动画蓝图加一个插槽),然后配置按键</p>
<p><img src="https://img.supervj.top//img/image-20201210105408009.png" alt="image-20201210105408009"></p>
<p>丢一个AI怪通过如下方式一直释放技能</p>
<p><img src="https://img.supervj.top//img/image-20201210105530613.png" alt="image-20201210105530613"></p>
<p>然后开测</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_10_10_56_14_650.gif" alt="录制_2020_12_10_10_56_14_650"></p>
<p>完成!!!</p>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayAbilitySystem入门与实战(七):GameplayEffect(二)</title>
    <url>/2020/12/25/GameplayAbilitySystem%E5%88%86%E6%9E%90(%E4%B8%83)_GameplayEffect2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇讲述了<code>GE</code>的一些基本概念, 非常概念化没有实战部分, 很容易混淆和忘记, 本片我们结合实际项目再配合<code>GA</code>的使用来模拟几个技能效果</p>
<a name = "GEEC">

<h2 id="伤害计算"><a href="#伤害计算" class="headerlink" title="伤害计算"></a>伤害计算</h2><p>我们在前面测试<code>GA</code>的时候已经简单测试了伤害,不过那个伤害就固定的一个值, 下面我们用自定义的类<code>GEEC</code>来计算这个伤害</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">USRGEEC_Damage : <span class="keyword">public</span> UGameplayEffectExecutionCalculation</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20201218172355966.png" alt="image-20201218172355966"></p>
<p>给上我们的<code>GEEC</code></p>
<span id="more"></span>

<p>在<code>GEEC</code>中只需要重写方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Execute_Implementation</span><span class="params">(<span class="keyword">const</span> FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, OUT FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>



<p>然后我们需要捕获我们角色的一些数据, 比如我们捕获我们发起者的攻击以及目标的护甲</p>
<p>为了方便使用, 我们自定义一个结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">SRDamageStatics</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(Attack);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(Armor);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(Health);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">SRDamageStatics</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//攻击力在创建GE时捕获, 因为技能可能有弹道, 需要在发射的时候就捕获而不是击中的时候,</span></span><br><span class="line">		<span class="comment">//类似的其他有关发射者的属性都所需要此时捕获</span></span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(USRAttributeSetBase, Attack, Source, <span class="literal">true</span>);</span><br><span class="line">		<span class="comment">//目标的防御在应用的时候捕获</span></span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(USRAttributeSetBase, Armor, Target, <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(USRAttributeSetBase, Health, Target, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> SRDamageStatics&amp; <span class="title">DamageStatics</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> SRDamageStatics DmgStatics;</span><br><span class="line">	<span class="keyword">return</span> DmgStatics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后设置捕获</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">USRGEEC_Damage::<span class="built_in">USRGEEC_Damage</span>()</span><br><span class="line">&#123;</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().AttackDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().ArmorDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().HealthDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面就是加加减减一下最终反馈到目标的血量(临时方案)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRGEEC_Damage::Execute_Implementation</span><span class="params">(<span class="keyword">const</span> FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, OUT FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAbilitySystemComponent* TargetAbilitySystemComponent = ExecutionParams.<span class="built_in">GetTargetAbilitySystemComponent</span>();</span><br><span class="line">	UAbilitySystemComponent* SourceAbilitySystemComponent = ExecutionParams.<span class="built_in">GetSourceAbilitySystemComponent</span>();</span><br><span class="line"></span><br><span class="line">	AActor* SourceActor = SourceAbilitySystemComponent ? SourceAbilitySystemComponent-&gt;<span class="built_in">GetAvatarActor</span>() : <span class="literal">nullptr</span>;</span><br><span class="line">	AActor* TargetActor = TargetAbilitySystemComponent ? TargetAbilitySystemComponent-&gt;<span class="built_in">GetAvatarActor</span>() : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> FGameplayEffectSpec&amp; Spec = ExecutionParams.<span class="built_in">GetOwningSpec</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取双方所有tag</span></span><br><span class="line">	<span class="keyword">const</span> FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">	<span class="keyword">const</span> FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line"></span><br><span class="line">	FAggregatorEvaluateParameters EvaluationParameters;</span><br><span class="line">	EvaluationParameters.SourceTags = SourceTags;</span><br><span class="line">	EvaluationParameters.TargetTags = TargetTags;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> ArmorPower = <span class="number">0.f</span>;</span><br><span class="line">	ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().ArmorDef, EvaluationParameters, ArmorPower);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> AttackValue = <span class="number">0.f</span>;</span><br><span class="line">	ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().AttackDef, EvaluationParameters, AttackValue);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> DamageDone = <span class="number">-1</span> * (AttackValue - ArmorPower);</span><br><span class="line">	<span class="keyword">if</span> (DamageDone &lt; <span class="number">0.f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OutExecutionOutput.<span class="built_in">AddOutputModifier</span>(<span class="built_in">FGameplayModifierEvaluatedData</span>(<span class="built_in">DamageStatics</span>().HealthProperty, EGameplayModOp::Additive, DamageDone));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试</p>
<p><img src="https://img.supervj.top//img/image-20201218175903444.png" alt="image-20201218175903444"></p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_18_17_57_55_376.gif" alt="录制_2020_12_18_17_57_55_376"></p>
<p>运行正常,每次伤害为8(10-2)</p>
<h2 id="自动回复"><a href="#自动回复" class="headerlink" title="自动回复"></a>自动回复</h2><p>我们属性里面有设置生命值和魔法值, 那么一般情况下这两种属性都有自动回复的机制,所以我们用<code>GE</code>来实现这个效果</p>
<p><img src="https://img.supervj.top//img/image-20201221093148509.png" alt="image-20201221093148509"></p>
<p>配置两个<code>GE</code>到我们的玩家角色的默认启动的<code>GE</code>内</p>
<p><img src="https://img.supervj.top//img/image-20201221093257062.png" alt="image-20201221093257062"></p>
<p>设置<code>GE</code>如上图, 设定持续事件为<code>Infinite</code>,计算方式是基于其他属性, 然后设置<code>Period</code>=1, 即每1秒执行一次</p>
<p><img src="https://img.supervj.top//img/image-20201221093407727.png" alt="image-20201221093407727"></p>
<p>在下面的移除标签内加上死亡状态, 即死亡了以后会移除自动回复效果</p>
<p>接下来简单测试一下添加了死亡<code>tag</code>以后的情况</p>
<p>我们用一个测试<code>GE</code>什么都不做,就添加一个<code>Death</code>标签</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_21_09_50_34_192.gif" alt="录制_2020_12_21_09_50_34_192"></p>
<p>搞定!</p>
<p>但是问题又来了, 这个生命回复到超过<code>MaxHealth</code>的时候就不对了, 我们必须在特定的地方对此做一个限制</p>
<h2 id="属性Clamp"><a href="#属性Clamp" class="headerlink" title="属性Clamp"></a>属性Clamp</h2><p>在<a href="">属性篇</a>中我们提过一个<code>PostGameplayEffectExecute()</code>函数, 用此函数就是官方建议我们来做属性<code>Clamp</code>处理的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRAttributeSetBase::PostGameplayEffectExecute</span><span class="params">(<span class="keyword">const</span> struct FGameplayEffectModCallbackData &amp;Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(SRLog, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;PostGameplayEffectExecute  &quot;</span>));</span><br><span class="line">	Super::<span class="built_in">PostGameplayEffectExecute</span>(Data);</span><br><span class="line">	</span><br><span class="line">	FGameplayEffectContextHandle Context = Data.EffectSpec.<span class="built_in">GetContext</span>();</span><br><span class="line">	UAbilitySystemComponent* SourceASC = Context.<span class="built_in">GetOriginalInstigatorAbilitySystemComponent</span>();</span><br><span class="line">	<span class="keyword">const</span> FGameplayTagContainer&amp; SourceTags = *Data.EffectSpec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">	FGameplayTagContainer SpecAssetTags;</span><br><span class="line">	Data.EffectSpec.<span class="built_in">GetAllAssetTags</span>(SpecAssetTags);</span><br><span class="line"></span><br><span class="line">	AActor* TargetActor = <span class="literal">nullptr</span>;</span><br><span class="line">	AController* TargetController = <span class="literal">nullptr</span>;</span><br><span class="line">	ASRCharacterBase* TargetCharacter = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (Data.Target.AbilityActorInfo.<span class="built_in">IsValid</span>() &amp;&amp; Data.Target.AbilityActorInfo-&gt;AvatarActor.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		TargetActor = Data.Target.AbilityActorInfo-&gt;AvatarActor.<span class="built_in">Get</span>();</span><br><span class="line">		TargetController = Data.Target.AbilityActorInfo-&gt;PlayerController.<span class="built_in">Get</span>();</span><br><span class="line">		TargetCharacter = Cast&lt;ASRCharacterBase&gt;(TargetActor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AActor* SourceActor = <span class="literal">nullptr</span>;</span><br><span class="line">	AController* SourceController = <span class="literal">nullptr</span>;</span><br><span class="line">	ASRCharacterBase* SourceCharacter = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (SourceASC &amp;&amp; SourceASC-&gt;AbilityActorInfo.<span class="built_in">IsValid</span>() &amp;&amp; SourceASC-&gt;AbilityActorInfo-&gt;AvatarActor.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		SourceActor = SourceASC-&gt;AbilityActorInfo-&gt;AvatarActor.<span class="built_in">Get</span>();</span><br><span class="line">		SourceController = SourceASC-&gt;AbilityActorInfo-&gt;PlayerController.<span class="built_in">Get</span>();</span><br><span class="line">		<span class="keyword">if</span> (SourceController == <span class="literal">nullptr</span> &amp;&amp; SourceActor != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (APawn* Pawn = Cast&lt;APawn&gt;(SourceActor))</span><br><span class="line">			&#123;</span><br><span class="line">				SourceController = Pawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (SourceController)</span><br><span class="line">		&#123;</span><br><span class="line">			SourceCharacter = Cast&lt;ASRCharacterBase&gt;(SourceController-&gt;<span class="built_in">GetPawn</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			SourceCharacter = Cast&lt;ASRCharacterBase&gt;(SourceActor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Context.<span class="built_in">GetEffectCauser</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			SourceActor = Context.<span class="built_in">GetEffectCauser</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Data.EvaluatedData.Attribute == <span class="built_in">GetHealthAttribute</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SetHealth</span>(FMath::<span class="built_in">Clamp</span>(<span class="built_in">GetHealth</span>(), <span class="number">0.0f</span>, <span class="built_in">GetMaxHealth</span>()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Data.EvaluatedData.Attribute ==  <span class="built_in">GetManaAttribute</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SetMana</span>(FMath::<span class="built_in">Clamp</span>(<span class="built_in">GetMana</span>(), <span class="number">0.0f</span>, <span class="built_in">GetMaxMana</span>()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面茫茫多的变量获取是为了后续做更多的内容, 如伤害处理等, 对于生命和魔法值的<code>Clamp</code>简单处理即可</p>
<blockquote>
<p>注意</p>
<p>Source是发起者</p>
<p>Target是作用目标, 即被修改属性的角色,</p>
<p>两者可能会相同, 容易混淆概念</p>
</blockquote>
<h2 id="伤害随等级增加"><a href="#伤害随等级增加" class="headerlink" title="伤害随等级增加"></a>伤害随等级增加</h2><p>前面我们用一个<code>GEEC</code>通过攻击-防御得到最后的生命值</p>
<p>我们继续扩展, 在下面的<code>ModifierMagnitude</code>内加入参数, 再给一个<code>CurveTable</code>参数,如下图</p>
<p><img src="https://img.supervj.top//img/image-20201222135917433.png" alt="image-20201222135917433"></p>
<p>此举意味着我们计算时的<code>Attack</code>值会额外增加对应等级的攻击力</p>
<p><code>CSV</code>表格的编辑如下</p>
<p><strong><img src="https://img.supervj.top//img/image-20201222140009303.png" alt="image-20201222140009303"></strong></p>
<p>然后可以得到不同等级对应的攻击力加成</p>
<h2 id="伤害计算中的属性关联"><a href="#伤害计算中的属性关联" class="headerlink" title="伤害计算中的属性关联"></a>伤害计算中的属性关联</h2><p><code>PostGameplayEffectExecute()</code>函数会在引用<code>GE</code>以后调用, 同时也会触发属性改变的事件响应,</p>
<p>同时这里需要注意, 我们的<code>Set***()</code>函数能触发事件响应.</p>
<blockquote>
<p> <strong>但是无法再次触发<code>PostGameplayEffectExecute()</code></strong></p>
</blockquote>
<p>意味着,加入我们希望通过修改<code>A</code>属性后来修改<code>B</code>属性可以在<code>PostGameplayEffectExecute()</code>函数内处理</p>
<p>比如,<code> Attack</code>属性=<code>AttackA+AttackB</code>, 那么可以在<code>PostGameplayEffectExecute()</code>函数内实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Data.EvaluatedData.Attribute == <span class="built_in">GetAttackAAttribute</span>() || ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">SetAttack</span>(<span class="built_in">GetAttackA</span>()+<span class="built_in">GetAttackB</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似这种形式也可以触发<code>Attack</code>的事件响应, 方便UI的同步显示效果</p>
<p>在案例里面, 我设置了5个主属性,如<code>力量,敏捷</code>等</p>
<p>随着主属性的修改, 其他副属性如<code>攻击力,护甲值,暴击率</code>等会随之改变, 这些操作是可以放到<code>PostGameplayEffectExecute()</code>内处理的</p>
<blockquote>
<p>可否把上述内容放到<code>PreAttributeChange()</code>内?</p>
<p><code>PreAttributeChange()</code>只是对属性的预处理, 此函数内不适合去<code>Get</code>其他函数的值, 不能保证此时这个值是否正确</p>
<p><code>PreAttributeChange()</code>比较适合对确定的某些属性最一些自适应处理, 如前面已经讲过的对当前生命值和最大生命值做处理函数<code>AdjustAttributeForMaxChange()</code></p>
</blockquote>
<h2 id="伤害进阶处理"><a href="#伤害进阶处理" class="headerlink" title="伤害进阶处理"></a>伤害进阶处理</h2><blockquote>
<p>现在有这么一个需求,先不考虑闪避, 格挡等因素, 但需要计算暴击</p>
<p>玩家技能1:</p>
<ul>
<li>造成攻击力若干百分比的物理伤害</li>
<li>造成攻击力若干百分比的火系伤害</li>
</ul>
<p>计算方式需求:</p>
<ul>
<li>物理伤害需计算护甲, 物理抗性等</li>
<li>法系伤害需计算相对应的法术抗性</li>
</ul>
</blockquote>
<p>首先需要在<code>Set</code>类内申明几个用于计算伤害的临时属性, 在<code>GASD</code>和<code>ActionRPG</code>项目中都采用了如此的方案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//临时攻击数据, 通过技能初始化, 用于结算最终伤害</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;AttackTemp&quot;</span>, ReplicatedUsing = OnRep_Attack_Physics)</span><br><span class="line">	FGameplayAttributeData Attack_Physics;</span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(USRAttributeSetBase, Attack_Physics)</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;AttackTemp&quot;</span>, ReplicatedUsing = OnRep_Attack_Fire)</span><br><span class="line">	FGameplayAttributeData Attack_Fire;</span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(USRAttributeSetBase, Attack_Fire)</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//临时受伤数据</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;DamageTemp&quot;</span>, ReplicatedUsing = OnRep_Damage_Physics)</span><br><span class="line">	FGameplayAttributeData Damage_Physics;</span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(USRAttributeSetBase, Damage_Physics)</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;DamageTemp&quot;</span>, ReplicatedUsing = OnRep_Damage_Fire)</span><br><span class="line">	FGameplayAttributeData Damage_Fire;</span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(USRAttributeSetBase, Damage_Fire)</span><br></pre></td></tr></table></figure>



<p>前面我们已经创建了一个<a href="#GEEC"><code>GEEC</code></a>, 然后我们进行扩展</p>
<p><strong>已略过属性捕捉部分</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRGEEC_Damage::Execute_Implementation</span><span class="params">(<span class="keyword">const</span> FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, OUT FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> PhysicsAttack = <span class="number">0.f</span>;</span><br><span class="line">    <span class="keyword">float</span> FireAttack = <span class="number">0.f</span>;</span><br><span class="line">  ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().Attack_PhysicsDef, EvaluationParameters, PhysicsAttack);</span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().Attack_FireDef, EvaluationParameters, FireAttack);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> critPro = <span class="number">0.f</span>;</span><br><span class="line">	<span class="keyword">float</span> critMul = <span class="number">1.f</span>;</span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().CritProDef, EvaluationParameters, critPro);</span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().CritMulDef, EvaluationParameters, critMul);</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">float</span> ArmorValue = <span class="number">0.f</span>;</span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().ArmorDef, EvaluationParameters, ArmorValue);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> PhysicsResistance = <span class="number">0.f</span>;</span><br><span class="line">	<span class="keyword">float</span> FireResistance = <span class="number">0.f</span>;</span><br><span class="line">  ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().Resistance_PhysicsDef, EvaluationParameters, PhysicsResistance);	ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().Resistance_FireDef, EvaluationParameters, FireResistance);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> PhysicsDamage = <span class="built_in">CalcPhysicsMitigatedDamage</span>(PhysicsAttack, ArmorValue, DamageReduceValue, PhysicsResistance);</span><br><span class="line">	<span class="keyword">float</span> FireDamage = <span class="built_in">CalcMagicMitigatedDamage</span>(FireAttack, DamageReduceValue, FireResistance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们捕获了所需要的属性, 同时通过两个辅助函数计算物理和法术伤害</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">USRGEEC_Damage::CalcPhysicsMitigatedDamage_Implementation</span><span class="params">(<span class="keyword">float</span> UnmitigatedDamage, <span class="keyword">float</span> TargetArmor, <span class="keyword">float</span> critPro, <span class="keyword">float</span> critMul, <span class="keyword">float</span> ReducePercent <span class="comment">/*= 0.0f*/</span>, <span class="keyword">float</span> PhysicsResistance <span class="comment">/*= 0.0f*/</span>)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> outDamage = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="keyword">bool</span> bIsCrit = UKismetMathLibrary::<span class="built_in">RandomBoolWithWeight</span>(critPro);</span><br><span class="line">	<span class="keyword">float</span> armorPerc = <span class="number">1</span> - (TargetArmor / (TargetArmor + <span class="number">500</span>));</span><br><span class="line">	<span class="keyword">float</span> globlePerc = FMath::<span class="built_in">Clamp</span>((<span class="number">1</span> - ReducePercent), <span class="number">0.01f</span>, <span class="number">100.f</span>);</span><br><span class="line">	<span class="keyword">float</span> resistancePerc = <span class="number">1</span> - (PhysicsResistance / (PhysicsResistance + <span class="number">50</span>));</span><br><span class="line">	<span class="keyword">float</span> critValue = FMath::<span class="built_in">Clamp</span>((bIsCrit ? critMul : <span class="number">1.0f</span>),<span class="number">1.0f</span>,<span class="number">999.0f</span>);</span><br><span class="line">	</span><br><span class="line">	outDamage = UnmitigatedDamage * armorPerc * globlePerc * resistancePerc * critValue;</span><br><span class="line">	<span class="keyword">if</span> (bDebug &amp;&amp; outDamage&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(SRLog, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;USRGEEC_Damage::CalcPhysicsMitigatedDamage, SourceDamage = %f, ArmorReduce = %f, GlobleReduce = %f, ResistanceReduce = %f , CritValue = %f, \n OutDamage = %f&quot;</span>),</span><br><span class="line">			UnmitigatedDamage, <span class="number">1</span> - armorPerc, <span class="number">1</span> - globlePerc, <span class="number">1</span> - resistancePerc, critValue, outDamage);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> outDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">USRGEEC_Damage::CalcMagicMitigatedDamage_Implementation</span><span class="params">(<span class="keyword">float</span> UnmitigatedDamage, <span class="keyword">float</span> critPro, <span class="keyword">float</span> critMul, <span class="keyword">float</span> ReducePercent <span class="comment">/*= 0.0f*/</span>, <span class="keyword">float</span> Resistance <span class="comment">/*= 0.0f*/</span>)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> outDamage = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="keyword">bool</span> bIsCrit = UKismetMathLibrary::<span class="built_in">RandomBoolWithWeight</span>(critPro);</span><br><span class="line">	<span class="keyword">float</span> globlePerc = FMath::<span class="built_in">Clamp</span>((<span class="number">1</span> - ReducePercent), <span class="number">0.01f</span>, <span class="number">100.f</span>);</span><br><span class="line">	<span class="keyword">float</span> resistancePerc = <span class="number">1</span> - (Resistance / (Resistance + <span class="number">50</span>));</span><br><span class="line">	<span class="keyword">float</span> critValue = FMath::<span class="built_in">Clamp</span>((bIsCrit ? critMul : <span class="number">1.0f</span>), <span class="number">1.0f</span>, <span class="number">999.0f</span>);</span><br><span class="line">	</span><br><span class="line">	outDamage = UnmitigatedDamage * globlePerc * resistancePerc * critValue;</span><br><span class="line">	<span class="keyword">if</span> (bDebug &amp;&amp; outDamage &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(SRLog, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;USRGEEC_Damage::CalcMagicMitigatedDamage, SourceDamage = %f, GlobleReduce = %f, ResistanceReduce = %f , CritValue = %f \n OutDamage = %f&quot;</span>), </span><br><span class="line">			UnmitigatedDamage, <span class="number">1</span> - globlePerc, <span class="number">1</span> - resistancePerc, critValue, outDamage);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> outDamage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后添加到修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (PhysicsDamage&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OutExecutionOutput.<span class="built_in">AddOutputModifier</span>(<span class="built_in">FGameplayModifierEvaluatedData</span>(<span class="built_in">DamageStatics</span>().Damage_PhysicsProperty, EGameplayModOp::Additive, PhysicsDamage));</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span> (FireDamage&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OutExecutionOutput.<span class="built_in">AddOutputModifier</span>(<span class="built_in">FGameplayModifierEvaluatedData</span>(<span class="built_in">DamageStatics</span>().Damage_FireProperty, EGameplayModOp::Additive, FireDamage));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>接下来会调用到目标单位的<code>AttributeSet</code>类中, 用一个函数<code>HandlDamage()</code>和宏<code>DAMAGE_HANDLE</code>来处理伤害和扣血</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRAttributeSetBase::HandlDamage</span><span class="params">(FGameplayAttribute Attribute, ASRCharacterBase* TargetCharacter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> damage, newHp;</span><br><span class="line">	<span class="built_in">DAMAGE_HANDLE</span>(Attribute, TargetCharacter, Physics, damage, newHp);</span><br><span class="line">	<span class="built_in">DAMAGE_HANDLE</span>(Attribute, TargetCharacter, Fire, damage, newHp);</span><br><span class="line">	<span class="built_in">DAMAGE_HANDLE</span>(Attribute, TargetCharacter, Ice, damage, newHp);</span><br><span class="line">	<span class="built_in">DAMAGE_HANDLE</span>(Attribute, TargetCharacter, Poison, damage, newHp);</span><br><span class="line">	<span class="built_in">DAMAGE_HANDLE</span>(Attribute, TargetCharacter, Electricity, damage, newHp);</span><br><span class="line">	<span class="built_in">DAMAGE_HANDLE</span>(Attribute, TargetCharacter, Holy, damage, newHp);</span><br><span class="line">	<span class="built_in">DAMAGE_HANDLE</span>(Attribute, TargetCharacter, Arcane, damage, newHp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DAMAGE_HANDLE(Attribute,C,Name,TempDamage,TempNewHp) \</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">if</span>(Attribute == GetDamage_##Name##Attribute()) \</span></span><br><span class="line"><span class="meta">	&#123;	\</span></span><br><span class="line"><span class="meta">		TempDamage = GetDamage_##Name(); \</span></span><br><span class="line"><span class="meta">		SetDamage_##Name(0);	\</span></span><br><span class="line"><span class="meta">		<span class="meta-keyword">if</span>(TempDamage&gt;0)	\</span></span><br><span class="line"><span class="meta">		&#123;	\</span></span><br><span class="line"><span class="meta">			ASRCharacterBase* character = Cast<span class="meta-string">&lt;ASRCharacterBase&gt;</span>(C);	\</span></span><br><span class="line"><span class="meta">			<span class="meta-keyword">if</span> (character&amp;&amp;character-&gt;IsAlive())\</span></span><br><span class="line"><span class="meta">			&#123;\</span></span><br><span class="line"><span class="meta">				TempNewHp = GetHealth() - TempDamage;\</span></span><br><span class="line"><span class="meta">				SRLOGEX2(TEXT(<span class="meta-string">&quot;USRAttributeSetBase::HandlDamage %s beDamage = %f&quot;</span>), *TargetCharacter-&gt;GetName(), TempDamage);\</span></span><br><span class="line"><span class="meta">			    SetHealth(TempNewHp);\</span></span><br><span class="line"><span class="meta">			&#125;\</span></span><br><span class="line"><span class="meta">		&#125;	\</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>



<p>然后是设置测试<code>GE</code>类, 我们同时用一张表格来配置技能对应等级的系数</p>
<p><img src="https://img.supervj.top//img/image-20201225172537711.png" alt="image-20201225172537711"></p>
<p><img src="https://img.supervj.top//img/image-20201225172450545.png" alt="image-20201225172450545"></p>
<blockquote>
<p>测试样本: 初始10攻击力, 目标护甲10, 物理抗性10, 伤害减免10%</p>
</blockquote>
<p>分别用1级技能和10级技能攻击测试物理部分</p>
<ul>
<li>1级</li>
</ul>
<p><img src="https://img.supervj.top//img/image-20201225173327395.png" alt="image-20201225173327395"></p>
<ul>
<li>10级</li>
</ul>
<p><img src="https://img.supervj.top//img/image-20201225173355889.png" alt="image-20201225173355889"></p>
<p>完成</p>
<h2 id="伤害进阶处理-闪避和格挡"><a href="#伤害进阶处理-闪避和格挡" class="headerlink" title="伤害进阶处理:闪避和格挡"></a>伤害进阶处理:闪避和格挡</h2><blockquote>
<p>接下来我们再考虑加入闪避和格挡因素,这两者一般游戏针对的都是物理攻击,当然不排除也有闪避法术的设定,我们这里采用的是前者</p>
<p>还需要考虑一个设定, 格挡是格挡税前伤害还是税后, 即伤害减免是在格挡的前后问题,我们使用在税后(伤害减免后)在进行格挡计算, 这种情况下格挡的收益比较大</p>
</blockquote>
<p>因为<code>GEEC</code>不适合做格挡和闪避的效果处理, 比如播放动画之类的, 那么此类消息我们打算传递给<code>ASC</code>去做处理或者转发</p>
<p>在<code>ASC</code>中申明几个代理和函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams</span>(FOnRecieveEventDodge, USRAbilitySystemComponent*, SourceASC, <span class="keyword">const</span> FString&amp;, ExtendInfo);</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams</span>(FOnReceiveEventBlock, USRAbilitySystemComponent*, SourceASC, <span class="keyword">const</span> FHitResult&amp;, HitResult, <span class="keyword">float</span>, UnmitigatedDamage,<span class="keyword">float</span>,BlockValue);</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_FiveParams</span>(FOnReceiveEventDamage, USRAbilitySystemComponent*, SourceASC, <span class="keyword">const</span> FHitResult&amp;, HitResult, <span class="keyword">float</span>, UnmitigatedDamage,<span class="keyword">float</span>, MitigatedDamage, ESRDamageType,DamageType);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRAbilitySystemComponent::ReceiveDodge</span><span class="params">(USRAbilitySystemComponent* SourceASC, <span class="keyword">const</span> FString&amp; ExtendInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bDebugLog)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SRLOGEX2</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s 闪避了 %s 的攻击&quot;</span>), *<span class="built_in">GetAvatarActor</span>()-&gt;<span class="built_in">GetName</span>(), *SourceASC-&gt;<span class="built_in">GetAvatarActor</span>()-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	OnDodge.<span class="built_in">Broadcast</span>(SourceASC, ExtendInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRAbilitySystemComponent::ReceiveDamage</span><span class="params">(USRAbilitySystemComponent* SourceASC, <span class="keyword">const</span> FHitResult&amp; HitResult, <span class="keyword">float</span> UnmitigatedDamage, <span class="keyword">float</span> MitigatedDamag, ESRDamageType DamageType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bDebugLog)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SRLOGEX5</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s 收到 %s 的%s攻击, 税前伤害 = %f, 税后= %f&quot;</span>), *<span class="built_in">GetAvatarActor</span>()-&gt;<span class="built_in">GetName</span>(), *SourceASC-&gt;<span class="built_in">GetAvatarActor</span>()-&gt;<span class="built_in">GetName</span>(), </span><br><span class="line">			*UFlib_SRUtilities::<span class="built_in">DamageTypeToString</span>(DamageType),UnmitigatedDamage, MitigatedDamag);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	OnDamage.<span class="built_in">Broadcast</span>(SourceASC, HitResult, UnmitigatedDamage, MitigatedDamag, DamageType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRAbilitySystemComponent::ReceiveBlock</span><span class="params">(USRAbilitySystemComponent* SourceASC, <span class="keyword">const</span> FHitResult&amp; HitResult, <span class="keyword">float</span> UnmitigatedDamage, <span class="keyword">float</span> BlockValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bDebugLog)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SRLOGEX4</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s 格挡了 %s 攻击的 %f 点伤害(格挡前伤害= %f)&quot;</span>), *<span class="built_in">GetAvatarActor</span>()-&gt;<span class="built_in">GetName</span>(), *SourceASC-&gt;<span class="built_in">GetAvatarActor</span>()-&gt;<span class="built_in">GetName</span>(), BlockValue, UnmitigatedDamage);</span><br><span class="line">	&#125;</span><br><span class="line">	OnBlock.<span class="built_in">Broadcast</span>(SourceASC, HitResult, UnmitigatedDamage,BlockValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了一个辅助函数, 我们在一个函数库中做了枚举和字符串的转换(蓝图自带的)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FString <span class="title">UFlib_SRUtilities::DamageTypeToString</span><span class="params">(ESRDamageType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> SREnumToString&lt;ESRDamageType&gt;(<span class="string">&quot;ESRDamageType&quot;</span>, type, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ESRDamageType <span class="title">UFlib_SRUtilities::StringToDamageType</span><span class="params">(<span class="keyword">const</span> FString&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> SRStringToEnum&lt;ESRDamageType&gt;(<span class="string">&quot;ESRDamageType&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是<code>GEEC</code>中额外加一些代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//闪避和格挡只能作用到物理伤害</span></span><br><span class="line">	<span class="keyword">if</span> (PhysicsDamage&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//先计算闪避</span></span><br><span class="line">		<span class="keyword">float</span> dodge = <span class="number">0.0f</span>;</span><br><span class="line">		ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().DodgeProDef, EvaluationParameters, dodge);</span><br><span class="line">		<span class="keyword">if</span> (dodge &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">bool</span> bIsMiss = UKismetMathLibrary::<span class="built_in">RandomBoolWithWeight</span>(dodge);</span><br><span class="line">			<span class="keyword">if</span> (bIsMiss)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (TargetAbilitySystemComponent&amp;&amp;SourceAbilitySystemComponent)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//如果闪避了, 那么不需要计算具体伤害</span></span><br><span class="line">					TargetAbilitySystemComponent-&gt;<span class="built_in">ReceiveDodge</span>(SourceAbilitySystemComponent);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//再计算格挡;格挡计算在税后,如果是税前那么需要在计算物理伤害之前进行;</span></span><br><span class="line">		<span class="comment">//有些设定需要正面才能格挡, 那么还需要计算方向</span></span><br><span class="line">		<span class="keyword">float</span> blockPro = <span class="number">0.0f</span>;</span><br><span class="line">		<span class="keyword">float</span> blockValue = <span class="number">0.0f</span>;</span><br><span class="line">		ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().BlockProDef, EvaluationParameters, blockPro);</span><br><span class="line">		ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().BlockValueDef, EvaluationParameters, blockValue);</span><br><span class="line">		<span class="keyword">if</span> (blockPro &gt; <span class="number">0</span> &amp;&amp; blockValue&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">bool</span> bBlocked = UKismetMathLibrary::<span class="built_in">RandomBoolWithWeight</span>(blockPro);</span><br><span class="line">			<span class="keyword">if</span> (bBlocked)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (blockValue&gt;=PhysicsDamage)</span><br><span class="line">				&#123;</span><br><span class="line">					TargetAbilitySystemComponent-&gt;<span class="built_in">ReceiveBlock</span>(SourceAbilitySystemComponent, hit, PhysicsDamage, blockValue);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">float</span> Unmi = PhysicsDamage;</span><br><span class="line">					PhysicsDamage = PhysicsDamage - blockValue;</span><br><span class="line">					TargetAbilitySystemComponent-&gt;<span class="built_in">ReceiveBlock</span>(SourceAbilitySystemComponent, hit, Unmi,blockValue);</span><br><span class="line">					TargetAbilitySystemComponent-&gt;<span class="built_in">ReceiveDamage</span>(SourceAbilitySystemComponent, hit, PhysicsAttack, PhysicsDamage,ESRDamageType::PHYSICS);</span><br><span class="line">					OutExecutionOutput.<span class="built_in">AddOutputModifier</span>(<span class="built_in">FGameplayModifierEvaluatedData</span>(<span class="built_in">DamageStatics</span>().Damage_PhysicsProperty, EGameplayModOp::Additive, PhysicsDamage));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			TargetAbilitySystemComponent-&gt;<span class="built_in">ReceiveDamage</span>(SourceAbilitySystemComponent, hit, PhysicsAttack,PhysicsDamage, ESRDamageType::PHYSICS);</span><br><span class="line">			OutExecutionOutput.<span class="built_in">AddOutputModifier</span>(<span class="built_in">FGameplayModifierEvaluatedData</span>(<span class="built_in">DamageStatics</span>().Damage_PhysicsProperty, EGameplayModOp::Additive, PhysicsDamage));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>测试</p>
<p><img src="https://img.supervj.top//img/image-20201226110601324.png" alt="image-20201226110601324"></p>
<p>完成!</p>
<h2 id="伤害进阶处理-MMC"><a href="#伤害进阶处理-MMC" class="headerlink" title="伤害进阶处理:MMC"></a>伤害进阶处理:MMC</h2><blockquote>
<p>需求: </p>
<p>法术技能有额外加成, 比如某个装备上有词缀(火系伤害+50%),那么问题来了,</p>
<p>我们之前测试的火系技能伤害最后就变成是 <code>FireDamage = 攻击力 * 等级系数 * (1 + 火系加成)</code></p>
<p>如果还是用<code>AttributeBase</code>基于属性的方式是不行了, 这里我们用一个自定义的<code>MMC</code>类就比较方便了</p>
</blockquote>
<p>上一篇已经大概讲了,<code>MMC</code>需要封装几个蓝图函数方便使用, 不然就去<code>cpp</code>吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;MMC&quot;</span>)</span><br><span class="line">	<span class="function">AActor* <span class="title">GetInstigator</span><span class="params">(<span class="keyword">const</span> FGameplayEffectSpec&amp; Spec)</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;MMC&quot;</span>)</span><br><span class="line">	<span class="function">FGameplayAttribute <span class="title">GetAttributeFromDef</span><span class="params">(<span class="keyword">const</span> FGameplayEffectAttributeCaptureDefinition&amp; _Def)</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;MMC&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">TryGetCapturedAttributeMagnitude</span><span class="params">(<span class="keyword">const</span> FGameplayEffectAttributeCaptureDefinition&amp; Def, <span class="keyword">const</span> FGameplayEffectSpec&amp; Spec)</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;MMC&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetLevel</span><span class="params">(<span class="keyword">const</span> FGameplayEffectSpec&amp; Spec)</span><span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>



<p><img src="https://img.supervj.top//img/image-20201226113630345.png" alt="image-20201226113630345"></p>
<p>补充一个属性图, 我们初始化的时候给了50%的火系加成</p>
<p><img src="https://img.supervj.top//img/image-20201226113716170.png" alt="image-20201226113716170"></p>
<p>测试</p>
<p><img src="https://img.supervj.top//img/image-20201226113752690.png" alt="image-20201226113752690"></p>
<p>重点看税前已经变成1.5的伤害了, 正确</p>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayAbilitySystem入门与实战(三):几个有用的异步事件</title>
    <url>/2020/12/21/GameplayAbilitySystem%E5%88%86%E6%9E%90(%E4%B8%89)_%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一篇单独创建几个非常有用的异步节点,如<code>UAsyncTask_ListenAttributeChanged</code>可以实时监听任意属性的更改情况,在初期我们用于临时UMG中,方便我们查询和debug;</p>
<p>可以使用继承自<code>UBlueprintAsyncActionBase</code>的基本异步类, 也可以使用<code>GAS</code>框架内的<code>UAbilityTask</code>来制作</p>
<p><img src="https://img.supervj.top//img/image-20201214155057270.png" alt="image-20201214155057270"></p>
<h2 id="异步事件-属性监听"><a href="#异步事件-属性监听" class="headerlink" title="异步事件:属性监听"></a>异步事件:属性监听</h2><p>这个节点相对比较简单, 原理就是通过<code>ASC</code>中的<code>GetGameplayAttributeValueChangeDelegate()</code>绑定对应属性的代理,然后简单的派发异步节点中的代理, 这是<code>GASD</code>项目采用的方案, </p>
<span id="more"></span>

<ul>
<li>头文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams</span>(FOnAttributeChanged, FGameplayAttribute, Attribute, <span class="keyword">float</span>, NewValue, <span class="keyword">float</span>, OldValue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SUPERROAD_API</span> <span class="title">UAsyncTask_ListenAttributeChanged</span> :</span> <span class="keyword">public</span> UBlueprintAsyncActionBase</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">		FOnAttributeChanged OnAttributeChanged;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听attribute 改变</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="function"><span class="keyword">static</span> UAsyncTask_ListenAttributeChanged* <span class="title">ListenForAttributeChange</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent, FGameplayAttribute Attribute)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数组版本</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="function"><span class="keyword">static</span> UAsyncTask_ListenAttributeChanged* <span class="title">ListenForAttributesChange</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent, TArray&lt;FGameplayAttribute&gt; Attributes)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">EndTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">		UAbilitySystemComponent* ASC;</span><br><span class="line"></span><br><span class="line">	FGameplayAttribute AttributeToListenFor;</span><br><span class="line">	TArray&lt;FGameplayAttribute&gt; AttributesToListenFor;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AttributeChanged</span><span class="params">(<span class="keyword">const</span> FOnAttributeChangeData&amp; Data)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>没什么特殊需要注意的, 提供了2个版本的监听</p>
<ul>
<li>cpp</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UAsyncTask_ListenAttributeChanged* <span class="title">UAsyncTask_ListenAttributeChanged::ListenForAttributeChange</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent, FGameplayAttribute Attribute)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAsyncTask_ListenAttributeChanged* WaitForAttributeChangedTask = NewObject&lt;UAsyncTask_ListenAttributeChanged&gt;();</span><br><span class="line">	WaitForAttributeChangedTask-&gt;ASC = AbilitySystemComponent;</span><br><span class="line">	WaitForAttributeChangedTask-&gt;AttributeToListenFor = Attribute;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsValid</span>(AbilitySystemComponent) || !Attribute.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForAttributeChangedTask-&gt;<span class="built_in">RemoveFromRoot</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(Attribute).<span class="built_in">AddUObject</span>(WaitForAttributeChangedTask, &amp;UAsyncTask_ListenAttributeChanged::AttributeChanged);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> WaitForAttributeChangedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造一个异步节点类, 赋值,绑定<code>ASC</code>事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UAsyncTask_ListenAttributeChanged* <span class="title">UAsyncTask_ListenAttributeChanged::ListenForAttributesChange</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent, TArray&lt;FGameplayAttribute&gt; Attributes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAsyncTask_ListenAttributeChanged* WaitForAttributeChangedTask = NewObject&lt;UAsyncTask_ListenAttributeChanged&gt;();</span><br><span class="line">	WaitForAttributeChangedTask-&gt;ASC = AbilitySystemComponent;</span><br><span class="line">	WaitForAttributeChangedTask-&gt;AttributesToListenFor = Attributes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsValid</span>(AbilitySystemComponent) || Attributes.<span class="built_in">Num</span>() &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForAttributeChangedTask-&gt;<span class="built_in">RemoveFromRoot</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (FGameplayAttribute Attribute : Attributes)</span><br><span class="line">	&#123;</span><br><span class="line">		AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(Attribute).<span class="built_in">AddUObject</span>(WaitForAttributeChangedTask, &amp;UAsyncTask_ListenAttributeChanged::AttributeChanged);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> WaitForAttributeChangedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组版本,区别不大</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAsyncTask_ListenAttributeChanged::EndTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(ASC))</span><br><span class="line">	&#123;</span><br><span class="line">		ASC-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(AttributeToListenFor).<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (FGameplayAttribute Attribute : AttributesToListenFor)</span><br><span class="line">		&#123;</span><br><span class="line">			ASC-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(Attribute).<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SetReadyToDestroy</span>();</span><br><span class="line">	<span class="built_in">MarkPendingKill</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EndTask</code>事件不能忘记执行,否则可能会导致引擎崩溃</p>
<p>在这里就是解除绑定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAsyncTask_ListenAttributeChanged::AttributeChanged</span><span class="params">(<span class="keyword">const</span> FOnAttributeChangeData&amp; Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OnAttributeChanged.<span class="built_in">Broadcast</span>(Data.Attribute, Data.NewValue, Data.OldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转发,派发代理</p>
<hr>
<p>这里创建了一个UMG控件通过公开的属性变量来监听特定的属性</p>
<p><img src="https://img.supervj.top//img/image-20201214155732889.png" alt="image-20201214155732889"></p>
<p>然后就放到一个<code>DebugUI</code>中,监听所有属性</p>
<p><img src="https://img.supervj.top//img/image-20201214155800692.png" alt="image-20201214155800692"></p>
<p>这是运行以后的</p>
<p><img src="https://img.supervj.top//img/image-20201214155816195.png" alt="image-20201214155816195"></p>
<hr>
<p>如果你想要自己定义一套属性响应机制也可以通过比如在<code>AttributeSet</code>内广播代理事件来达到同样的目的,  我们模仿<code>ASC</code>的那一套来实现一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_ThreeParams</span>(FOnAttributeChangedMulDly, <span class="keyword">const</span> FGameplayAttribute&amp;,<span class="keyword">float</span>,<span class="keyword">float</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">FOnAttributeChangedMulDly&amp; <span class="title">GetGameplayAttributeValueChangeDelegate</span><span class="params">(FGameplayAttribute Attribute)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BroadcastValueChanged</span><span class="params">(FGameplayAttribute Attribute)</span></span>;</span><br><span class="line">	TMap&lt;FGameplayAttribute, FOnAttributeChangedMulDly&gt; AttributeValueChangeDelegates;</span><br></pre></td></tr></table></figure>

<p>然后异步事件节点通过类似的方式绑定就可以了, 我们这里输出的是<code>Current</code>和<code>Base</code>值, 与前面方案有所不同</p>
<h2 id="异步事件-冷却"><a href="#异步事件-冷却" class="headerlink" title="异步事件:冷却"></a>异步事件:冷却</h2><p>冷却时间比前面的属性略微复杂一点点, 监听了两个时间,开始和结束,并没有中间过程, 查看<code>ASC</code>以及<code>GE</code>和<code>GA</code>的代码发现并无相关的事件代理, 但是可以有方法找到当前技能或者<code>GE</code>的<code>RemainingTime</code>和<code>Duration</code>.</p>
<p>无妨, 这个或许是因为消耗问题, 没有必要一直派发代理来告诉我们CD刷新了, 我们做测试或者到时候<code>UI</code>显示的转圈圈效果也只需要做个本地的效果就可以了</p>
<ul>
<li>头文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams</span>(FOnCooldownChanged, FGameplayTag, CooldownTag, <span class="keyword">float</span>, TimeRemaining, <span class="keyword">float</span>, Duration);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">		FOnCooldownChanged OnCooldownBegin;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">		FOnCooldownChanged OnCooldownEnd;</span><br></pre></td></tr></table></figure>

<p>类似的创建静态事件返回自己</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">static</span> UAsyncTask_ListenCooldownUpdated* <span class="title">ListenForCooldownChange</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent, FGameplayTagContainer InCooldownTags, <span class="keyword">bool</span> InUseServerCooldown)</span></span>;</span><br></pre></td></tr></table></figure>

<p>几个<code>Protected</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">		UAbilitySystemComponent* ASC;</span><br><span class="line">	FGameplayTagContainer CooldownTags;</span><br><span class="line">	<span class="keyword">bool</span> UseServerCooldown;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnActiveGameplayEffectAddedCallback</span><span class="params">(UAbilitySystemComponent* Target, <span class="keyword">const</span> FGameplayEffectSpec&amp; SpecApplied, FActiveGameplayEffectHandle ActiveHandle)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CooldownTagChanged</span><span class="params">(<span class="keyword">const</span> FGameplayTag CooldownTag, int32 NewCount)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">GetCooldownRemainingForTag</span><span class="params">(FGameplayTagContainer InCooldownTags, <span class="keyword">float</span>&amp; TimeRemaining, <span class="keyword">float</span>&amp; CooldownDuration)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>cpp</code></li>
</ul>
<p>先看激活<code>GE</code>的回调事件</p>
<p>先从<code>Spec</code>中拿到需要的<code>tag</code>,查询我们指定的冷却<code>tag</code>是否包含在里面</p>
<p>如果存在, 那么拿到所需要的时间根据相关设置广播</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAsyncTask_ListenCooldownUpdated::OnActiveGameplayEffectAddedCallback</span><span class="params">(UAbilitySystemComponent* Target, <span class="keyword">const</span> FGameplayEffectSpec&amp; SpecApplied, FActiveGameplayEffectHandle ActiveHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FGameplayTagContainer AssetTags;</span><br><span class="line">	SpecApplied.<span class="built_in">GetAllAssetTags</span>(AssetTags);</span><br><span class="line"></span><br><span class="line">	FGameplayTagContainer GrantedTags;</span><br><span class="line">	SpecApplied.<span class="built_in">GetAllGrantedTags</span>(GrantedTags);</span><br><span class="line"></span><br><span class="line">	TArray&lt;FGameplayTag&gt; CooldownTagArray;</span><br><span class="line">	CooldownTags.<span class="built_in">GetGameplayTagArray</span>(CooldownTagArray);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (FGameplayTag CooldownTag : CooldownTagArray)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (AssetTags.<span class="built_in">HasTagExact</span>(CooldownTag) || GrantedTags.<span class="built_in">HasTagExact</span>(CooldownTag))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> TimeRemaining = <span class="number">0.0f</span>;</span><br><span class="line">			<span class="keyword">float</span> Duration = <span class="number">0.0f</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="function">FGameplayTagContainer <span class="title">CooldownTagContainer</span><span class="params">(GrantedTags.GetByIndex(<span class="number">0</span>))</span></span>;</span><br><span class="line">			<span class="built_in">GetCooldownRemainingForTag</span>(CooldownTagContainer, TimeRemaining, Duration);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ASC-&gt;<span class="built_in">GetOwnerRole</span>() == ROLE_Authority)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 服务端玩家</span></span><br><span class="line">				OnCooldownBegin.<span class="built_in">Broadcast</span>(CooldownTag, TimeRemaining, Duration);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!UseServerCooldown &amp;&amp; SpecApplied.<span class="built_in">GetContext</span>().<span class="built_in">GetAbilityInstance_NotReplicated</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 客户端使用预测冷却时间</span></span><br><span class="line">				OnCooldownBegin.<span class="built_in">Broadcast</span>(CooldownTag, TimeRemaining, Duration);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (UseServerCooldown &amp;&amp; SpecApplied.<span class="built_in">GetContext</span>().<span class="built_in">GetAbilityInstance_NotReplicated</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 客户端使用服务端冷却</span></span><br><span class="line">				OnCooldownBegin.<span class="built_in">Broadcast</span>(CooldownTag, TimeRemaining, Duration);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (UseServerCooldown &amp;&amp; SpecApplied.<span class="built_in">GetContext</span>().<span class="built_in">GetAbilityInstance_NotReplicated</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//客户端使用服务器的冷却时间，但这是GE预测的冷却时间。</span></span><br><span class="line">				<span class="comment">//在服务器冷却时间到来之前，这可以使技能变灰。</span></span><br><span class="line">				OnCooldownBegin.<span class="built_in">Broadcast</span>(CooldownTag, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>tag</code>找到所需的时间, 这两个时间是保存在<code>GE</code>中的, 也可以通过<code>ASC</code>去查询得到.</p>
<p>下面方法是从数组中找到值最大的作为返回值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UAsyncTask_ListenCooldownUpdated::GetCooldownRemainingForTag</span><span class="params">(FGameplayTagContainer InCooldownTags, <span class="keyword">float</span>&amp; TimeRemaining, <span class="keyword">float</span>&amp; CooldownDuration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(ASC) &amp;&amp; InCooldownTags.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		TimeRemaining = <span class="number">0.f</span>;</span><br><span class="line">		CooldownDuration = <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">		FGameplayEffectQuery <span class="keyword">const</span> Query = FGameplayEffectQuery::<span class="built_in">MakeQuery_MatchAnyOwningTags</span>(InCooldownTags);</span><br><span class="line">		TArray&lt; TPair&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; &gt; DurationAndTimeRemaining = ASC-&gt;<span class="built_in">GetActiveEffectsTimeRemainingAndDuration</span>(Query);</span><br><span class="line">		<span class="keyword">if</span> (DurationAndTimeRemaining.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			int32 BestIdx = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">float</span> LongestTime = DurationAndTimeRemaining[<span class="number">0</span>].Key;</span><br><span class="line">			<span class="keyword">for</span> (int32 Idx = <span class="number">1</span>; Idx &lt; DurationAndTimeRemaining.<span class="built_in">Num</span>(); ++Idx)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (DurationAndTimeRemaining[Idx].Key &gt; LongestTime)</span><br><span class="line">				&#123;</span><br><span class="line">					LongestTime = DurationAndTimeRemaining[Idx].Key;</span><br><span class="line">					BestIdx = Idx;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			TimeRemaining = DurationAndTimeRemaining[BestIdx].Key;</span><br><span class="line">			CooldownDuration = DurationAndTimeRemaining[BestIdx].Value;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 下面再看静态方法, 这个也没什么大的难点, 绑定了<code>GE</code>激活的代理, 然后根据<code>tag</code>注册<code>tag</code>对应的事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">UAsyncTask_ListenCooldownUpdated* <span class="title">UAsyncTask_ListenCooldownUpdated::ListenForCooldownChange</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent, FGameplayTagContainer InCooldownTags, <span class="keyword">bool</span> InUseServerCooldown)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAsyncTask_ListenCooldownUpdated* task = NewObject&lt;UAsyncTask_ListenCooldownUpdated&gt;();</span><br><span class="line">	task-&gt;ASC = AbilitySystemComponent;</span><br><span class="line">	task-&gt;CooldownTags = InCooldownTags;</span><br><span class="line">	task-&gt;UseServerCooldown = InUseServerCooldown;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsValid</span>(AbilitySystemComponent) || InCooldownTags.<span class="built_in">Num</span>() &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		task-&gt;<span class="built_in">EndTask</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AbilitySystemComponent-&gt;OnActiveGameplayEffectAddedDelegateToSelf.<span class="built_in">AddUObject</span>(task, &amp;UAsyncTask_ListenCooldownUpdated::OnActiveGameplayEffectAddedCallback);</span><br><span class="line"></span><br><span class="line">	TArray&lt;FGameplayTag&gt; CooldownTagArray;</span><br><span class="line">	InCooldownTags.<span class="built_in">GetGameplayTagArray</span>(CooldownTagArray);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (FGameplayTag CooldownTag : CooldownTagArray)</span><br><span class="line">	&#123;</span><br><span class="line">		AbilitySystemComponent-&gt;<span class="built_in">RegisterGameplayTagEvent</span>(CooldownTag, EGameplayTagEventType::NewOrRemoved).<span class="built_in">AddUObject</span>(task, &amp;UAsyncTask_ListenCooldownUpdated::CooldownTagChanged);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>结束事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAsyncTask_ListenCooldownUpdated::EndTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(ASC))</span><br><span class="line">	&#123;</span><br><span class="line">		ASC-&gt;OnActiveGameplayEffectAddedDelegateToSelf.<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		TArray&lt;FGameplayTag&gt; CooldownTagArray;</span><br><span class="line">		CooldownTags.<span class="built_in">GetGameplayTagArray</span>(CooldownTagArray);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (FGameplayTag CooldownTag : CooldownTagArray)</span><br><span class="line">		&#123;</span><br><span class="line">			ASC-&gt;<span class="built_in">RegisterGameplayTagEvent</span>(CooldownTag, EGameplayTagEventType::NewOrRemoved).<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SetReadyToDestroy</span>();</span><br><span class="line">	<span class="built_in">MarkPendingKill</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是<code>tag</code>改变的事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAsyncTask_ListenCooldownUpdated::CooldownTagChanged</span><span class="params">(<span class="keyword">const</span> FGameplayTag CooldownTag, int32 NewCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (NewCount == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OnCooldownEnd.<span class="built_in">Broadcast</span>(CooldownTag, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="异步事件-GE层数"><a href="#异步事件-GE层数" class="headerlink" title="异步事件:GE层数"></a>异步事件:GE层数</h2><p>这个节点用于监听可以叠加的<code>GE</code>的层数</p>
<ul>
<li>头文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams</span>(FOnGameplayEffectStackChanged, FGameplayTag, EffectGameplayTag, FActiveGameplayEffectHandle, Handle, int32, NewStackCount, int32, OldStackCount);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SUPERROAD_API</span> <span class="title">UAsyncTask_ListenGEStackChanged</span> :</span> <span class="keyword">public</span> UBlueprintAsyncActionBase</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">		FOnGameplayEffectStackChanged OnGameplayEffectStackChange;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="function"><span class="keyword">static</span> UAsyncTask_ListenGEStackChanged* <span class="title">ListenForGameplayEffectStackChange</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent, FGameplayTag InEffectGameplayTag)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">EndTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">		UAbilitySystemComponent* ASC;</span><br><span class="line"></span><br><span class="line">	FGameplayTag EffectGameplayTag;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnActiveGameplayEffectAddedCallback</span><span class="params">(UAbilitySystemComponent* Target, <span class="keyword">const</span> FGameplayEffectSpec&amp; SpecApplied, FActiveGameplayEffectHandle ActiveHandle)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRemoveGameplayEffectCallback</span><span class="params">(<span class="keyword">const</span> FActiveGameplayEffect&amp; EffectRemoved)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GameplayEffectStackChanged</span><span class="params">(FActiveGameplayEffectHandle EffectHandle, int32 NewStackCount, int32 PreviousStackCount)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>头文件跟之前的区别不大, 三个本地事件分别用于绑定 激活/移除<code>GE</code>和层数变化</p>
<ul>
<li><code>cpp</code></li>
</ul>
<p>静态函数绑定了2个代理</p>
<p><code>OnActiveGameplayEffectAddedDelegateToSelf</code>和<code>OnAnyGameplayEffectRemovedDelegate</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UAsyncTask_ListenGEStackChanged* <span class="title">UAsyncTask_ListenGEStackChanged::ListenForGameplayEffectStackChange</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent, FGameplayTag InEffectGameplayTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	UAsyncTask_ListenGEStackChanged* task = NewObject&lt;UAsyncTask_ListenGEStackChanged&gt;();</span><br><span class="line">	task-&gt;ASC = AbilitySystemComponent;</span><br><span class="line">	task-&gt;EffectGameplayTag = InEffectGameplayTag;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsValid</span>(AbilitySystemComponent) || !InEffectGameplayTag.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		task-&gt;<span class="built_in">EndTask</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AbilitySystemComponent-&gt;OnActiveGameplayEffectAddedDelegateToSelf.<span class="built_in">AddUObject</span>(task, &amp;UAsyncTask_ListenGEStackChanged::OnActiveGameplayEffectAddedCallback);</span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">OnAnyGameplayEffectRemovedDelegate</span>().<span class="built_in">AddUObject</span>(task, &amp;UAsyncTask_ListenGEStackChanged::OnRemoveGameplayEffectCallback);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后结束任务的时候接触绑定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAsyncTask_ListenGEStackChanged::EndTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(ASC))</span><br><span class="line">	&#123;</span><br><span class="line">		ASC-&gt;OnActiveGameplayEffectAddedDelegateToSelf.<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line">		ASC-&gt;<span class="built_in">OnAnyGameplayEffectRemovedDelegate</span>().<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SetReadyToDestroy</span>();</span><br><span class="line">	<span class="built_in">MarkPendingKill</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>激活<code>GE</code>的时候做了一个<code>tag</code>判断,如果复合就绑定<code>OnGameplayEffectStackChangeDelegate</code>并且广播代理</p>
<p>同理在移除的时候也广播</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAsyncTask_ListenGEStackChanged::OnActiveGameplayEffectAddedCallback</span><span class="params">(UAbilitySystemComponent* Target, <span class="keyword">const</span> FGameplayEffectSpec&amp; SpecApplied, FActiveGameplayEffectHandle ActiveHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FGameplayTagContainer AssetTags;</span><br><span class="line">	SpecApplied.<span class="built_in">GetAllAssetTags</span>(AssetTags);</span><br><span class="line"></span><br><span class="line">	FGameplayTagContainer GrantedTags;</span><br><span class="line">	SpecApplied.<span class="built_in">GetAllGrantedTags</span>(GrantedTags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (AssetTags.<span class="built_in">HasTagExact</span>(EffectGameplayTag) || GrantedTags.<span class="built_in">HasTagExact</span>(EffectGameplayTag))</span><br><span class="line">	&#123;</span><br><span class="line">		ASC-&gt;<span class="built_in">OnGameplayEffectStackChangeDelegate</span>(ActiveHandle)-&gt;<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;UAsyncTask_ListenGEStackChanged::GameplayEffectStackChanged);</span><br><span class="line">		OnGameplayEffectStackChange.<span class="built_in">Broadcast</span>(EffectGameplayTag, ActiveHandle, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAsyncTask_ListenGEStackChanged::OnRemoveGameplayEffectCallback</span><span class="params">(<span class="keyword">const</span> FActiveGameplayEffect&amp; EffectRemoved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FGameplayTagContainer AssetTags;</span><br><span class="line">	EffectRemoved.Spec.<span class="built_in">GetAllAssetTags</span>(AssetTags);</span><br><span class="line"></span><br><span class="line">	FGameplayTagContainer GrantedTags;</span><br><span class="line">	EffectRemoved.Spec.<span class="built_in">GetAllGrantedTags</span>(GrantedTags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (AssetTags.<span class="built_in">HasTagExact</span>(EffectGameplayTag) || GrantedTags.<span class="built_in">HasTagExact</span>(EffectGameplayTag))</span><br><span class="line">	&#123;</span><br><span class="line">		OnGameplayEffectStackChange.<span class="built_in">Broadcast</span>(EffectGameplayTag, EffectRemoved.Handle, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAsyncTask_ListenGEStackChanged::GameplayEffectStackChanged</span><span class="params">(FActiveGameplayEffectHandle EffectHandle, int32 NewStackCount, int32 PreviousStackCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OnGameplayEffectStackChange.<span class="built_in">Broadcast</span>(EffectGameplayTag, EffectHandle, NewStackCount, PreviousStackCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayAbilitySystem入门与实战(二):属性</title>
    <url>/2020/12/20/GameplayAbilitySystem%E5%88%86%E6%9E%90(%E4%BA%8C)_%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一篇已经完成了初始化,角色可以在服务端和客户端正确触发技能,那么这一篇我们开始研究如何声明我们<code>GAS</code>框架内的属性</p>
<p><u>暗黑3属性图镇楼</u></p>
<img src="https://img.supervj.top//img/image-20201217111712682.png" alt="image-20201217111712682" style="zoom:50%;" />





<span id="more"></span>

<h2 id="属性类"><a href="#属性类" class="headerlink" title="属性类"></a>属性类</h2><p><code>GAS</code>常用的属性类是<code>FGameplayAttribute</code>和<code>FGameplayAttributeData</code></p>
<ul>
<li><code>FGameplayAttributeData</code></li>
</ul>
<p>此结构体内有两个<code>float</code>变量, 表示<code>Base</code>和<code>Current</code>两个值, 一般情况下是一致的. 多数游戏中的生命值,魔法值等多数属性都可以使用此属性</p>
<p>这里请看如下关键代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FAggregatorRef* RefPtr = AttributeAggregatorMap.<span class="built_in">Find</span>(Attribute);</span><br><span class="line">	<span class="keyword">if</span> (RefPtr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// There is an aggregator for this attribute, so set the base value. The dirty callback chain</span></span><br><span class="line">		<span class="comment">// will update the actual AttributeSet property value for us.		</span></span><br><span class="line">		RefPtr-&gt;<span class="built_in">Get</span>()-&gt;<span class="built_in">SetBaseValue</span>(NewBaseValue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if there is no aggregator set the current value (base == current in this case)</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InternalUpdateNumericalAttribute</span>(Attribute, NewBaseValue, <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是在<code>GameplayEffect.cpp</code>;中的<code>SetAttributeBaseValue()</code>函数体中的, 本函数设置了<code>Base</code>值,然后<code>InternalUpdateNumericalAttribute()</code>设置了与<code>Base</code>一样的<code>Current</code>值, 从除非你自己创建了<code>FAggregatorRef</code>类, 该类通过<code>FActiveGameplayEffectsContainer::FindOrCreateAttributeAggregator()</code>创建,此方法是私有的, 实测通过<code>FActiveGameplayEffectsContainer::CaptureAttributeForGameplayEffect()</code>可以在外部创建, 那么使用起来就有点略微麻烦了,而且如果使用默认的<code>FAggregatorRef</code>类还是会饶了一圈通过<code>OnAttributeAggregatorDirty()</code>再执行<code>InternalUpdateNumericalAttribute()</code>把<code>Current</code>值给设置为与<code>Base</code>值一样的值.</p>
<p>当然你强行拿到<code>FGameplayAttributeData</code>直接<code>SetCurrentValue()</code>是可以改变的, 但是无法通过<code>GE</code>来改到<code>Current</code>值,而且没有属性的事件响应</p>
<blockquote>
<p>对此处没有过多研究,如有错误请执教</p>
</blockquote>
<ul>
<li><code>FGameplayAttribute</code></li>
</ul>
<p>相比而言只有一个浮点值, 对于一些辅助属性或者UI之类的属性可以用此属性</p>
<ul>
<li>事件响应</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(AttributeSetBase-&gt;<span class="built_in">GetHealthAttribute</span>()).<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;APlayerState::HealthChanged);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HealthChanged</span><span class="params">(<span class="keyword">const</span> FOnAttributeChangeData&amp; Data)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用上述两个方法来绑定生命属性更改以后的回调，我们可以在绑定的事件处理比如UI之类的逻辑</p>
<p>后面会创建一个下图所示的异步节点来监听属性改变, 方便在各个地方得到属性数据</p>
<p><img src="https://img.supervj.top/img/gitlab/image-20201024195609117.png" alt="image-20201024195609117"></p>
<h2 id="属性集-AttributeSet"><a href="#属性集-AttributeSet" class="headerlink" title="属性集/AttributeSet"></a>属性集/AttributeSet</h2><p>顾名思义，属性集就是多个属性的容器，通常在拥有类的构造函数中创建，当然目前必须用C++</p>
<p>例如我们也可以在<code>CharacterBase</code>的构造函数构造此类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">		USRAttributeSetBase* AttributeSet;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AttributeSet = CreateDefaultSubobject&lt;USRAttributeSetBase&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AttributeSet&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li>辅助宏</li>
</ul>
<p><code>AttributeSet.h</code>中为我们提供了几个很有用的辅助宏, 用于方便我们在<code>cpp</code>中<code>get</code>,<code>set</code>,<code>init</code>等属性操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName) \</span></span><br></pre></td></tr></table></figure>

<p>我们再用<code>ATTRIBUTE_ACCESSORS</code>宏包裹4个宏</p>
<hr>
<p>然后用如下方法申明一个属性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Health&quot;</span>, ReplicatedUsing = OnRep_Health)</span><br><span class="line">		FGameplayAttributeData Health;</span><br><span class="line">	<span class="built_in">ATTRIBUTE_ACCESSORS</span>(USRAttributeSetBase, Health)</span><br></pre></td></tr></table></figure>

<p>测试可以在<code>cpp</code>中调用如下方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">InitHealth</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">GetHealth</span>();</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">SetHealth</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">GetHealthAttribute</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意: 这个是cpp中的函数,在蓝图中无法使用</p>
</blockquote>
<p>在蓝图中可以通过如下方式获取, 不能<code>Set</code></p>
<p><img src="https://img.supervj.top/img/advVR/image-20200922134907045.png" alt="image-20200922134907045"></p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>如果属性设置了同步(Rep)</p>
<p>那么可以在实现的时候用宏<code>GAMEPLAYATTRIBUTE_REPNOTIFY</code>来处理属性的同步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UVGAttributeSet::OnRep_Health</span><span class="params">(<span class="keyword">const</span> FGameplayAttributeData&amp; OldHealth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">GAMEPLAYATTRIBUTE_REPNOTIFY</span>(UVGAttributeSet, Health, OldHealth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为<code>OnRep</code>函数是<code>UFUNCTION()</code>,所以因为UE的限制, 没办法用宏来快速声明和定义, 所以属性很多的话只能手动一个个声明定义</p>
</blockquote>
<p>最后,同步的属性需要在<code>GetLifetimeReplicatedProps</code>函数内用宏<code>DOREPLIFETIME_CONDITION_NOTIFY</code>处理同步,<code>REPNOTIFY_Always</code>属性意味着服务器值过来以后一定会走<code>Rep</code>函数, 默认情况如果值不变不用调用;</p>
<blockquote>
<p> 后面两个参数可以不填, 默认值是<code>COND_None,REPNOTIFY_OnChanged</code></p>
</blockquote>
<p>如果是类似<code>MetaAttribute</code>类的非同步属性, 那么此函数也会取消同步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UVGAttributeSet::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UVGAttributeSet, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态添加-移除"><a href="#动态添加-移除" class="headerlink" title="动态添加/移除"></a>动态添加/移除</h3><p>属性集也可以动态的添加和移除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;SpawnedAttributes.<span class="built_in">AddUnique</span>(WeaponAttributeSetPointer);</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">ForceReplication</span>();</span><br><span class="line"></span><br><span class="line">AbilitySystemComponent-&gt;SpawnedAttributes.<span class="built_in">Remove</span>(WeaponAttributeSetPointer);</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">ForceReplication</span>();</span><br></pre></td></tr></table></figure>



<h2 id="预处理-PreAttributeChange"><a href="#预处理-PreAttributeChange" class="headerlink" title="预处理/PreAttributeChange"></a>预处理/PreAttributeChange</h2><p>属性在正在修改之前会到函数<code>PreAttributeChange()</code></p>
<p>这里比较适合对<code>NewValue</code>进行<code>Clamp</code>处理,比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Attribute == <span class="built_in">GetMoveSpeedAttribute</span>())</span><br><span class="line">&#123;</span><br><span class="line">    NewValue = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(NewValue, <span class="number">150</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者我们在这里对修改生命和魔法的最大值做一个处理, 请思考一般Moba或RPG等游戏中最大值修改以后, 当前的值也会按照百分比修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRAttributeSetBase::AdjustAttributeForMaxChange</span><span class="params">(FGameplayAttributeData&amp; AffectedAttribute, <span class="keyword">const</span> FGameplayAttributeData&amp; MaxAttribute, <span class="keyword">float</span> NewMaxValue, <span class="keyword">const</span> FGameplayAttribute&amp; AffectedAttributeProperty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAbilitySystemComponent* AbilityComp = <span class="built_in">GetOwningAbilitySystemComponent</span>();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> CurrentMaxValue = MaxAttribute.<span class="built_in">GetCurrentValue</span>();</span><br><span class="line">	<span class="keyword">if</span> (!FMath::<span class="built_in">IsNearlyEqual</span>(CurrentMaxValue, NewMaxValue) &amp;&amp; AbilityComp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 更改当前值以保持 Cur / Max 的百分比</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">float</span> CurrentValue = AffectedAttribute.<span class="built_in">GetCurrentValue</span>();</span><br><span class="line">		<span class="keyword">float</span> NewDelta = (CurrentMaxValue &gt; <span class="number">0.f</span>) ? (CurrentValue * NewMaxValue / CurrentMaxValue) - CurrentValue : NewMaxValue;</span><br><span class="line"></span><br><span class="line">		AbilityComp-&gt;<span class="built_in">ApplyModToAttributeUnsafe</span>(AffectedAttributeProperty, EGameplayModOp::Additive, NewDelta);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在预处理中执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRAttributeSetBase::PreAttributeChange</span><span class="params">(<span class="keyword">const</span> FGameplayAttribute&amp; Attribute, <span class="keyword">float</span>&amp; NewValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(SRLog, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Attribute Pre Changed old = %s, new= %f&quot;</span>), Attribute.<span class="built_in">GetUProperty</span>(), NewValue);</span><br><span class="line">	Super::<span class="built_in">PreAttributeBaseChange</span>(Attribute, NewValue);</span><br><span class="line">	<span class="keyword">if</span> (Attribute == <span class="built_in">GetMaxManaAttribute</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">AdjustAttributeForMaxChange</span>(Health, MaxHealth, NewValue, <span class="built_in">GetHealthAttribute</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Attribute == <span class="built_in">GetMaxManaAttribute</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">AdjustAttributeForMaxChange</span>(Mana, MaxMana, NewValue, <span class="built_in">GetManaAttribute</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="PostGameplayEffectExecute"><a href="#PostGameplayEffectExecute" class="headerlink" title="PostGameplayEffectExecute"></a>PostGameplayEffectExecute</h2><p><code>PostGameplayEffectExecute()</code>函数会在瞬间执行的<code>GameplayEffect</code>修改到属性的时候执行</p>
<p>这里可以做属性做一些额外的操作,比如对一些临时属性进行处理然后反馈到最终角色上, 我们后面会在这里做对临时的伤害值进行处理后, 修改角色的生命值等操作.</p>
<p>因为还涉及到很多后续的内容, 这里先不展开</p>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayAbilitySystem入门与实战(五):GameplayAbility(二)</title>
    <url>/2020/12/23/GameplayAbilitySystem%E5%88%86%E6%9E%90(%E4%BA%94)_GameplayAbility2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前文已经大概了解了<code>GA</code>的大致内容,本片结合项目来详细使用一下技能.</p>
<p>因为技能可以是通过按键直接触发, 我们在<code>GA</code>中多数是播放动画来表示技能执行的, 所以我们需要一个一个方便我们<code>GA</code>使用的播放动画的节点</p>
<p><code>GAS</code>中有很多已经封装好的异步节点, 很多都是非常有用的,如下图(太多无法截全)</p>
<p><img src="https://img.supervj.top//img/image-20201217142941527.png" alt="image-20201217142941527"></p>
<p>其中有一个<code>PlayMontageAndWait</code>的节点, 可以用这个来播放动画蒙太奇, 然后通过动画通知来开启攻击能力, 攻击者(或者武器)触发攻击事件, 然后触发对应的<code>GE</code>来达到伤害的目的</p>
<a name = "前言">

<p>那么我们重新捋一下, 我们在<code>GA</code>中播放动画, 然后外面的动画通知和检测我们不管, 我们还在<code>GA</code>这里监听某些<code>Tag</code>的事件, 响应以后我们在这里应用<code>GE</code>效果(<code>ActionRPG</code>的思路),这样是不是更简单直观一点</p>
<p>照着这个思路我们来做一下</p>
<span id="more"></span>











<a name = "获取目标">

<h2 id="获取目标"><a href="#获取目标" class="headerlink" title="获取目标"></a>获取目标</h2><p>思考一下, 我们释放技能的时候需要知道目标是谁, 最好需要有<code>HitResult</code>数据方便我们知道打击位置播放特效等效果</p>
<p>那么各类技能或者普通攻击获取这个信息的方式都可能不一样,所以我们就自定义一个类专门来用于获取目标数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(Blueprintable, meta = (ShowWorldContextPin))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SUPERROAD_API</span> <span class="title">USRTargetType</span> :</span> <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="built_in">USRTargetType</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintNativeEvent)</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">GetTargets</span><span class="params">(ASRCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类就专门提供给蓝图重写, 默认不需要实现什么内容</p>
<ul>
<li>TargetingCharacter: 释放技能的角色</li>
<li>TargetingActor: 释放技能的对象, 可能是角色,也可能是武器或者投掷物等</li>
<li>EventData: 即<a href="#FGameplayEventData"><code>FGameplayEventData</code></a>,用于扩展参数</li>
</ul>
<ul>
<li>蓝图重写</li>
</ul>
<p><img src="https://img.supervj.top//img/image-20201218102443161.png" alt="image-20201218102443161"></p>
<p>如上图, 我们做一个最简单的box检测, 把找到的目标返回出去.</p>
<p>至于怎么用, 我们后面将</p>
<a name = "数据结构">

<h2 id="创建新的数据结构"><a href="#创建新的数据结构" class="headerlink" title="创建新的数据结构"></a>创建新的数据结构</h2><p><a href="#%E5%89%8D%E8%A8%80">前言</a>说了, 我们播放动画然后需要收到事件信息, 理论上我们可以如下图这样做</p>
<p><img src="https://img.supervj.top//img/image-20201218102759524.png" alt="image-20201218102759524"></p>
<p>但是这样太笨拙, 而且<code>WaitGameplayEvent</code>返回的参数也不是很方便我们执行<code>GE</code>,所以我们把相关数据结构整合一下然后后面再创建一个新的整合版的异步事件</p>
<h3 id="FSRGameplayEffectContainer"><a href="#FSRGameplayEffectContainer" class="headerlink" title="FSRGameplayEffectContainer"></a>FSRGameplayEffectContainer</h3><p>这个数据会作为<code>TMap</code>的值放到<code>GA</code>的配置中,保存了一个<code>SRTargetType</code>类,即前面讲的<a href="#%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87">获取目标↑</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SUPERROAD_API</span> <span class="title">FSRGameplayEffectContainer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FSRGameplayEffectContainer</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/********** 目标类型*********/</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = GameplayEffectContainer)</span><br><span class="line">		TSubclassOf&lt;USRTargetType&gt; TargetType;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 应用到目标上的GE */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = GameplayEffectContainer)</span><br><span class="line">		TArray&lt;TSubclassOf&lt;UGameplayEffect&gt;&gt; TargetGameplayEffectClasses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<p>然后我们到我们的<code>GA</code>基类<code>SRGameplayAbilityBase</code>中声明变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标签对应的GE信息</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly, Category = GameplayEffects)</span><br><span class="line">	TMap&lt;FGameplayTag, FSRGameplayEffectContainer&gt; EffectContainerMap;</span><br></pre></td></tr></table></figure>





<h3 id="FSRGameplayEffectContainerSpec"><a href="#FSRGameplayEffectContainerSpec" class="headerlink" title="FSRGameplayEffectContainerSpec"></a>FSRGameplayEffectContainerSpec</h3><p>用来处理<code>SRGameplayEffectContainer</code>数据传递的结构体,参考GE和GA等都会有类似的Spec类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 目标数据 */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = GameplayEffectContainer)</span><br><span class="line">	FGameplayAbilityTargetDataHandle TargetData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 应用到目标的GESpec */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = GameplayEffectContainer)</span><br><span class="line">	TArray&lt;FGameplayEffectSpecHandle&gt; TargetGameplayEffectSpecs;</span><br></pre></td></tr></table></figure>

<p>几个函数有必要看一下, 因为后面马上我们会用到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FSRGameplayEffectContainerSpec::HasValidEffects</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> TargetGameplayEffectSpecs.<span class="built_in">Num</span>() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FSRGameplayEffectContainerSpec::HasValidTargets</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> TargetData.<span class="built_in">Num</span>() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSRGameplayEffectContainerSpec::AddTargets</span><span class="params">(<span class="keyword">const</span> TArray&lt;FHitResult&gt;&amp; HitResults, <span class="keyword">const</span> TArray&lt;AActor*&gt;&amp; TargetActors)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> FHitResult&amp; HitResult : HitResults)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//hit类型的目标数据</span></span><br><span class="line">		FGameplayAbilityTargetData_SingleTargetHit* NewData = <span class="keyword">new</span> <span class="built_in">FGameplayAbilityTargetData_SingleTargetHit</span>(HitResult);</span><br><span class="line">		TargetData.<span class="built_in">Add</span>(NewData);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (TargetActors.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//actor数组的目标数据</span></span><br><span class="line">		FGameplayAbilityTargetData_ActorArray* NewData = <span class="keyword">new</span> <span class="built_in">FGameplayAbilityTargetData_ActorArray</span>();</span><br><span class="line">		NewData-&gt;TargetActorArray.<span class="built_in">Append</span>(TargetActors);</span><br><span class="line">		TargetData.<span class="built_in">Add</span>(NewData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h2><p><a href="#%E5%89%8D%E8%A8%80">前言</a>大概提了一下<code>GAS</code>中已经封装了很多继承自<code>AbilityTask</code>的异步事件, 我们找到<code>UAbilityTask_PlayMontageAndWait</code>类, 在此基础上扩展一些参数就可以了</p>
<p>创建类<code>UAbilityTask_PlayMontage : public UAbilityTask</code></p>
<p>申明如下代理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams</span>(FSRPlayMontageWaitEventDlg, FGameplayTag, EventTag, FGameplayEventData, EventData);</span><br></pre></td></tr></table></figure>

<p>这个代理决定我们异步事件回调函数的参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">		FSRPlayMontageWaitEventDlg OnCompleted;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">		FSRPlayMontageWaitEventDlg OnBlendOut;</span><br><span class="line">	<span class="comment">//打断</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">		FSRPlayMontageWaitEventDlg OnInterrupted;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 被执行 CancelAbility */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">		FSRPlayMontageWaitEventDlg OnCancelled;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 触发匹配Tag的Event*/</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">		FSRPlayMontageWaitEventDlg EventReceived;</span><br></pre></td></tr></table></figure>

<p>上面参数用了我们自己的代理, 除了最后一个其余是模仿<code>UAbilityTask_PlayMontageAndWait</code>的</p>
<p>然后一路模仿, 实现关于事件监听和广播</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FDelegateHandle EventHandle;			</span><br><span class="line">EventHandle = ASC-&gt;<span class="built_in">AddGameplayEventTagContainerDelegate</span>(EventTags, FGameplayEventTagMulticastDelegate::FDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;UAbilityTask_PlayMontage::OnGameplayEvent));</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAbilityTask_PlayMontage::OnGameplayEvent</span><span class="params">(FGameplayTag EventTag, <span class="keyword">const</span> FGameplayEventData* Payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ShouldBroadcastAbilityTaskDelegates</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		FGameplayEventData TempData = *Payload;</span><br><span class="line">		TempData.EventTag = EventTag;</span><br><span class="line"></span><br><span class="line">		EventReceived.<span class="built_in">Broadcast</span>(EventTag, TempData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>完成!</p>
<p><img src="https://img.supervj.top//img/image-20201218154751973.png" alt="image-20201218154751973"></p>
<h2 id="封装激活GE事件"><a href="#封装激活GE事件" class="headerlink" title="封装激活GE事件"></a>封装激活GE事件</h2><p>我们测试一下, 我们通过动画通知到角色, 然后角色调用<code>SendGameplayEventToActor</code>后成功走到了我们测试的<code>GA</code></p>
<p><img src="https://img.supervj.top//img/image-20201218110426836.png" alt="image-20201218110426836"></p>
<p><img src="https://img.supervj.top//img/image-20201218110739309.png" alt="image-20201218110739309"></p>
<p>但是蓝图中用这个返回参数来应用<code>GE</code>还是够呛</p>
<p>那么接下来就是封装可以利用这两个返回参数能执行相应<code>GE</code>效果的函数</p>
<hr>
<ul>
<li><code>ApplyEffectContainerSpec</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TArray&lt;FActiveGameplayEffectHandle&gt; <span class="title">USRGameplayAbilityBase::ApplyEffectContainerSpec</span><span class="params">(<span class="keyword">const</span> FSRGameplayEffectContainerSpec&amp; ContainerSpec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TArray&lt;FActiveGameplayEffectHandle&gt; AllEffects;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历GE并应用</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> FGameplayEffectSpecHandle&amp; SpecHandle : ContainerSpec.TargetGameplayEffectSpecs)</span><br><span class="line">	&#123;</span><br><span class="line">		AllEffects.<span class="built_in">Append</span>(<span class="built_in">K2_ApplyGameplayEffectSpecToTarget</span>(SpecHandle, ContainerSpec.TargetData));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> AllEffects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们已经申明了自己的<a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>,通过这个<code>FSRGameplayEffectContainerSpec</code>用<code>K2_ApplyGameplayEffectSpecToTarget</code>执行<code>GE</code>, 那我们还需要一个构建这个<code>Spec</code>参数</p>
<ul>
<li><code>MakeEffectContainerSpecFromContainer</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FSRGameplayEffectContainerSpec <span class="title">USRGameplayAbilityBase::MakeEffectContainerSpecFromContainer</span><span class="params">(<span class="keyword">const</span> FSRGameplayEffectContainer&amp; Container, <span class="keyword">const</span> FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel <span class="comment">/*= -1*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FSRGameplayEffectContainerSpec resultSpec;</span><br><span class="line">	AActor* OwningActor = <span class="built_in">GetOwningActorFromActorInfo</span>();</span><br><span class="line">	ASRCharacterBase* OwningChar = Cast&lt;ASRCharacterBase&gt;(OwningActor);</span><br><span class="line">	USRAbilitySystemComponent* OwningASC = Cast&lt;USRAbilitySystemComponent&gt;(<span class="built_in">GetAbilitySystemComponentFromActorInfo</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (OwningASC)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//TargetType有指定</span></span><br><span class="line">		<span class="keyword">if</span> (Container.TargetType.<span class="built_in">Get</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			TArray&lt;FHitResult&gt; HitResults;</span><br><span class="line">			TArray&lt;AActor*&gt; TargetActors;</span><br><span class="line">			<span class="keyword">const</span> USRTargetType* TargetTypeCDO = Container.TargetType.<span class="built_in">GetDefaultObject</span>();</span><br><span class="line">			AActor* AvatarActor = <span class="built_in">GetAvatarActorFromActorInfo</span>();</span><br><span class="line">			<span class="comment">//获取目标数据</span></span><br><span class="line">			TargetTypeCDO-&gt;<span class="built_in">GetTargets</span>(OwningChar, AvatarActor, EventData, HitResults, TargetActors);</span><br><span class="line">			<span class="comment">//添加目标数据, 此目标会被应用GE</span></span><br><span class="line">			resultSpec.<span class="built_in">AddTargets</span>(HitResults, TargetActors);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//OverrideGameplayLevel = -1</span></span><br><span class="line">		<span class="keyword">if</span> (OverrideGameplayLevel == INDEX_NONE)</span><br><span class="line">		&#123;</span><br><span class="line">			OverrideGameplayLevel = <span class="built_in">GetAbilityLevel</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span>  TSubclassOf&lt;UGameplayEffect&gt;&amp; c : Container.TargetGameplayEffectClasses)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//构建并添加GE到Spec内</span></span><br><span class="line">			resultSpec.TargetGameplayEffectSpecs.<span class="built_in">Add</span>(<span class="built_in">MakeOutgoingGameplayEffectSpec</span>(c, OverrideGameplayLevel));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resultSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法目标是从<code>SRTargetType</code>类得到目标类和<code>Hit</code>数据, 通过<code>FSRGameplayEffectContainerSpec::AddTargets</code>()添加到<code>TargetData</code>数据中</p>
<p>但是这个函数是通过<code>FSRGameplayEffectContainer</code>和<code>EventData</code>创建<code>Spec</code>, 还不是特别的方便</p>
<p>接下来我们补充一个通过<code>Tag</code>来构建<code>Spec</code>的辅助函数</p>
<ul>
<li><code>MakeEffectContainerSpec</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FSRGameplayEffectContainerSpec <span class="title">USRGameplayAbilityBase::MakeEffectContainerSpec</span><span class="params">(FGameplayTag ContainerTag, <span class="keyword">const</span> FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel <span class="comment">/*= -1*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FSRGameplayEffectContainer* FoundContainer = EffectContainerMap.<span class="built_in">Find</span>(ContainerTag);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FoundContainer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">MakeEffectContainerSpecFromContainer</span>(*FoundContainer, EventData, OverrideGameplayLevel);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">FSRGameplayEffectContainerSpec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键就是从我们<code>GA</code>配置的<code>Map</code>变量去找到对应的值, 那这个函数就是我们比较方便使用的</p>
<p>那如果我们希望通过异步事件的返回参数直接应用<code>GE</code>, 我们每次要执行两个函数, 比较麻烦,接下来把两个函数合到一起</p>
<ul>
<li><code>ApplyEffectContainer</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TArray&lt;FActiveGameplayEffectHandle&gt; <span class="title">USRGameplayAbilityBase::ApplyEffectContainer</span><span class="params">(FGameplayTag ContainerTag, <span class="keyword">const</span> FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel <span class="comment">/*= -1*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FSRGameplayEffectContainerSpec Spec = <span class="built_in">MakeEffectContainerSpec</span>(ContainerTag, EventData, OverrideGameplayLevel);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ApplyEffectContainerSpec</span>(Spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们的测试<code>GE</code>就扣一点血,如下图</p>
<p><img src="https://img.supervj.top//img/image-20201218155846401.png" alt="image-20201218155846401"></p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_18_16_00_23_999.gif" alt="录制_2020_12_18_16_00_23_999"></p>
<p>成功应用</p>
<h2 id="补充若干重要的结构体数据"><a href="#补充若干重要的结构体数据" class="headerlink" title="补充若干重要的结构体数据"></a>补充若干重要的结构体数据</h2><a name = "FGameplayEventData">

<h3 id="FGameplayEventData"><a href="#FGameplayEventData" class="headerlink" title="FGameplayEventData"></a>FGameplayEventData</h3><p>传递数据的一个结构体,包含了诸多信息, 也有两个专门针对<code>GA</code>的<code>Tag</code>栏的标记(<code>SourceTag</code>,<code>TargetTag</code>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件tag</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = GameplayAbilityTriggerPayload)</span><br><span class="line">	FGameplayTag EventTag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 发起者 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = GameplayAbilityTriggerPayload)</span><br><span class="line">	<span class="keyword">const</span> AActor* Instigator;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 目标*/</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = GameplayAbilityTriggerPayload)</span><br><span class="line">	<span class="keyword">const</span> AActor* Target;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 扩展类 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = GameplayAbilityTriggerPayload)</span><br><span class="line">	<span class="keyword">const</span> UObject* OptionalObject;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 扩展类2 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = GameplayAbilityTriggerPayload)</span><br><span class="line">	<span class="keyword">const</span> UObject* OptionalObject2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** GE上下文,请参考GE部分 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = GameplayAbilityTriggerPayload)</span><br><span class="line">	FGameplayEffectContextHandle ContextHandle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**发起者的Tag */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = GameplayAbilityTriggerPayload)</span><br><span class="line">	FGameplayTagContainer InstigatorTags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 目标tag */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = GameplayAbilityTriggerPayload)</span><br><span class="line">	FGameplayTagContainer TargetTags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**这个事件的修改参数 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = GameplayAbilityTriggerPayload)</span><br><span class="line">	<span class="keyword">float</span> EventMagnitude;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 目标数据 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = GameplayAbilityTriggerPayload)</span><br><span class="line">	FGameplayAbilityTargetDataHandle TargetData;</span><br></pre></td></tr></table></figure>





<h3 id="目标数据-FGameplayAbilityTargetData"><a href="#目标数据-FGameplayAbilityTargetData" class="headerlink" title="目标数据/FGameplayAbilityTargetData"></a>目标数据/FGameplayAbilityTargetData</h3><p>这是一个基类,仅提供了一些虚函数</p>
<p>目的是传递发起者和目标的基本信息</p>
<h4 id="FGameplayAbilityTargetDataHandle"><a href="#FGameplayAbilityTargetDataHandle" class="headerlink" title="FGameplayAbilityTargetDataHandle"></a>FGameplayAbilityTargetDataHandle</h4><p>处理前者数据的类,一般在传递数据时候使用</p>
<p>保存了<code>FGameplayAbilityTargetData</code>的数组</p>
<h4 id="FGameplayAbilityTargetData-LocationInfo"><a href="#FGameplayAbilityTargetData-LocationInfo" class="headerlink" title="FGameplayAbilityTargetData_LocationInfo"></a>FGameplayAbilityTargetData_LocationInfo</h4><p>继承自<code>FGameplayAbilityTargetData</code>,</p>
<p>保存了发起者和目标的位置信息,用<code>FGameplayAbilityTargetingLocationInfo</code>保存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = Targeting)</span><br><span class="line">	FGameplayAbilityTargetingLocationInfo SourceLocation;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = Targeting)</span><br><span class="line">	FGameplayAbilityTargetingLocationInfo TargetLocation;</span><br></pre></td></tr></table></figure>

<h4 id="FGameplayAbilityTargetData-ActorArray"><a href="#FGameplayAbilityTargetData-ActorArray" class="headerlink" title="FGameplayAbilityTargetData_ActorArray"></a>FGameplayAbilityTargetData_ActorArray</h4><p>继承自<code>FGameplayAbilityTargetData</code>,</p>
<p>保存了发起者和目标数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = Targeting)</span><br><span class="line">	FGameplayAbilityTargetingLocationInfo SourceLocation;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = Targeting)</span><br><span class="line">	TArray&lt;TWeakObjectPtr&lt;AActor&gt; &gt; TargetActorArray;</span><br></pre></td></tr></table></figure>



<h4 id="FGameplayAbilityTargetData-SingleTargetHit"><a href="#FGameplayAbilityTargetData-SingleTargetHit" class="headerlink" title="FGameplayAbilityTargetData_SingleTargetHit"></a>FGameplayAbilityTargetData_SingleTargetHit</h4><p>继承自<code>FGameplayAbilityTargetData</code>,</p>
<p>保存了Hit信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FHitResult	HitResult;</span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="keyword">bool</span> bHitReplaced = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>









<h4 id="FGameplayAbilityTargetingLocationInfo"><a href="#FGameplayAbilityTargetingLocationInfo" class="headerlink" title="FGameplayAbilityTargetingLocationInfo"></a>FGameplayAbilityTargetingLocationInfo</h4><p>用不同的格式保存位置信息</p>
<ul>
<li>位置类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> EGameplayAbilityTargetingLocationType</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">Type</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="comment">/** 提取实际位置信息,这是最后的备选方案 */</span></span><br><span class="line">		<span class="function">LiteralTransform		<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Literal Transform&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">		<span class="comment">/**从相关actor中得到变换信息 */</span></span></span><br><span class="line"><span class="function">		ActorTransform			<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Actor Transform&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">		<span class="comment">/**从骨骼模型中的插槽提取变换信息 */</span></span></span><br><span class="line"><span class="function">		SocketTransform			<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Socket Transform&quot;</span>)</span>,		</span></span><br><span class="line"><span class="function">	&#125;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置类型</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadWrite, meta = (ExposeOnSpawn = <span class="literal">true</span>), Category = Targeting)</span><br><span class="line">	TEnumAsByte&lt;EGameplayAbilityTargetingLocationType::Type&gt; LocationType;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果技能超过了计算范围, 那么会使用这个信息 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, meta = (ExposeOnSpawn = <span class="literal">true</span>), Category = Targeting)</span><br><span class="line">	FTransform LiteralTransform;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 基于actor的目标需要源actor，而基于socket的目标不需要源actor. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, meta = (ExposeOnSpawn = <span class="literal">true</span>), Category = Targeting)</span><br><span class="line">	AActor* SourceActor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**基于插槽的目标需要骨架网格组件来检查指定。 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, meta = (ExposeOnSpawn = <span class="literal">true</span>), Category = Targeting)</span><br><span class="line">	UMeshComponent* SourceComponent;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 使用数据的GA */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, meta = (ExposeOnSpawn = <span class="literal">true</span>), Category = Targeting)</span><br><span class="line">	UGameplayAbility* SourceAbility;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果SourceComponent有效，这是将使用的Socket转换的名称。如果没有提供Socket，将使用SourceComponent的转换。 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, meta = (ExposeOnSpawn = <span class="literal">true</span>), Category = Targeting)</span><br><span class="line">	FName SourceSocketName;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayAbilitySystem入门与实战(八):GameplayCueNotify</title>
    <url>/2020/12/24/GameplayAbilitySystem%E5%88%86%E6%9E%90(%E5%85%AB)_GameplayCue/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>GameplayCueNotify(GCN)</code>用于非逻辑层的效果，如音效,特效,相机震动等</p>
<p><code>CGN</code>有两个基类,如下图</p>
<table>
<thead>
<tr>
<th><code>GameplayCue</code> Class</th>
<th>Event</th>
<th><code>GE</code>类型</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>GameplayCueNotify_Static</code></td>
<td><code>Execute</code></td>
<td><code>Instant</code> or <code>Periodic</code></td>
<td>一般处理一次性触发的效果如打击效果</td>
</tr>
<tr>
<td><code>GameplayCueNotify_Actor</code></td>
<td><code>Add</code> or <code>Remove</code></td>
<td><code>Duration</code> or <code>Infinite</code></td>
<td>此类<code>GC</code>是实例化的，它们可以随着时间进行操作，直到它们被“删除”。当支持的“Duration”或“Infinite”<code>GE</code>被移除或手动调用remove时，这些对于循环声音和粒子效果是很好的。它们还提供了一些选项来管理允许同时“添加”的数量，以便多个应用程序使用相同效果时只启动一次声音或粒子。</td>
</tr>
</tbody></table>
<blockquote>
<p>使用<code>GameplayCueNotify_Actor</code>时注意<code>Auto Destroy on Remove</code>选项,否则后续调用<code>add</code>可能不能正常工作</p>
</blockquote>
<span id="more"></span>

<h2 id="Gameplay-Cue-Manager"><a href="#Gameplay-Cue-Manager" class="headerlink" title="Gameplay Cue Manager"></a>Gameplay Cue Manager</h2><p> <code>GameplayCueManager</code>会扫描指定路径的所有<code>GameplayCueNotifies</code> 然后加入到内存中,默认路径保存在<code>AbilitySystemGlobals</code>中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Look in these paths for GameplayCueNotifies. These are your &quot;always loaded&quot; set. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config)</span><br><span class="line">	TArray&lt;FString&gt;	GameplayCueNotifyPaths;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GameplayCueNotifyPaths.<span class="built_in">Add</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Game&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果需要修改路径可以修改插件内容</p>
<p>这里需要注意,如果是比较大型的游戏, 游戏中会有数量非常庞大的<code>GameplayCueNotifies</code> ,如果游戏启动的时候就加载所有,那么必然造成很多的内存浪费,如果有这个问题, 可以继承<code>GameplayCueManager</code>,然后重写方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ShouldAsyncLoadObjectLibrariesAtStart</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>当然我们必须在此类创建的时候需要如下修改<code>GlobalGameplayCueManagerClass</code>或者<code>GlobalGameplayCueManagerName</code>的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UGameplayCueManager* <span class="title">UAbilitySystemGlobals::GetGameplayCueManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//*******************</span></span><br><span class="line"><span class="comment">// Load specific gameplaycue manager object if specified</span></span><br><span class="line">		<span class="keyword">if</span> (GlobalGameplayCueManagerName.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			GlobalGameplayCueManager = LoadObject&lt;UGameplayCueManager&gt;(<span class="literal">nullptr</span>, *GlobalGameplayCueManagerName.<span class="built_in">ToString</span>(), <span class="literal">nullptr</span>, LOAD_None, <span class="literal">nullptr</span>);</span><br><span class="line">			<span class="keyword">if</span> (GlobalGameplayCueManager == <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ABILITY_LOG</span>(Error, <span class="built_in">TEXT</span>(<span class="string">&quot;Unable to Load GameplayCueManager %s&quot;</span>), *GlobalGameplayCueManagerName.<span class="built_in">ToString</span>() );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Load specific gameplaycue manager class if specified</span></span><br><span class="line">		<span class="keyword">if</span> ( GlobalGameplayCueManager == <span class="literal">nullptr</span> &amp;&amp; GlobalGameplayCueManagerClass.<span class="built_in">IsValid</span>() )</span><br><span class="line">		&#123;</span><br><span class="line">			UClass* GCMClass = LoadClass&lt;UObject&gt;(<span class="literal">NULL</span>, *GlobalGameplayCueManagerClass.<span class="built_in">ToString</span>(), <span class="literal">NULL</span>, LOAD_None, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">if</span> (GCMClass)</span><br><span class="line">			&#123;</span><br><span class="line">				GlobalGameplayCueManager = NewObject&lt;UGameplayCueManager&gt;(<span class="keyword">this</span>, GCMClass, NAME_None);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//*****************</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><code>CGN</code>可以依附与<code>GE</code>    ,在<code>GE</code>的<code>Display</code>选项中添加<code>CGN</code>;</p>
<p><img src="https://img.supervj.top//img/image-20201207174308746.png" alt="image-20201207174308746"></p>
<p>新建<code>static</code>类型的<code>CGN</code></p>
<p>在蓝图类中设置<code>GC</code>对应的<code>Tag</code></p>
<p><img src="https://img.supervj.top//img/image-20201207174456052.png" alt="image-20201207174456052"></p>
<p>编辑器模式下会自动扫描有引用关系的类,这个蛮好用的</p>
<p>如果<code>GE</code>是<code>Instant</code>模式,那么在<code>GCN</code>中会先后调用<code>Handle</code>和<code>Excute</code>事件一次</p>
<p>如果是有持续时间的,那么<code>Handle</code>会调用多次,因为<code>Handle</code>本身就有<code>EventType</code>类型以及其他因素, <code>Excute</code>会在初始调用一次, 如果有<code>Period</code>&gt;0,那么每隔一段时间会执行<code>Handle</code>和<code>Execute</code>一次</p>
<blockquote>
<p>这个<code>GC</code>的各个函数调用有点容易混淆,这里做一次测试</p>
<p>测试<code>GA</code>持续3秒后结束,测试<code>GE</code>的<code>Period</code>设置1秒(非instant)</p>
<p>执行顺序:</p>
<p><code>HE</code>:<code>HandleExcuted</code></p>
<p><code>HOA</code>:<code>HandleOnActive</code></p>
<p><code>HWA</code>:<code>HandleWhileActive</code></p>
<p><code>HR</code>:<code>HandleRemove</code></p>
<p><code>OA</code>:<code>OnActive</code></p>
<p><code>OE</code>:<code>OnExcute</code></p>
<p><code>OR</code>:<code>OnRemove</code></p>
<p><code>WA</code>:<code>WhileActive</code></p>
</blockquote>
<p>测试逻辑大致见下图</p>
<p><img src="https://img.supervj.top//img/image-20201208102303011.png" alt="image-20201208102303011"></p>
<table>
<thead>
<tr>
<th><code>GCN</code>类型</th>
<th>激活方式</th>
<th><code>GE</code>持续性</th>
<th>执行顺序</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>static</code></td>
<td><code>GE</code></td>
<td><code>Instant</code></td>
<td>HE-&gt;OE,</td>
<td>没有调用OR</td>
</tr>
<tr>
<td><code>static</code></td>
<td><code>GE</code></td>
<td><code>Duration=3</code></td>
<td>HOA-&gt;OA-&gt;HOA-&gt;OA-&gt;HWA-&gt;WA-&gt;<code>ActiveAbility继续执行</code>-&gt;HE-&gt;OE……….(HE-&gt;OE)*2….-&gt;<code>EndAbility</code>-&gt;OE-&gt;HE-&gt;HR-&gt;OR-&gt;HR-&gt;OR</td>
<td><code>ActiveAbility</code>执行完以后才调用第一次HE+OE, 最后<code>EndAbility</code>运行以后执行一次OE+HE和两次HR+OR</td>
</tr>
<tr>
<td><code>static</code></td>
<td><code>GE</code></td>
<td><code>Infinite</code></td>
<td>HOA-&gt;OA-&gt;HOA-&gt;OA-&gt;HWA-&gt;WA-&gt;HE-&gt;OE……….(HE-&gt;OE)*n</td>
<td>前两部分同上,没有结束, 手动remove以后同上一致</td>
</tr>
<tr>
<td><code>static</code></td>
<td><code>Add</code></td>
<td>与<code>GE</code>无关</td>
<td>HOA-&gt;OA-&gt;HWA-&gt;WA…..HOR-&gt;OR.</td>
<td>随<code>GA</code>结束而结束,如果提前<code>Remove</code>也正常调用HOR和OR</td>
</tr>
<tr>
<td><code>static</code></td>
<td><code>Excute</code></td>
<td>与<code>GE</code>无关</td>
<td>HE-&gt;OE</td>
<td>没有调用OR,没法<code>Remove</code></td>
</tr>
<tr>
<td><code>Actor</code></td>
<td><code>GE</code></td>
<td><code>Instant</code></td>
<td></td>
<td>与<code>static</code>模式一致</td>
</tr>
<tr>
<td><code>Actor</code></td>
<td><code>GE</code></td>
<td><code>Duration=3</code></td>
<td></td>
<td>与<code>static</code>模式一致</td>
</tr>
<tr>
<td><code>Actor</code></td>
<td><code>GE</code></td>
<td><code>Infinite</code></td>
<td></td>
<td>与<code>static</code>模式一致</td>
</tr>
<tr>
<td><code>Actor</code></td>
<td><code>Add</code>/<code>Execute</code></td>
<td>与<code>GE</code>无关</td>
<td></td>
<td>与<code>static</code>模式一致</td>
</tr>
</tbody></table>
<p>我们可以发现<code>static</code>和<code>actor</code>模式的<code>GCN</code>机制类似, 按照文档说明的, <code>static</code>用<code>Execute</code>以及适合瞬间触发的效果,<code>Actor</code>用<code>Add</code>和<code>Remove</code>的方式用到有持续时间的效果也有一定道理;</p>
<p>一般瞬间的<code>GCN</code>重写<code>Excute</code>方法即可</p>
<p>持续性的看情况重写<code>OnActive</code>和<code>WhileActive</code>以及<code>Remove</code>等</p>
<h2 id="本地GCN"><a href="#本地GCN" class="headerlink" title="本地GCN"></a>本地GCN</h2><p><code>GCN</code>默认都是RPC同步的,那么对于部分的本地效果肯定是没必要的, 我们可以直接调用<code>GameplayCueManager-&gt;HandleGameplayCue()</code>来执行本地<code>GCN</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFlib_VGAS::ExecuteGameplayCueLocal</span><span class="params">(UAbilitySystemComponent* AbilityComponent, <span class="keyword">const</span> FGameplayTag GameplayCueTag, <span class="keyword">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(AbilityComponent-&gt;<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::Executed, GameplayCueParameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFlib_VGAS::AddGameplayCueLocal</span><span class="params">(UAbilitySystemComponent* AbilityComponent, <span class="keyword">const</span> FGameplayTag GameplayCueTag, <span class="keyword">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(AbilityComponent-&gt;<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::OnActive, GameplayCueParameters);</span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(AbilityComponent-&gt;<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::WhileActive, GameplayCueParameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFlib_VGAS::RemoveGameplayCueLocal</span><span class="params">(UAbilitySystemComponent* AbilityComponent, <span class="keyword">const</span> FGameplayTag GameplayCueTag, <span class="keyword">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(AbilityComponent-&gt;<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::Removed, GameplayCueParameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>新建一个静态瞬间的<code>GCN</code>,另外我们在之前的测试<code>GE</code>中加入这个<code>GCN</code>的标签</p>
<p><img src="https://img.supervj.top//img/image-20201226155642603.png" alt="image-20201226155642603"></p>
<p><img src="https://img.supervj.top//img/image-20201226155658792.png" alt="image-20201226155658792"></p>
<ul>
<li>单人测试</li>
</ul>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_26_15_57_23_916.gif" alt="录制_2020_12_26_15_57_23_916"></p>
<ul>
<li>双人测试</li>
</ul>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_26_15_58_26_889.gif" alt="录制_2020_12_26_15_58_26_889"></p>
<hr>
<p>如果在生命回复中加入一个回复效果的<code>GCN</code>效果, 比如下图</p>
<p><img src="https://img.supervj.top//img/image-20201226160731595.png" alt="image-20201226160731595"></p>
<p>那么实测只会在服务端有特效, 这是因为我们<code>StartupEffect</code>这种<code>GE</code>效果是只在服务端应用,我们使用一般的<code>GA</code>来添加<code>GCN</code>效果就可以了</p>
<p><img src="https://img.supervj.top//img/image-20201226160804931.png" alt="image-20201226160804931"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>对于大量<code>RPC</code>任务而言, 可以设置<code>AbilitySystem.AlwaysConvertGESpecToGCParams 1</code>,这将转换<code>GameplayEffectSpecs</code>到<code>FGameplayCueParameter</code>结构和RPC，而不是整个<code>FGameplayEffectSpecForRPC</code>。这节省了带宽，但也有较少的信息</p>
<h3 id="Ability-System-Globals"><a href="#Ability-System-Globals" class="headerlink" title="Ability System Globals"></a>Ability System Globals</h3><p><code>Ability System Globals</code>类保存了<code>GAS</code>系统的多数全局信息</p>
<p>4.24版本之后在程序启动之初需要对数据进行初始化,否则会引起报错甚至奔溃,可以到引擎子系统中初始化或者如<code>ActionRPG</code>中使用自定义的<code>AssetManager</code>类来初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USREngineSubsystem::Initialize</span><span class="params">(FSubsystemCollectionBase&amp; Collection)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Initialize</span>(Collection);</span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">InitGlobalData</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

























]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayAbilitySystem入门与实战(四):GameplayAbility(一)</title>
    <url>/2020/12/22/GameplayAbilitySystem%E5%88%86%E6%9E%90(%E5%9B%9B)_GameplayAbility/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在第一篇<a href="https://supervj.top/2020/12/19/GameplayAbilitySystem%E5%88%86%E6%9E%90(%E4%B8%80)_%E5%88%9D%E5%A7%8B%E5%8C%96/">初始化</a>的时候简单讲解了技能的添加和使用, 但是没有对技能<code>GameplayAbility</code>(<code>GA</code>)做详细介绍,本片开始对<code>GA</code>中的主要功能注意剖析</p>
<h2 id="注册-移除技能"><a href="#注册-移除技能" class="headerlink" title="注册/移除技能"></a>注册/移除技能</h2><p>之前我们通过配置的方式自动注册起始技能, 那么我们肯定需要动态的增加或者删除技能, 为了方便使用, 封装蓝图库</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Server, Reliable, WithValidation, Category = <span class="string">&quot;SR|ASC&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">RPC_Ser_AddAbility</span><span class="params">(TSubclassOf&lt;USRGameplayAbilityBase&gt; AbilityClass, int32 level = <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Server, Reliable, WithValidation, Category = <span class="string">&quot;SR|ASC&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">RPC_Ser_RemoveAbilityByClass</span><span class="params">(TSubclassOf&lt;USRGameplayAbilityBase&gt; AbilityClass)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Server, Reliable, WithValidation, Category = <span class="string">&quot;SR|ASC&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">RPC_Ser_RemoveAbilityByName</span><span class="params">(<span class="keyword">const</span> FString&amp; name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下3个非RPC事件</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;SR|ASC&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">AddNewAbility</span><span class="params">(TSubclassOf&lt;USRGameplayAbilityBase&gt; AbilityClass, int32 level = <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;SR|ASC&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">RemoveAbilityByClass</span><span class="params">(TSubclassOf&lt;USRGameplayAbilityBase&gt; AbilityClass)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;SR|ASC&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">RemoveAbilityByName</span><span class="params">(<span class="keyword">const</span> FString&amp; name)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">USRAbilitySystemComponent::AddNewAbility</span><span class="params">(TSubclassOf&lt;USRGameplayAbilityBase&gt; AbilityClass, int32 level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (AbilitySpecMap.<span class="built_in">Num</span>()&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (TPair&lt;FString, FGameplayAbilitySpec*&gt; p : AbilitySpecMap)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p.Value-&gt;Ability-&gt;<span class="built_in">GetClass</span>() == AbilityClass)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">UE_LOG</span>(SRLog, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;USRAbilitySystemComponent::AddNewAbility Failed!! Has Repeat Ability&quot;</span>));</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FGameplayAbilitySpec spec = <span class="built_in">FGameplayAbilitySpec</span>(AbilityClass, level, <span class="keyword">static_cast</span>&lt;int32&gt;(AbilityClass.<span class="built_in">GetDefaultObject</span>()-&gt;InputID), <span class="built_in">GetOwnerActor</span>());</span><br><span class="line">	<span class="built_in">GiveAbility</span>(spec);</span><br><span class="line">	AbilitySpecMap.<span class="built_in">Add</span>(AbilityClass.<span class="built_in">GetDefaultObject</span>()-&gt;AbilityName, <span class="keyword">this</span>-&gt;<span class="built_in">FindAbilitySpecFromClass</span>(AbilityClass));</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">USRAbilitySystemComponent::RemoveAbilityByClass</span><span class="params">(TSubclassOf&lt;USRGameplayAbilityBase&gt; AbilityClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FGameplayAbilitySpec* spec = <span class="built_in">FindAbilitySpecFromClass</span>(AbilityClass);</span><br><span class="line">	<span class="keyword">if</span> (spec)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">ClearAbility</span>(spec-&gt;Handle);</span><br><span class="line">		<span class="keyword">for</span> (TPair&lt;FString, FGameplayAbilitySpec*&gt; p : AbilitySpecMap)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p.Value-&gt;Ability-&gt;<span class="built_in">GetClass</span>() == AbilityClass)</span><br><span class="line">			&#123;</span><br><span class="line">				AbilitySpecMap.<span class="built_in">Remove</span>(p.Key);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(SRLog, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;USRAbilitySystemComponent::RemoveAbilityByClass Failed!! Do not has this ability&quot;</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>Name</code>版本是我们在<code>GA</code>类中自定义的, 通过<code>TMap&lt;FString, FGameplayAbilitySpec*&gt; AbilitySpecMap</code>保存在我们<code>ASC</code>中</p>
<p><img src="https://img.supervj.top//img/image-20201226141212117.png" alt="image-20201226141212117"></p>
<h2 id="触发技能"><a href="#触发技能" class="headerlink" title="触发技能"></a>触发技能</h2><p>如果是已经用之前按键绑定的技能, 那么按键就会直接触发技能</p>
<p>还有其他几个方法来手动触发技能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Abilities&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryActivateAbilitiesByTag</span><span class="params">(<span class="keyword">const</span> FGameplayTagContainer&amp; GameplayTagContainer, <span class="keyword">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Abilities&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryActivateAbilityByClass</span><span class="params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityToActivate, <span class="keyword">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle AbilityToActivate, <span class="keyword">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TriggerAbilityFromGameplayEvent</span><span class="params">(FGameplayAbilitySpecHandle AbilityToTrigger, FGameplayAbilityActorInfo* ActorInfo, FGameplayTag Tag, <span class="keyword">const</span> FGameplayEventData* Payload, UAbilitySystemComponent&amp; Component)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FGameplayAbilitySpecHandle <span class="title">GiveAbilityAndActivateOnce</span><span class="params">(<span class="keyword">const</span> FGameplayAbilitySpec&amp; AbilitySpec)</span></span>;</span><br></pre></td></tr></table></figure>

<p>到蓝图中就是如下</p>
<p><img src="https://img.supervj.top//img/image-20201218084759424.png" alt="image-20201218084759424"></p>
<p>激活技能的不同方法决定<code>GA</code>中的函数调用,  一般都是执行到<code>ActiveAbility</code>, </p>
<p>如果通过事件的方式触发技能, 即上述中的<code>TriggerAbilityFromGameplayEvent</code>或者蓝图中的<code>SendGameplayEventToActor</code>,那么可以提供一个<code>Payload</code>参数作为扩展参数,这个非常有用</p>
<p>那么在<code>GA</code>中可以重写函数<code>ActivateAbilityFromEvent</code>,前提是不要重写默认的<code>ActivateAbility</code>函数;</p>
<p>通过事件触发的方式还会与后续的<code>tag</code>有关系, 这个后续再讲</p>
<p><img src="https://img.supervj.top//img/image-20201203145317457.png" alt="image-20201203145317457"></p>
<blockquote>
<p> 技能逻辑没有固定规则, 完全可以自己脑洞, 不过千万不要忘记在技能完成以后调用<code>EndAbility</code>来结束技能,否则技能一直结束不了而类似一个被动技能一直存在</p>
</blockquote>
<h3 id="被动技能"><a href="#被动技能" class="headerlink" title="被动技能"></a>被动技能</h3><p>被动技能如果是默认就存在(触发),可以在<code>GA</code>中的<code>OnAvatarSet</code>事件中最判断处理,如果有必要就直接调用<code>TryActivateAbility</code>(我们之前已经申明了一个布尔变量<code>bAutoActive</code>), 然后不要调用<code>EndAbility</code>就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UVGGameplayAbility::OnAvatarSet</span><span class="params">(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">OnAvatarSet</span>(ActorInfo, Spec);</span><br><span class="line">	<span class="keyword">if</span> (bAutoActivate)<span class="comment">//bool变量交给蓝图配置</span></span><br><span class="line">	&#123;</span><br><span class="line">		ActorInfo-&gt;AbilitySystemComponent-&gt;<span class="built_in">TryActivateAbility</span>(Spec.Handle, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭-中断技能"><a href="#关闭-中断技能" class="headerlink" title="关闭/中断技能"></a>关闭/中断技能</h2><p>目前在<code>ASC</code>中有如下几个方法关闭技能,都未暴露给蓝图;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAbility</span><span class="params">(UGameplayAbility* Ability)</span></span>;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAbilityHandle</span><span class="params">(<span class="keyword">const</span> FGameplayAbilitySpecHandle&amp; AbilityHandle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAbilities</span><span class="params">(<span class="keyword">const</span> FGameplayTagContainer* WithTags=<span class="literal">nullptr</span>, <span class="keyword">const</span> FGameplayTagContainer* WithoutTags=<span class="literal">nullptr</span>, UGameplayAbility* Ignore=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAllAbilities</span><span class="params">(UGameplayAbility* Ignore=<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在蓝图中只能在<code>GA</code>中自己调用<code>CancelAbility</code>关闭技能</p>
<p>不过我们可以自己封装蓝图函数库,如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*稍微注意一点,这里的FGameplayTagContainer参数我们使用引用而不是AbilityComponent::CancelAbilities函数中的指针,顺便来个AutoCreateRef都是方便蓝图使用*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFlib_GAS::CancelAbilityWithTag</span><span class="params">(UAbilitySystemComponent* AbilityComponent, <span class="keyword">const</span> FGameplayTagContainer&amp; WithTags, <span class="keyword">const</span> FGameplayTagContainer&amp; WithoutTags, UGameplayAbility* Ignore)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!AbilityComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	AbilityComponent-&gt;<span class="built_in">CancelAbilities</span>(&amp;WithTags, &amp;WithoutTags, Ignore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFlib_GAS::CancelAllAbilities</span><span class="params">(UAbilitySystemComponent* AbilityComponent, UGameplayAbility* Ignore <span class="comment">/*= nullptr*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!AbilityComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	AbilityComponent-&gt;<span class="built_in">CancelAllAbilities</span>(Ignore);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//************************************</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20201203164413337.png" alt="image-20201203164413337"></p>
<blockquote>
<p><code>GASDocumentation</code> 项目文档说 <code>CancelAllAbilities</code>有时候无法正常生效,但是我这边实测可以正常关闭技能</p>
</blockquote>
<h2 id="获取激活的技能"><a href="#获取激活的技能" class="headerlink" title="获取激活的技能"></a>获取激活的技能</h2><p>可以通过方法<code>    void GetActivatableGameplayAbilitySpecsByAllMatchingTags(const FGameplayTagContainer&amp; GameplayTagContainer, TArray &lt; struct FGameplayAbilitySpec* &gt;&amp; MatchingGameplayAbilities, bool bOnlyAbilitiesThatSatisfyTagRequirements = true) const;</code>根据<code>tag</code>获取正在运行的技能</p>
<p>照样可以封装一个蓝图函数库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;VGAS | FunctionLib&quot;</span>, meta = (AutoCreateRefTerm = <span class="string">&quot;GameplayTagContainer, WithTags&quot;</span>))</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetActivatableGameplayAbilitySpecsByAllMatchingTags</span><span class="params">(UAbilitySystemComponent* AbilityComponent, <span class="keyword">const</span> FGameplayTagContainer&amp; GameplayTagContainer, TArray &lt; struct FGameplayAbilitySpec &gt;&amp; MatchingGameplayAbilities, <span class="keyword">bool</span> bOnlyAbilitiesThatSatisfyTagRequirements)</span></span>;</span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFlib_VGAS::GetActivatableGameplayAbilitySpecsByAllMatchingTags</span><span class="params">(UAbilitySystemComponent* AbilityComponent, <span class="keyword">const</span> FGameplayTagContainer&amp; GameplayTagContainer, TArray &lt; struct FGameplayAbilitySpec &gt;&amp; MatchingGameplayAbilities, <span class="keyword">bool</span> bOnlyAbilitiesThatSatisfyTagRequirements)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!AbilityComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	TArray &lt;FGameplayAbilitySpec* &gt; returnAbilities;</span><br><span class="line"></span><br><span class="line">	AbilityComponent-&gt;<span class="built_in">GetActivatableGameplayAbilitySpecsByAllMatchingTags</span>(GameplayTagContainer, returnAbilities, bOnlyAbilitiesThatSatisfyTagRequirements);</span><br><span class="line">	<span class="keyword">for</span> (FGameplayAbilitySpec* i : returnAbilities)</span><br><span class="line">	&#123;</span><br><span class="line">		MatchingGameplayAbilities.<span class="built_in">Add</span>(*i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里还是因为蓝图的原因,传参不能按照原版本传参,需要一个临时变量<code>returnAbilities</code>小小的加工一下</p>
</blockquote>
<p><img src="https://img.supervj.top//img/image-20201203173016089.png" alt="image-20201203173016089"></p>
<a name = "实例化模式">

<h2 id="实例化模式"><a href="#实例化模式" class="headerlink" title="实例化模式"></a>实例化模式</h2><p>技能的实例化模式分为3种,见下表</p>
<table>
<thead>
<tr>
<th><code>Instancing Policy</code></th>
<th>Description</th>
<th>Example of when to use</th>
</tr>
</thead>
<tbody><tr>
<td>Instanced Per Actor</td>
<td>每个<code>ASC</code>只会生成一个实例,每次触发<code>GA</code>时服用实例对象</td>
<td>这个是最常用的方式</td>
</tr>
<tr>
<td>Instanced Per Execution</td>
<td>每次<code>GA</code>激活都会产生一个实例</td>
<td>这个方式不太常用,但是可以每个技能都独立作用</td>
</tr>
<tr>
<td>Non-Instanced</td>
<td><code>GA</code>自己默认Obj来维护自身,不会生成实例</td>
<td>这是三种方法中性能最好的，但是在使用的时候是最受限制的。<code>非实例化</code>的<code>GameplayAbilities</code>不能存储状态，这意味着没有动态变量，也没有绑定到<code>AbilityTask</code>委托。在MOBA或RTS中，最适合使用它们的是那些经常使用的简单技能，比如仆从基本攻击或者角色的<code>Jump</code></td>
</tr>
</tbody></table>
<h2 id="网络方案"><a href="#网络方案" class="headerlink" title="网络方案"></a>网络方案</h2><p><img src="https://img.supervj.top//img/image-20201204152923024.png" alt="image-20201204152923024"></p>
<table>
<thead>
<tr>
<th><code>Net Execution Policy</code></th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Local Only</code></td>
<td>只运行在本地客户端,这个比较适合在只表现本地效果的技能,单人游戏中需要使用<code>Server Only</code></td>
</tr>
<tr>
<td><code>Local Predicted</code></td>
<td>先本地运行, 服务端会校准本地客户端错误的内容</td>
</tr>
<tr>
<td><code>Server Only</code></td>
<td>只在服务端运行, 本地技能适合运行在服务端,单人游戏也适合用此</td>
</tr>
<tr>
<td><code>Server Initiated</code></td>
<td>服务端先运行然后再运行在客户端,不常用</td>
</tr>
</tbody></table>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><code>GA</code>的标签非常重要而且使用,包含如下标签</p>
<table>
<thead>
<tr>
<th><code>GameplayTag Container</code></th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Ability Tags</code></td>
<td>当前技能拥有的标签, 也是通过<code>tag</code>来激活技能的凭证</td>
</tr>
<tr>
<td><code>Cancel Abilities with Tag</code></td>
<td>当前技能会关闭的拥有此类<code>tag</code>的正在运行技能</td>
</tr>
<tr>
<td><code>Block Abilities with Tag</code></td>
<td>运行技能的会阻挡拥有此类<code>tag</code>的技能(并不会返回失败)</td>
</tr>
<tr>
<td><code>Activation Owned Tags</code></td>
<td>此技能会激活的<code>tag</code></td>
</tr>
<tr>
<td><code>Activation Required Tags</code></td>
<td>激活技能所需要包含的<code>tag</code></td>
</tr>
<tr>
<td><code>Activation Blocked Tags</code></td>
<td>当拥有此类<code>tag</code>的技能正在运行时,该技能会被阻挡(并不会返回失败)</td>
</tr>
<tr>
<td><code>Source Required Tags</code></td>
<td>此标签包括如下共4个标签内,都是通过<code>ByEvent</code>的方式作用才有效; 此标签在输入的时候必须包含才能运行</td>
</tr>
<tr>
<td><code>Source Blocked Tags</code></td>
<td>同理会被阻挡的标签</td>
</tr>
<tr>
<td><code>Target Required Tags</code></td>
<td>同理目标必须包含的<code>tag</code></td>
</tr>
<tr>
<td><code>Target Blocked Tags</code></td>
<td>同理目标如果包含会被阻挡的<code>tag</code></td>
</tr>
</tbody></table>
<p><img src="https://img.supervj.top//img/image-20201204170040609.png" alt="image-20201204170040609"></p>
<h2 id="Gameplay-Ability-Spec"><a href="#Gameplay-Ability-Spec" class="headerlink" title="Gameplay Ability Spec"></a>Gameplay Ability Spec</h2><p><code>Gameplay Ability Spec</code>在<code>GA</code>正确激活后会创建, 内部提供了诸多<code>GA</code>中的数据如 <code>class</code>,<code>level</code>,<code>input bindings</code>等</p>
<p>如果<code>GA</code>在服务端创建, 会同步到客户端</p>
<p><code>Gameplay Ability Spec</code>创建实例规则请参考<a href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%BC%8F">实例化模式 ↑</a></p>
<h2 id="GA的传递数据"><a href="#GA的传递数据" class="headerlink" title="GA的传递数据"></a>GA的传递数据</h2><p><code>GA</code>传递外部数据有如下几种方式</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Activate <code>GameplayAbility</code> by Event</td>
<td>通过此方法激活技能会有一个<code>Payload</code>参数, 可以用来传递诸多参数;如两个<code>UObject</code>参数更加方便扩展自定义数据</td>
</tr>
<tr>
<td>Use <code>WaitGameplayEvent</code> <code>AbilityTask</code></td>
<td>用这个方法可以监听其他<code>tag</code>技能的状态,以此类得到<code>payload</code>数据</td>
</tr>
<tr>
<td>Use <code>TargetData</code></td>
<td>用结构体 <code>TargetData</code> 传递数据是一个办法,具体以后补充</td>
</tr>
<tr>
<td>Store Data on the <code>OwnerActor</code> or <code>AvatarActor</code></td>
<td>把数据存到<code>GA</code>的<code>OwnerActor</code>或者角色中,但是你需要确保网络同步</td>
</tr>
</tbody></table>
<p><img src="https://img.supervj.top//img/image-20201204171513695.png" alt="image-20201204171513695"></p>
<h2 id="技能消耗-冷却"><a href="#技能消耗-冷却" class="headerlink" title="技能消耗/冷却"></a>技能消耗/冷却</h2><p>技能的消耗和冷却通过<code>GameplayEffect</code>实现, 详情可以查看<a href="https://supervj.top/2020/12/23/GameplayAbilitySystem%E5%88%86%E6%9E%90(%E5%85%AD)_GameplayEffect1/">GameplayEffect篇</a></p>
<h2 id="技能升级"><a href="#技能升级" class="headerlink" title="技能升级"></a>技能升级</h2><table>
<thead>
<tr>
<th>Level Up Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Ungrant and Regrant at the New Level</td>
<td>移除<code>GA</code>,重新注册一个等级不一样的<code>GA</code>,此方式会终止<code>GA</code></td>
</tr>
<tr>
<td>Increase the <code>GameplayAbilitySpec&#39;s</code> Level</td>
<td>对<code>spec</code>中的<code>level</code>进行升级处理,这种方式不会终止<code>GA</code></td>
</tr>
</tbody></table>
<p>蓝图中无法得到<code>GA</code>中的<code>Level</code>变量, 所以无论是对<code>GA</code>的<code>Level</code>进行处理还是<code>GE</code>都需要在cpp中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USRAbilitySystemComponent::UpgradeAbilityByName</span><span class="params">(<span class="keyword">const</span> FString&amp; name, int32 upLevel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (AbilitySpecMap.<span class="built_in">Contains</span>(name))</span><br><span class="line">	&#123;</span><br><span class="line">		FGameplayAbilitySpec* spec = *AbilitySpecMap.<span class="built_in">Find</span>(name);</span><br><span class="line">		spec-&gt;Level += upLevel;</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">MarkAbilitySpecDirty</span>(*spec);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为添加的时候已经存放了<code>TMap&lt;FString, FGameplayAbilitySpec*&gt; AbilitySpecMap</code>, 直接对其进行操作即可, 按照<code>GAS</code>注释说明需要调用<code>MarkAbilitySpecDirty()</code></p>
<h2 id="网络规则"><a href="#网络规则" class="headerlink" title="网络规则"></a>网络规则</h2><table>
<thead>
<tr>
<th><code>NetSecurityPolicy</code></th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ClientOrServer</code></td>
<td>无要求,客户端和服务器都可以自由触发</td>
</tr>
<tr>
<td><code>ServerOnlyExecution</code></td>
<td>客户端请求执行将被服务器忽略。客户端仍然可以请求服务器取消或终止此功能。</td>
</tr>
<tr>
<td><code>ServerOnlyTermination</code></td>
<td>客户端可以请求执行, 但是不能请求终止或者取消</td>
</tr>
<tr>
<td><code>ServerOnly</code></td>
<td>只有服务端有权执行,客户端无法执行任何操作</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayAbilitySystem入门与实战(六):GameplayEffect(一)</title>
    <url>/2020/12/24/GameplayAbilitySystem%E5%88%86%E6%9E%90(%E5%85%AD)_GameplayEffect1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>GameplayEffect</code>在<code>GAS</code>框架中的重要性不言而喻, 内容非常多,,但是本身基本上只作为一个数据载体而存在,蓝图中也无法重写和执行任何事件.</p>
<p> 本篇梳理一下<code>GE</code>的常用属性和基本概念, 实战部分我们在下一篇展开</p>
<h2 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h2><p><code>GE</code>是属性修改的容器, 分为如下几个类型</p>
<table>
<thead>
<tr>
<th>Duration Type</th>
<th>GameplayCue Event</th>
<th>When to use</th>
</tr>
</thead>
<tbody><tr>
<td><code>Instant</code></td>
<td>Execute</td>
<td>对<code>BaseValue</code>的立即生效的处理,<code>GameplayTags</code> 不会被应用到, 即使在一帧之内</td>
</tr>
<tr>
<td><code>Duration</code></td>
<td>Add &amp; Remove</td>
<td>对<code>CurrentValue</code>持续修改.可以应用<code>GameplayTags</code>.持续事件在GE类中指定</td>
</tr>
<tr>
<td><code>Infinite</code></td>
<td>Add &amp; Remove</td>
<td>类似<code>Duration</code>,但是是永久的直到手动移除(如通过ASC)</td>
</tr>
</tbody></table>
<p><code>Duration</code>和<code>Infinite</code>模式会出现<code>Period</code>选项</p>
<p><img src="https://img.supervj.top//img/image-20201201143832164.png" alt="image-20201201143832164"></p>
<p>如果<code>ExecutePeriodicEffectOnApplication</code>=true,那么每隔<code>Period</code>秒就执行</p>
<p><code>periodic inhibition policy</code>刷新策略,如是否覆盖</p>
<p>如果<code>Tag</code>匹配或者不匹配, GE可以临时性的关闭或者开启,这移除操作不会移除GE,只是临时的移除GE的修改效果</p>
<p>如果要手动的直接应用GE的修改, 可以调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UAbilitySystemComponent::ActiveGameplayEffects.<span class="built_in">SetActiveGameplayEffectLevel</span>(FActiveGameplayEffectHandle ActiveHandle, int32 NewLevel)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>GE</code>的属性设置一般建议在编辑器用蓝图编辑, 理论上可以用<code>cpp</code>设定参数, 但是不直观也比较麻烦</p>
</blockquote>
<hr>
<span id="more"></span>





<h2 id="一些重要的数据结构"><a href="#一些重要的数据结构" class="headerlink" title="一些重要的数据结构"></a>一些重要的数据结构</h2><h3 id="FGameplayEffectContext"><a href="#FGameplayEffectContext" class="headerlink" title="FGameplayEffectContext"></a>FGameplayEffectContext</h3><p>保存了<code>GE</code>相关的所有数据, 用于在<code>GE</code>执行的过程中传递重要信息</p>
<p>可以继承他用来扩展参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发起者,即拥有ASC的actor, 本项目是ASRCharacterBase类</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TWeakObjectPtr&lt;AActor&gt; Instigator;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 应用GE的类, 可以是武器或者子弹 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TWeakObjectPtr&lt;AActor&gt; EffectCauser;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 响应GE的默认GA对象 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TWeakObjectPtr&lt;UGameplayAbility&gt; AbilityCDO;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 响应GE的GA实例化对象 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(NotReplicated)</span><br><span class="line">	TWeakObjectPtr&lt;UGameplayAbility&gt; AbilityInstanceNotReplicated;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 技能等级 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	int32 AbilityLevel;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 创建这个GE的对象, 可以是Actor或者其他对象 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TWeakObjectPtr&lt;UObject&gt; SourceObject;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**与发起者绑定的ASC */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(NotReplicated)</span><br><span class="line">	TWeakObjectPtr&lt;UAbilitySystemComponent&gt; InstigatorAbilitySystemComponent;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 引用的Actor */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TArray&lt;TWeakObjectPtr&lt;AActor&gt;&gt; Actors;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 射线数据 */</span></span><br><span class="line">	TSharedPtr&lt;FHitResult&gt;	HitResult;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**原始坐标 ,如果bHasWorldOrigin为否则为空*/</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FVector	WorldOrigin;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	uint8 bHasWorldOrigin:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** SourceObject是否能同步, 这个布尔本身不同步 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	uint8 bReplicateSourceObject:<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="FGameplayEffectContextHandle"><a href="#FGameplayEffectContextHandle" class="headerlink" title="FGameplayEffectContextHandle"></a>FGameplayEffectContextHandle</h3><p>用来处理<code>FGameplayEffectContext</code>的数据,只保存了一个变量<code>TSharedPtr&lt;FGameplayEffectContext&gt; Data;</code></p>
<p>可以直接用<code>FGameplayEffectContext</code>构造以及赋值, 以及可以通过此数据结构获取和修改<code>FGameplayEffectContext</code>中的大多数数据</p>
<h3 id="GameplayEffectSpec"><a href="#GameplayEffectSpec" class="headerlink" title="GameplayEffectSpec"></a>GameplayEffectSpec</h3><ul>
<li><code>GameplayEffectSpec</code> 是 <code>GameplayEffect</code> 创建的,可以通过方法<code>MakeOutgoingSpec()</code>创建</li>
<li><code>GameplayEffectSpecs</code> 被成功创建后返回一个结构体<code>FActiveGameplayEffect</code>.</li>
<li><code>GameplayEffectSpec</code>的级别 通常与创建“GameplayEffectSpec”的<code>GA</code>级别相同，但可以有所不同</li>
<li><code>GameplayEffectSpec</code>的持续时间一般与<code>GE</code>相同,但是可以不同</li>
<li>同样的 <code>GameplayEffectSpec</code> 的周期一般与<code>GE</code>相同但是也可以不同</li>
<li><code>GameplayEffectSpec</code>的堆栈数量限制来自于<code>GE</code></li>
<li><code>GameplayEffectContextHandle</code> 告诉我们谁创建了 <code>GameplayEffectSpec</code>.</li>
<li><code>Attributes</code> 在 <code>GameplayEffectSpec</code>创建时就已经捕获了</li>
<li>除了<code>GE</code>授予的<code>GameplayTags</code>之外，<code>GameplayEffectSpec</code>授予目标的<code>DynamicGrantedTags</code>。</li>
<li><code>GE</code>拥有的<code>AssetTags</code>会被添加到 <code>GameplayEffectSpec</code> 的<code>DynamicAssetTags</code> </li>
<li><code>SetByCaller</code> <code>TMaps</code>.</li>
</ul>
<h3 id="FGameplayEffectAttributeCaptureDefinition"><a href="#FGameplayEffectAttributeCaptureDefinition" class="headerlink" title="FGameplayEffectAttributeCaptureDefinition"></a>FGameplayEffectAttributeCaptureDefinition</h3><p>这是一个定义捕获数据的结构体</p>
<p>也就是我们蓝图中在<code>GEEC</code>中可以看到的几个属性, 其中在类<code>UGameplayEffectCalculation</code>中申明了<code>TArray&lt;FGameplayEffectAttributeCaptureDefinition&gt; RelevantAttributesToCapture;</code> 在派生类<code>UGameplayEffectExecutionCalculation</code>中申明了<code>TArray&lt;FGameplayEffectAttributeCaptureDefinition&gt; InvalidScopedModifierAttributes;</code></p>
<h3 id="FGameplayEffectCustomExecutionParameters"><a href="#FGameplayEffectCustomExecutionParameters" class="headerlink" title="FGameplayEffectCustomExecutionParameters"></a>FGameplayEffectCustomExecutionParameters</h3><p><code>GEEC</code>的输入参数</p>
<p>成员变量基本都是私有的, 了解几个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> FGameplayEffectSpec&amp; <span class="title">GetOwningSpec</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">GetTargetAbilitySystemComponent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">GetSourceAbilitySystemComponent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面几个比较简单, 字面意思</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AttemptCalculateCapturedAttributeMagnitude</span><span class="params">(<span class="keyword">const</span> FGameplayEffectAttributeCaptureDefinition&amp; InCaptureDef, <span class="keyword">const</span> FAggregatorEvaluateParameters&amp; InEvalParams, OUT <span class="keyword">float</span>&amp; OutMagnitude)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法比较有用, 函数翻译过来是<code>尝试计算捕获属性量级</code>, 其实简单使用的话可以理解为<strong>把Def转换成浮点值</strong></p>
<p>这里也用到了<a href="#FAggregatorEvaluateParameters%60">FAggregatorEvaluateParameters</a></p>
<a name = "FAggregatorEvaluateParameters">

<h3 id="FAggregatorEvaluateParameters"><a href="#FAggregatorEvaluateParameters" class="headerlink" title="FAggregatorEvaluateParameters"></a>FAggregatorEvaluateParameters</h3><p>寄存器计算时用于传递参数的结构体, 参数不多</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GAMEPLAYABILITIES_API</span> <span class="title">FAggregatorEvaluateParameters</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">FAggregatorEvaluateParameters</span>()</span><br><span class="line">		: <span class="built_in">SourceTags</span>(<span class="literal">nullptr</span>)</span><br><span class="line">		, <span class="built_in">TargetTags</span>(<span class="literal">nullptr</span>)</span><br><span class="line">		, <span class="built_in">IncludePredictiveMods</span>(<span class="literal">false</span>) </span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> FGameplayTagContainer* SourceTags;</span><br><span class="line">	<span class="keyword">const</span> FGameplayTagContainer* TargetTags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Any mods with one of these handles will be ignored during evaluation */</span></span><br><span class="line">	TArray&lt;FActiveGameplayEffectHandle&gt; IgnoreHandles;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** If any tags are specified in the filter, a mod&#x27;s owning active gameplay effect&#x27;s source tags must match ALL of them in order for the mod to count during evaluation */</span></span><br><span class="line">	FGameplayTagContainer AppliedSourceTagFilter;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** If any tags are specified in the filter, a mod&#x27;s owning active gameplay effect&#x27;s target tags must match ALL of them in order for the mod to count during evaluation */</span></span><br><span class="line">	FGameplayTagContainer AppliedTargetTagFilter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> IncludePredictiveMods;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><img src="https://img.supervj.top//img/image-20201201150412944.png" alt="image-20201201150412944">可以简单的用上述方法在GAS中应用GE</p>
<p>如果想监听来自<code>ASC</code>的持续的GE效果,可以用如下方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;OnActiveGameplayEffectAddedDelegateToSelf.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;AVGCharacterBase::OnActiveGameplayEffectAddedCallback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnActiveGameplayEffectAddedCallback</span><span class="params">(UAbilitySystemComponent* Target, <span class="keyword">const</span> FGameplayEffectSpec&amp; SpecApplied, FActiveGameplayEffectHandle ActiveHandle)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<p>同样的可以通过各种方法移除,如</p>
<p><img src="https://img.supervj.top//img/image-20201201151513828.png" alt="image-20201201151513828"></p>
<p>通过如下方式监听移除事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">OnAnyGameplayEffectRemovedDelegate</span>().<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;APACharacterBase::OnRemoveGameplayEffectCallback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRemoveGameplayEffectCallback</span><span class="params">(<span class="keyword">const</span> FActiveGameplayEffect&amp; EffectRemoved)</span></span>;</span><br></pre></td></tr></table></figure>



<hr>
<ul>
<li>cpp的方式应用GE</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始效果,用来初始化属性</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;VGAS | Abilities&quot;</span>)</span><br><span class="line">		TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">UGameplayEffect</span>&gt;</span> DefaultAttributeEffect;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FGameplayEffectContextHandle EffectContextHandle = AbilitySystemComponent-&gt;<span class="built_in">MakeEffectContext</span>();</span><br><span class="line">EffectContextHandle.<span class="built_in">AddSourceObject</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">FGameplayEffectSpecHandle SpecHandle = AbilitySystemComponent-&gt;<span class="built_in">MakeOutgoingSpec</span>(DefaultAttributeEffect, <span class="built_in">GetCharacterLevel</span>(), EffectContextHandle);</span><br><span class="line"><span class="keyword">if</span> (SpecHandle.<span class="built_in">IsValid</span>())</span><br><span class="line">&#123;</span><br><span class="line">	FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent-&gt;<span class="built_in">ApplyGameplayEffectSpecToTarget</span>(*SpecHandle.Data.<span class="built_in">Get</span>(), AbilitySystemComponent.<span class="built_in">Get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p><img src="https://img.supervj.top//img/image-20201201151641620.png" alt="image-20201201151641620"></p>
<p>如上图分为 <strong>加/乘/除/覆盖</strong> 4个方式</p>
<ul>
<li>修改模式</li>
</ul>
<table>
<thead>
<tr>
<th><code>Modifier</code> Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Scalable Float</code></td>
<td><code>FScalableFloats</code> 一般可以用一个常量来定义,当然也可以用<code>CurveTable</code>来定义<img src="https://github.com/tranek/GASDocumentation/raw/master/Images/scalablefloats.png" alt="ScalableFloat"></td>
</tr>
<tr>
<td><code>Attribute Based</code></td>
<td>基于一个属性的修改</td>
</tr>
<tr>
<td><code>Custom Calculation Class</code></td>
<td>通过一个类自定义修改,一般需要在cpp中操作,蓝图无法展开结构体</td>
</tr>
<tr>
<td><code>Set By Caller</code></td>
<td><code>SetByCaller</code> 一般在外部需要实时修改值的时候用,比如玩家按键时间决定此GE参数大小的情况下</td>
</tr>
</tbody></table>
<p>乘除方式会用如下方式计算,可以理解为都基于<em>1</em>计算,而非比较容易理解的叠加在一起</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + (Mod1.Magnitude - <span class="number">1</span>) + (Mod2.Magnitude - <span class="number">1</span>) + ...</span><br></pre></td></tr></table></figure>

<p>比如如果有2个乘法计算,参数都是1.5,那么得到的结果并不是<code>value*1.5*1.5</code>,而是<code>value*1*(0.5+0.5)</code></p>
<p>这里会有几个问题存在(每个系统都有各自的计算方法)</p>
<ul>
<li>Multipliers:0.5<ul>
<li>1+(0.5-1)=0.5; 正确</li>
</ul>
</li>
<li>Multipliers:0.5,0.5<ul>
<li>1 + (0.5 - 1) + (0.5 - 1) = 0; 错误</li>
</ul>
</li>
</ul>
<p>这里的问题在<code>Paragon</code>中是通过设计方面解决的,即在设计的时候就使用最多只有一个小于1的乘数</p>
<p>源码计算的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> Multiplicitive = <span class="built_in">SumMods</span>(Mods[EGameplayModOp::Multiplicitive], GameplayEffectUtilities::<span class="built_in">GetModifierBiasByModifierOp</span>(EGameplayModOp::Multiplicitive), Parameters);</span><br><span class="line"><span class="comment">//******************************</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">FAggregatorModChannel::SumMods</span><span class="params">(<span class="keyword">const</span> TArray&lt;FAggregatorMod&gt;&amp; InMods, <span class="keyword">float</span> Bias, <span class="keyword">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> Sum = Bias;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> FAggregatorMod&amp; Mod : InMods)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Mod.<span class="built_in">Qualifies</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			Sum += (Mod.EvaluatedMagnitude - Bias); <span class="comment">//乘法的系数是通过加法</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果要修改算法</p>
<p>那么需要修改引擎代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">FAggregatorModChannel::EvaluateWithBase</span><span class="params">(<span class="keyword">float</span> InlineBaseValue, <span class="keyword">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">float</span> Multiplicitive = <span class="built_in">MultiplyMods</span>(Mods[EGameplayModOp::Multiplicitive], Parameters);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ((InlineBaseValue + Additive) * Multiplicitive) / Division;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">FAggregatorModChannel::MultiplyMods</span><span class="params">(<span class="keyword">const</span> TArray&lt;FAggregatorMod&gt;&amp; InMods, <span class="keyword">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> Multiplier = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> FAggregatorMod&amp; Mod : InMods)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Mod.<span class="built_in">Qualifies</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			Multiplier *= Mod.EvaluatedMagnitude;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Multiplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注:  <code>MultiplyModes</code> 函数原本是没有的</p>
</blockquote>
<h3 id="修改相关标签"><a href="#修改相关标签" class="headerlink" title="修改相关标签"></a>修改相关标签</h3><p><code>SourceTags</code> 和<code>TargetTags</code>的运行机制跟<code>GA</code>类似, 如果是有持续时间的<code>GE</code>只会在第一次运行的时候执行<code>Tag</code>操作</p>
<p><code>AttributeBase</code>模式会有2个<code>TagFilter</code>过滤变量</p>
<h2 id="叠加-堆"><a href="#叠加-堆" class="headerlink" title="叠加/堆"></a>叠加/堆</h2><p>每一个GE会实例化一个<code>GameplayEffectsSpec</code>对象,无论之前是否已经存在</p>
<p>从GE对象可以得到当前堆的数量</p>
<p>堆类型有两种</p>
<table>
<thead>
<tr>
<th>Stacking Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Aggregate by Source</td>
<td>目标上的每个源“ASC”都有一个单独的实例。每个源可以应用X数量的堆</td>
</tr>
<tr>
<td>Aggregate by Target</td>
<td>无论源是什么，目标上只有一个堆实例。每个源都可以将堆应用到共享堆限制</td>
</tr>
</tbody></table>
<p><img src="https://img.supervj.top//img/image-20201202092332123.png" alt="image-20201202092332123"></p>
<h2 id="授予技能-Grant-Abilities"><a href="#授予技能-Grant-Abilities" class="headerlink" title="授予技能/Grant Abilities"></a>授予技能/Grant Abilities</h2><p><code>GE</code>可以给<code>ASC</code>新的技能</p>
<p><img src="https://img.supervj.top//img/image-20201202092736123.png" alt="image-20201202092736123"></p>
<table>
<thead>
<tr>
<th>Removal Policy</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Cancel Ability Immediately</td>
<td>当赋予该<code>GA</code>的<code>GE</code>从目标上移除时，该<code>GA</code>会立即被取消和移除</td>
</tr>
<tr>
<td>Remove Ability on End</td>
<td>被授予的<code>GA</code>被允许完成，然后从目标上移除。</td>
</tr>
<tr>
<td>Do Nothing</td>
<td>授予的<code>GA</code>不受从目标上移除<code>GE</code>的影响。目标具有永久的能力，直到后来被手动删除。</td>
</tr>
</tbody></table>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><table>
<thead>
<tr>
<th>Category</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Gameplay Effect Asset Tags</td>
<td><code>GameplayEffect</code> 它们自己不做任何功能，只用于描述<code>GE</code></td>
</tr>
<tr>
<td>Granted Tags</td>
<td>此类标签伴随着<code>GE</code>的生命周期,同时也会添加到<code>ASC</code>中;在<code>GE</code>移除以后也会移除;只在有持续时间的<code>GE</code>中生效</td>
</tr>
<tr>
<td>Ongoing Tag Requirements</td>
<td>此类标签会将<code>GE</code>暂时性的开/关,只作用于有持续时间的<code>GE</code>,<br />举个例子: 一个<code>GE</code>来模拟一个5秒的恢复效果, 那么在此标签给与一个<code>Tag</code>, 其他无论是<code>GE</code>还是<code>GA</code>添加了这个<code>Tag</code>后这个恢复就触发了</td>
</tr>
<tr>
<td>Application Tag Requirements</td>
<td>跟目标相关的标签,如果不符合就不能作用到目标</td>
</tr>
<tr>
<td>Remove Gameplay Effects with Tags</td>
<td>如果目标<code>GE</code>拥有此类标签,那么在<code>GE</code>生效后会移除这些标签的<code>GE</code></td>
</tr>
</tbody></table>
<h2 id="免疫-减免"><a href="#免疫-减免" class="headerlink" title="免疫/减免"></a>免疫/减免</h2><p><img src="https://img.supervj.top//img/image-20201202094459865.png" alt="image-20201202094459865"></p>
<p>可以通过代理<code>FImmunityBlockGE OnImmunityBlockGameplayEffectDelegate</code>来监听免疫能力的改变</p>
<h2 id="SetByCaller"><a href="#SetByCaller" class="headerlink" title="SetByCaller"></a>SetByCaller</h2><p>在<code>Modifiers</code>中,必须提前在<code>GE</code>中定义好,只能使用<code>GameplayTag</code>版本,如果<code>GE</code>定义后<code>GameplaySpec</code>没有拥有正确的tag,那么会报错</p>
<p>如果在其他地方,那么不需要提前定义</p>
<p>关于<code>SetByCaller</code>相关方法,在蓝图中可以用如下</p>
<p><img src="https://img.supervj.top//img/image-20201202102139353.png" alt="image-20201202102139353"></p>
<p> 在cpp中可以用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGameplayEffectSpec::SetSetByCallerMagnitude</span><span class="params">(FName DataName, <span class="keyword">float</span> Magnitude)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGameplayEffectSpec::SetSetByCallerMagnitude</span><span class="params">(FGameplayTag DataTag, <span class="keyword">float</span> Magnitude)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetSetByCallerMagnitude</span><span class="params">(FName DataName, <span class="keyword">bool</span> WarnIfNotFound = <span class="literal">true</span>, <span class="keyword">float</span> DefaultIfNotFound = <span class="number">0.f</span>)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetSetByCallerMagnitude</span><span class="params">(FGameplayTag DataTag, <span class="keyword">bool</span> WarnIfNotFound = <span class="literal">true</span>, <span class="keyword">float</span> DefaultIfNotFound = <span class="number">0.f</span>)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="Modifier-Magnitude-Calculation"><a href="#Modifier-Magnitude-Calculation" class="headerlink" title="Modifier Magnitude Calculation"></a>Modifier Magnitude Calculation</h2><p><code>Modifier Magnitude Calculation</code>与<code>GameplayEffectExecutionCalculations</code>有点类似,但是没有后者功能强大但是更重要</p>
<p><code>MMC</code>的唯一目的就是通过方法<code>CalculateBaseMagnitude</code>返回一个浮点值</p>
<p><img src="https://img.supervj.top//img/image-20201202103436539.png" alt="image-20201202103436539"></p>
<p><code>MMC</code>可以在任意的<code>GE</code>中使用</p>
<p><code>MMC</code>可以捕获任意的不管是<code>Source</code>还是<code>Target</code>的属性,并且完全访问<code>GameplayEffectSpec</code>对象来获取<code>GameplayTags</code>和<code>SetByCaller</code></p>
<p><img src="https://img.supervj.top//img/image-20201202104135362.png" alt="image-20201202104135362"></p>
<p><code>Snapshot</code>的属性会在<code>GE</code>创建的时候被捕获,反之在应用时被捕获</p>
<table>
<thead>
<tr>
<th>Snapshot</th>
<th>Source or Target</th>
<th>Captured on <code>GameplayEffectSpec</code></th>
<th>Automatically updates when <code>Attribute</code> changes for <code>Infinite</code> or <code>Duration</code> <code>GE</code></th>
</tr>
</thead>
<tbody><tr>
<td>Yes</td>
<td>Source</td>
<td>Creation</td>
<td>No</td>
</tr>
<tr>
<td>Yes</td>
<td>Target</td>
<td>Application</td>
<td>No</td>
</tr>
<tr>
<td>No</td>
<td>Source</td>
<td>Application</td>
<td>Yes</td>
</tr>
<tr>
<td>No</td>
<td>Target</td>
<td>Application</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>重新计算不会触发函数<code>PreAttributeChange</code>,所以必须在这里进行必要的<code>Clamp</code>操作</p>
<p><code>MMC</code>在蓝图中的使用不是很方便, 蓝图无法从<code>FGameplayEffectSpec</code>获取任何参数, 也无法调用<code>GetCapturedAttributeMagnitude()</code>获取捕获属性的值, 如果非要在蓝图中编辑 ,那么建议封装一个蓝图可见的函数包裹函数<code>GetCapturedAttributeMagnitude()</code>, 那么就可以获取到捕获属性的值了就可以魔改一些内容了,我们在下一篇会详细讲述</p>
<blockquote>
<p>注意, <code>CalculateBaseMagnitude()</code>函数是<code>const</code>函数</p>
</blockquote>
<h2 id="Gameplay-Effect-Execution-Calculation"><a href="#Gameplay-Effect-Execution-Calculation" class="headerlink" title="Gameplay Effect Execution Calculation"></a>Gameplay Effect Execution Calculation</h2><p><code>Gameplay Effect Execution Calculation</code>下文简称<code>GEEC</code>功能类似<code>MMC</code>, 但是功能更强大</p>
<p>一般只应用于非持续性的<code>GE</code></p>
<p>关于捕获方式如下表</p>
<table>
<thead>
<tr>
<th>Snapshot</th>
<th>Source or Target</th>
<th>Captured on <code>GameplayEffectSpec</code></th>
</tr>
</thead>
<tbody><tr>
<td>Yes</td>
<td>Source</td>
<td>Creation</td>
</tr>
<tr>
<td>Yes</td>
<td>Target</td>
<td>Application</td>
</tr>
<tr>
<td>No</td>
<td>Source</td>
<td>Application</td>
</tr>
<tr>
<td>No</td>
<td>Target</td>
<td>Application</td>
</tr>
</tbody></table>
<p>在蓝图中可以重写方法<code>Excute</code>,但是意义不大, 参数无法在蓝图中获取什么有用的数据</p>
<p><img src="https://img.supervj.top//img/image-20201216152057021.png" alt="image-20201216152057021"></p>
<p><strong>关于这个的详细应用我们会在后续展开</strong></p>
<h2 id="Custom-Application-Requirement"><a href="#Custom-Application-Requirement" class="headerlink" title="Custom Application Requirement"></a>Custom Application Requirement</h2><p>自定义<code>GE</code>是否可以被应用</p>
<p><img src="https://img.supervj.top//img/image-20201202110224455.png" alt="image-20201202110224455"></p>
<h2 id="技能消耗-Cost-Gameplay-Effect"><a href="#技能消耗-Cost-Gameplay-Effect" class="headerlink" title="技能消耗/Cost Gameplay Effect"></a>技能消耗/Cost Gameplay Effect</h2><p><code>Cost Gameplay Effect(CTGE)</code>定义了<code>GA</code>释放所需要的消耗，</p>
<p>当然可以直接定义一个浮点参数，记得给<strong>负值</strong>，必定消耗一般是扣除的</p>
<p>目前有两种方式来扩展</p>
<ol>
<li>使用<code>MMC</code>，然后重写方法<code>CalculateBaseMagnitude</code></li>
<li>重写<code>GA</code>中的<code>GetCostGameplayEffect</code>方法，手动动态创建一个<code>GE</code>，然后读取<code>Cost Value</code></li>
</ol>
<p><img src="https://img.supervj.top/img/gitlab/image-20201205091051810.png" alt="image-20201205091051810"></p>
<blockquote>
<p>因为默认情况下的<code>GameplayEffectSpec</code>的变量是没有暴露给蓝图的，上图中我重新定义了一个结构体然后暴露给蓝图使用</p>
</blockquote>
<h2 id="冷却系统-Cooldown-Gameplay-Effect"><a href="#冷却系统-Cooldown-Gameplay-Effect" class="headerlink" title="冷却系统/Cooldown Gameplay Effect"></a>冷却系统/Cooldown Gameplay Effect</h2><p><code>Cooldown Gameplay Effect(CDGE)</code>定义了技能的冷却时间，在<code>CDGE</code>中，我们可以不做任何属性修改，只需要提供一个<code>Tag</code>来标志冷却时间；当然类似<code>CTGE</code>，我们也可以用<code>MMC</code>来自定义算法</p>
<p>多数情况下，可以为每一个<code>GA</code>提供一个唯一的<code>CDGE</code>，如果想要复用同一个<code>CDGE</code>，那么我们可以在对<code>GE</code>创建的<code>GameplayEffectSpec</code>中的数据进行修改，这种方式只能在实例化技能（<code>Instanced</code>）使用</p>
<p>两种方式来扩展<code>CDGE</code>的计算</p>
<ol>
<li><p>使用<code>SetByCaller</code></p>
<p>我们意图把对CD的控制放到<code>GA</code>中,那么我们在自定义的<code>GA</code>中声明一个<code>FScalableFloat</code>变量<code>CD</code>,然后声明<code>FGameplayTagContainer CDTags</code></p>
<p>即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly,EditAnywhere)</span><br><span class="line">	FScalableFloat CD;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere)</span><br><span class="line">	FGameplayTagContainer CDTags;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>然后需要重写两个基类方法,需要一个临时变量<code>FGameplayTagContainer tempTags</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> FGameplayTagContainer* <span class="title">UGA_TestCpp1::GetCooldownTags</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FGameplayTagContainer* MutableTags = <span class="keyword">const_cast</span>&lt;FGameplayTagContainer*&gt;(&amp;tempTags);</span><br><span class="line">	<span class="keyword">const</span> FGameplayTagContainer* ParentTags = Super::<span class="built_in">GetCooldownTags</span>();</span><br><span class="line">	<span class="keyword">if</span> (ParentTags)</span><br><span class="line">	&#123;</span><br><span class="line">		MutableTags-&gt;<span class="built_in">AppendTags</span>(*ParentTags);</span><br><span class="line">	&#125;</span><br><span class="line">	MutableTags-&gt;<span class="built_in">AppendTags</span>(CDTags);</span><br><span class="line">	<span class="keyword">return</span> MutableTags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UGA_TestCpp1::ApplyCooldown</span><span class="params">(<span class="keyword">const</span> FGameplayAbilitySpecHandle Handle, <span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilityActivationInfo ActivationInfo)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UGameplayEffect* CooldownGE = <span class="built_in">GetCooldownGameplayEffect</span>();</span><br><span class="line">	<span class="keyword">if</span> (CooldownGE)</span><br><span class="line">	&#123;</span><br><span class="line">		FGameplayEffectSpecHandle SpecHandle = <span class="built_in">MakeOutgoingGameplayEffectSpec</span>(CooldownGE-&gt;<span class="built_in">GetClass</span>(), <span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">		SpecHandle.Data.<span class="built_in">Get</span>()-&gt;DynamicGrantedTags.<span class="built_in">AppendTags</span>(CDTags);</span><br><span class="line">		FName tagName = <span class="built_in">FName</span>(*(CDTags.<span class="built_in">ToStringSimple</span>()));</span><br><span class="line">		SpecHandle.Data.<span class="built_in">Get</span>()-&gt;<span class="built_in">SetSetByCallerMagnitude</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(tagName), CD.<span class="built_in">GetValueAtLevel</span>(<span class="built_in">GetAbilityLevel</span>()));</span><br><span class="line">		<span class="built_in">ApplyGameplayEffectSpecToOwner</span>(Handle, ActorInfo, ActivationInfo, SpecHandle);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p><code>FGameplayTagContainer</code>转<code>FName</code>用到的<code>FString</code>需要用<code>ToStringSimple()</code></p>
<p><code>RequestGameplayTag()</code>方法在默认情况下如果找不到标签会直接导致引擎崩溃</p>
</blockquote>
<p>这样我们可以直接在<code>GA</code>中定义我们自己的冷却时间</p>
<ol start="2">
<li>使用<code>MMC</code></li>
</ol>
<p>方法类似对<code>Cost</code>的处理, 重写<code>MMC</code>中的<code>CalculateBaseMagnitude</code>方法, 无论从蓝图还是cpp中都可以通过对返回的<code>float</code>值作为<code>CD</code>处理</p>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用指北</title>
    <url>/2020/05/12/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍Git软件和Github在Windows平台的简单使用方式</p>
</blockquote>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>安装包可以在<a href="%5Bhttps://git-scm.com%5D(https://git-scm.com/)">官网</a>下载，选择对应版本无脑下一步安装</p>
<h3 id="初次设置"><a href="#初次设置" class="headerlink" title="初次设置"></a>初次设置</h3><p>安装完成后，邮件菜单即可调用Git命令，点击进入后需要初始化账户名和邮箱</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一路Enter键后会需要设置自己的账户和密码，注意正确输入</li>
<li>然后在<code>C:\Users\你的用户名\.ssh</code>路径下可以找到如下3个文件</li>
</ul>
<p><img src="https://img.supervj.top/imggit_1.jpg"></p>
<ul>
<li>后缀为<code>pub</code>的文件，这个是公钥，在后续会用的到，也可以放心的告诉别人</li>
<li>后缀为<code>rsa</code>的是私钥，不要泄露出去</li>
</ul>
<h5 id="关于SSHKey"><a href="#关于SSHKey" class="headerlink" title="关于SSHKey"></a>关于SSHKey</h5><blockquote>
<p>GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
</blockquote>
<h3 id="注册GitHub账户"><a href="#注册GitHub账户" class="headerlink" title="注册GitHub账户"></a>注册GitHub账户</h3><ol>
<li>到<a href="%5Bhttps://github.com%5D(https://github.com/)">github官网</a>自行注册并登录</li>
<li>右键点击右上角头像边的箭头，选择<code>setting</code>进入</li>
</ol>
<p><img src="https://img.supervj.top/imggit_2.jpg"></p>
<ol start="3">
<li>找到左侧的<code>SSH and GPG keys</code>，点击<code>NewSSHKey</code></li>
</ol>
<p><img src="https://img.supervj.top/imggit_3.jpg"></p>
<ol start="4">
<li> 找到之前生成的<strong>公钥</strong>文件，用记事本打开复制里面全部内容，然后粘贴到如下图<code>key</code> 内，点击<code>AddSSHKey</code>完成,</li>
</ol>
<p><img src="https://img.supervj.top/imggit_4.jpg"></p>
<h3 id="使用Git"><a href="#使用Git" class="headerlink" title="使用Git"></a>使用Git</h3><h5 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h5><ul>
<li>在桌面直接右键进入git</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">cd E:/     <span class="comment">--进入E盘</span></span><br><span class="line">mkdir GitTest <span class="comment">--创建文件夹GitTest</span></span><br><span class="line">cd ./GitTest  <span class="comment">--进入GitTest文件夹</span></span><br><span class="line">git init <span class="comment">--初始化</span></span><br></pre></td></tr></table></figure>

<p>如上述代码所示，完成在E盘新建文件夹然后初始化的过程，其中前三步非每次必须，可以直接手动创建文件夹，然后通过<code>git init</code>初始化</p>
<h5 id="提交本地文件"><a href="#提交本地文件" class="headerlink" title="提交本地文件"></a>提交本地文件</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">vim test.txt <span class="comment">--新建文件</span></span><br></pre></td></tr></table></figure>

<p>按键盘<code>Insert</code>键进入编辑模式，输入<code>hello</code>,然后按顺序<code>ESC</code>,<code>:</code>,<code>wq</code>退出</p>
<p>上述步骤完成了创建文件，写入退出的过程，到此生成了文件和内容如下图 </p>
<p><img src="https://img.supervj.top/imggit_5.jpg"></p>
<p><img src="https://img.supervj.top/imggit_6.jpg"></p>
<blockquote>
<p>对，一顿操作猛如虎，回头一想就是Linux那一套☠</p>
</blockquote>
<ul>
<li>上述步骤完全可以自行创建和编辑内容，然后我们开始提交</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git add test.txt <span class="comment">//提交text.txt文件到待提交列表</span></span><br><span class="line">git commit -m <span class="string">&quot;第一次提交&quot;</span>  <span class="comment">//正式提交到仓库</span></span><br></pre></td></tr></table></figure>

<p>至此我们已经提交到了本地仓库，可以通过命令<code>git log</code> 查询日志找到记录</p>
<h5 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h5><p>到这一步我们得先创建一个远程仓库，来到我们github，通过<code>Your respositories</code>&gt;<code>New</code>创建新的仓库，这里我们创建了名为<code>Test</code> 的仓库</p>
<ul>
<li>找到如下图所示，复制地址信息(推荐使用SSH，使用HTTPS经常需要输入账户)</li>
</ul>
<p><img src="https://img.supervj.top/imggit_8.jpg"></p>
<p>然后运行git命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git remote add origin <span class="string">&quot;你的地址&quot;</span> <span class="comment">//添加远程仓库地址</span></span><br></pre></td></tr></table></figure>

<h5 id="提交-拉取远程仓库"><a href="#提交-拉取远程仓库" class="headerlink" title="提交/拉取远程仓库"></a>提交/拉取远程仓库</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git add push origin -u master <span class="comment">//master为当前分支，默认一般就是master,可以自行修改，下同</span></span><br></pre></td></tr></table></figure>

<p>到这里就提交到了远程仓库,如下图所示</p>
<p><img src="https://img.supervj.top/imggit_9.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git pull origin master </span><br></pre></td></tr></table></figure>

<p>从远程仓库拉取master分支的内容</p>
<h5 id="取消关联远程仓库"><a href="#取消关联远程仓库" class="headerlink" title="取消关联远程仓库"></a>取消关联远程仓库</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>

<h5 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -b是base的意思，就是以当前分支为基础创建一个新分支 </span></span><br><span class="line">git branch $&#123;new_branch_name&#125; -b</span><br><span class="line"><span class="comment">// 切换分支</span></span><br><span class="line">git checkout $&#123;new_branch_name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用git checkout命令加上-b参数表示创建并切换</span></span><br><span class="line">git checkout -b $&#123;new_branch_name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于以下两条命令:</span></span><br><span class="line">git branch $&#123;new_branch_name&#125;</span><br><span class="line">git checkout $&#123;new_branch_name&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Checkout的用法"><a href="#Checkout的用法" class="headerlink" title="Checkout的用法"></a>Checkout的用法</h6><p><code>checkout</code>有三种用途：切换分支、移除修改、从历史版本中签出，后面会写到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从远程的origin/level为基础创建本地分支</span></span><br><span class="line">git checkout -b level origin/level</span><br><span class="line"><span class="comment">//上面的命令等同于下面两条</span></span><br><span class="line">git checkout -b origin/level</span><br><span class="line">git branch -m level</span><br></pre></td></tr></table></figure>

<h5 id="推送本地当前分支到远程分支"><a href="#推送本地当前分支到远程分支" class="headerlink" title="推送本地当前分支到远程分支"></a>推送本地当前分支到远程分支</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若远程不存在$&#123;new_branch_name&#125;分支则会自动创建</span></span><br><span class="line">git push $&#123;remote_repo_name&#125; $&#123;new_branch_name&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先需要切换回需要合并到的分支，比如将dev分支合并到master分支</span></span><br><span class="line">git branch master</span><br><span class="line"><span class="comment">// 将dev分支合并到当前分支</span></span><br><span class="line">git merge dev</span><br><span class="line"><span class="comment">// 合并完毕后就可以删除dev分支</span></span><br></pre></td></tr></table></figure>

<h5 id="取消合并"><a href="#取消合并" class="headerlink" title="取消合并"></a>取消合并</h5><p>如果本地与远程分支(或本地分支)有冲突可以取消合并，使本地分支回到合并之前的状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git merge --<span class="built_in">abort</span></span><br></pre></td></tr></table></figure>

<h5 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a><strong>解决冲突</strong></h5><blockquote>
<p>在使用git协作开发的时候，冲突是经常会遇到的问题，也是对于新手来说非常棘手的问题</p>
</blockquote>
<ul>
<li>首先我们要在本地处理好自己的文件</li>
</ul>
<h6 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git checkout -- test.txt  <span class="comment">//撤销对test.txt文件的修改</span></span><br><span class="line">git checkout -- .  <span class="comment">//撤销本次所有文件的修改</span></span><br><span class="line">git reset -- test.txt  <span class="comment">//如果已经add了test文件，需要先使用本条命令退出add状态</span></span><br><span class="line">git reset -- .     <span class="comment">//撤销所有文件的add状态</span></span><br></pre></td></tr></table></figure>



<h6 id="解决拉取冲突"><a href="#解决拉取冲突" class="headerlink" title="解决拉取冲突"></a>解决拉取冲突</h6><p> 如果在拉取以后发生冲突了，在拉取日志里就有报错，通过<code>git status</code>命令也可以看到有红色部分，通过下列命令解决</p>
<p>如果我们要保留远程分支的<code>test.txt</code>可以执行以下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保留远程版本的test.txt</span></span><br><span class="line">$ git checkout --theirs test.txt</span><br></pre></td></tr></table></figure>

<p>而保留本地分支的文件命令为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ git checkout --ours test.txt</span><br></pre></td></tr></table></figure>

<p>然后再此执行如下命令，<strong>注意这会再一次生成提交记录</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line"><span class="comment">//假如上面执行的是 --theirs</span></span><br><span class="line">$ git commit -m <span class="string">&quot;合并冲突，保留远程版本&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时本地就与远程合并了，并且合并时保持了远程的文件版本。</p>
<h6 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h6><p>如果想要取消本地的某次提交<code>$&#123;123456&#125;</code>的更改可以使用回退到历史版本，然后使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git reset --hard <span class="number">123455</span></span><br><span class="line"><span class="comment">//将123456提交的文件签出到123455的提交中去</span></span><br><span class="line"><span class="comment">//相当于直接在123455的基础上做了123456中的文件修改</span></span><br><span class="line">$ git checkout <span class="number">123456</span> .</span><br><span class="line"><span class="comment">//然后在reset/checkout不想提交的文件即可</span></span><br></pre></td></tr></table></figure>

<h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除本地分支</span></span><br><span class="line"><span class="comment">// 注意：删除分支之前要合并分支，不然会报错(或者使用-D强制删除)</span></span><br><span class="line"><span class="comment">// error: The branch &#x27;dev&#x27; is not fully merged.</span></span><br><span class="line"><span class="comment">// If you are sure you want to delete it, run &#x27;git branch -D dev&#x27;.</span></span><br><span class="line">git branch -D dev</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除远程分支</span></span><br><span class="line">git push $&#123;repo_name&#125; --<span class="keyword">delete</span> $&#123;remote_branch_name&#125;</span><br></pre></td></tr></table></figure>

<h5 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a><strong>版本回退</strong></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline  <span class="comment">//查看所有提交记录</span></span><br><span class="line">git reset --hard <span class="string">&quot;版本号&quot;</span>  <span class="comment">//回退到某个版本，版本号为查询记录里黄色部分    </span></span><br><span class="line">git reset <span class="string">&quot;版本号&quot;</span> <span class="string">&quot;filename&quot;</span>    <span class="comment">//某个文件回退到某个版本</span></span><br></pre></td></tr></table></figure>

<h5 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// clone仓库所有分支</span></span><br><span class="line">git clone <span class="string">&quot;仓库地址&quot;</span></span><br><span class="line"><span class="comment">// 只clone一个分支可以使用-b指定分支名字</span></span><br><span class="line">git clone -b <span class="string">&quot;分支名称&quot;</span> <span class="string">&quot;仓库地址&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="切换到远程分支"><a href="#切换到远程分支" class="headerlink" title="切换到远程分支"></a>切换到远程分支</h5><p>远程仓库 <code>git clone</code> 下来后，执行 <code>git branch</code>，只能看到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>并不会看到其他分支，即便远程仓库上有其他分支。</p>
<p>可以使用<code>git branch -va</code>首先列出本地/远程分支列表：</p>
<p><img src="https://img.supervj.top/imggit_10.jpg"></p>
<p>通过<code>git checkout remotes/origin/master</code>切换到远程分支</p>
<p>再进行如下操作 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure>

<p>最后得到如下结果 </p>
<p><img src="https://img.supervj.top/imggit_12.jpg"></p>
<p>然后在本地修改dev分支的内容就可以提交到远程dev分支(此案例远程没有dev分支)</p>
<h5 id="忽略不想提交的文件"><a href="#忽略不想提交的文件" class="headerlink" title="忽略不想提交的文件"></a>忽略不想提交的文件</h5><p>有时我们不想要把所有的东西都提交到仓库中(比如一些编译生成的二进制文件)，可以使用.gitignore来排除不需要提交的文件。<br>在Windows下我们不能够直接创建这个文件，因为是.开头没有文件名，所以需要在GitBash下使用命令创建：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">touch .gitignore <span class="comment">//创建文件</span></span><br></pre></td></tr></table></figure>

<p>然后用记事本打开编辑里面的内容并保存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排除当前目录下的public文件夹</span></span><br><span class="line"><span class="keyword">public</span>/</span><br><span class="line"><span class="comment">//排除所有的.exe文件</span></span><br><span class="line">*.exe</span><br><span class="line"><span class="comment">//排除所有的txt文件</span></span><br><span class="line">*.txt</span><br><span class="line">Intermediate <span class="comment">//排除Intermediate文件的提交</span></span><br><span class="line">Saved </span><br><span class="line">Content/Test/  </span><br></pre></td></tr></table></figure>

<blockquote>
<p> 其中在上述最后3条对于UE4的开发比较常用</p>
</blockquote>
<p>关于忽略文件的更多内容，可以查看此<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900004590234208">文档</a></p>
<h5 id="比较不同版本的差异"><a href="#比较不同版本的差异" class="headerlink" title="比较不同版本的差异"></a>比较不同版本的差异</h5><p>我们继续在<code>test.txt</code>文件加入一行<code>world</code>，然后运行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<p>得到如下</p>
<p><img src="https://img.supervj.top/imggit.jpg"></p>
<p>其他命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看尚未暂存的某个文件更新了哪些</span></span><br><span class="line">$ git diff filename</span><br><span class="line"><span class="comment">//查看已经暂存起来的文件和上次提交的版本之间的差异</span></span><br><span class="line">$ git diff –cached</span><br><span class="line"><span class="comment">//查看已经暂存起来的某个文件和上次提交的版本之间的差异</span></span><br><span class="line">$ git diff –cached filename</span><br><span class="line"><span class="comment">//查看某两个版本之间的差异</span></span><br><span class="line">git diff ffd98b291e0caa6c33575c1ef465eae661ce40c9 b8e7b00c02b95b320f14b625663fdecf2d63e74c</span><br><span class="line"><span class="comment">//查看某两个版本的某个文件之间的差异</span></span><br><span class="line">git diff ffd98b291e0caa6c33575c1ef465eae661ce40c9:filename b8e7b00c02b95b320f14b625663fdecf2d63e74c:filename</span><br></pre></td></tr></table></figure>

<p>两个分支的差异</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">git diff topic <span class="title">master</span> <span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">git diff topic..<span class="title">master</span>  <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">git diff topic...<span class="title">master</span> <span class="params">(<span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>用法1，直接跟两个使用空格分隔的分支名会直接将两个分支上最新的提交做diff，相当于diff了两个commit。<br>用法2，用两个点号分隔的分支名，作用同用法1(装酷利器)<br>用法3，用三个点号分隔的分支名会输出自topic与master分别开发以来，master分支上的change。<br><strong>需要注意</strong>的是这里的..和…不能与git rev-list中的..和…混淆。</p>
<h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><p>如果使用<code>git</code>终端时出现以下错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">error: bad signature</span><br><span class="line">fatal: index file corrupt</span><br></pre></td></tr></table></figure>

<p>这是由于索引损坏造成的，可以通过下面的方式来处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rm -f .git/index</span><br><span class="line">git reset</span><br></pre></td></tr></table></figure>

<h5 id="关闭Git的SSL验证"><a href="#关闭Git的SSL验证" class="headerlink" title="关闭Git的SSL验证"></a>关闭Git的SSL验证</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h5 id="私钥权限过于开放报错"><a href="#私钥权限过于开放报错" class="headerlink" title="私钥权限过于开放报错"></a>私钥权限过于开放报错</h5><p>使用git出现如下报错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">Permissions <span class="number">0644</span> <span class="keyword">for</span> <span class="string">&#x27;/root/.ssh/id_rsa&#x27;</span> are too open.</span><br><span class="line">It is required that your <span class="keyword">private</span> key files are NOT accessible by others.</span><br><span class="line">This <span class="keyword">private</span> key will be ignored.</span><br><span class="line">Load key <span class="string">&quot;/root/.ssh/id_rsa&quot;</span>: <span class="function">bad permissions</span></span><br><span class="line"><span class="function">Permission <span class="title">denied</span> <span class="params">(publickey)</span>.</span></span><br><span class="line"><span class="function">fatal: Could not read from remote repository.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Please make sure you have the correct access rights</span></span><br><span class="line"><span class="function">and the repository exists.</span></span><br></pre></td></tr></table></figure>

<p>这是提示你的Git私钥读写权限过于开放会有安全问题</p>
<p>解决方法：对文件<code>.ssh/id_rsa</code>点右键属性-<code>安全/高级</code>，禁用继承，将文件所有者更改为你自己的账户，然后添加你自己的账户和<code>SYSTEM</code>完整的控制权，保存即可。</p>
<h5 id="Git更新远程分支列表"><a href="#Git更新远程分支列表" class="headerlink" title="Git更新远程分支列表"></a>Git更新远程分支列表</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git remote update origin --prune</span><br></pre></td></tr></table></figure>

<h5 id="submodule"><a href="#submodule" class="headerlink" title="submodule"></a>submodule</h5><p>如果再一个git仓库中又用到其他git仓库的，就可以使用<code>git module</code>来处理这个包含关系。</p>
<p>如果直接在git仓库A中把另一个仓库B clone下载作为A的子目录，在<code>git add</code>时会有下列类似的提示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hint: Yo<span class="string">u&#x27;ve added another git repository inside your current repository.</span></span><br><span class="line"><span class="string">hint: Clones of the outer repository will not contain the contents of</span></span><br><span class="line"><span class="string">hint: the embedded repository and will not know how to obtain it.</span></span><br><span class="line"><span class="string">hint: If you meant to add a submodule, use:</span></span><br><span class="line"><span class="string">hint:</span></span><br><span class="line"><span class="string">hint:   git submodule add &lt;url&gt; Plugins/VaRest</span></span><br><span class="line"><span class="string">hint:</span></span><br><span class="line"><span class="string">hint: If you added this path by mistake, you can remove it from the</span></span><br><span class="line"><span class="string">hint: index with:</span></span><br><span class="line"><span class="string">hint:</span></span><br><span class="line"><span class="string">hint:   git rm --cached Plugins/VaRest</span></span><br><span class="line"><span class="string">hint:</span></span><br><span class="line"><span class="string">hint: See &quot;git help submodule&quot; for more information.</span></span><br></pre></td></tr></table></figure>

<p>目的就是告诉你你包含了另一个git的仓库。</p>
<p>正确的处理办法是，先把之前clone的B删除，然后使用<code>git submodule</code>来clone B:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ git submodule add git@github.com:VJien/img.git</span><br><span class="line">Cloning into <span class="string">&#x27;E:/GitTest/img&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: <span class="number">123</span>, done.</span><br><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">123</span>/<span class="number">123</span>), done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">118</span>/<span class="number">118</span>), done.</span><br><span class="line">remote: Total <span class="number">123</span> (delta <span class="number">39</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">123</span>/<span class="number">123</span>), <span class="number">4.05</span> MiB | <span class="number">466.00</span> KiB/s, done.</span><br><span class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">39</span>/<span class="number">39</span>), done.</span><br><span class="line">warning: LF will be replaced by CRLF in .gitmodules.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>会把B clone下来，然后进到B的目录里面，将版本记录改为你想要的commit，然后再add/commit即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   Plugins/<span class="built_in">VaRest</span> (<span class="keyword">new</span> commits)</span><br></pre></td></tr></table></figure>

<p>然后再push到远程仓库即可，在远程仓库中，A项目中的B目录就不是直接上传的文件，而是连接到真正的B的源仓库。</p>
<h6 id="初始更新子模块"><a href="#初始更新子模块" class="headerlink" title="初始更新子模块"></a>初始更新子模块</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<h6 id="后续更新子模块"><a href="#后续更新子模块" class="headerlink" title="后续更新子模块"></a>后续更新子模块</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git submodule foreach git fetch</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">git submoudule update --remote</span><br></pre></td></tr></table></figure>

<h6 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h6><p>删除一个以添加的子模块需要有以下几个步骤：</p>
<ol>
<li>删除子模块的目录</li>
<li>删除<code>.gitmodules</code>中的关于该子模块的信息</li>
<li>删除<code>.git/config</code>中关于该子模块的信息</li>
<li>删除<code>.git/modules</code>下该子模块的目录</li>
</ol>
<p>执行完上面几步操作之后就可以了，但是如果有报错问题可以删掉缓存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git rm --cached 子模块名称</span><br></pre></td></tr></table></figure>







<h5 id="创建本地空仓库"><a href="#创建本地空仓库" class="headerlink" title="创建本地空仓库"></a>创建本地空仓库</h5><p>个命令是创建一个空仓库，可以在其他的项目中将该仓库添加为远程仓库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git --bare init</span><br></pre></td></tr></table></figure>



<blockquote>
<p>部分内容参考至本人好友查理同学的☛<a href="https://imzlp.me/posts/53696/">博客</a>☚</p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Json文件读写</title>
    <url>/2020/08/07/Json/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍UE4下的JSON文件的读写</p>
</blockquote>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>首先我们需要扩展普通的文件读写方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UTestLib::V_LoadStringFromFile</span><span class="params">(<span class="keyword">const</span> FString&amp; FileName, <span class="keyword">const</span> FString&amp; RelativePath, FString&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!FileName.<span class="built_in">IsEmpty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		FString file=FPaths::<span class="built_in">ProjectContentDir</span>()+RelativePath+FileName;</span><br><span class="line">		<span class="keyword">return</span>  FFileHelper::<span class="built_in">LoadFileToString</span>(result,*file);				</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UTestLib::V_SaveStringToFile</span><span class="params">(<span class="keyword">const</span> FString&amp; FileName, <span class="keyword">const</span> FString&amp; RelativePath, <span class="keyword">const</span> FString&amp; string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!FileName.<span class="built_in">IsEmpty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		FString file = FPaths::<span class="built_in">ProjectContentDir</span>() + RelativePath + FileName;</span><br><span class="line">		<span class="keyword">return</span>  FFileHelper::<span class="built_in">SaveStringToFile</span>(string,*file);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法是以工程目录下的Content路径为基础的，如果需要指定其他路径就需要替换<code> FPaths::ProjectContentDir()</code>方法或者干脆直接把整个路径给公开</p>
<span id="more"></span>

<h3 id="JSON文件读写"><a href="#JSON文件读写" class="headerlink" title="JSON文件读写"></a>JSON文件读写</h3><p>先来一个示例<code>JSON</code>文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;school&quot;</span>: <span class="string">&quot;Super&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;name&quot;</span>:</span><br><span class="line">	[</span><br><span class="line">		<span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Jien&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Harry&quot;</span></span><br><span class="line">	],</span><br><span class="line">	<span class="attr">&quot;Tom&quot;</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;boy&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;score&quot;</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;Math&quot;</span>:<span class="number">99</span>,</span><br><span class="line">			<span class="attr">&quot;English&quot;</span>:<span class="number">80</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">&quot;Jien&quot;</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;boy&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;score&quot;</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;Math&quot;</span>:<span class="number">88</span>,</span><br><span class="line">			<span class="attr">&quot;English&quot;</span>:<span class="number">95</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>解释几个关键参数</p>
<ul>
<li>TJsonReader</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TSharedPtr&lt;FJsonObject&gt; JSONContentObject;</span><br><span class="line">TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; Reader = TJsonReaderFactory&lt;TCHAR&gt;::<span class="built_in">Create</span>(JSONInput);</span><br></pre></td></tr></table></figure>

<p>用来反序列化的一个类，把文件中的字符串先存放到<code>TJsonReader</code>的智能指针里;同样的还有写入操作和序列化操作，对应的类就是<code>TJsonWriter</code></p>
<ul>
<li><code>FJsonObject</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FJsonSerializer::<span class="built_in">Deserialize</span>(Reader, JSONContentObject)</span><br></pre></td></tr></table></figure>

<p>通过<code>FJsonSerializer</code>把<code>TJsonReader</code> 反序列化到<code>FJsonObject</code>中，然后就可以通过方法来解读</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StringValue=JSONContentObject-&gt;<span class="built_in">GetStringField</span>(key);</span><br></pre></td></tr></table></figure>

<p>当然，有个前提是这个key对应的一个值，如示例中的<code>&quot;school&quot;: &quot;Super</code></p>
<ul>
<li>FJsonValue</li>
</ul>
<p>因为JSON文件是可以使用数组和嵌套的，对于数组，就必须用到<code>FJsonValue</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;name&quot;:</span></span><br><span class="line"><span class="comment">	[</span></span><br><span class="line"><span class="comment">		&quot;Tom&quot;,</span></span><br><span class="line"><span class="comment">		&quot;Jien&quot;,</span></span><br><span class="line"><span class="comment">		&quot;Harry&quot;</span></span><br><span class="line"><span class="comment">	],</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParedValue;</span><br><span class="line">TSharedPtr&lt;FJsonObject&gt; JsonObj;</span><br><span class="line"><span class="keyword">if</span> (FJsonSerializer::<span class="built_in">Deserialize</span>(JsonReader, JsonObj))</span><br><span class="line">&#123;</span><br><span class="line">	JsonParedValue = JsonObj-&gt;<span class="built_in">GetArrayField</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>name</code>对应的是一个数组，所以得到的<code>FJsonValue</code>就是这个数组的成员</p>
<p>然后通过下面方法得到所有成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: JsonParedValue)</span><br><span class="line">&#123;</span><br><span class="line">    value.<span class="built_in">Add</span>(i-&gt;<span class="built_in">AsString</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的解析一个键值对，值是数组的方法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UTestLib::V_LoadValueArrayFromJsonKey</span><span class="params">(<span class="keyword">const</span> FString&amp; JsonString, <span class="keyword">const</span> FString&amp; key, TArray&lt;FString&gt;&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParedValue;</span><br><span class="line">	TSharedPtr&lt;FJsonObject&gt; JsonObj;</span><br><span class="line">	TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::<span class="built_in">Create</span>(JsonString);</span><br><span class="line">	<span class="keyword">if</span> (FJsonSerializer::<span class="built_in">Deserialize</span>(JsonReader, JsonObj))</span><br><span class="line">	&#123;</span><br><span class="line">		JsonParedValue = JsonObj-&gt;<span class="built_in">GetArrayField</span>(key);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i: JsonParedValue)</span><br><span class="line">		&#123;</span><br><span class="line">			value.<span class="built_in">Add</span>(i-&gt;<span class="built_in">AsString</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的键值对的方法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UTestLib::V_LoadValueFromJsonKey</span><span class="params">(<span class="keyword">const</span> FString&amp; JsonString, <span class="keyword">const</span> FString&amp; key, FString&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParedValue;</span><br><span class="line">	TSharedPtr&lt;FJsonObject&gt; JsonObj;</span><br><span class="line">	TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader=TJsonReaderFactory&lt;TCHAR&gt;::<span class="built_in">Create</span>(JsonString);</span><br><span class="line">	<span class="keyword">if</span> (FJsonSerializer::<span class="built_in">Deserialize</span>(JsonReader, JsonObj))</span><br><span class="line">	&#123;</span><br><span class="line">		value=JsonObj-&gt;<span class="built_in">GetStringField</span>(key);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写入会麻烦一点，首先需要些一个函数来把<code>FJsonObject</code>转换为<code>FString</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UTestLib::GetStringFromJsonObj</span><span class="params">(<span class="keyword">const</span> TSharedPtr&lt;FJsonObject&gt;&amp; InJsonObj, FString&amp; OutStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (InJsonObj.<span class="built_in">IsValid</span>() &amp;&amp; InJsonObj-&gt;Values.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		TSharedRef&lt;TJsonWriter&lt;TCHAR&gt;&gt; t_writer = TJsonWriterFactory&lt;&gt;::<span class="built_in">Create</span>(&amp;OutStr);</span><br><span class="line">		FJsonSerializer::<span class="built_in">Serialize</span>(InJsonObj.<span class="built_in">ToSharedRef</span>(), t_writer);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们直接写一个改写固定键值对的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UTestLib::V_SaveJsonData</span><span class="params">(<span class="keyword">const</span> FString&amp; FileName, <span class="keyword">const</span> FString&amp; RelativePath, <span class="keyword">const</span> FString&amp; key, <span class="keyword">const</span> FString&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FString JsonString;</span><br><span class="line">	FString result;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">V_LoadStringFromFile</span>(FileName, RelativePath, JsonString))</span><br><span class="line">	&#123;</span><br><span class="line">		TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParedValue;</span><br><span class="line">		TSharedPtr&lt;FJsonObject&gt; JsonObj;</span><br><span class="line">		TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = 	TJsonReaderFactory&lt;TCHAR&gt;::<span class="built_in">Create</span>(JsonString);</span><br><span class="line">		<span class="keyword">if</span> (FJsonSerializer::<span class="built_in">Deserialize</span>(JsonReader, JsonObj))</span><br><span class="line">		&#123;</span><br><span class="line">			JsonObj-&gt;<span class="built_in">SetStringField</span>(key,value);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetStringFromJsonObj</span>(JsonObj, result))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">V_SaveStringToFile</span>(FileName, RelativePath, result);</span><br><span class="line">            &#125;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后得到结果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="attr">&quot;school&quot;</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;name&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Jien&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Harry&quot;</span></span><br><span class="line">	],</span><br><span class="line">	<span class="attr">&quot;Tom&quot;</span>:..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo+GithubPages部署个人静态博客</title>
    <url>/2020/12/04/Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>使用静态博客有些日子了, 前阵子博客文件被手残折腾没了(还好文章有备份), 重新部署一下有点生疏了.</p>
<p>于是还是决定写一篇部署博客的文章重新记录一下部署流程</p>
</blockquote>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>手动百度搜索node.js下载并安装</li>
<li>下载并安装git</li>
<li>注册github账户</li>
</ul>
<blockquote>
<p>关于git和github的使用在另外一篇博客里有详细说明，点击<a href="">这里</a></p>
</blockquote>
<ul>
<li>创建<code>你的用户名.github.io</code>的仓库,此仓库是用来保存博客文件的<ul>
<li>虽然非绝对必要但是强烈将以注册一个自己的域名,如阿里云;否则可能导致访问速度过慢或者无效</li>
<li>在setting中的<code>GitHubPages</code>栏填写自己的域名</li>
</ul>
</li>
</ul>
<p><img src="https://img.supervj.top//img/image-20201204094746007.png" alt="image-20201204094746007"></p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p><code>GitBash</code>模式下输入安装<code>hexo</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>

<p>选择一个博客文件夹,输入如下代码初始化<code>hexo</code>环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p>初始化后在文件内会生成若干文件和文件夹,大致如下</p>
<p><img src="https://img.supervj.top//img/image-20201204095336780.png" alt="image-20201204095336780"></p>
<span id="more"></span>

<h3 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h3><p>部署需要安装部署插件<code>deployer</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>安装过程可能会报警告, 我这边提示版本9.0过期什么的,不用理会,继续</p>
<p><code>hexo</code>的部署一般只需要简单几个命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo clean --清理,一般修改配置以后需要执行</span><br><span class="line">$ hexo g 	-- 生成</span><br><span class="line">$ hexo d	-- 部署,即修改到静态博客</span><br><span class="line">$ hexo s	-- 本地预览,在部署之前可以先预览一下,一般是输入localhost:4000 预览</span><br></pre></td></tr></table></figure>

<p>然后打开我们博客根目录下的<code>_config.yml</code>文件,此文件是博客的配置文件,需要区分的是在每一个主题内也有一个同名文件, 那个是主题自身的配置文件</p>
<p>把最下面的<code>deploy</code>信息修改为我们<code>github</code>的对应信息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">你的仓库地址.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">分支名称</span></span><br></pre></td></tr></table></figure>





<h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>默认会有一个<code>landscape</code>主题,略丑</p>
<p>我们可以下载一个比较流行的主题如 <code>next</code>或者<code>pure</code>之类的</p>
<p>以<code>next</code>为例,clone目前最新的8.0版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:next-theme/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>

<p>打开博客配置文件,在主题设置的地方设置主题为<code>next</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br></pre></td></tr></table></figure>

<p>直接<code>hexo s + localhost:4000</code>预览</p>
<p><img src="https://img.supervj.top//img/image-20201204100220556.png" alt="image-20201204100220556"></p>
<p>一切顺利!</p>
<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>博客配置里面有一些比较重要的我们大概梳理一下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">博客名称</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">描述,会显示在博客名称下(具体需要根据主题)</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">关键字</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">作者名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span> <span class="comment">#时区</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>   <span class="comment">#时间显示方式</span></span><br></pre></td></tr></table></figure>



<p>打开文件夹<code>source</code>,里面的<code>_posts</code>内就是存放<code>md</code>格式的博客文件的</p>
<h3 id="文档加密"><a href="#文档加密" class="headerlink" title="文档加密"></a>文档加密</h3><p>安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-blog-encrypt</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>/Hexo/_config.yml</code>文件中添加内容:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encrypt:</span><br><span class="line">	enable:true</span><br></pre></td></tr></table></figure>

<p>然后在博客抬头部分加入如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">password:</span> <span class="comment">##密码   </span></span><br><span class="line"><span class="attr">abstract:</span> <span class="comment">##输入密码之前的博客提示</span></span><br><span class="line"><span class="attr">message:</span> <span class="comment">##密码输入框上描述性内容</span></span><br></pre></td></tr></table></figure>







<h3 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/next</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议更新主题之前先备份一下整个博客文件, 因为主题升级可能导致部分功能出错,严重的话博客无法正常显示(本人亲测)</p>
</blockquote>
<h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><h5 id="主题风格选择"><a href="#主题风格选择" class="headerlink" title="主题风格选择"></a>主题风格选择</h5><p><code>next</code>主题内有4个风格,可以自己选择; 部分配置选项跟某些风格有冲突,需要注意</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>





<h5 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h5><p>头像相关设置在主题配置文件内</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://*.png</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>上面显示的是博客主要位置头像,如下图</p>
<p><img src="https://img.supervj.top//img/image-20201204103822630.png" alt="image-20201204103822630"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">https://*.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">https://*.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">https://*.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">https://*.png</span></span><br></pre></td></tr></table></figure>

<p>上面代码显示的浏览器比如下图位置显示的头像</p>
<p><img src="https://img.supervj.top//img/image-20201204103859512.png" alt="image-20201204103859512"></p>
<p>反正也没多的准备,都统一用一个了</p>
<h5 id="配置-about、tag、categories菜单"><a href="#配置-about、tag、categories菜单" class="headerlink" title="配置 about、tag、categories菜单"></a>配置 about、tag、categories菜单</h5><p><code>source</code>文件夹中默认只有<code>_posts</code>文件夹, 我们需要手动创建<code>about</code>,<code>tag</code>等文件夹</p>
<p>同时打开<code>next</code>主题配置文件中的所需要的注释,如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20201204101922528.png" alt="image-20201204101922528"></p>
<p><code>about</code>一般是介绍博主的个人信息和博客信息, ,需要生成一个<code>index.md</code>的文件</p>
<p>可以用如下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>

<p>类似的<code>tags</code>和<code>categories</code>也是</p>
<p>上面的<code>404</code>页面我本人没兴趣就没有去设置,有兴趣的朋友可以自己去找相关文档设置一下</p>
<h5 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h5><p> 我们在主题配置文件中会看到一个<code>local_search</code>关键字,默认<code>enable: false</code>, 我们先把他打开</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>但是这个还不够, 点击搜索还是没有作用</p>
<p>因为本地搜索还需要插件支持</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>输入上述命令安装插件</p>
<p>然后在项目配置文件最底下加入如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>



<p><img src="https://img.supervj.top//img/image-20201204102850552.png" alt="image-20201204102850552"></p>
<p>如此完成本地搜索功能</p>
<h5 id="RSS订阅"><a href="#RSS订阅" class="headerlink" title="RSS订阅"></a>RSS订阅</h5><p>主题文件底部添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">icon.png</span></span><br><span class="line">  <span class="attr">autodiscovery:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span></span><br></pre></td></tr></table></figure>

<p>next配置文件打开<code>RSS</code>注释</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">RSS:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure>





<h5 id="底部版权显示"><a href="#底部版权显示" class="headerlink" title="底部版权显示"></a>底部版权显示</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line"><span class="comment">#建站年份,默认是当前的</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># 年份与作者之间的图片,可以参考 https://fontawesome.com/icons</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">    <span class="comment"># 动画表现</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 颜色</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#00DB00&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 作者,不填写就使用博客配置中的作者</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 显示 Hexo &amp; NexT</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>





<h5 id="社交信息"><a href="#社交信息" class="headerlink" title="社交信息"></a>社交信息</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || fab fa-github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br></pre></td></tr></table></figure>

<p>自行开启, 国内用户常用的估计也就前三个了</p>
<h5 id="字数统计等"><a href="#字数统计等" class="headerlink" title="字数统计等"></a>字数统计等</h5><p>主题配置中有<code>symbols_count_time:</code>相关字眼</p>
<blockquote>
<p>字数显示设置跟老版本有区别, 不要盲目安装老版本插件, 亲测安装以后导致整个博客文件崩坏</p>
</blockquote>
<p>按照注释中的说明操作,安装插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-word-counter</span><br></pre></td></tr></table></figure>

<p>然后复制如下内容到博客配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>另外可以直接打开主题配置中的<code>busuanzi</code>阅读统计</p>
<p>最终效果如下</p>
<p><img src="https://img.supervj.top//img/image-20201204112707103.png" alt="image-20201204112707103"></p>
<h5 id="原创申明"><a href="#原创申明" class="headerlink" title="原创申明"></a>原创申明</h5><p>打开主题配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<p><img src="https://img.supervj.top//img/image-20201204112831797.png" alt="image-20201204112831797"></p>
<h5 id="添加到google搜索"><a href="#添加到google搜索" class="headerlink" title="添加到google搜索"></a>添加到google搜索</h5><p>要添加到搜索引擎,我们先需要生成我们的站点地图文件,先安装插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save  <span class="comment">#这个是百度的,我没添加</span></span><br></pre></td></tr></table></figure>

<p>然后在博客配置文件中添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动生成sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>

<p>然后生成博客文件</p>
<p>正常情况下在博客<code>public</code>目录下生成了一个<code>sitemap.xml</code>文件,这样就是成功了</p>
<p>然后就需要提交给谷歌,点击<a href="https://search.google.com/search-console?resource_id=sc-domain:supervj.top&hl=zh-CN">这里</a>进行谷歌部分操作</p>
<p>点击添加资源自行添加网站域名</p>
<p>然后在google中输入 <code>site:你的域名</code>测试</p>
<h5 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h5><p>比较简单,打开主题配置文件对应的<code>reward</code>设置,并附上自己的打赏图片</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, a donate button will be displayed in every article by default.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#comment: Buy me a coffee</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">https://img.supervj.top/img/reward/微信图片_20200601120451.jpg</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">https://img.supervj.top/img/reward/alipayReward.jpg</span> </span><br><span class="line">  <span class="comment">#paypal: /images/paypal.png</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>





<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>代码可以直接设置主题, 可以到<a href="https://theme-next.js.org/highlight/">这里</a>预览效果</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">monokai-sublime</span>  <span class="comment">#设置自己的主题</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">tomorrow-night</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment">#开启复制按钮</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">style:</span></span><br></pre></td></tr></table></figure>





<h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><p>到<a href="https://fonts.google.com/?preview.text_type=custom">谷歌字体</a>查找自己感兴趣的字体</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment">#开启</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#全局字体</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span>  <span class="comment">#个人感觉比较好看的中文字体</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">0.85</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 抬头, 博客名称会是这个字体</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">ZCOOL</span> <span class="string">XiaoWei</span></span><br><span class="line">    <span class="attr">size:</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># 所有标题</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">NoTo</span> <span class="string">Sans</span> <span class="string">SC</span></span><br><span class="line">    <span class="attr">size:</span>  </span><br><span class="line"></span><br><span class="line">  <span class="comment"># 文章字体</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 代码字体</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Consolas</span> <span class="comment">#vs等宽字体</span></span><br></pre></td></tr></table></figure>



<h5 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h5><p>评论系统<code>next</code>支持很多版本, 随意选择自己喜欢的</p>
<p>我这里拿<code>Changyan</code>做了测试,使用还算方便</p>
<p>点击<a href="https://changyan.kuaizhan.com/">官网</a>,进入<code>畅言云评</code></p>
<p><img src="https://img.supervj.top//img/image-20201204140400688.png" alt="image-20201204140400688"></p>
<p>一路注册进去,最后得到类似下图的代码</p>
<p><img src="https://img.supervj.top//img/image-20201204140501083.png" alt="image-20201204140501083"></p>
<p>回头看我们<code>next</code>内的代码</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">changyan:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> </span><br><span class="line">  <span class="attr">appkey:</span></span><br></pre></td></tr></table></figure>

<p>发现略微有区别,没事, 我们霸王硬上弓,<code>appid</code>就填上, 把<code>conf</code>内容复制到<code>appkey</code>中</p>
<p><img src="https://img.supervj.top//img/image-20201204140616055.png" alt="image-20201204140616055"></p>
<p>测试完成发现正常工作, 就是评价之前需要登陆一下系统还得绑定手机, 略微麻烦</p>
<p>登录后台发现已有记录</p>
<p><img src="https://img.supervj.top//img/image-20201204140702577.png" alt="image-20201204140702577"></p>
<h5 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>

<p>打开博客文件如上注释,同时在博客根目录的<code>source</code>内创建如代码所示文件,此文件是自定义样式的文件</p>
<h6 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h6><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">body</span> &#123;</span><br><span class="line">    <span class="string">background-image:url(https://source.unsplash.com/random/1600x900);</span></span><br><span class="line">    <span class="attr">background-repeat:</span> <span class="literal">no</span><span class="string">-repeat;</span></span><br><span class="line">    <span class="attr">background-attachment:</span> <span class="string">fixed;</span></span><br><span class="line">    <span class="attr">background-position:</span> <span class="string">center;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h6><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.main-inner</span> &#123;</span><br><span class="line">    <span class="attr">background-color:</span> <span class="string">rgba(255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.88</span><span class="string">);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="边框圆滑"><a href="#边框圆滑" class="headerlink" title="边框圆滑"></a>边框圆滑</h6><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.header-inner</span> &#123;</span><br><span class="line">    <span class="attr">border-radius:</span> <span class="string">30px</span> <span class="string">30px</span> <span class="string">30px</span> <span class="string">30px;</span></span><br><span class="line">    <span class="attr">box-shadow:</span> <span class="string">8px</span> <span class="string">7px</span> <span class="string">2px</span> <span class="number">0</span> <span class="string">rgba(0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span><span class="string">)</span>, <span class="string">7px</span> <span class="string">4px</span> <span class="string">1px</span> <span class="string">-2px</span> <span class="string">rgba(0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.06</span><span class="string">)</span>, <span class="number">0</span> <span class="string">1px</span> <span class="string">5px</span> <span class="number">0</span> <span class="string">rgba(0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span><span class="string">);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">.sidebar-inner&#123;</span></span><br><span class="line">    <span class="attr">border-radius:</span> <span class="string">30px</span> <span class="string">30px</span> <span class="string">30px</span> <span class="string">30px;</span></span><br><span class="line">    <span class="attr">box-shadow:</span> <span class="string">8px</span> <span class="string">7px</span> <span class="string">2px</span> <span class="number">0</span> <span class="string">rgba(0,0,0,0.12),</span> <span class="string">7px</span> <span class="string">4px</span> <span class="string">1px</span> <span class="string">-2px</span> <span class="string">rgba(0,0,0,0.06),</span> <span class="number">0</span> <span class="string">1px</span> <span class="string">5px</span> <span class="number">0</span> <span class="string">rgba(0,0,0,0.12);</span>    </span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.pagination</span> &#123;</span><br><span class="line">    <span class="attr">border-radius:</span> <span class="string">30px</span> <span class="string">80px</span> <span class="string">30px</span> <span class="string">80px;</span></span><br><span class="line">    <span class="attr">box-shadow:</span> <span class="string">8px</span> <span class="string">7px</span> <span class="string">2px</span> <span class="number">0</span> <span class="string">rgba(0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span><span class="string">)</span>, <span class="string">7px</span> <span class="string">4px</span> <span class="string">1px</span> <span class="string">-2px</span> <span class="string">rgba(0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.06</span><span class="string">)</span>, <span class="number">0</span> <span class="string">1px</span> <span class="string">5px</span> <span class="number">0</span> <span class="string">rgba(0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span><span class="string">);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="代码风格-普通模式的"><a href="#代码风格-普通模式的" class="headerlink" title="代码风格(普通模式的)"></a>代码风格(普通模式的)</h6><ul>
<li>默认颜色</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">code</span> &#123;</span><br><span class="line">  <span class="attr">padding:</span> <span class="string">3px</span> <span class="string">5px;</span></span><br><span class="line">  <span class="attr">word-wrap:</span> <span class="string">break-word;</span></span><br><span class="line">  <span class="attr">color:</span> <span class="comment">#32CD32;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="comment">#F0F8FF;</span></span><br><span class="line">  <span class="attr">border-radius:</span> <span class="string">6px;</span></span><br><span class="line">  <span class="attr">font-size:</span> <span class="string">15px;</span></span><br><span class="line">  <span class="attr">font-weight:</span> <span class="string">Bolder;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>鼠标选择的颜色</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">鼠标选择的段落变成绿色</span></span><br><span class="line"><span class="string">::selection</span> &#123;</span><br><span class="line">    <span class="attr">background-color:</span> <span class="comment">#59ff83;</span></span><br><span class="line">    <span class="attr">color:</span> <span class="comment">#555;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="阅读全文按钮"><a href="#阅读全文按钮" class="headerlink" title="阅读全文按钮"></a>阅读全文按钮</h6><p>需要配合<code>md</code>文档中给与阅读全文的代码</p>
<p><code>&lt;!-- more --&gt;</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.post-button</span> <span class="string">.btn</span> &#123;</span><br><span class="line">    <span class="attr">color:</span> <span class="comment">#555!important;</span></span><br><span class="line">    <span class="attr">background-color:</span> <span class="comment">#fff;</span></span><br><span class="line">    <span class="attr">border-radius:</span> <span class="string">3px;</span></span><br><span class="line">    <span class="attr">font-size:</span> <span class="string">15px;</span></span><br><span class="line">    <span class="attr">box-shadow:</span> <span class="string">inset</span> <span class="number">0</span> <span class="number">0</span> <span class="string">10px</span> <span class="number">0</span> <span class="comment">#e346035c;</span></span><br><span class="line">    <span class="attr">border:</span> <span class="string">none!important;</span></span><br><span class="line">    <span class="attr">transition-property:</span> <span class="string">unset;</span></span><br><span class="line">    <span class="attr">padding:</span> <span class="number">0</span> <span class="string">15px;</span></span><br><span class="line">    <span class="attr">border-radius:</span> <span class="string">30px</span> <span class="string">30px</span> <span class="string">30px</span> <span class="string">30px;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="strong字体"><a href="#strong字体" class="headerlink" title="strong字体"></a>strong字体</h6><p>strong字体包括<strong>两个星号</strong> 和 </p>
<ul>
<li>这样的</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">strong&#123;</span></span><br><span class="line"><span class="attr">font-weight:</span> <span class="string">bold;</span></span><br><span class="line">    <span class="attr">background-color:</span> <span class="comment">#E6E6FA;  </span></span><br><span class="line">    <span class="attr">border-radius:</span> <span class="string">39px;</span></span><br><span class="line">    <span class="attr">color:</span> <span class="comment">#171be7;</span></span><br><span class="line">    <span class="attr">padding-left:</span> <span class="string">0px;</span></span><br><span class="line">    <span class="attr">padding-right:</span> <span class="string">1px;</span></span><br><span class="line">    <span class="attr">text-shadow:</span> <span class="string">1px</span> <span class="string">1px</span> <span class="string">1px</span> <span class="comment">#0003;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20201204144618614.png" alt="image-20201204144618614"></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>DX学习笔记（四）：绘制几何体</title>
    <url>/2020/06/30/LearnDX12_DrawGeo/</url>
    <content><![CDATA[<h2 id="用DirectX绘制几何体"><a href="#用DirectX绘制几何体" class="headerlink" title="用DirectX绘制几何体"></a>用DirectX绘制几何体</h2><p><img src="https://img.supervj.top/img/DX/DrawBox.gif"></p>
<h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><h5 id="顶点与输入布局"><a href="#顶点与输入布局" class="headerlink" title="顶点与输入布局"></a>顶点与输入布局</h5><ol>
<li>创建顶点结构体</li>
<li>设置输入布局描述<code>D3D12_INPUT_ELEMENT_DESC</code></li>
</ol>
<h5 id="顶点-索引缓冲区"><a href="#顶点-索引缓冲区" class="headerlink" title="顶点/索引缓冲区"></a>顶点/索引缓冲区</h5><ol>
<li>创建顶点数据/索引数据</li>
<li>创建缓冲区/索引缓冲区</li>
</ol>
<h5 id="顶点着色-像素着色"><a href="#顶点着色-像素着色" class="headerlink" title="顶点着色/像素着色"></a>顶点着色/像素着色</h5><ol>
<li>编写HLSL着色器文件</li>
<li>编译着色器</li>
</ol>
<h5 id="常量缓冲区（上传堆，CPU可写，GPU可读）"><a href="#常量缓冲区（上传堆，CPU可写，GPU可读）" class="headerlink" title="常量缓冲区（上传堆，CPU可写，GPU可读）"></a>常量缓冲区（上传堆，CPU可写，GPU可读）</h5><ol>
<li>填充常量缓冲区所需的描述符(<code>D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV</code>)</li>
<li>构造缓冲区对象（单独的类），该类创建常量缓冲区</li>
<li>设置缓冲区大小为256B的整数倍</li>
<li>创建常量缓冲区视图</li>
<li>创建根签名</li>
</ol>
<blockquote>
<p>后续在提交命令列表的时候讲根签名和常量缓冲区绑定到流水线</p>
</blockquote>
<h5 id="流水线状态对象-PSO"><a href="#流水线状态对象-PSO" class="headerlink" title="流水线状态对象 PSO"></a>流水线状态对象 PSO</h5><ol>
<li>创建PSO对象 <code>D3D12_GRAPHICS_PIPELINE_STATE_DESC</code></li>
<li>设置PSO对象的各类参数，包括输入布局描述符、根签名、PS、VS、光栅器对象等</li>
<li>通过<code>md3dDevice-&gt;CreateGraphicsPipelineState(&amp;psoDesc,IID_PPV_ARGS(&amp;mPSO))</code>创建PSO</li>
</ol>
<h5 id="构建几何体"><a href="#构建几何体" class="headerlink" title="构建几何体"></a>构建几何体</h5><ol>
<li>顶点/索引数据，布局描述</li>
<li>创建Geo类，并且设置类内参数，这些参数在填充视口描述的时候需要</li>
<li>创建顶点/索引缓冲区</li>
<li>在绘制阶段通过命令列表将顶点和索引视图绑定到流水线插槽</li>
<li>通过<code>DrawIndexedInstanced</code>绘制几何体</li>
</ol>
<h5 id="刷新（update）"><a href="#刷新（update）" class="headerlink" title="刷新（update）"></a>刷新（update）</h5><ol>
<li>根据鼠标信息重新构建观察矩阵（相对坐标的变换）</li>
<li>刷新常量缓冲区</li>
</ol>
<h5 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h5><ol>
<li>重新构建透视投影矩阵</li>
<li>然后反馈到Update的常量缓冲区上</li>
</ol>
<blockquote>
<p>世界矩阵随移动/旋转/缩放而改变</p>
<p>观察矩阵随虚拟摄像机的移动/旋转/缩放而改变</p>
<p>投影矩阵随窗口大小调整而改变</p>
</blockquote>
<blockquote>
<p>刷新的数据通过根签名设置到着色器</p>
</blockquote>
<h3 id="顶点与输入布局-1"><a href="#顶点与输入布局-1" class="headerlink" title="顶点与输入布局"></a>顶点与输入布局</h3><ul>
<li>顶点结构体</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XMFLOAT3 Pos;</span><br><span class="line">    XMFLOAT4 Color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XMFLOAT3 Pos;</span><br><span class="line">    XMFLOAT3 Normal;</span><br><span class="line">    XMFLOAT2 Tex0;</span><br><span class="line">    XMFLOAT2 Tex1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>输入布局描述</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_INPUT_LAYOUT_DESC</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    _Field_size_full_(NumElements)  <span class="keyword">const</span> D3D12_INPUT_ELEMENT_DESC *pInputElementDescs;</span><br><span class="line">    UINT NumElements;<span class="comment">//数量</span></span><br><span class="line">    &#125; 	D3D12_INPUT_LAYOUT_DESC;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_INPUT_ELEMENT_DESC</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    LPCSTR SemanticName;</span><br><span class="line">    UINT SemanticIndex;</span><br><span class="line">    DXGI_FORMAT Format;</span><br><span class="line">    UINT InputSlot;</span><br><span class="line">    UINT AlignedByteOffset;</span><br><span class="line">    D3D12_INPUT_CLASSIFICATION InputSlotClass;</span><br><span class="line">    UINT InstanceDataStepRate;</span><br><span class="line">    &#125; 	D3D12_INPUT_ELEMENT_DESC;</span><br></pre></td></tr></table></figure>

<ol>
<li>SemanticName：语义，用于将<strong>顶点结构体</strong>中的元素与<strong>顶点着色器</strong>输入签名（参数列表）中的元素映射起来</li>
<li>SemanticIndex：附加到语义的索引。</li>
<li>Format：顶点元素格式，如<code>DXGI_FORMAT_R32_FLOAT</code>1D32位浮点标量</li>
<li>InputSlot：传递元素所用的输入槽，DirectX12一共16个，索引0-15，一般用同一个输入槽即输入槽0</li>
<li>AlignedByteOffset：顶点结构体的首地址到某点元素起始地址的偏移量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XMFLOAT3 Pos;<span class="comment">//偏移0字节</span></span><br><span class="line">    XMFLOAT3 Normal;<span class="comment">//偏移12字节</span></span><br><span class="line">    XMFLOAT2 Tex0;<span class="comment">//偏移24字节</span></span><br><span class="line">    XMFLOAT2 Tex1;<span class="comment">//偏移32字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>InputSlotClass：一般指定为<code>D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA</code>，另外一种<code>D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA</code>用于实现实例化的高级技术</li>
<li>InstanceDataStepRate：一般设置0，如果采用实例化就用1</li>
</ol>
<ul>
<li>示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">D3D12_INPUT_ELEMENT_DESC desc1 =</span><br><span class="line">  &#123;</span><br><span class="line">      &#123; <span class="string">&quot;POSITION&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="number">0</span>, <span class="number">0</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">      &#123; <span class="string">&quot;COLOR&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">D3D12_INPUT_ELEMENT_DESC desc2 =</span><br><span class="line">  &#123;</span><br><span class="line">      &#123; <span class="string">&quot;POSITION&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="number">0</span>, <span class="number">0</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">      &#123; <span class="string">&quot;NORMAL&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;TEXCOORD&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="number">0</span>, <span class="number">24</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">      &#123; <span class="string">&quot;TEXCOORD&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">32</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>



<h3 id="顶点缓冲区"><a href="#顶点缓冲区" class="headerlink" title="顶点缓冲区"></a>顶点缓冲区</h3><p>为了使GPU可以访问顶点数组，就需要把它们放置在<code>缓冲区</code>的GPU资源（ID2D12Resource）</p>
<ul>
<li><p>顶点缓冲区：存储顶点的缓冲区</p>
</li>
<li><p>缓冲区描述:<code>CD3D12_RESOURCE_DESC</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CD3DX12_RESOURCE_DESC</span> :</span> <span class="keyword">public</span> D3D12_RESOURCE_DESC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CD3DX12_RESOURCE_DESC</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CD3DX12_RESOURCE_DESC</span><span class="params">( <span class="keyword">const</span> D3D12_RESOURCE_DESC&amp; o )</span> :</span></span><br><span class="line"><span class="function">        D3D12_RESOURCE_DESC( o )</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    <span class="built_in">CD3DX12_RESOURCE_DESC</span>( </span><br><span class="line">        D3D12_RESOURCE_DIMENSION dimension,</span><br><span class="line">        UINT64 alignment,</span><br><span class="line">        UINT64 width,</span><br><span class="line">        UINT height,</span><br><span class="line">        UINT16 depthOrArraySize,</span><br><span class="line">        UINT16 mipLevels,</span><br><span class="line">        DXGI_FORMAT format,</span><br><span class="line">        UINT sampleCount,</span><br><span class="line">        UINT sampleQuality,</span><br><span class="line">        D3D12_TEXTURE_LAYOUT layout,</span><br><span class="line">        D3D12_RESOURCE_FLAGS flags )</span><br><span class="line">        <span class="comment">/**********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此描述继承自<code>D3D_RESOURCE_DESC</code>，重点实现了几个比较便捷的方法如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> CD3DX12_RESOURCE_DESC <span class="title">Buffer</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">       UINT64 width,</span></span></span><br><span class="line"><span class="params"><span class="function">       D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,</span></span></span><br><span class="line"><span class="params"><span class="function">       UINT64 alignment = <span class="number">0</span> )</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">CD3DX12_RESOURCE_DESC</span>( D3D12_RESOURCE_DIMENSION_BUFFER, alignment, width, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, </span><br><span class="line">           DXGI_FORMAT_UNKNOWN, <span class="number">1</span>, <span class="number">0</span>, D3D12_TEXTURE_LAYOUT_ROW_MAJOR, flags );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其他还有比如<code>CD3DX12_RESOURCE_DESC::Tex1D,CD3DX12_RESOURCE_DESC::2D</code>等便捷方法</p>
<p>然后通过<code>ID3D12Device::CreateCommittedResource</code>方法创建<code>ID3D12Resource</code>对象</p>
<ul>
<li>示例：创建默认缓冲区函数申明</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the actual default buffer resource.</span></span><br><span class="line">  <span class="built_in">ThrowIfFailed</span>(device-&gt;<span class="built_in">CreateCommittedResource</span>(</span><br><span class="line">      &amp;<span class="built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),</span><br><span class="line">      D3D12_HEAP_FLAG_NONE,</span><br><span class="line">      &amp;CD3DX12_RESOURCE_DESC::<span class="built_in">Buffer</span>(byteSize),</span><br><span class="line">D3D12_RESOURCE_STATE_COMMON,</span><br><span class="line">      <span class="literal">nullptr</span>,</span><br><span class="line">      <span class="built_in">IID_PPV_ARGS</span>(defaultBuffer.<span class="built_in">GetAddressOf</span>())));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DX12中所有资源都用<code>ID3D12Resource</code>接口表示，DX11用各种比如<code>ID3D11Buffers</code>等表示</p>
</blockquote>
<p>为了优化性能，静态几何体的顶点缓冲区置于默认堆中</p>
<p>因为CPU不能向默认堆(<code>D3D12_HEAP_TYPE_DEFAULT</code>)中的顶点缓冲区写入数据，所以就需要用到一个中介</p>
<ul>
<li><p>上传缓冲区<br>为了将数据从CPU复制到GPU显存中，即将顶点数据从系统内存复制到上传缓冲区，然后再复制到真正的顶点缓冲区中</p>
</li>
<li><p>示例:创建默认缓冲区函数实现</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Microsoft::<span class="function">WRL::ComPtr&lt;ID3D12Resource&gt; <span class="title">d3dUtil::CreateDefaultBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ID3D12Device* device,</span></span></span><br><span class="line"><span class="params"><span class="function">    ID3D12GraphicsCommandList* cmdList,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">void</span>* initData,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT64 byteSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt;&amp; uploadBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComPtr&lt;ID3D12Resource&gt; defaultBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建实际的默认缓冲区资源</span></span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(device-&gt;<span class="built_in">CreateCommittedResource</span>(</span><br><span class="line">        &amp;<span class="built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),</span><br><span class="line">        D3D12_HEAP_FLAG_NONE,</span><br><span class="line">        &amp;CD3DX12_RESOURCE_DESC::<span class="built_in">Buffer</span>(byteSize),</span><br><span class="line">		D3D12_RESOURCE_STATE_COMMON,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="built_in">IID_PPV_ARGS</span>(defaultBuffer.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了将CPU端内存中的数据复制到缓冲区，我们就创建处于中介位置的上传堆</span></span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(device-&gt;<span class="built_in">CreateCommittedResource</span>(</span><br><span class="line">        &amp;<span class="built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),</span><br><span class="line">		D3D12_HEAP_FLAG_NONE,</span><br><span class="line">        &amp;CD3DX12_RESOURCE_DESC::<span class="built_in">Buffer</span>(byteSize),</span><br><span class="line">		D3D12_RESOURCE_STATE_GENERIC_READ,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="built_in">IID_PPV_ARGS</span>(uploadBuffer.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述我们希望复制到默认缓冲区的数据</span></span><br><span class="line">    D3D12_SUBRESOURCE_DATA subResourceData = &#123;&#125;;</span><br><span class="line">    subResourceData.pData = initData;</span><br><span class="line">    subResourceData.RowPitch = byteSize;</span><br><span class="line">    subResourceData.SlicePitch = subResourceData.RowPitch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据复制到默认缓冲区的流程</span></span><br><span class="line">    <span class="comment">//UpdateSubresources辅助函数将数据从CPU复制到上传堆</span></span><br><span class="line">    <span class="comment">//再通过ID3D12CommandList::CopySubresourceRegion函数复制到mBuff中</span></span><br><span class="line">	cmdList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(defaultBuffer.<span class="built_in">Get</span>(), </span><br><span class="line">		D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_COPY_DEST));</span><br><span class="line">    UpdateSubresources&lt;<span class="number">1</span>&gt;(cmdList, defaultBuffer.<span class="built_in">Get</span>(), uploadBuffer.<span class="built_in">Get</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, &amp;subResourceData);</span><br><span class="line">	cmdList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(defaultBuffer.<span class="built_in">Get</span>(),</span><br><span class="line">		D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_GENERIC_READ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uploadBuffer必须在调用方法以后依然存在，因为命令列表的复制操作可能未执行，等调用者复制完消息以后才可以释放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> defaultBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>D3D12_SUBRESOURCE_DATA</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_SUBRESOURCE_DATA</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *pData;<span class="comment">//初始化缓冲区所用的数据指针</span></span><br><span class="line">    LONG_PTR RowPitch;<span class="comment">//对于缓冲区，此参数为欲复制数据的字节数</span></span><br><span class="line">    LONG_PTR SlicePitch;<span class="comment">//同上</span></span><br><span class="line">    &#125; 	D3D12_SUBRESOURCE_DATA;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例：创建有立方体8个顶点的默认缓冲区</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> std::array&lt;Vertex, 8&gt; vertices =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::White) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(<span class="number">-1.0f</span>, +<span class="number">1.0f</span>, <span class="number">-1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Black) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(+<span class="number">1.0f</span>, +<span class="number">1.0f</span>, <span class="number">-1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Red) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(+<span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Green) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, +<span class="number">1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Blue) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(<span class="number">-1.0f</span>, +<span class="number">1.0f</span>, +<span class="number">1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Yellow) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(+<span class="number">1.0f</span>, +<span class="number">1.0f</span>, +<span class="number">1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Cyan) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(+<span class="number">1.0f</span>, <span class="number">-1.0f</span>, +<span class="number">1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Magenta) &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UINT vbByteSize = (UINT)vertices.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line">Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; VertexBufferGPU = <span class="literal">nullptr</span>;</span><br><span class="line">Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; VertexBufferUploader = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">mBoxGeo-&gt;VertexBufferGPU = d3dUtil::<span class="built_in">CreateDefaultBuffer</span>(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">		mCommandList.<span class="built_in">Get</span>(), vertices.<span class="built_in">data</span>(), vbByteSize, mBoxGeo-&gt;VertexBufferUploader);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top/img/DX/image-20200630173313574.png" alt="image-20200630173313574"></p>
<ul>
<li>顶点缓冲区视图:为了将顶点缓冲区绑定到渲染流水线</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_VERTEX_BUFFER_VIEW</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;</span><br><span class="line">    UINT SizeInBytes;</span><br><span class="line">    UINT StrideInBytes;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<ol>
<li>BufferLocation：顶点缓冲区的虚拟地址，通过<code>ID3D12Resource::GetGPUVirtualAddress</code>方法得到此地址</li>
<li>SizeInBytes：顶点缓冲区大小（字节）</li>
<li>StrideInBytes：每个顶点元素占用的字节</li>
</ol>
<p>然后将顶点缓冲区视图和渲染流水线上的一个输入槽绑定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数：所用的输入槽，一般用0</span></span><br><span class="line"><span class="comment">//第二个参数：与输入槽绑定的缓冲区数量，即pView数组中视图的数量</span></span><br><span class="line"><span class="comment">//视图数组的第一个元素的地址</span></span><br><span class="line">mCommandList-&gt;<span class="built_in">IASetVertexBuffers</span>(<span class="number">0</span>, <span class="number">1</span>, &amp;mBoxGeo-&gt;<span class="built_in">VertexBufferView</span>());</span><br></pre></td></tr></table></figure>



<blockquote>
<p>将顶点缓冲区置入输入槽并不会进行绘制操作，仅仅是为顶点数据送至渲染流水线做好准备</p>
</blockquote>
<p>真正绘制顶点的方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数1：每个实例绘制的顶点数</span></span><br><span class="line"><span class="comment">//参数2：实例化高级技术，目前给1</span></span><br><span class="line"><span class="comment">//参数3：第一个被绘制顶点的索引</span></span><br><span class="line"><span class="comment">//参数4：实例化技术，目前给0</span></span><br><span class="line">mCommandList-&gt;<span class="built_in">DrawIndexedInstanced</span>(</span><br><span class="line">		mBoxGeo-&gt;DrawArgs[<span class="string">&quot;box&quot;</span>].IndexCount, </span><br><span class="line">		<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="索引和索引缓冲区"><a href="#索引和索引缓冲区" class="headerlink" title="索引和索引缓冲区"></a>索引和索引缓冲区</h3><ul>
<li>索引缓冲区</li>
</ul>
<p>与顶点类似，为了使GPU可以访问索引数组，需要将它们放置于GPU的缓冲区资源内,此缓冲区即<code>索引缓冲区</code></p>
<p>同样用<code>CreateDefaultBuffer</code>方法创建索引缓冲区</p>
<p>索引缓冲区用到结构体<code>D3D12_INDEX_BUFFER_VIEW</code>描述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_INDEX_BUFFER_VIEW</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;<span class="comment">//带创建索引缓冲区虚拟地址，用ID3D12Resource::GetGUPVirtualAddress()得到</span></span><br><span class="line">    UINT SizeInBytes;<span class="comment">//索引缓冲区大小</span></span><br><span class="line">    DXGI_FORMAT Format;<span class="comment">//必须为DXGI_FORMAT_R16_UINT类型或者DXGI_FORMAT_R32_UINT</span></span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>同顶点缓冲区，也需要绑定到渲染流水线，通过<code>ID3D12GraphicsCommandList::IASetIndexBuffer</code>方法将索引缓冲区绑定到输入装配器阶段</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	std::array&lt;std::<span class="keyword">uint16_t</span>, 36&gt; indices =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// front face</span></span><br><span class="line">		<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">		<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">		<span class="comment">// back face</span></span><br><span class="line">		<span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>,</span><br><span class="line">		<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">		<span class="comment">// left face</span></span><br><span class="line">		<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>,</span><br><span class="line">		<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">		<span class="comment">// right face</span></span><br><span class="line">		<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>,</span><br><span class="line">		<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">		<span class="comment">// top face</span></span><br><span class="line">		<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">		<span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">		<span class="comment">// bottom face</span></span><br><span class="line">		<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>,</span><br><span class="line">		<span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UINT ibByteSize = (UINT)indices.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(std::<span class="keyword">uint16_t</span>);</span><br><span class="line"></span><br><span class="line">Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; IndexBufferGPU = <span class="literal">nullptr</span>;</span><br><span class="line">Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; IndexBufferUploader = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">mBoxGeo-&gt;IndexBufferGPU = d3dUtil::<span class="built_in">CreateDefaultBuffer</span>(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">		mCommandList.<span class="built_in">Get</span>(), indices.<span class="built_in">data</span>(), ibByteSize, mBoxGeo-&gt;IndexBufferUploader);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>使用索引时，要用<code>ID3D12GraphicsCommandList::DrawIndexedInstanced</code>代替<code>DrawInstanced</code>方法</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第4个参数：读取顶点之前，要为每个索引都加上的整数值</span></span><br><span class="line"><span class="comment">//其他参考顶点绘制</span></span><br><span class="line">mCommandList-&gt;<span class="built_in">DrawIndexedInstanced</span>(</span><br><span class="line">		mBoxGeo-&gt;DrawArgs[<span class="string">&quot;box&quot;</span>].IndexCount, </span><br><span class="line">		<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>将多个顶点缓冲区和索引缓冲区合并以后会需要用到第4个参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mCommandList-&gt;<span class="built_in">DrawIndexedInstanced</span>(numOfBox, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mCommandList-&gt;<span class="built_in">DrawIndexedInstanced</span>(numOfSph, <span class="number">1</span>, firstSphIdx, firstSphIdx, <span class="number">0</span>);</span><br><span class="line">mCommandList-&gt;<span class="built_in">DrawIndexedInstanced</span>(numOfCyl, <span class="number">1</span>, firstCylIdx, firstCylIdx, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<p><img src="https://img.supervj.top/img/DX/image-20200624172043571.png" alt="image-20200624172043571"></p>
<h3 id="顶点着色器示例"><a href="#顶点着色器示例" class="headerlink" title="顶点着色器示例"></a>顶点着色器示例</h3><ul>
<li>高级着色器语言：HLSL</li>
</ul>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cbuffer cbPerObject:<span class="built_in"><span class="keyword">register</span></span>(b0)</span><br><span class="line">&#123;</span><br><span class="line">    float4x4 gWorldViewProj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VS</span><span class="params">(float3 iPosL:POSITION,float4 iColor:COLOR,out float4 oPosH:SV_POSTION,out float4 oColor:COLOR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//把顶点变换到齐次裁剪空间</span></span><br><span class="line">    oPosH = <span class="built_in">mul</span>(<span class="built_in">float4</span>(iPosL,<span class="number">1.0f</span>),gWolrdViewProj);</span><br><span class="line">    <span class="comment">//将顶点颜色信息传至像素着色器</span></span><br><span class="line">    oColor=iColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HLSL没有指针和引用，用<code>out</code>表示输出参数</p>
<p>HLSL所有函数都是lnline函数</p>
<p>参数<code>POSITION</code>和<code>COLOR</code>语义将元素映射到顶点着色器对应的输入参数；同理输出参数的语义将参数映射到下一个阶段（几何着色器或者像素着色器）对应的输入参数；</p>
<p><code>SV_POSTION</code>的<code>SV</code>代表系统值，此数据存有齐次裁剪空间顶点信息，指定了此语义以后使GPU进行如裁剪、深度测试等处理时，实现其他属性无法介入的有关运算</p>
<p>任何没有系统修饰的参数，都可以根据需求以合法的语义修饰</p>
<p>可以把函数的参数封装成结构体，下面是另一种实现方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexIn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 PosL:POSTION;</span><br><span class="line">    float4 Color:COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 PosH:SV_POSTION;</span><br><span class="line">    float4 Color:COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VextexOut <span class="title">VS</span><span class="params">(VertexIn vin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VertexOut vout;</span><br><span class="line">    vout.PosH=<span class="built_in">mul</span>(<span class="built_in">float4</span>(vin.PosL,<span class="number">1.0f</span>),gWolrdViewProj);</span><br><span class="line">    vout.Color=vin.Color;</span><br><span class="line">    <span class="keyword">return</span> vout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果没有使用<code>几何着色器</code>，那么顶点着色器必须用<code>SV_POSITION</code>来输出顶点在齐次裁剪空间的位置</p>
<p>如果使用了，可以把得到齐次裁剪空间位置的工作交给它来处理</p>
<p>顶点着色器/几何着色器无法完成透视除法，此阶段只能完成投影矩阵运算，透视除法由后续硬件执行</p>
</blockquote>
<h5 id="布局描述符与签名匹配问题"><a href="#布局描述符与签名匹配问题" class="headerlink" title="布局描述符与签名匹配问题"></a>布局描述符与签名匹配问题</h5><p><code>ID3D12Device::CreateGraphicsPipelineState</code>函数时，需要指定布局描述符和顶点着色器,这就涉及到参数匹配问题</p>
<ul>
<li>不匹配</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XMFLOAT3 Pos;</span><br><span class="line">    XMFLOAT4 Color;</span><br><span class="line">    <span class="comment">//XMFLOAT3 Normal;//缺少此行输入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> D3D12_INPUT_ELEMENT_DESC[] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; <span class="string">&quot;POSITION&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="number">0</span>, <span class="number">0</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;COLOR&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">      &#123; <span class="string">&quot;NORMAL&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">24</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexIn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 PosL:POSTION;</span><br><span class="line">    float4 Color:COLOR;</span><br><span class="line">    float3 Normal:NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 PosH:SV_POSTION;</span><br><span class="line">    float4 Color:COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VertexOut <span class="title">VS</span><span class="params">(VertexIn vin)</span></span>&#123;...&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>匹配</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XMFLOAT3 Pos;</span><br><span class="line">    XMFLOAT4 Color;</span><br><span class="line">    XMFLOAT3 Normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> D3D12_INPUT_ELEMENT_DESC[] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; <span class="string">&quot;POSITION&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="number">0</span>, <span class="number">0</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;COLOR&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">      &#123; <span class="string">&quot;NORMAL&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">24</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexIn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 PosL:POSTION;</span><br><span class="line">    float4 Color:COLOR;</span><br><span class="line">    <span class="comment">//float3 Normal:NORMAL;//输入有多余的参数可以匹配</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 PosH:SV_POSTION;</span><br><span class="line">    float4 Color:COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VertexOut <span class="title">VS</span><span class="params">(VertexIn vin)</span></span>&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>匹配</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XMFLOAT3 Pos;</span><br><span class="line">    XMFLOAT4 Color;</span><br><span class="line">    XMFLOAT3 Normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> D3D12_INPUT_ELEMENT_DESC[] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; <span class="string">&quot;POSITION&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="number">0</span>, <span class="number">0</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;COLOR&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">      &#123; <span class="string">&quot;NORMAL&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">24</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexIn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 PosL:POSTION;</span><br><span class="line">    float4 Color:COLOR;</span><br><span class="line">    int3  Normal:NORMAL;<span class="comment">//Direct3D会对数据类型重新解释，但会报警告</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 PosH:SV_POSTION;</span><br><span class="line">    float4 Color:COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VertexOut <span class="title">VS</span><span class="params">(VertexIn vin)</span></span>&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="像素着色器示例"><a href="#像素着色器示例" class="headerlink" title="像素着色器示例"></a>像素着色器示例</h3><p>光栅化阶段先对顶点着色器进行插值计算，然后把数据传递至像素着色器作为输出</p>
<p>像素着色器针对每一个像素片段而运行的函数，但是部分像素片段不会传入或者留存在后台缓冲区，会在深度测试等情况被丢弃掉；即<strong>像素</strong>是最终写入后台缓冲区的数据，<strong>像素片段</strong>是候选像素</p>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cbuffer cbPerObject:<span class="built_in"><span class="keyword">register</span></span>(b0)</span><br><span class="line">&#123;</span><br><span class="line">    float4x4 gWorldViewProj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VS</span><span class="params">(float3 iPosL:POSITION,float4 iColor:COLOR,out float4 oPosH:SV_POSTION,out float4 oColor:COLOR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//把顶点变换到齐次裁剪空间</span></span><br><span class="line">    oPosH = <span class="built_in">mul</span>(<span class="built_in">float4</span>(iPosL,<span class="number">1.0f</span>),gWolrdViewProj);</span><br><span class="line">    <span class="comment">//将顶点颜色信息传至像素着色器</span></span><br><span class="line">    oColor=iColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">PS</span><span class="params">(float4 posH:SV_POSITION,float4 color:COLOR)</span>:SV_TARGET</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数列表后的<code>SV_TARGET</code>表示该返回值的类型樱岛与渲染目标格式相匹配(<code>render target format</code> )1</p>
<p>同样可以利用输入输出结构体来重写上述代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexIn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 PosL:POSTION;</span><br><span class="line">    float4 Color:COLOR;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 PosH:SV_POSTION;</span><br><span class="line">    float4 Color:COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VextexOut <span class="title">VS</span><span class="params">(VertexIn vin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VertexOut vout;</span><br><span class="line">    vout.PosH=<span class="built_in">mul</span>(<span class="built_in">float4</span>(vin.PosL,<span class="number">1.0f</span>),gWolrdViewProj);</span><br><span class="line">    vout.Color=vin.Color;</span><br><span class="line">    <span class="keyword">return</span> vout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">float4 <span class="title">PS</span><span class="params">(VertexOut pin)</span>:VS_TARGET</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> pin.Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="常量缓冲区"><a href="#常量缓冲区" class="headerlink" title="常量缓冲区"></a>常量缓冲区</h3><h5 id="创建常量缓冲区"><a href="#创建常量缓冲区" class="headerlink" title="创建常量缓冲区"></a>创建常量缓冲区</h5><p>常量缓冲区也是一种GPU资源<code>ID3D12Resource</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cbuffer cbPerObject:<span class="built_in"><span class="keyword">register</span></span>(b0)</span><br><span class="line">&#123;</span><br><span class="line">    float4x4 gWorldViewProj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码中的<code>cbuffer</code>对象（常量缓冲区）的名称就是<code>cbPerObject</code>，存储一个4x4矩阵<code>gWorldViewProj</code></p>
<p>此矩阵表示把一个点从局部空间变换到齐次裁剪空间所用到的由世界、视图和投影3种变换组合而成的矩阵</p>
<blockquote>
<p>与顶点和索引缓冲区不同，从常量缓冲区由CPU<strong>每帧更新顶一次</strong></p>
<p>常量缓冲区创建到上传堆而非默认堆，使得我们从CPU端更新常量</p>
<p>常量缓冲区的硬件有特别要求，<strong>大小必须为256B的整数倍</strong></p>
</blockquote>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectConstants</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XMFLOAT4X4 WorldViewProj = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> UINT mElementByteSize = d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T));<span class="comment">//换算使得缓冲区大小保持在256B的倍数</span></span><br><span class="line"></span><br><span class="line">Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; mUploadBuffer;</span><br><span class="line"><span class="built_in">ThrowIfFailed</span>(device-&gt;<span class="built_in">CreateCommittedResource</span>(</span><br><span class="line">            &amp;<span class="built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),</span><br><span class="line">            D3D12_HEAP_FLAG_NONE,</span><br><span class="line">            &amp;CD3DX12_RESOURCE_DESC::<span class="built_in">Buffer</span>(mElementByteSize*elementCount),</span><br><span class="line">			D3D12_RESOURCE_STATE_GENERIC_READ,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="built_in">IID_PPV_ARGS</span>(&amp;mUploadBuffer)));</span><br></pre></td></tr></table></figure>

<p><code>mUploadCBuffer</code>存储了一个<code>ObjectConstants</code>类型的常量缓冲区数组</p>
<p>绘制物体时，只要将常量缓冲区视图<code>CBV</code>绑定到那个存有物体相应常量缓冲区的子区域即可</p>
<ul>
<li>着色器模型5.1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectConstants</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4x4 gWorldViewProj;</span><br><span class="line">    uint matIndex;</span><br><span class="line">&#125;;</span><br><span class="line">ConstantBuffer&lt;ObjectConstants&gt; gObjConstants : <span class="built_in"><span class="keyword">register</span></span>(b0);</span><br></pre></td></tr></table></figure>

<p>常量缓冲区的数据元素被定义在一个单独的结构体中，随后用这个结构来创建一个常量缓冲区，然后就可以在着色器里访问常量缓冲区中的各个字段</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uint index = gObjConstants.matIndex;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>着色器模型定义了HLSL的编写规范，确定了其内置函数、着色器属性等一切语言元素</p>
</blockquote>
<h5 id="更新常量缓冲区"><a href="#更新常量缓冲区" class="headerlink" title="更新常量缓冲区"></a>更新常量缓冲区</h5><p>常量缓冲区是用<code>D3D12_HEAP_TYPE_UPLOAD</code>类型创建的，所以可以用CPU为常量缓冲区更新数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; mUploadBuffer;</span><br><span class="line">BYTE* mMappedData = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//参数1：预映射的子资源，对于缓冲区来说设置为0</span></span><br><span class="line"><span class="comment">//参数2：指向D3D12_RANGE结构体的可选项，描述了映射范围，如果是空就对整个资源映射</span></span><br><span class="line"><span class="comment">//参数3：双重指针返回待映射资源书的目标内存块</span></span><br><span class="line"><span class="built_in">ThrowIfFailed</span>(mUploadBuffer-&gt;<span class="built_in">Map</span>(<span class="number">0</span>, <span class="literal">nullptr</span>, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;mMappedData)));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(mMappedData,&amp;data,dataSizeInBytes);<span class="comment">//用此函数将数据从系统内存复制到常量缓冲区</span></span><br></pre></td></tr></table></figure>

<p>等更新完成，然后在释放映射内存之前对其进行<code>Unmap(取消映射)</code>操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mUploadBuffer != <span class="literal">nullptr</span>)</span><br><span class="line">    mUploadBuffer-&gt;<span class="built_in">Unmap</span>(<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">mMappedData = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p><code>Unmap</code>的第一个参数是子资源索引，第二个是指向<code>D3D12_RANGE</code>结构体的指针，描述取消映射的内存范围，如空则整个资源映射。</p>
<h5 id="上传缓冲区辅助函数"><a href="#上传缓冲区辅助函数" class="headerlink" title="上传缓冲区辅助函数"></a>上传缓冲区辅助函数</h5><ul>
<li>UploadBuffer类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UploadBuffer</span>(ID3D12Device* device, UINT elementCount, <span class="keyword">bool</span> isConstantBuffer) : </span><br><span class="line">        <span class="built_in">mIsConstantBuffer</span>(isConstantBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        mElementByteSize = <span class="built_in"><span class="keyword">sizeof</span></span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//常量缓冲区的大小为256B的整数倍</span></span><br><span class="line">        <span class="comment">//长度者两种规格来查看常量数据</span></span><br><span class="line">        <span class="comment">//UINT64 SizeInBytes;//256的整数倍</span></span><br><span class="line">        <span class="comment">//UINT OffsetInBytes;//256的整数倍</span></span><br><span class="line">        <span class="keyword">if</span>(isConstantBuffer)</span><br><span class="line">            mElementByteSize = d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ThrowIfFailed</span>(device-&gt;<span class="built_in">CreateCommittedResource</span>(</span><br><span class="line">            &amp;<span class="built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),</span><br><span class="line">            D3D12_HEAP_FLAG_NONE,</span><br><span class="line">            &amp;CD3DX12_RESOURCE_DESC::<span class="built_in">Buffer</span>(mElementByteSize*elementCount),</span><br><span class="line">			D3D12_RESOURCE_STATE_GENERIC_READ,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="built_in">IID_PPV_ARGS</span>(&amp;mUploadBuffer)));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ThrowIfFailed</span>(mUploadBuffer-&gt;<span class="built_in">Map</span>(<span class="number">0</span>, <span class="literal">nullptr</span>, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;mMappedData)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要还会需改当前的资源，我们就无需取消映射</span></span><br><span class="line">        <span class="comment">// 但是在资源被GPU使用期间，我们千万不可向该资源进行写操作（所以需要借助同步技术）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UploadBuffer</span>(<span class="keyword">const</span> UploadBuffer&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    UploadBuffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UploadBuffer&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">UploadBuffer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mUploadBuffer != <span class="literal">nullptr</span>)</span><br><span class="line">            mUploadBuffer-&gt;<span class="built_in">Unmap</span>(<span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        mMappedData = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ID3D12Resource* <span class="title">Resource</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mUploadBuffer.<span class="built_in">Get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CopyData</span><span class="params">(<span class="keyword">int</span> elementIndex, <span class="keyword">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;mMappedData[elementIndex*mElementByteSize], &amp;data, <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; mUploadBuffer;</span><br><span class="line">    BYTE* mMappedData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    UINT mElementByteSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> mIsConstantBuffer = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>世界矩阵随移动/旋转/缩放而改变</p>
<p>观察矩阵随虚拟摄像机的移动/旋转/缩放而改变</p>
<p>投影矩阵随窗口大小调整而改变</p>
</blockquote>
<ul>
<li>OnMouseMove</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BoxApp::OnMouseMove</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((btnState &amp; MK_LBUTTON) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据鼠标的移动距离计算旋转角度，令每个像素按此角度的1/4旋转</span></span><br><span class="line">        <span class="keyword">float</span> dx = <span class="built_in">XMConvertToRadians</span>(<span class="number">0.25f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x - mLastMousePos.x));</span><br><span class="line">        <span class="keyword">float</span> dy = <span class="built_in">XMConvertToRadians</span>(<span class="number">0.25f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(y - mLastMousePos.y));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据鼠标输入来更新摄像机绕立方体旋转的角度</span></span><br><span class="line">        mTheta += dx;</span><br><span class="line">        mPhi += dy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制角度mPhi的范围</span></span><br><span class="line">        mPhi = MathHelper::<span class="built_in">Clamp</span>(mPhi, <span class="number">0.1f</span>, MathHelper::Pi - <span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((btnState &amp; MK_RBUTTON) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使场景中的每个像素按鼠标移动距离的0.005倍进行缩放</span></span><br><span class="line">        <span class="keyword">float</span> dx = <span class="number">0.005f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x - mLastMousePos.x);</span><br><span class="line">        <span class="keyword">float</span> dy = <span class="number">0.005f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(y - mLastMousePos.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据鼠标的输入更新摄像机的可视范围半径</span></span><br><span class="line">        mRadius += dx - dy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制可视半径范围</span></span><br><span class="line">        mRadius = MathHelper::<span class="built_in">Clamp</span>(mRadius, <span class="number">3.0f</span>, <span class="number">15.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastMousePos.x = x;</span><br><span class="line">    mLastMousePos.y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Update</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BoxApp::Update</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将球坐标（球面坐标）转换为笛卡尔坐标系</span></span><br><span class="line">    <span class="keyword">float</span> x = mRadius*<span class="built_in">sinf</span>(mPhi)*<span class="built_in">cosf</span>(mTheta);</span><br><span class="line">    <span class="keyword">float</span> z = mRadius*<span class="built_in">sinf</span>(mPhi)*<span class="built_in">sinf</span>(mTheta);</span><br><span class="line">    <span class="keyword">float</span> y = mRadius*<span class="built_in">cosf</span>(mPhi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建观察矩阵</span></span><br><span class="line">    XMVECTOR pos = <span class="built_in">XMVectorSet</span>(x, y, z, <span class="number">1.0f</span>);</span><br><span class="line">    XMVECTOR target = <span class="built_in">XMVectorZero</span>();</span><br><span class="line">    XMVECTOR up = <span class="built_in">XMVectorSet</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    XMMATRIX view = <span class="built_in">XMMatrixLookAtLH</span>(pos, target, up);</span><br><span class="line">    <span class="built_in">XMStoreFloat4x4</span>(&amp;mView, view);</span><br><span class="line"></span><br><span class="line">    XMMATRIX world = <span class="built_in">XMLoadFloat4x4</span>(&amp;mWorld);</span><br><span class="line">    XMMATRIX proj = <span class="built_in">XMLoadFloat4x4</span>(&amp;mProj);</span><br><span class="line">    XMMATRIX worldViewProj = world*view*proj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用最新的 worldViewProj 矩阵来更新常量缓冲区</span></span><br><span class="line">	ObjectConstants objConstants;</span><br><span class="line">    <span class="built_in">XMStoreFloat4x4</span>(&amp;objConstants.WorldViewProj, <span class="built_in">XMMatrixTranspose</span>(worldViewProj));</span><br><span class="line">    mObjectCB-&gt;<span class="built_in">CopyData</span>(<span class="number">0</span>, objConstants);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="常量缓冲区描述符"><a href="#常量缓冲区描述符" class="headerlink" title="常量缓冲区描述符"></a>常量缓冲区描述符</h5><p>常量缓冲区描述符都存放在以<code>D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV</code>类型的描述符堆里，这个堆混合存储了常量缓冲区、着色器资源和无序访问描述符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">D3D12_DESCRIPTOR_HEAP_DESC cbvHeapDesc;</span><br><span class="line">   cbvHeapDesc.NumDescriptors = <span class="number">1</span>;</span><br><span class="line">   cbvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;</span><br><span class="line">   cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;</span><br><span class="line">cbvHeapDesc.NodeMask = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateDescriptorHeap</span>(&amp;cbvHeapDesc,</span><br><span class="line">       <span class="built_in">IID_PPV_ARGS</span>(&amp;mCbvHeap)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在创建着色器程序访问的描述符时，需要把Flags指定为<code>DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE</code></p>
</blockquote>
<p>然后通过如下代码创建常量缓冲区</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BoxApp::BuildConstantBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//此常量缓冲区存储了绘制n个物体所需的常量数据</span></span><br><span class="line">	std::unique_ptr&lt;UploadBuffer&lt;ObjectConstants&gt;&gt; mObjectCB = std::make_unique&lt;UploadBuffer&lt;ObjectConstants&gt;&gt;(md3dDevice.<span class="built_in">Get</span>(), <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	UINT objCBByteSize = d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ObjectConstants));</span><br><span class="line">	<span class="comment">//缓冲区的起始地址	</span></span><br><span class="line">	D3D12_GPU_VIRTUAL_ADDRESS cbAddress = mObjectCB-&gt;<span class="built_in">Resource</span>()-&gt;<span class="built_in">GetGPUVirtualAddress</span>();</span><br><span class="line">    <span class="comment">//偏移到常量缓冲区中绘制第i个物体所需的常量数据</span></span><br><span class="line">    <span class="keyword">int</span> boxCBufIndex = <span class="number">0</span>;</span><br><span class="line">	cbAddress += boxCBufIndex*objCBByteSize;</span><br><span class="line"></span><br><span class="line">	D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc;</span><br><span class="line">	cbvDesc.BufferLocation = cbAddress;</span><br><span class="line">	cbvDesc.SizeInBytes = d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ObjectConstants));</span><br><span class="line"></span><br><span class="line">	md3dDevice-&gt;<span class="built_in">CreateConstantBufferView</span>(</span><br><span class="line">		&amp;cbvDesc,</span><br><span class="line">		mCbvHeap-&gt;<span class="built_in">GetCPUDescriptorHandleForHeapStart</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="根签名和描述符表"><a href="#根签名和描述符表" class="headerlink" title="根签名和描述符表"></a>根签名和描述符表</h5><ul>
<li>根签名</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将纹理资源绑定到纹理寄存器槽0</span></span><br><span class="line">Texture2D gDiffuseMap : <span class="built_in"><span class="keyword">register</span></span>(t0);</span><br><span class="line"><span class="comment">//把下列采样器资源一次绑定到采样器槽0-5</span></span><br><span class="line">SamplerState gsamPointWrap : <span class="built_in"><span class="keyword">register</span></span>(s0);</span><br><span class="line">SamplerState gsamPointClamp : <span class="built_in"><span class="keyword">register</span></span>(s1);</span><br><span class="line"><span class="comment">//将常量缓冲区资源绑定到常量缓冲区寄存器槽0</span></span><br><span class="line">cbuffer cbPerObject : <span class="built_in"><span class="keyword">register</span></span>(b0)</span><br><span class="line">&#123;</span><br><span class="line">    float4x4 gWorld;</span><br><span class="line">    float4x4 gTexTransform;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绘制每种材质所需的各种不同的常量数据</span></span><br><span class="line">cbuffer cbMaterial : <span class="built_in"><span class="keyword">register</span></span>(b2)</span><br><span class="line">&#123;</span><br><span class="line">    float4 gDiffuseAlbedo;</span><br><span class="line">    float3 gFresnelR0;</span><br><span class="line">    <span class="keyword">float</span> gRoughness;</span><br><span class="line">    float4x4 gMatTransform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>register(*#)</code>中的<code>*</code>表示寄存器传递的资源类型。</p>
<p>t:着色器资源视图；</p>
<p>s:采样器</p>
<p>u:无序访问视图</p>
<p>b:常量缓冲区视图</p>
</blockquote>
<blockquote>
<p>在执行绘制命令之前，那些应用程序将绑定到渲染流水线上的资源，它们会被映射到着色器的对应输入寄存器。</p>
<p>根签名一定要与使用它的着色器相兼容，在创建流水线状态对象时会对此进行验证</p>
<p>不同的绘制调用可能会用到一组不同的着色器程序，意味着要用到不同的<strong>根签名</strong></p>
</blockquote>
<p>在Direct3D中，根签名由<code>ID3D12RootSignature</code>接口表示，并用一组描述绘制调用过程中着色器所需资源的<code>根参数</code>定义而成。</p>
<p>根参数可以是<code>根常量</code>、<code>根描述符</code>或者<code>描述符表</code></p>
<blockquote>
<p>如果把着色器程序看成是一个大函数，那顶点数据和常量数据就是从CPU传入着色器函数的参数，而根签名就好比这些参数的函数签名。所以根签名其实就是将着色器需要用到的数据绑定到对应的寄存器槽上，供着色器访问。</p>
</blockquote>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">oid <span class="title">BoxApp::BuildRootSignature</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Shader programs typically require resources as input (constant buffers,</span></span><br><span class="line">	<span class="comment">// textures, samplers).  The root signature defines the resources the shader</span></span><br><span class="line">	<span class="comment">// programs expect.  If we think of the shader programs as a function, and</span></span><br><span class="line">	<span class="comment">// the input resources as function parameters, then the root signature can be</span></span><br><span class="line">	<span class="comment">// thought of as defining the function signature.  </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根参数可以是根常量、根描述符或者描述符表</span></span><br><span class="line">	CD3DX12_ROOT_PARAMETER slotRootParameter[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个只存有一个CBV的描述符表</span></span><br><span class="line">	CD3DX12_DESCRIPTOR_RANGE cbvTable;</span><br><span class="line">	cbvTable.<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//1：表中的描述符数量，0：将此段描述符区域绑定至此基准着色器寄存器</span></span><br><span class="line">	slotRootParameter[<span class="number">0</span>].<span class="built_in">InitAsDescriptorTable</span>(<span class="number">1</span>, &amp;cbvTable);<span class="comment">//1：描述符区域的数量；table:指向描述符区域数组的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根签名由一组根参数构成</span></span><br><span class="line">	<span class="function">CD3DX12_ROOT_SIGNATURE_DESC <span class="title">rootSigDesc</span><span class="params">(<span class="number">1</span>, slotRootParameter, <span class="number">0</span>, <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建仅含一个槽位的根签名</span></span><br><span class="line">	ComPtr&lt;ID3DBlob&gt; serializedRootSig = <span class="literal">nullptr</span>;</span><br><span class="line">	ComPtr&lt;ID3DBlob&gt; errorBlob = <span class="literal">nullptr</span>;</span><br><span class="line">	HRESULT hr = <span class="built_in">D3D12SerializeRootSignature</span>(&amp;rootSigDesc, D3D_ROOT_SIGNATURE_VERSION_1,</span><br><span class="line">		serializedRootSig.<span class="built_in">GetAddressOf</span>(), errorBlob.<span class="built_in">GetAddressOf</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(errorBlob != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="built_in">OutputDebugStringA</span>((<span class="keyword">char</span>*)errorBlob-&gt;<span class="built_in">GetBufferPointer</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(hr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateRootSignature</span>(</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		serializedRootSig-&gt;<span class="built_in">GetBufferPointer</span>(),</span><br><span class="line">		serializedRootSig-&gt;<span class="built_in">GetBufferSize</span>(),</span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(&amp;mRootSignature)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Root parameter can be a table, root descriptor or root constants.</span></span><br><span class="line">	CD3DX12_ROOT_PARAMETER slotRootParameter[<span class="number">1</span>];</span><br><span class="line">cbvTable.<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV,<span class="comment">//描述符表的类型</span></span><br><span class="line">              <span class="number">1</span>, <span class="comment">//表中描述符的数量</span></span><br><span class="line">              <span class="number">0</span>);<span class="comment">//将这段描述符区域绑定至此基础着色器寄存器</span></span><br><span class="line">	slotRootParameter[<span class="number">0</span>].<span class="built_in">InitAsDescriptorTable</span>(<span class="number">1</span>,<span class="comment">//描述符区域的数量</span></span><br><span class="line">                                               &amp;cbvTable);<span class="comment">//指向描述符区域数组的指针</span></span><br></pre></td></tr></table></figure>

<p>上述代码创建了一个根参数，目的是将含有一个<code>CBV</code>的描述符表绑定到常量缓冲区寄存器0，即<code>HLSL</code>代码中的<code>register(b0)</code></p>
<hr>
<p>根签名至定义了应用程序要绑定到渲染流水线的资源，没有真正的执行任何资源绑定操作</p>
<p>只有通过命令列表设置根签名，才可以用<code>ID3D12GraphicsCommandList::SetGraphicsRootDescriptorTable</code> 方法令描述符表与渲染流水线绑定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mCommandList-&gt;<span class="built_in">SetGraphicsRootDescriptorTable</span>(<span class="number">0</span>, <span class="comment">//将根参数按此索引进行设置</span></span><br><span class="line">mCbvHeap-&gt;<span class="built_in">GetGPUDescriptorHandleForHeapStart</span>());<span class="comment">//此参数指定的是将要想着色器绑定的描述符表中的第一个描述符位于描述符堆中的句柄</span></span><br></pre></td></tr></table></figure>

<p>下列代码先将根签名和CBV堆设置到命令列表上，并随后通过设置描述符表来指定我们希望绑定到渲染流水线的资源</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mCommandList-&gt;<span class="built_in">SetGraphicsRootSignature</span>(mRootSignature.<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line">ID3D12DescriptorHeap* descriptorHeaps[] = &#123; mCbvHeap.<span class="built_in">Get</span>() &#125;;</span><br><span class="line">	mCommandList-&gt;<span class="built_in">SetDescriptorHeaps</span>(_countof(descriptorHeaps), descriptorHeaps);</span><br><span class="line"><span class="comment">//偏移到此次绘制调用所需的CBV处</span></span><br><span class="line"><span class="function">CD3DX12_GPU_DESCRIPTOR_HANDLE <span class="title">cbv</span><span class="params">(mCbvHeap-&gt;GetGPUDescriptorHandleForHeapStart())</span></span>;</span><br><span class="line">cbv.<span class="built_in">Offset</span>(cbvIndex,mCbvSrvUavDescriptorSize);</span><br><span class="line"></span><br><span class="line">mCommandList-&gt;<span class="built_in">SetGraphicsRootDescriptorTable</span>(<span class="number">0</span>,cbv);</span><br></pre></td></tr></table></figure>





<p>·</p>
<h3 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h3><p>着色器程序必须先被编译为一种可移植的字节码，接下来图形驱动程序将获取这些字节码，并将其重新便以为针对当前系统GPU所优化的本地指令[ATI1]</p>
<p>可以用如下函数在运行期间对着色器进行编译</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DCompileFromFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCWSTR pFileName,<span class="comment">//希望编译的以.hlsl作为扩展名的源代码文件</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> D3D_SHADER_MACRO *pDefines,<span class="comment">//本书中用nullptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ID3DInclude *pInclude,<span class="comment">//同上</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPOCSTR pEntrypoint,<span class="comment">//着色器入口点函数，一个.hlsl文件可能存有多个着色器程序</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR pTarget,<span class="comment">//指定所用着色器类型和版本的字符串，本书用的是5.0和5.1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT Flags1,<span class="comment">//一般用2种：D3DCOMPLIE_DEBUG/D3DCOMPILE_SKIP_OPTIMIZATIOIN，详见SDK</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT Flags2,<span class="comment">//本书不用</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ID3DBlob **ppCode,<span class="comment">//返回一个数据结构指针，存储着编译好的着色器对象字节码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ID3DBlob **ppErrorMsgs<span class="comment">//返回报错信息               </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>ID3DBlob</li>
</ul>
<p>一段普通的内存块，有2个接口方法</p>
<ol>
<li><code>LPVOID GetBufferPointer</code>:返回对象中数据的<code>void*</code>类型的指针，使用之前需要转换为适当类型</li>
<li><code>SIZE_T GetBufferSize</code>：返回缓冲区字节大小</li>
</ol>
<ul>
<li>运行时编译着色器函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ComPtr&lt;ID3DBlob&gt;  <span class="title">CompileShader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> std::wstring&amp; fileName, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> D3D_SHADER_MACRO* defines, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> std::string&amp; enteryPoint, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> std::string&amp; target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//若处于调试模式，则使用调试标志</span></span><br><span class="line">	UINT compileFlags = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG) || defined(_DEBUG)</span></span><br><span class="line">	<span class="comment">//用调试模式来编译着色器 | 指示编译器跳过优化阶段</span></span><br><span class="line">	compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// defined(DEBUG) || defined(_DEBUG)</span></span></span><br><span class="line"></span><br><span class="line">	HRESULT hr = S_OK;</span><br><span class="line"></span><br><span class="line">	ComPtr&lt;ID3DBlob&gt; byteCode = <span class="literal">nullptr</span>;</span><br><span class="line">	ComPtr&lt;ID3DBlob&gt; errors;</span><br><span class="line">	hr = <span class="built_in">D3DCompileFromFile</span>(fileName.<span class="built_in">c_str</span>(), <span class="comment">//hlsl源文件名</span></span><br><span class="line">		defines,	<span class="comment">//高级选项，指定为空指针</span></span><br><span class="line">		D3D_COMPILE_STANDARD_FILE_INCLUDE,	<span class="comment">//高级选项，可以指定为空指针</span></span><br><span class="line">		enteryPoint.<span class="built_in">c_str</span>(),	<span class="comment">//着色器的入口点函数名</span></span><br><span class="line">		target.<span class="built_in">c_str</span>(),		<span class="comment">//指定所用着色器类型和版本的字符串</span></span><br><span class="line">		compileFlags,	<span class="comment">//指示对着色器断代码应当如何编译的标志</span></span><br><span class="line">		<span class="number">0</span>,	<span class="comment">//高级选项</span></span><br><span class="line">		&amp;byteCode,	<span class="comment">//编译好的字节码</span></span><br><span class="line">		&amp;errors);	<span class="comment">//错误信息</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (errors != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">OutputDebugStringA</span>((<span class="keyword">char</span>*)errors-&gt;<span class="built_in">GetBufferPointer</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(hr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> byteCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="离线编译"><a href="#离线编译" class="headerlink" title="离线编译"></a>离线编译</h5><p>离线编译的原因</p>
<ol>
<li>对于复杂的着色器，编译耗时太长，因此借助离线编译即可缩短应用程序的加载时间</li>
<li>以便在早于运行时的构建处理期间提早发现编译错误</li>
<li>对于Windows9应用商店的应用而言，必须采取离线编译这种方式</li>
</ol>
<blockquote>
<p>一般用<code>.cso</code>为已编译的着色器对象的扩展名</p>
</blockquote>
<p>使用DirectX自带的<code>FXC</code>命令行编译工具编译</p>
<ul>
<li>如用CMD输入代码编译</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C:\<span class="function">Program <span class="title">Files</span> <span class="params">(x86)</span>\Windows Kits\10\bin\x86&gt;fxc.exe C:\Users\Administrator\Desktop\color.hlsl /T vs_5_0 /Fo <span class="string">&quot;color.cso&quot;</span> /E <span class="string">&quot;VS&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>成功输出<code>color.cso</code>文件</p>
<blockquote>
<p>compilation object save succeeded; see C:\Program Files (x86)\Windows Kits\10\bin\x86\color.cso</p>
</blockquote>
<ul>
<li>常用的编译参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/Od</td>
<td>禁用优化（利于调试）</td>
</tr>
<tr>
<td>/Zi</td>
<td>开启调试信息</td>
</tr>
<tr>
<td>/T “string”</td>
<td>着色器模型版本,如输入<code>vs_5_0</code></td>
</tr>
<tr>
<td>/E “string”</td>
<td>着色器入口，如案例中的<code>VS</code>,<code>PS</code></td>
</tr>
<tr>
<td>/Fo “string”</td>
<td>经过编译的着色器对象字节码</td>
</tr>
<tr>
<td>/Fc “string”</td>
<td>输出一个着色器汇编语言清单（调试、查阅细节）</td>
</tr>
</tbody></table>
<p>其他清单可以参考<a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dtools/dx-graphics-tools-fxc-syntax">微软SDK文档</a></p>
<h3 id="光栅器状态"><a href="#光栅器状态" class="headerlink" title="光栅器状态"></a>光栅器状态</h3><p>光栅器状态只接受配置，非可编程，由结构体<code>D3D12_RASTERIZER_DESC</code>表示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_RASTERIZER_DESC</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    D3D12_FILL_MODE FillMode;<span class="comment">//默认：D3D12_FILL_MODE_SOLID</span></span><br><span class="line">    D3D12_CULL_MODE CullMode;<span class="comment">//默认: D3D12_CULL_MODE_BACK</span></span><br><span class="line">    BOOL FrontCounterClockwise;<span class="comment">//默认:false</span></span><br><span class="line">    INT DepthBias;</span><br><span class="line">    FLOAT DepthBiasClamp;</span><br><span class="line">    FLOAT SlopeScaledDepthBias;</span><br><span class="line">    BOOL DepthClipEnable;</span><br><span class="line">    BOOL MultisampleEnable;</span><br><span class="line">    BOOL AntialiasedLineEnable;</span><br><span class="line">    UINT ForcedSampleCount;</span><br><span class="line">    D3D12_CONSERVATIVE_RASTERIZATION_MODE ConservativeRaster;</span><br><span class="line">    &#125; 	D3D12_RASTERIZER_DESC;</span><br></pre></td></tr></table></figure>

<p>FillMode:默认是实体渲染，如果用<code>D3D12_FILL_MODE_WIREFRAME</code>则是线框渲染</p>
<p>CullMode：默认剔除背面，<code>D3D12_CULL_MODE_NONE</code>不剔除，<code>D3D12_CULL_MODE_FRONT</code>剔除正面</p>
<p>FrontCounterClockwise：默认false，根据观察视角，将定点顺序为顺时针方向的三角形看作正面；如true则相反</p>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CD3DX12_RASTERIZER_DESC <span class="title">rsDesc</span><span class="params">(D3D12_DEFAULT)</span></span>;</span><br><span class="line">reDesc.FillMode = D3D12_FILL_MODE_WIREFRAME;</span><br><span class="line">reDesc.CullMode = D3D12_CULL_MODE_NONE;</span><br></pre></td></tr></table></figure>

<p><code>CD3DX12_RASTERIZER_DESC</code>是扩展自<code>D3DX12_RASTERIZER_DESC</code>的结构，添加了一些辅助构造函数的工具类，如接受<code>CD3DX12_DEFAULT</code>参数的构造函数。</p>
<p><code>CD3DX12_DEFAULT</code>是一个哑类型(dummy),将需要被初始化的成员重载为默认值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CD3DX12_DEFAULT</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> DECLSPEC_SELECTANY CD3DX12_DEFAULT D3D12_DEFAULT;</span><br></pre></td></tr></table></figure>

<h3 id="流水线状态对象"><a href="#流水线状态对象" class="headerlink" title="流水线状态对象"></a>流水线状态对象</h3><p><code>ID3D12PipelineState</code>表示<strong>流水线状态对象(PSO)</strong></p>
<p>结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_GRAPHICS_PIPELINE_STATE_DESC</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    ID3D12RootSignature *pRootSignature;<span class="comment">//指向一个于此PSO绑定的根签名，该根签名必须与PSO指定的着色器兼容</span></span><br><span class="line">    D3D12_SHADER_BYTECODE VS;<span class="comment">//待绑定的顶点着色器，用结构体 D3D12_SHADER_BYTECODE表示</span></span><br><span class="line">    D3D12_SHADER_BYTECODE PS;<span class="comment">//待绑定的像素着色器</span></span><br><span class="line">    D3D12_SHADER_BYTECODE DS;<span class="comment">//域着色器</span></span><br><span class="line">    D3D12_SHADER_BYTECODE HS;<span class="comment">//外壳着色器</span></span><br><span class="line">    D3D12_SHADER_BYTECODE GS;<span class="comment">//几何着色器</span></span><br><span class="line">    D3D12_STREAM_OUTPUT_DESC StreamOutput;<span class="comment">//流输出高级技术</span></span><br><span class="line">    D3D12_BLEND_DESC BlendState;<span class="comment">//混合，默认指定CD3DX12_BLEND_DESC(D3D12_DEFAULT)</span></span><br><span class="line">    UINT SampleMask;<span class="comment">//禁止的采样，默认0xffffffff都进行采样</span></span><br><span class="line">    D3D12_RASTERIZER_DESC RasterizerState;<span class="comment">//指定用来配置光栅器的光栅化状态</span></span><br><span class="line">    D3D12_DEPTH_STENCIL_DESC DepthStencilState;<span class="comment">//用于配置深度/模板测试的深度/模板状态，默认用D3D12_DEPTH_STENCIL_DESC(D3D12_DEFAULT)</span></span><br><span class="line">    D3D12_INPUT_LAYOUT_DESC InputLayout;<span class="comment">//输入布局描述，有两个成员，D3D12_INPUT_ELEMENT_DESC数组和一个表示元素个数的无符号整数</span></span><br><span class="line">    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue;</span><br><span class="line">    D3D12_PRIMITIVE_TOPOLOGY_TYPE PrimitiveTopologyType;<span class="comment">//图元的拓扑类型，D3D12_PRIMITIVE_TOPOLOGY_TYPE</span></span><br><span class="line">    UINT NumRenderTargets;<span class="comment">//同时所用的渲染目标数量</span></span><br><span class="line">    DXGI_FORMAT RTVFormats[ <span class="number">8</span> ];<span class="comment">//渲染目标格式</span></span><br><span class="line">    DXGI_FORMAT DSVFormat;<span class="comment">//深度/模板缓冲的格式</span></span><br><span class="line">    DXGI_SAMPLE_DESC SampleDesc;<span class="comment">//多重采样对每个像素采样的数量和质量级别</span></span><br><span class="line">    UINT NodeMask;</span><br><span class="line">    D3D12_CACHED_PIPELINE_STATE CachedPSO;</span><br><span class="line">    D3D12_PIPELINE_STATE_FLAGS Flags;</span><br><span class="line">    &#125; 	D3D12_GRAPHICS_PIPELINE_STATE_DESC;</span><br></pre></td></tr></table></figure>



<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;psoDesc, <span class="built_in"><span class="keyword">sizeof</span></span>(D3D12_GRAPHICS_PIPELINE_STATE_DESC));</span><br><span class="line">    psoDesc.InputLayout = &#123; mInputLayout.<span class="built_in">data</span>(), (UINT)mInputLayout.<span class="built_in">size</span>() &#125;;</span><br><span class="line">    psoDesc.pRootSignature = mRootSignature.<span class="built_in">Get</span>();</span><br><span class="line">    psoDesc.VS = </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;BYTE*&gt;(mvsByteCode-&gt;<span class="built_in">GetBufferPointer</span>()), </span><br><span class="line">		mvsByteCode-&gt;<span class="built_in">GetBufferSize</span>() </span><br><span class="line">	&#125;;</span><br><span class="line">    psoDesc.PS = </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;BYTE*&gt;(mpsByteCode-&gt;<span class="built_in">GetBufferPointer</span>()), </span><br><span class="line">		mpsByteCode-&gt;<span class="built_in">GetBufferSize</span>() </span><br><span class="line">	&#125;;</span><br><span class="line">    psoDesc.RasterizerState = <span class="built_in">CD3DX12_RASTERIZER_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">    psoDesc.BlendState = <span class="built_in">CD3DX12_BLEND_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">    psoDesc.DepthStencilState = <span class="built_in">CD3DX12_DEPTH_STENCIL_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">    psoDesc.SampleMask = UINT_MAX;</span><br><span class="line">    psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;</span><br><span class="line">    psoDesc.NumRenderTargets = <span class="number">1</span>;</span><br><span class="line">    psoDesc.RTVFormats[<span class="number">0</span>] = mBackBufferFormat;</span><br><span class="line">    psoDesc.SampleDesc.Count = m4xMsaaState ? <span class="number">4</span> : <span class="number">1</span>;</span><br><span class="line">    psoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    psoDesc.DSVFormat = mDepthStencilFormat;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateGraphicsPipelineState</span>(&amp;psoDesc, <span class="built_in">IID_PPV_ARGS</span>(&amp;mPSO)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PSO的验证和创建过于耗时，所以一般在初始化期间就生成PSO</p>
<p>视口和裁剪矩形等属性独立于PSO</p>
</blockquote>
<p>用不同的PSO绘制不同的物体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mCommandList-&gt;<span class="built_in">Reset</span>(mDirectCmdListAlloc.<span class="built_in">Get</span>(),mPSO1.<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line">mCommandList-&gt;<span class="built_in">Reset</span>(mDirectCmdListAlloc.<span class="built_in">Get</span>(),mPSO2.<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line">mCommandList-&gt;<span class="built_in">Reset</span>(mDirectCmdListAlloc.<span class="built_in">Get</span>(),mPSO3.<span class="built_in">Get</span>());</span><br></pre></td></tr></table></figure>









<h3 id="几何图形辅助结构体"><a href="#几何图形辅助结构体" class="headerlink" title="几何图形辅助结构体"></a>几何图形辅助结构体</h3><p>此结构体定义了MeshGeometry中存储的单个几何体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubmeshGeometry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	UINT IndexCount = <span class="number">0</span>;</span><br><span class="line">	UINT StartIndexLocation = <span class="number">0</span>;</span><br><span class="line">	INT BaseVertexLocation = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过此子网格来定义当前结构体中所存几何体的包围盒 bounding box ，后续章节会讲述</span></span><br><span class="line">	DirectX::BoundingBox Bounds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MeshGeometry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// 几何体网格集的名称</span></span><br><span class="line">	std::string Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统内存中的副本，由于顶点/索引可以是泛型格式，所以用Blob类型</span></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3DBlob&gt; VertexBufferCPU = <span class="literal">nullptr</span>;</span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3DBlob&gt; IndexBufferCPU  = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; VertexBufferGPU = <span class="literal">nullptr</span>;</span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; IndexBufferGPU = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; VertexBufferUploader = <span class="literal">nullptr</span>;</span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; IndexBufferUploader = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区数据</span></span><br><span class="line">	UINT VertexByteStride = <span class="number">0</span>;</span><br><span class="line">	UINT VertexBufferByteSize = <span class="number">0</span>;</span><br><span class="line">	DXGI_FORMAT IndexFormat = DXGI_FORMAT_R16_UINT;</span><br><span class="line">	UINT IndexBufferByteSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个结构体能够存储一组顶点/索引缓冲区中的多个几何体</span></span><br><span class="line">    <span class="comment">//用下列容器来定义子网格几何体，就能单独绘制其中的子网格</span></span><br><span class="line">	std::unordered_map&lt;std::string, SubmeshGeometry&gt; DrawArgs;</span><br><span class="line"></span><br><span class="line">	<span class="function">D3D12_VERTEX_BUFFER_VIEW <span class="title">VertexBufferView</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		D3D12_VERTEX_BUFFER_VIEW vbv;</span><br><span class="line">		vbv.BufferLocation = VertexBufferGPU-&gt;<span class="built_in">GetGPUVirtualAddress</span>();</span><br><span class="line">		vbv.StrideInBytes = VertexByteStride;</span><br><span class="line">		vbv.SizeInBytes = VertexBufferByteSize;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> vbv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">D3D12_INDEX_BUFFER_VIEW <span class="title">IndexBufferView</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		D3D12_INDEX_BUFFER_VIEW ibv;</span><br><span class="line">		ibv.BufferLocation = IndexBufferGPU-&gt;<span class="built_in">GetGPUVirtualAddress</span>();</span><br><span class="line">		ibv.Format = IndexFormat;</span><br><span class="line">		ibv.SizeInBytes = IndexBufferByteSize;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ibv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等数据上传GPU后，我们就能释放内存了</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DisposeUploaders</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		VertexBufferUploader = <span class="literal">nullptr</span>;</span><br><span class="line">		IndexBufferUploader = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="绘制Box"><a href="#绘制Box" class="headerlink" title="绘制Box"></a>绘制Box</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../Common/d3dUtil.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DXApp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../Common/UploadBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../Common/MathHelper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX::PackedVector;</span><br><span class="line"><span class="keyword">using</span> Microsoft::WRL::ComPtr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _DEBUG 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	XMFLOAT3 Pos;</span><br><span class="line">	XMFLOAT4 Color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectConstants</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	XMFLOAT4X4 WorldViewProj=MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBox</span>:</span><span class="keyword">public</span> DXApp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyBox</span>(HINSTANCE instance);</span><br><span class="line">	<span class="built_in">MyBox</span>(<span class="keyword">const</span> MyBox&amp; rhs)=<span class="keyword">delete</span>;</span><br><span class="line">	MyBox&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyBox&amp; rhs)=<span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">MyBox</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseDown</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseUp</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseMove</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="keyword">override</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildDescriptorHeaps</span><span class="params">()</span></span>;<span class="comment">//常量缓冲区描述符堆</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildConstantBuffers</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildRootSignature</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildShadersAndInputLayout</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildBoxGeometry</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildPSO</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnResize</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	ComPtr&lt;ID3D12DescriptorHeap&gt; mCbvHeap = <span class="literal">nullptr</span>;</span><br><span class="line">	ComPtr&lt;ID3D12RootSignature&gt; mRootSignature = <span class="literal">nullptr</span>;</span><br><span class="line">	std::unique_ptr&lt;UploadBuffer&lt;ObjectConstants&gt;&gt; mObjectCB = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//封装的几何体结构体的指针</span></span><br><span class="line">	std::unique_ptr&lt;MeshGeometry&gt; mBoxGeo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//编译材质参数</span></span><br><span class="line">	ComPtr&lt;ID3DBlob&gt; mvsByteCode = <span class="literal">nullptr</span>;</span><br><span class="line">	ComPtr&lt;ID3DBlob&gt; mpsByteCode = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//输入布局描述</span></span><br><span class="line">	std::vector&lt;D3D12_INPUT_ELEMENT_DESC&gt; mInputLayout;</span><br><span class="line">	</span><br><span class="line">	ComPtr&lt;ID3D12PipelineState&gt; mPSO = <span class="literal">nullptr</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	XMFLOAT4X4 mWorld = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">	XMFLOAT4X4 mView = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">	XMFLOAT4X4 mProj = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> mTheta = <span class="number">1.5f</span>*XM_PI;</span><br><span class="line">	<span class="keyword">float</span> mPhi = XM_PIDIV2;</span><br><span class="line">	<span class="keyword">float</span> mRadius = <span class="number">5.0f</span>;</span><br><span class="line">	POINT mLastMousePos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyBox::<span class="built_in">MyBox</span>(HINSTANCE instance):<span class="built_in">DXApp</span>(instance)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyBox::~<span class="built_in">MyBox</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::Update</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 将球坐标（球面坐标）转换为笛卡尔坐标系</span></span><br><span class="line">	<span class="keyword">float</span> x = mRadius * <span class="built_in">sinf</span>(mPhi)*<span class="built_in">cosf</span>(mTheta);</span><br><span class="line">	<span class="keyword">float</span> z = mRadius * <span class="built_in">sinf</span>(mPhi)*<span class="built_in">sinf</span>(mTheta);</span><br><span class="line">	<span class="keyword">float</span> y = mRadius * <span class="built_in">cosf</span>(mPhi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建观察矩阵</span></span><br><span class="line">	XMVECTOR pos = <span class="built_in">XMVectorSet</span>(x, y, z, <span class="number">1.0f</span>);</span><br><span class="line">	XMVECTOR target = <span class="built_in">XMVectorZero</span>();</span><br><span class="line">	XMVECTOR up = <span class="built_in">XMVectorSet</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	XMMATRIX view = <span class="built_in">XMMatrixLookAtLH</span>(pos, target, up);</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mView, view);<span class="comment">//观察矩阵</span></span><br><span class="line"></span><br><span class="line">	XMMATRIX world = <span class="built_in">XMLoadFloat4x4</span>(&amp;mWorld);</span><br><span class="line">	XMMATRIX proj = <span class="built_in">XMLoadFloat4x4</span>(&amp;mProj);</span><br><span class="line">	XMMATRIX worldViewProj = world * view*proj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用最新的 worldViewProj 矩阵来更新常量缓冲区</span></span><br><span class="line">	ObjectConstants objConstants;</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;objConstants.WorldViewProj, <span class="built_in">XMMatrixTranspose</span>(worldViewProj));</span><br><span class="line">	mObjectCB-&gt;<span class="built_in">CopyData</span>(<span class="number">0</span>, objConstants);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::Draw</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mDirectCmdListAlloc-&gt;<span class="built_in">Reset</span>());</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Reset</span>(mDirectCmdListAlloc.<span class="built_in">Get</span>(), mPSO.<span class="built_in">Get</span>()));</span><br><span class="line"></span><br><span class="line">	mCommandList-&gt;<span class="built_in">RSSetViewports</span>(<span class="number">1</span>,&amp;mScreenViewport);</span><br><span class="line">	mCommandList-&gt;<span class="built_in">RSSetScissorRects</span>(<span class="number">1</span>,&amp;mScissorRect);</span><br><span class="line">	<span class="comment">//指示资源使用情况的状态转换。</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>,&amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(<span class="built_in">CurrentBackBuffer</span>(),D3D12_RESOURCE_STATE_PRESENT,D3D12_RESOURCE_STATE_RENDER_TARGET));</span><br><span class="line">	<span class="comment">//清理后台缓冲区和深度缓冲区</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">ClearRenderTargetView</span>(<span class="built_in">CurrentBackBufferView</span>(),Colors::LightSteelBlue,<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">	mCommandList-&gt;<span class="built_in">ClearDepthStencilView</span>(<span class="built_in">DepthStencilView</span>(),D3D12_CLEAR_FLAG_DEPTH | D3D12_CLEAR_FLAG_STENCIL,<span class="number">1.0f</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="comment">//指定要渲染的缓冲区</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">OMSetRenderTargets</span>(<span class="number">1</span> , &amp;<span class="built_in">CurrentBackBufferView</span>(),<span class="literal">true</span>, &amp;<span class="built_in">DepthStencilView</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定cbv描述符堆成员为一个</span></span><br><span class="line">	ID3D12DescriptorHeap* descriptorHeaps[]=&#123;mCbvHeap.<span class="built_in">Get</span>()&#125;;</span><br><span class="line">	mCommandList-&gt;<span class="built_in">SetDescriptorHeaps</span>(_countof(descriptorHeaps),descriptorHeaps);</span><br><span class="line">	<span class="comment">//设置根签名</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">SetGraphicsRootSignature</span>(mRootSignature.<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//顶点缓冲区视图和渲染流水线上的一个输入槽绑定</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">IASetVertexBuffers</span>(<span class="number">0</span>,<span class="number">1</span>,&amp;mBoxGeo-&gt;<span class="built_in">VertexBufferView</span>());</span><br><span class="line">	mCommandList-&gt;<span class="built_in">IASetIndexBuffer</span>(&amp;mBoxGeo-&gt;<span class="built_in">IndexBufferView</span>());</span><br><span class="line">	mCommandList-&gt;<span class="built_in">IASetPrimitiveTopology</span>(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);<span class="comment">//这里是DX11版本，没有12版本</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//描述符表与渲染流水线绑定</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">SetGraphicsRootDescriptorTable</span>(<span class="number">0</span>,mCbvHeap-&gt;<span class="built_in">GetGPUDescriptorHandleForHeapStart</span>());</span><br><span class="line"></span><br><span class="line">	mCommandList-&gt;<span class="built_in">DrawIndexedInstanced</span>(mBoxGeo-&gt;DrawArgs[<span class="string">&quot;box&quot;</span>].IndexCount,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	mCommandList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>,&amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(<span class="built_in">CurrentBackBuffer</span>(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Close</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提交命令列表，交换前后台缓冲区</span></span><br><span class="line">	ID3D12CommandList* cmdLists[]=&#123;mCommandList.<span class="built_in">Get</span>()&#125;;</span><br><span class="line">	mCommandQueue-&gt;<span class="built_in">ExecuteCommandLists</span>(_countof(cmdLists),cmdLists);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mSwapChain-&gt;<span class="built_in">Present</span>(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	mCurrBackBuffer=(mCurrBackBuffer+<span class="number">1</span>)%SwapChainBufferCount;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FlushCommandQueue</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::OnResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DXApp::<span class="built_in">OnResize</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The window resized, so update the aspect ratio and recompute the projection matrix.</span></span><br><span class="line">	XMMATRIX P = <span class="built_in">XMMatrixPerspectiveFovLH</span>(<span class="number">0.25f</span>*MathHelper::Pi, <span class="built_in">AspectRatio</span>(), <span class="number">1.0f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mProj, P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::OnMouseDown</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mLastMousePos.x = x;</span><br><span class="line">	mLastMousePos.y = y;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SetCapture</span>(mhMainWnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::OnMouseUp</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ReleaseCapture</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::OnMouseMove</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((btnState &amp; MK_LBUTTON) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//  根据鼠标的移动距离计算旋转角度，令每个像素按此角度的1/4旋转</span></span><br><span class="line">		<span class="keyword">float</span> dx = <span class="built_in">XMConvertToRadians</span>(<span class="number">0.25f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x - mLastMousePos.x));</span><br><span class="line">		<span class="keyword">float</span> dy = <span class="built_in">XMConvertToRadians</span>(<span class="number">0.25f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(y - mLastMousePos.y));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据鼠标输入来更新摄像机绕立方体旋转的角度</span></span><br><span class="line">		mTheta -= dx;</span><br><span class="line">		mPhi -= dy;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//限制角度mPhi的范围</span></span><br><span class="line">		mPhi = MathHelper::<span class="built_in">Clamp</span>(mPhi, <span class="number">0.1f</span>, MathHelper::Pi - <span class="number">0.1f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((btnState &amp; MK_RBUTTON) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 使场景中的每个像素按鼠标移动距离的0.005倍进行缩放</span></span><br><span class="line">		<span class="keyword">float</span> dx = <span class="number">0.005f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x - mLastMousePos.x);</span><br><span class="line">		<span class="keyword">float</span> dy = <span class="number">0.005f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(y - mLastMousePos.y);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据鼠标的输入更新摄像机的可视范围半径</span></span><br><span class="line">		mRadius += dx - dy;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 限制可视半径范围</span></span><br><span class="line">		mRadius = MathHelper::<span class="built_in">Clamp</span>(mRadius, <span class="number">3.0f</span>, <span class="number">15.0f</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mLastMousePos.x = x;</span><br><span class="line">	mLastMousePos.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::BuildDescriptorHeaps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D3D12_DESCRIPTOR_HEAP_DESC cbvHeapDesc;</span><br><span class="line">	cbvHeapDesc.Flags=D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;<span class="comment">//创建着色器程序访问的描述符时需要指定visible</span></span><br><span class="line">	cbvHeapDesc.NodeMask=<span class="number">0</span>;</span><br><span class="line">	cbvHeapDesc.NumDescriptors=<span class="number">1</span>;</span><br><span class="line">	cbvHeapDesc.Type=D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateDescriptorHeap</span>(&amp;cbvHeapDesc,<span class="built_in">IID_PPV_ARGS</span>(&amp;mCbvHeap)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::BuildConstantBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//此常量缓冲区存储了绘制n个物体所需的常量数据</span></span><br><span class="line">	mObjectCB=std::make_unique&lt;UploadBuffer&lt;ObjectConstants&gt;&gt;(md3dDevice.<span class="built_in">Get</span>(),<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	UINT objCBByteSize=d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ObjectConstants));</span><br><span class="line">	<span class="comment">//缓冲区的起始地址	</span></span><br><span class="line">	D3D12_GPU_VIRTUAL_ADDRESS cbAddress=mObjectCB-&gt;<span class="built_in">Resource</span>()-&gt;<span class="built_in">GetGPUVirtualAddress</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> boxCBufIndex=<span class="number">0</span>;</span><br><span class="line">	cbAddress += boxCBufIndex*objCBByteSize;</span><br><span class="line"></span><br><span class="line">	D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc;</span><br><span class="line">	cbvDesc.BufferLocation = cbAddress;</span><br><span class="line">	cbvDesc.SizeInBytes = d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ObjectConstants));</span><br><span class="line"></span><br><span class="line">	md3dDevice-&gt;<span class="built_in">CreateConstantBufferView</span>(&amp;cbvDesc,mCbvHeap-&gt;<span class="built_in">GetCPUDescriptorHandleForHeapStart</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::BuildRootSignature</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CD3DX12_ROOT_PARAMETER slotRootParameter[<span class="number">1</span>];<span class="comment">//根签名表</span></span><br><span class="line"></span><br><span class="line">	CD3DX12_DESCRIPTOR_RANGE cbvTable;</span><br><span class="line">	<span class="comment">//1：表中的描述符数量，0：将此段描述符区域绑定至此基准着色器寄存器</span></span><br><span class="line">	cbvTable.<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//1：描述符区域的数量；table:指向描述符区域数组的指针</span></span><br><span class="line">	slotRootParameter[<span class="number">0</span>].<span class="built_in">InitAsDescriptorTable</span>(<span class="number">1</span>,&amp;cbvTable);</span><br><span class="line">	<span class="comment">// 根签名由一组根参数构成</span></span><br><span class="line">	<span class="function">CD3DX12_ROOT_SIGNATURE_DESC <span class="title">rootSigDesc</span><span class="params">(<span class="number">1</span>,slotRootParameter,<span class="number">0</span>,<span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</span></span>;</span><br><span class="line"></span><br><span class="line">	ComPtr&lt;ID3DBlob&gt; serializedRootSig = <span class="literal">nullptr</span>;</span><br><span class="line">	ComPtr&lt;ID3DBlob&gt; errorBlob=<span class="literal">nullptr</span>;</span><br><span class="line">	HRESULT hr=<span class="built_in">D3D12SerializeRootSignature</span>(&amp;rootSigDesc,D3D_ROOT_SIGNATURE_VERSION_1,</span><br><span class="line">	serializedRootSig.<span class="built_in">GetAddressOf</span>(),errorBlob.<span class="built_in">GetAddressOf</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (errorBlob!=<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="built_in">OutputDebugStringA</span>((<span class="keyword">char</span>*)errorBlob-&gt;<span class="built_in">GetBufferPointer</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(hr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateRootSignature</span>(</span><br><span class="line">	<span class="number">0</span>,serializedRootSig-&gt;<span class="built_in">GetBufferPointer</span>(),</span><br><span class="line">	serializedRootSig-&gt;<span class="built_in">GetBufferSize</span>(),</span><br><span class="line">	<span class="built_in">IID_PPV_ARGS</span>(&amp;mRootSignature)</span><br><span class="line">	));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::BuildShadersAndInputLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HRESULT hr = S_OK;</span><br><span class="line">	mvsByteCode = d3dUtil::<span class="built_in">CompileShader</span>(<span class="string">L&quot;Shaders\\color.hlsl&quot;</span>, <span class="literal">nullptr</span>, <span class="string">&quot;VS&quot;</span>, <span class="string">&quot;vs_5_0&quot;</span>);</span><br><span class="line">	mpsByteCode = d3dUtil::<span class="built_in">CompileShader</span>(<span class="string">L&quot;Shaders\\color.hlsl&quot;</span>, <span class="literal">nullptr</span>, <span class="string">&quot;PS&quot;</span>, <span class="string">&quot;ps_5_0&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mInputLayout=</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;POSITION&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="number">0</span>, <span class="number">0</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;COLOR&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::BuildBoxGeometry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::array&lt;Vertex,8&gt; verteices=</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Red) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(<span class="number">-1.0f</span>, +<span class="number">1.0f</span>, <span class="number">-1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Green) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(+<span class="number">1.0f</span>, +<span class="number">1.0f</span>, <span class="number">-1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Blue) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(+<span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::White) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, +<span class="number">1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Blue) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(<span class="number">-1.0f</span>, +<span class="number">1.0f</span>, +<span class="number">1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::White) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(+<span class="number">1.0f</span>, +<span class="number">1.0f</span>, +<span class="number">1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Red) &#125;),</span><br><span class="line">		<span class="built_in">Vertex</span>(&#123; <span class="built_in">XMFLOAT3</span>(+<span class="number">1.0f</span>, <span class="number">-1.0f</span>, +<span class="number">1.0f</span>), <span class="built_in">XMFLOAT4</span>(Colors::Green) &#125;)</span><br><span class="line">	&#125;;</span><br><span class="line">	std::array&lt;std::<span class="keyword">uint16_t</span>, 36&gt; indices = </span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// front face</span></span><br><span class="line">			<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">			<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">			<span class="comment">// back face</span></span><br><span class="line">			<span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>,</span><br><span class="line">			<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">			<span class="comment">// left face</span></span><br><span class="line">			<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>,</span><br><span class="line">			<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">			<span class="comment">// right face</span></span><br><span class="line">			<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>,</span><br><span class="line">			<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">			<span class="comment">// top face</span></span><br><span class="line">			<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">			<span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">			<span class="comment">// bottom face</span></span><br><span class="line">			<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>,</span><br><span class="line">			<span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> UINT vbByteSize = (UINT)verteices.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line">	<span class="keyword">const</span> UINT ibByteSize = (UINT)indices.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(std::<span class="keyword">uint16_t</span>);</span><br><span class="line"></span><br><span class="line">	mBoxGeo=std::make_unique&lt;MeshGeometry&gt;();</span><br><span class="line">	mBoxGeo-&gt;Name = <span class="string">&quot;boxGeo&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(<span class="built_in">D3DCreateBlob</span>(vbByteSize,&amp;mBoxGeo-&gt;VertexBufferCPU));</span><br><span class="line">	<span class="built_in">CopyMemory</span>(mBoxGeo-&gt;VertexBufferCPU-&gt;<span class="built_in">GetBufferPointer</span>(),verteices.<span class="built_in">data</span>(),vbByteSize);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(<span class="built_in">D3DCreateBlob</span>(ibByteSize, &amp;mBoxGeo-&gt;IndexBufferCPU));</span><br><span class="line">	<span class="built_in">CopyMemory</span>(mBoxGeo-&gt;IndexBufferCPU-&gt;<span class="built_in">GetBufferPointer</span>(), indices.<span class="built_in">data</span>(), ibByteSize);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建顶点/索引默认缓冲区</span></span><br><span class="line">	mBoxGeo-&gt;VertexBufferGPU = d3dUtil::<span class="built_in">CreateDefaultBuffer</span>(</span><br><span class="line">	md3dDevice.<span class="built_in">Get</span>(),mCommandList.<span class="built_in">Get</span>(),verteices.<span class="built_in">data</span>(),vbByteSize,mBoxGeo-&gt;VertexBufferUploader);</span><br><span class="line">	mBoxGeo-&gt;IndexBufferGPU= d3dUtil::<span class="built_in">CreateDefaultBuffer</span>(</span><br><span class="line">	md3dDevice.<span class="built_in">Get</span>(),mCommandList.<span class="built_in">Get</span>(),indices.<span class="built_in">data</span>(),ibByteSize,mBoxGeo-&gt;IndexBufferUploader);</span><br><span class="line">	<span class="comment">//缓冲区数据</span></span><br><span class="line">	<span class="comment">//字节跨度</span></span><br><span class="line">	mBoxGeo-&gt;VertexByteStride=<span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line">	mBoxGeo-&gt;VertexBufferByteSize=vbByteSize;</span><br><span class="line">	mBoxGeo-&gt;IndexFormat=DXGI_FORMAT_R16_UINT;</span><br><span class="line">	mBoxGeo-&gt;IndexBufferByteSize=ibByteSize;</span><br><span class="line"></span><br><span class="line">	SubmeshGeometry subMesh;</span><br><span class="line">	subMesh.IndexCount=(UINT) indices.<span class="built_in">size</span>();</span><br><span class="line">	subMesh.StartIndexLocation=<span class="number">0</span>;</span><br><span class="line">	subMesh.BaseVertexLocation=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个结构体能够存储一组顶点/索引缓冲区中的多个几何体</span></span><br><span class="line">	<span class="comment">//用下列容器来定义子网格几何体，就能单独绘制其中的子网格</span></span><br><span class="line">	mBoxGeo-&gt;DrawArgs[<span class="string">&quot;box&quot;</span>]=subMesh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyBox::BuildPSO</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//流水线状态描述</span></span><br><span class="line">	D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc;</span><br><span class="line">	<span class="comment">//将数据的缓冲区用0来填充,使用一块内存区域前对其进行清空处理可以避免内存数据的不确定性。</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;psoDesc,<span class="built_in"><span class="keyword">sizeof</span></span>(D3D12_GRAPHICS_PIPELINE_STATE_DESC));</span><br><span class="line">	psoDesc.InputLayout=&#123;mInputLayout.<span class="built_in">data</span>(),(UINT)mInputLayout.<span class="built_in">size</span>()&#125;;</span><br><span class="line">	psoDesc.pRootSignature=mRootSignature.<span class="built_in">Get</span>();</span><br><span class="line">	psoDesc.VS=</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;BYTE*&gt;(mvsByteCode-&gt;<span class="built_in">GetBufferPointer</span>()),</span><br><span class="line">		mvsByteCode-&gt;<span class="built_in">GetBufferSize</span>()</span><br><span class="line">	&#125;;</span><br><span class="line">	psoDesc.PS=</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;BYTE*&gt;(mpsByteCode-&gt;<span class="built_in">GetBufferPointer</span>()),</span><br><span class="line">		mpsByteCode-&gt;<span class="built_in">GetBufferSize</span>()</span><br><span class="line">	&#125;;</span><br><span class="line">	psoDesc.RasterizerState = <span class="built_in">CD3DX12_RASTERIZER_DESC</span>(D3D12_DEFAULT);	<span class="comment">//光栅化状态</span></span><br><span class="line">	psoDesc.BlendState= <span class="built_in">CD3DX12_BLEND_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">	psoDesc.DepthStencilState = <span class="built_in">CD3DX12_DEPTH_STENCIL_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">	psoDesc.SampleMask=UINT_MAX;</span><br><span class="line">	psoDesc.PrimitiveTopologyType=D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;</span><br><span class="line">	psoDesc.NumRenderTargets=<span class="number">1</span>;</span><br><span class="line">	psoDesc.RTVFormats[<span class="number">0</span>]=mBackBufferFormat;</span><br><span class="line">	psoDesc.SampleDesc.Count= m4xMsaaState?<span class="number">4</span>:<span class="number">1</span>;</span><br><span class="line">	psoDesc.SampleDesc.Quality=m4xMsaaState?(m4xMsaaState<span class="number">-1</span>):<span class="number">0</span>;</span><br><span class="line">	psoDesc.DSVFormat=mDepthStencilFormat;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateGraphicsPipelineState</span>(&amp;psoDesc,<span class="built_in">IID_PPV_ARGS</span>(&amp;mPSO)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MyBox::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!DXApp::<span class="built_in">Initialize</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//准备初始化命令之前线重置命令列表</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Reset</span>(mDirectCmdListAlloc.<span class="built_in">Get</span>(),<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BuildDescriptorHeaps</span>();</span><br><span class="line">	<span class="built_in">BuildConstantBuffers</span>();</span><br><span class="line">	<span class="built_in">BuildRootSignature</span>();</span><br><span class="line">	<span class="built_in">BuildShadersAndInputLayout</span>();</span><br><span class="line">	<span class="built_in">BuildBoxGeometry</span>();</span><br><span class="line">	<span class="built_in">BuildPSO</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Close</span>());</span><br><span class="line">	ID3D12CommandList* cmdLists[]=&#123;mCommandList.<span class="built_in">Get</span>()&#125;;</span><br><span class="line">	mCommandQueue-&gt;<span class="built_in">ExecuteCommandLists</span>(_countof(cmdLists),cmdLists);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FlushCommandQueue</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ <span class="keyword">int</span> nShowCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable run-time memory check for debug builds.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG) | defined(_DEBUG)</span></span><br><span class="line">	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">MyBox <span class="title">theApp</span><span class="params">(hInstance)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (!theApp.<span class="built_in">Initialize</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> theApp.<span class="built_in">Run</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (DxException&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="built_in">MessageBox</span>(<span class="literal">nullptr</span>, e.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>(), <span class="string">L&quot;HR Failed&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>DirectX</tag>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DX学习笔记（一）：数学基础</title>
    <url>/2020/06/23/LearnDX12_Math/</url>
    <content><![CDATA[<h2 id="向量代数"><a href="#向量代数" class="headerlink" title="向量代数"></a>向量代数</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>DirectX3D采用的左手坐标系</p>
<ul>
<li>左手坐标系：伸出左手，手指方向对准X轴正方向，弯曲手指对象Y轴正方向，大拇指指的就是Z轴正方向</li>
</ul>
<h5 id="向量的基本运算"><a href="#向量的基本运算" class="headerlink" title="向量的基本运算"></a>向量的基本运算</h5><ul>
<li><p>两个向量相等。即u=v。当且仅当u和v的每个分量相等，即u<sub>x</sub>=v<sub>x</sub>,u<sub>y</sub>=v<sub>y</sub>, u<sub>z</sub>=v<sub>z</sub></p>
</li>
<li><p>向量的加法即两个向量对应分量都相加</p>
</li>
<li><p>向量与标量相乘即每一个分量与标量相乘</p>
</li>
<li><p>向量减法与加法类似</p>
</li>
</ul>
<p>向量加法的几何意义u+v，即u的尾部与v的头部重合</p>
<h5 id="向量的长度和单位向量"><a href="#向量的长度和单位向量" class="headerlink" title="向量的长度和单位向量"></a>向量的长度和单位向量</h5><ul>
<li>3D向量的模可以用2次毕达哥拉斯定理（勾股定理）计算得到</li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118213350051.png" alt="image-20200118213350051"></p>
</blockquote>
<ul>
<li>一个向量的长度变为单位长度称为向量的<strong>规范化（normalizing）</strong>,具体实现方法是</li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118213401165.png" alt="image-20200118213401165"></p>
</blockquote>
<h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h3><ul>
<li>点积（dot product）是一种计算结果为标量值的向量乘法</li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118213420038.png" alt="image-20200118213420038"></p>
</blockquote>
<ul>
<li>如果u·v=0，那么u和v正交（垂直）</li>
<li>如果u·v&gt;0,那么夹角为锐角，即小于90°</li>
<li>如果&gt;0,那么夹角为钝角</li>
</ul>
<h5 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h5><blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118213446595.png" alt="image-20200118213446595"></p>
</blockquote>
<p>即向量p是v在n向量上的投影</p>
<p>一般的投影公式如下</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118213508242.png" alt="image-20200118213508242"></p>
</blockquote>
<h3 id="正交化"><a href="#正交化" class="headerlink" title="正交化"></a>正交化</h3><p>如果向量集里面所有向量都相互正交，那么此向量集是<strong>规范正交</strong></p>
<h5 id="格拉姆-施密特正交化"><a href="#格拉姆-施密特正交化" class="headerlink" title="格拉姆-施密特正交化"></a><strong>格拉姆-施密特正交化</strong></h5><blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118213545042.png" alt="image-20200118213545042"></p>
</blockquote>
<p>从文字上描述即，将向量v添加到规范正交集中时，需要用<strong>v减去这个规范正交集中的所有其他向量{w1,w2…}方向上的分量投影</strong>，这样确保新加入的v与该集合中的其他放量相互正交</p>
<ul>
<li>假设有向量集{v0,v1}，将其规范正交至集{w0,w1}</li>
</ul>
<p>则需要进行如下操作</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118213557536.png" alt="image-20200118213557536"></p>
</blockquote>
<ul>
<li>如果是三维向量集{v0,v1,v2}，至规范正交集{w0,w1,w2}</li>
</ul>
<p>则进行如下操作</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118213605437.png" alt="image-20200118213605437"></p>
<p><img src="https://img.supervj.top/img/DX/image-20200118213614501.png" alt="image-20200118213614501"></p>
</blockquote>
<h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h3><p>叉积公式</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118213635523.png" alt="image-20200118213635523"></p>
</blockquote>
<p>两个向量叉积的意义即得到正交于两个向量的向量，采用的左手坐标系，即手指指向一个向量，通过向内弯曲小于等于180°的角度后到达另外一个向量，则大拇指方向是叉积所得向量的方向</p>
<h5 id="用叉积类规范正交化"><a href="#用叉积类规范正交化" class="headerlink" title="用叉积类规范正交化"></a>用叉积类规范正交化</h5><blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118213701332.png" alt="image-20200118213701332"></p>
</blockquote>
<h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>点（x,y,z）即从原点至该点的向量</p>
<h3 id="用DirectXMath库"><a href="#用DirectXMath库" class="headerlink" title="用DirectXMath库"></a>用DirectXMath库</h3><h5 id="DirectXMath变量的使用规范"><a href="#DirectXMath变量的使用规范" class="headerlink" title="DirectXMath变量的使用规范"></a>DirectXMath变量的使用规范</h5><ul>
<li>局部变量或全局变量用XMVECTOR类型</li>
<li>对于类中的数据成员，用XMFLOAT2\XMFLOAT3和XMFLOAT4类型</li>
<li>在运算之前，通过加载函数将XMFLOATn类型转换成XMVECTOR类型</li>
<li>用XMVECTOR实例来进行运算</li>
<li>通过存储函数将XMVECTOR类型转换为XMFLOATn类型</li>
</ul>
<h5 id="加载方法和存储方法"><a href="#加载方法和存储方法" class="headerlink" title="加载方法和存储方法"></a>加载方法和存储方法</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数据从XMFLOAT2类型加载到XMVECTOR类型</span></span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMLoadFloat2</span><span class="params">(<span class="keyword">const</span> XMFLOAT2* pSource)</span></span>;</span><br><span class="line"><span class="comment">//将数据从XMFLOAT3类型加载到XMVECTOR类型，XMFLOAT4类似</span></span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMLoadFloat3</span><span class="params">(<span class="keyword">const</span> XMFLOAT3* pSource)</span></span>;</span><br><span class="line"><span class="comment">//将数据从XMVECTOR类型存储到XMFLOAT2类型，XMFLOAT3以及XMFLOAT4方法类似</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> XM_CALLCONV <span class="title">XMStoreFloat2</span><span class="params">(XMFLOAT2* pDestination,FXMVECTOR V)</span></span>;</span><br><span class="line"><span class="comment">//********************//</span></span><br><span class="line"><span class="comment">//得到XMVECTOR实例中的一个分量或者将一个方脸转换为XMVECTOR类型</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> XM_CALLCONV <span class="title">XMVectorGetX</span><span class="params">(FXMVECTOR V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> XM_CALLCONV <span class="title">XMVectorGetY</span><span class="params">(FXMVECTOR V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> XM_CALLCONV <span class="title">XMVectorGetZ</span><span class="params">(FXMVECTOR V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> XM_CALLCONV <span class="title">XMVectorGetX</span><span class="params">(FXMVECTOR V)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMVectorSetX</span><span class="params">(FXMVECTOR V,<span class="keyword">float</span> x)</span></span>;</span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMVectorSetY</span><span class="params">(FXMVECTOR V,<span class="keyword">float</span> y)</span></span>;</span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMVectorSetZ</span><span class="params">(FXMVECTOR V,<span class="keyword">float</span> z)</span></span>;.</span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMVectorSetW</span><span class="params">(FXMVECTOR V,<span class="keyword">float</span> w)</span></span>;</span><br></pre></td></tr></table></figure>



<h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><h6 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h6><ul>
<li>前三个 XMVECTOR 参数用类型 <code>FXMVECTOR</code></li>
<li>第四个 XMVECTOR 参数用 <code>GXMVECTOR</code></li>
<li>第5、6个 XMVECTOR 参数用 <code>HXMVECTOR</code></li>
<li>其余的 XMVECTOR 参数用 <code>CXMVECTOR</code></li>
</ul>
<blockquote>
<p>在32位windows系统，编译器将根据**_fastcall**调用约定将前3个XMVECTOR参数传递到寄存器，其余放到栈</p>
<p>在32位windows系统，编译器将根据**_vectorcall**调用约定将前6个XMVECTOR参数传递到寄存器，其余放到栈上</p>
<p>其余平台上的定义，可以参见 <code>DirectXMath</code>库文档中的  <code>Library Internals</code>下的 <code>Calling Converntions</code> 部分的<code>[DirectXMath]</code></p>
</blockquote>
<h5 id="常向量"><a href="#常向量" class="headerlink" title="常向量"></a>常向量</h5><p>XMVECTOR类型的常量实例用 <strong><code>XMVECTORF32</code></strong> 表示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> XMVECTORF32 v1 = &#123; <span class="number">0.5f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>XMVECTORF32是一种16字节对齐的结构体，数学库中有将他转换至XMVECTOR类型的运算符</p>
<p>另外也可以用<code>XMVECTORU32</code>类型来创建由证书数据构成的XMVECTOR常向量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> XMVECTORU32 v2 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h5><p>XMVECTOR类型针对向量的加法、减法和标量乘法都重载了运算符，如下</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118215001131.png" alt="image-20200118215001131"></p>
</blockquote>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>DirectXMath库定义了一组于PI有关的常用数学常量近似值</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118215207615.png" alt="image-20200118215207615"></p>
</blockquote>
<p>另外还有角度和弧度之间的转化以及比较大小的函数</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118215348688.png" alt="image-20200118215348688"></p>
<p><img src="https://img.supervj.top/img/DX/image-20200118215354016.png" alt="image-20200118215354016"></p>
</blockquote>
<h5 id="Setter函数"><a href="#Setter函数" class="headerlink" title="Setter函数"></a>Setter函数</h5><p>DirectXMath库提供了下列函数，用来设置XMVECTOR类型中的数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回零向量</span></span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMVectorZero</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回&#123;1，1，1，1&#125;</span></span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMVectorSplatOne</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回&#123;x,y,z,w&#125;</span></span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMVectorSet</span><span class="params">(<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z,<span class="keyword">float</span> w)</span></span>;</span><br><span class="line"><span class="comment">//返回&#123;value),value),value),value)&#125;</span></span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMVectorReplicate</span><span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line"><span class="comment">//返回&#123;Vx，Vx，Vx，Vx&#125;，同理；用SplateY，SplayteZ可以返回P&#123;Vy...&#125;,或者&#123;Vz..&#125;</span></span><br><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMVectorSplateX</span><span class="params">(FXMVECTOR V)</span></span>;    </span><br></pre></td></tr></table></figure>

<h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DirectXMath.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DirectXPackedVector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX::PackedVector;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写了&lt;&lt;运算符，使得cout函数可以输出XMVECTOR</span></span><br><span class="line">ostream&amp; XM_CALLCONV <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, FXMVECTOR v)</span><br><span class="line">&#123;</span><br><span class="line">	XMFLOAT4 dest;</span><br><span class="line">	<span class="built_in">XMStoreFloat4</span>(&amp;dest, v);</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; dest.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; dest.y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; dest.z &lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;dest.w&lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">XMVerifyCPUSupport</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;directx math not supported&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> XMVECTORF32 v1 = &#123; <span class="number">0.5f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span> &#125;;</span><br><span class="line">	XMVECTOR v2 = <span class="built_in">XMVectorReplicate</span>(<span class="number">0.99f</span>);</span><br><span class="line">	XMVECTOR v3 = &#123; <span class="number">.5</span>f,<span class="number">.5</span>f,<span class="number">.5</span>f,<span class="number">.5</span>f &#125;;</span><br><span class="line">	XMVECTOR v4 = <span class="built_in">XMVectorSet</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	XMVECTOR v5 = <span class="built_in">XMVectorSplatOne</span>();</span><br><span class="line">	XMVECTOR v6 = <span class="built_in">XMVectorZero</span>();</span><br><span class="line">	XMVECTOR v7 = <span class="built_in">XMVectorSplatZ</span>(v4);</span><br><span class="line">	cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3 &lt;&lt; v4 &lt;&lt; v5 &lt;&lt; v6 &lt;&lt; v7;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200118221313633.png" alt="image-20200118221313633"></p>
</blockquote>
<h5 id="向量函数"><a href="#向量函数" class="headerlink" title="向量函数"></a>向量函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">XMVECTOR v1 = <span class="built_in">XMVectorSet</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">	XMVECTOR v2 = <span class="built_in">XMVectorSet</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">5</span>);</span><br><span class="line">	XMVECTOR v3 = <span class="built_in">XMVectorSet</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span>);</span><br><span class="line">	XMVECTOR a = <span class="built_in">XMVector4Length</span>(v1);<span class="comment">//||v1||2,2_范数，即平方和的更号</span></span><br><span class="line">	XMVECTOR b = <span class="built_in">XMVector4LengthSq</span>(v1);<span class="comment">//||v1||1,1_范数，即平方和</span></span><br><span class="line">	XMVECTOR c = v1 - v2;<span class="comment">//减法</span></span><br><span class="line">	XMVECTOR d = <span class="number">10</span> * v1;<span class="comment">//乘法</span></span><br><span class="line">	XMVECTOR e = <span class="built_in">XMVector4Normalize</span>(v1);<span class="comment">//标准化，即v1/|v1|</span></span><br><span class="line">	XMVECTOR f = <span class="built_in">XMVector3Dot</span>(v1,v2);<span class="comment">//v1·v1</span></span><br><span class="line">	XMVECTOR g = <span class="built_in">XMVector3Cross</span>(v1, v2);<span class="comment">//v1*v1</span></span><br><span class="line">	XMVECTOR projw, perpw;</span><br><span class="line">	<span class="built_in">XMVector3ComponentsFromNormal</span>(&amp;projw, &amp;perpw, v1, v3);<span class="comment">//求v1在v3的proj和perp</span></span><br><span class="line">	XMVECTOR angle = <span class="built_in">XMVector4AngleBetweenVectors</span>(v1, v2);<span class="comment">//2个向量的夹角</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;e&lt;&lt;f&lt;&lt;g&lt;&lt;projw&lt;&lt;perpw&lt;&lt;angle;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200119135645869.png" alt="image-20200119135645869"></p>
</blockquote>
<h5 id="浮点数的误差"><a href="#浮点数的误差" class="headerlink" title="浮点数的误差"></a>浮点数的误差</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">XMVector Epsilon=&#123;<span class="number">0.1</span>，<span class="number">0.1</span>，<span class="number">0.1</span>，<span class="number">0.1</span>&#125;；</span><br><span class="line"><span class="keyword">bool</span> IsEqual = <span class="built_in">XMVectorNearEqual</span>(v1, v2，Epsilon);<span class="comment">//约等于来解决</span></span><br></pre></td></tr></table></figure>

<h2 id="矩阵代数"><a href="#矩阵代数" class="headerlink" title="矩阵代数"></a>矩阵代数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>m*n的矩阵M，即由m行，n列构成的矩形阵列</p>
<ul>
<li>A<sub>1.*</sub></li>
<li>A<sub>*.1</sub></li>
</ul>
<p><img src="https://img.supervj.top/img/DX/image-20200120070458975.png" alt="image-20200120070458975"></p>
<p><img src="https://img.supervj.top/img/DX/image-20200120070505831.png" alt="image-20200120070505831"></p>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><ul>
<li>矩阵<strong>AxB</strong>乘法的前提条件：A的列数必须于B的行数相同</li>
</ul>
<p>乘法公式</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120070807173.png" alt="image-20200120070807173"></p>
</blockquote>
<ul>
<li>即矩阵A的第<strong>i</strong>个行向量于B的第<strong>j</strong>个列向量点积</li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120070906956.png" alt="image-20200120070906956"></p>
</blockquote>
<ul>
<li>行列数不相等的矩阵乘法不满足交换律即 <strong>AB≠BA</strong></li>
</ul>
<h5 id="向量于矩阵乘法"><a href="#向量于矩阵乘法" class="headerlink" title="向量于矩阵乘法"></a>向量于矩阵乘法</h5><blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120071122512.png" alt="image-20200120071122512"></p>
<p><img src="https://img.supervj.top/img/DX/image-20200120071219317.png" alt="image-20200120071219317"></p>
</blockquote>
<h3 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h3><p><strong>转置矩阵（transpose matrix）</strong>是将原矩阵阵列的 行与列进行互换 即mn的矩阵变成nm的矩阵</p>
<p>**M **的转置矩阵记作 <strong>M<sup>t</sup></strong></p>
<ul>
<li>转置矩阵具有下列性质</li>
</ul>
<blockquote>
<p><strong><img src="https://img.supervj.top/img/DX/image-20200120071623379.png" alt="image-20200120071623379"></strong></p>
</blockquote>
<h3 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h3><p><strong>单位矩阵(identity matrix)<strong>是一种主对角线上的元素都是</strong>1</strong>，其他元素都是0的方阵，如</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120071758210.png" alt="image-20200120071758210"></p>
</blockquote>
<ul>
<li>任何单位与单位矩阵相乘，得到的依然是原来的矩阵，而且满足交换律</li>
</ul>
<blockquote>
<p>MI=IM=M</p>
</blockquote>
<h3 id="矩阵的行列式"><a href="#矩阵的行列式" class="headerlink" title="矩阵的行列式"></a>矩阵的行列式</h3><p>行列式记作： <strong>det A</strong></p>
<ul>
<li>当且仅当det A≠0时，方阵A是可逆的</li>
</ul>
<h5 id="余子阵"><a href="#余子阵" class="headerlink" title="余子阵"></a>余子阵</h5><p>n x n的矩阵A，<strong>余子阵（minor matrix）</strong> <img src="https://img.supervj.top/img/DX/image-20200120191929162.png" alt="image-20200120191929162">即从A中去除第 <strong>i</strong> 行和第 <strong>j</strong> 列的**(n-1)*(n-1)**矩阵</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120200716480.png" alt="image-20200120200716480"></p>
<p><img src="https://img.supervj.top/img/DX/image-20200120200727115.png" alt="image-20200120200727115"></p>
<p><img src="https://img.supervj.top/img/DX/image-20200120200736692.png" alt="image-20200120200736692"></p>
</blockquote>
<h5 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h5><p><img src="https://img.supervj.top/img/DX/image-20200120200844209.png" alt="image-20200120200844209"></p>
<ul>
<li>对于2 x 2 的矩阵来说，行列式公式为：</li>
</ul>
<p><img src="https://img.supervj.top/img/DX/image-20200120200914468.png" alt="image-20200120200914468"></p>
<ul>
<li>3 x 3的矩阵，行列式公式为：</li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120201007378.png" alt="image-20200120201007378"></p>
</blockquote>
<ul>
<li>4 x 4的矩阵，行列式公式为：</li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120201040699.png" alt="image-20200120201040699"></p>
</blockquote>
<ul>
<li>案例：</li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120201108843.png" alt="image-20200120201108843"></p>
</blockquote>
<blockquote>
<p><strong>一个矩阵的行列式就是一个平行多面体的（定向的）体积，这个多面体的每条边对应着对应矩阵的列。如果学生得知了这个秘密（在纯粹的代数式的教育中，这个秘密被仔细的隐藏了起来），那么行列式的整个理论都将成为多重线性形式理论的一部分。倘若用别的方式来定义行列式，任何敏感的人都将会永远痛恨诸如行列式，Jacobian式，以及隐函数定理这些东西。</strong></p>
<p>​                          <strong>——俄国数学家阿诺尔德（Vladimir Arnold）《论数学教育》</strong></p>
</blockquote>
<h3 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h3><p><img src="https://img.supervj.top/img/DX/image-20200120201159666.png" alt="image-20200120201159666"></p>
<p>如果A中的每个元素分别计算出C<sub>ij</sub>,并将它至于矩阵C<sub>A</sub>中的第 <strong>i</strong> 行，第 <strong>j</strong> 列，那么将获得矩阵A的 <strong>代数余子式矩阵(cofactor matrix of A)</strong></p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120201605278.png" alt="image-20200120201605278"></p>
</blockquote>
<p>取矩阵C<sub>A</sub>的转置矩阵，得到<strong>矩阵A的伴随矩阵（adjoint matrix of A）</strong>，记作</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120204905556.png" alt="image-20200120204905556"></p>
</blockquote>
<h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><ul>
<li>只有方阵才有逆矩阵</li>
<li>n x n矩阵M的逆也是一个n x n的矩阵，记作 M<sup>-1</sup></li>
<li>不是每个方阵都有逆矩阵，存在逆矩阵的方阵称为<strong>可逆矩阵（invertible matrix）</strong>，不存在逆矩阵的叫做<strong>奇异矩阵（singular matrix）</strong></li>
<li>可逆矩阵的逆矩阵是唯一的</li>
<li>可逆矩阵有逆矩阵相乘等到单位方阵： MM<sup>-1</sup>=M<sup>-1</sup>M=I，矩阵与其逆矩阵妈祖交换律</li>
</ul>
<p>逆矩阵的推导公式</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120205253567.png" alt="image-20200120205253567"></p>
</blockquote>
<ul>
<li>案例，<img src="https://img.supervj.top/img/DX/image-20200120205340831.png" alt="image-20200120205340831"></li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120205418259.png" alt="image-20200120205418259"></p>
</blockquote>
<ul>
<li><img src="https://img.supervj.top/img/DX/image-20200120205505699.png" alt="image-20200120205505699"></li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120205519977.png" alt="image-20200120205519977"></p>
</blockquote>
<ul>
<li><img src="https://img.supervj.top/img/DX/image-20200120211359396.png" alt="image-20200120211359396"></li>
</ul>
<h3 id="DirectXMath库处理矩阵阵列"><a href="#DirectXMath库处理矩阵阵列" class="headerlink" title="DirectXMath库处理矩阵阵列"></a>DirectXMath库处理矩阵阵列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream&amp; XM_CALLCONV <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, FXMVECTOR v)</span><br><span class="line">&#123;</span><br><span class="line">	XMFLOAT4 dest;</span><br><span class="line">	<span class="built_in">XMStoreFloat4</span>(&amp;dest, v);</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; dest.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; dest.y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; dest.z &lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;dest.w&lt;&lt; <span class="string">&quot;)&quot;</span> ;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; XM_CALLCONV <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, FXMMATRIX v)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		os &lt;&lt; <span class="built_in">XMVectorGetX</span>(v.r[i]) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		os &lt;&lt; <span class="built_in">XMVectorGetY</span>(v.r[i]) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		os &lt;&lt; <span class="built_in">XMVectorGetZ</span>(v.r[i]) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		os &lt;&lt; <span class="built_in">XMVectorGetW</span>(v.r[i]) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		os &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">XMVerifyCPUSupport</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;directx math not supported&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">XMMATRIX <span class="title">A</span></span></span><br><span class="line"><span class="function">	<span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="number">0.0f</span>, <span class="number">2.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">4.0f</span>, <span class="number">0.0f</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">1.0f</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line">		XMMATRIX B = <span class="built_in">XMMatrixIdentity</span>();<span class="comment">//单位矩阵，斜线都是1</span></span><br><span class="line">	XMMATRIX C = A * B;<span class="comment">//矩阵乘法，AI=A；</span></span><br><span class="line">	XMMATRIX D = <span class="built_in">XMMatrixTranspose</span>(A);<span class="comment">//转置矩阵，行列反转</span></span><br><span class="line">	XMVECTOR det = <span class="built_in">XMMatrixDeterminant</span>(A);<span class="comment">//得到（det A,det A,det A,det A）</span></span><br><span class="line">	XMMATRIX E = <span class="built_in">XMMatrixInverse</span>(&amp;det, A);<span class="comment">//返回M逆矩阵</span></span><br><span class="line">	XMMATRIX F = A * E;<span class="comment">//矩阵与逆矩阵乘积等于单位矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; A &lt;&lt; endl &lt;&lt; B &lt;&lt; endl &lt;&lt; C &lt;&lt; endl &lt;&lt; D &lt;&lt; endl &lt;&lt; E &lt;&lt; endl &lt;&lt; det &lt;&lt; endl &lt;&lt; F;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200120211048937.png" alt="image-20200120211048937"></p>
</blockquote>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>线性变换函数满足</p>
<h6 id="线性变换函数公式"><a href="#线性变换函数公式" class="headerlink" title="线性变换函数公式"></a>线性变换函数公式</h6><blockquote>
<p> <img src="https://img.supervj.top/img/DX/image-20200121070851768.png" alt="image-20200121070851768"></p>
</blockquote>
<h5 id="矩阵表示法"><a href="#矩阵表示法" class="headerlink" title="矩阵表示法"></a>矩阵表示法</h5><p>**u=(x,y,z)**也可以写作</p>
<h6 id="矩阵表示法公式"><a href="#矩阵表示法公式" class="headerlink" title="矩阵表示法公式"></a>矩阵表示法公式</h6><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://img.supervj.top/img/DX/image-20200121071106597.png" alt="image-20200121071106597"></h6><h6 id="R3-标准基向量"><a href="#R3-标准基向量" class="headerlink" title="R3,标准基向量"></a>R<sup>3</sup>,标准基向量</h6><p><strong>i=(1,0,0), j=(0,1,0), k=(0,0,1)</strong></p>
<h6 id="矩阵表示法公式2"><a href="#矩阵表示法公式2" class="headerlink" title="矩阵表示法公式2"></a>矩阵表示法公式2</h6><p><img src="https://img.supervj.top/img/DX/image-20200121071255330.png" alt="image-20200121071255330"></p>
<p>根据线性组合，上述公式可以改写成</p>
<h6 id="线性变换的矩阵表示法"><a href="#线性变换的矩阵表示法" class="headerlink" title="线性变换的矩阵表示法"></a>线性变换的矩阵表示法</h6><p><img src="https://img.supervj.top/img/DX/image-20200121071642398.png" alt="image-20200121071642398"></p>
<p>我们称矩阵 <strong>A</strong>是线性变换的矩阵表示法</p>
<h5 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h5><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><p><img src="https://img.supervj.top/img/DX/image-20200121071743966.png" alt="image-20200121071743966"></p>
<ul>
<li>S就是一种线性变换</li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200121071817696.png" alt="image-20200121071817696"></p>
</blockquote>
<h6 id="缩放变换的矩阵表达式"><a href="#缩放变换的矩阵表达式" class="headerlink" title="缩放变换的矩阵表达式"></a>缩放变换的矩阵表达式</h6><blockquote>
<p> <img src="https://img.supervj.top/img/DX/image-20200121071907341.png" alt="image-20200121071907341"></p>
</blockquote>
<ul>
<li>缩放矩阵的逆矩阵</li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200623102531554.png" alt="image-20200623102531554"></p>
</blockquote>
<ul>
<li>案例</li>
</ul>
<p><img src="https://img.supervj.top/img/DX/image-20200623102549550.png" alt="image-20200623102549550"></p>
<h5 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h5><h6 id="旋转矩阵基础公式"><a href="#旋转矩阵基础公式" class="headerlink" title="旋转矩阵基础公式"></a>旋转矩阵基础公式</h6><blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200121153741133.png" alt="image-20200121153741133"></p>
<p><img src="https://img.supervj.top/img/DX/image-20200623102608770.png" alt="image-20200623102608770"></p>
</blockquote>
<ul>
<li><p>上述公式里，<em><strong>c=cosθ</strong></em> 而且 <em><strong>s=sinθ</strong></em></p>
</li>
<li><p>旋转矩阵有个特性：每个行向量都为单位长度且两两正交，即这些行向量都是<strong>规范正交(orthonormal)</strong></p>
</li>
<li><p>若一个矩阵的行向量都是规范正交的，则此矩阵为<strong>正交矩阵（orthogonal matrix）</strong></p>
</li>
</ul>
<h6 id="正交矩阵的逆矩阵"><a href="#正交矩阵的逆矩阵" class="headerlink" title="正交矩阵的逆矩阵"></a>正交矩阵的逆矩阵</h6><blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200121154123112.png" alt="image-20200121154123112"></p>
</blockquote>
<h6 id="通俗公式"><a href="#通俗公式" class="headerlink" title="通俗公式"></a>通俗公式</h6><p>如果选择绕<em><strong>x、y、z</strong></em>轴旋转，即分别取 <em><strong>n =（1，0，0）、n =（0，1，0）、n =（0，0，1）</strong></em>，那么对应的旋转矩阵是</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200121154343881.png" alt="image-20200121154343881"></p>
</blockquote>
<h6 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h6><blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200121154450682.png" alt="image-20200121154450682"></p>
</blockquote>
<h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><ul>
<li><em><strong>（x,y,z,0）</strong></em>表示向量</li>
<li><em><strong>（x,y,z,1）</strong></em>表示点</li>
</ul>
<h5 id="仿射变换定义"><a href="#仿射变换定义" class="headerlink" title="仿射变换定义"></a>仿射变换定义</h5><ul>
<li>仿射变换：一个线性变换加上一个平移变量 <em><strong>b</strong></em>,即</li>
</ul>
<blockquote>
<p> <em><strong>α(u)=τ(u)+b</strong></em></p>
</blockquote>
<ul>
<li>或者用矩阵表示法,A是一个线性变换的矩阵表示</li>
</ul>
<blockquote>
<p> <img src="https://img.supervj.top/img/DX/image-20200121160932351.png" alt="image-20200121160932351"></p>
</blockquote>
<ul>
<li>如果w=1把坐标扩充为齐次坐标，那么把上述公式简化成</li>
</ul>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200121161200597.png" alt="image-20200121161200597"></p>
</blockquote>
<h5 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h5><h6 id="恒等变换"><a href="#恒等变换" class="headerlink" title="恒等变换"></a>恒等变换</h6><p><strong>恒等变换</strong>是一种直接返回其输入参数的线性变换，如 <em><strong>I(u)=u</strong></em></p>
<p>如果将平移变换定义为仿射变换，贼其中的线性变换就是一种恒等变换，即</p>
<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200121161843458.png" alt="image-20200121161843458"></p>
</blockquote>
<h6 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h6><p><img src="https://img.supervj.top/img/DX/image-20200121161704819.png" alt="image-20200121161704819"></p>
<h6 id="平移矩阵的逆矩阵"><a href="#平移矩阵的逆矩阵" class="headerlink" title="平移矩阵的逆矩阵"></a>平移矩阵的逆矩阵</h6><p><img src="https://img.supervj.top/img/DX/image-20200121161727755.png" alt="image-20200121161727755"></p>
<h6 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h6><p><img src="https://img.supervj.top/img/DX/image-20200121161922233.png" alt="image-20200121161922233"></p>
<h5 id="缩放和旋转的放射矩阵"><a href="#缩放和旋转的放射矩阵" class="headerlink" title="缩放和旋转的放射矩阵"></a>缩放和旋转的放射矩阵</h5><ul>
<li>如果放射变换的 b=0 ,则放射变换就是线性变换</li>
<li>意味着，可以通过一个 4 x 4 的放射矩阵表达任意线性变换</li>
</ul>
<h6 id="4x4的缩放矩阵"><a href="#4x4的缩放矩阵" class="headerlink" title="4x4的缩放矩阵"></a>4x4的缩放矩阵</h6><p><img src="https://img.supervj.top/img/DX/image-20200121163133298.png" alt="image-20200121163133298"></p>
<h6 id="4x4的旋转矩阵"><a href="#4x4的旋转矩阵" class="headerlink" title="4x4的旋转矩阵"></a>4x4的旋转矩阵</h6><p><img src="https://img.supervj.top/img/DX/image-20200121163151822.png" alt="image-20200121163151822"></p>
<h5 id="仿射变换矩阵的几何意义"><a href="#仿射变换矩阵的几何意义" class="headerlink" title="仿射变换矩阵的几何意义"></a>仿射变换矩阵的几何意义</h5><p><img src="https://img.supervj.top/img/DX/image-20200121163854031.png" alt="image-20200121163854031"></p>
<h4 id="变换的复合"><a href="#变换的复合" class="headerlink" title="变换的复合"></a>变换的复合</h4><p>假设<em><strong>S</strong></em>为缩放矩阵，<em><strong>T</strong></em>为平移矩阵，<em><strong>R</strong></em>为旋转矩阵</p>
<p>因为矩阵乘法（不满足交换律），所以我么可以定义<em><strong>C=SRT</strong></em>，即把3个矩阵变成1个，方便计算</p>
<h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><h5 id="坐标变换矩阵-标架变换矩阵公式"><a href="#坐标变换矩阵-标架变换矩阵公式" class="headerlink" title="坐标变换矩阵/标架变换矩阵公式"></a>坐标变换矩阵/标架变换矩阵公式</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://img.supervj.top/img/DX/image-20200121170431813.png" alt="image-20200121170431813"></h5><h5 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h5><ul>
<li>3个标架<strong>F,G,H</strong></li>
<li><strong>A</strong>：<strong>F</strong>转换到<strong>G</strong>的变换矩阵</li>
<li><strong>B</strong>：<strong>G</strong>转换到<strong>H</strong>的变换矩阵</li>
<li><em><strong>p<sub>F</sub></strong></em>:<strong>F</strong>中的一个向量</li>
<li>求：此向量在标架H中的坐标<em><strong>P<sub>H</sub></strong></em></li>
</ul>
<p>***(p<sub>F</sub>***<strong>A)B</strong>=<em><strong>P<sub>H</sub></strong></em></p>
<p><em><strong>(p<sub>G</sub></strong></em><strong>)B</strong>=<em><strong>P<sub>H</sub></strong></em></p>
<ul>
<li>由于矩阵乘法满足结合律，所以</li>
</ul>
<p><em><strong>p<sub>F</sub></strong></em>(<strong>AB</strong>)=<em><strong>P<sub>H</sub></strong></em></p>
<h5 id="逆矩阵-1"><a href="#逆矩阵-1" class="headerlink" title="逆矩阵"></a>逆矩阵</h5><p><em><strong>p<sub>F</sub>A</strong></em>=<em><strong>P<sub>H</sub></strong></em></p>
<p><em><strong>P<sub>F</sub></strong></em>=<em><strong>p<sub>H</sub>A<sup>-1</sup></strong></em></p>
<h4 id="变换矩阵与坐标变换矩阵"><a href="#变换矩阵与坐标变换矩阵" class="headerlink" title="变换矩阵与坐标变换矩阵"></a>变换矩阵与坐标变换矩阵</h4><p>在数学上，可以将<strong>改变几何体的变换</strong>解释为<strong>坐标变换</strong>，反之亦然</p>
<h4 id="DirectXMath库的变换函数"><a href="#DirectXMath库的变换函数" class="headerlink" title="DirectXMath库的变换函数"></a>DirectXMath库的变换函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DirectXMath.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DirectXPackedVector.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX::PackedVector;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;( ostream&amp; os, FXMVECTOR v)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	XMFLOAT4 value;</span><br><span class="line">	<span class="built_in">XMStoreFloat4</span>(&amp;value, v);</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; value.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; value.y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; value.z &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; value.w &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, FXMMATRIX M)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		os  &lt;&lt; <span class="built_in">XMVectorGetX</span>(M.r[i]) &lt;&lt; <span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">		os  &lt;&lt; <span class="built_in">XMVectorGetY</span>(M.r[i]) &lt;&lt; <span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">		os  &lt;&lt; <span class="built_in">XMVectorGetZ</span>(M.r[i]) &lt;&lt; <span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">		os  &lt;&lt; <span class="built_in">XMVectorGetW</span>(M.r[i]) &lt;&lt; <span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">		os &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	XMMATRIX m1 =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>,</span><br><span class="line">		<span class="number">3.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0f</span>,</span><br><span class="line">		<span class="number">4.0f</span>, <span class="number">4.0f</span>, <span class="number">4.0f</span>, <span class="number">4.0f</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//缩放系数</span></span><br><span class="line">	XMMATRIX Scale1 = <span class="built_in">XMMatrixScaling</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>);<span class="comment">//缩放矩阵1</span></span><br><span class="line">	XMVECTOR v1 = <span class="built_in">XMVectorSet</span>(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>);</span><br><span class="line">	XMMATRIX Scale2 = <span class="built_in">XMMatrixScalingFromVector</span>(v1);<span class="comment">//缩放矩阵2，根据Vector</span></span><br><span class="line"></span><br><span class="line">	XMMATRIX RotX = <span class="built_in">XMMatrixRotationX</span>(<span class="number">90.f</span>);<span class="comment">//X轴旋转矩阵</span></span><br><span class="line">	XMMATRIX RotY = <span class="built_in">XMMatrixRotationY</span>(<span class="number">45.f</span>);</span><br><span class="line">	XMMATRIX RotZ = <span class="built_in">XMMatrixRotationZ</span>(<span class="number">-180.f</span>);</span><br><span class="line">	XMVECTOR Axis= <span class="built_in">XMVectorSet</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	XMMATRIX RotAxis = <span class="built_in">XMMatrixRotationAxis</span>(Axis, <span class="number">45.f</span>);<span class="comment">//根据自定义轴旋转</span></span><br><span class="line">	XMMATRIX TransT = <span class="built_in">XMMatrixTranslation</span>(<span class="number">100.f</span>, <span class="number">10.f</span>, <span class="number">-20.f</span>);<span class="comment">//位移矩阵</span></span><br><span class="line">	XMVECTOR vTransCoord = <span class="built_in">XMVector3TransformCoord</span>(v1, TransT);<span class="comment">//移动向量</span></span><br><span class="line">	XMVECTOR vTransNormal = <span class="built_in">XMVector3TransformNormal</span>(v1, TransT);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m=&quot;</span> &lt;&lt; endl &lt;&lt; m1  &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m*scale1=&quot;</span> &lt;&lt; endl&lt;&lt; m1* Scale1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m*scale2==&quot;</span> &lt;&lt; endl &lt;&lt; m1*Scale2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;RotX==&quot;</span> &lt;&lt; endl &lt;&lt; RotX &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m*RotX==&quot;</span> &lt;&lt; endl &lt;&lt; m1 * RotX &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1:TransCoord==&quot;</span> &lt;&lt; endl &lt;&lt; vTransCoord &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1:TransNormal==&quot;</span> &lt;&lt; endl &lt;&lt; vTransNormal &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://img.supervj.top/img/DX/image-20200121182846768.png" alt="image-20200121182846768"></p>
</blockquote>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>DirectX</tag>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DX学习笔记（二）：DX初始化</title>
    <url>/2020/06/22/LearnDX12_Init/</url>
    <content><![CDATA[<h2 id="Direct3D初始化"><a href="#Direct3D初始化" class="headerlink" title="Direct3D初始化"></a>Direct3D初始化</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h5 id="组件对象模型"><a href="#组件对象模型" class="headerlink" title="组件对象模型"></a>组件对象模型</h5><p>组件对象模型<em><strong>（Component Object Model,COM）</strong></em>:不受DirectX语言束缚，并且向后兼容的技术</p>
<ul>
<li>获得COM接口需要借助特定函数，而不是C++的new</li>
<li>删除COM有Release方法，而不是delete</li>
<li><code>Mirrosoft::WRL::ComPtr</code>类是Window是下的<em><strong>COM</strong></em>对象的智能指针</li>
<li>当<em><strong>ComPtr</strong></em>出作用域时，它会自动调用Release方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Get: 返回一个指向此底层COM接口的指针，此方法常用于把原始COM接口指针作为参数传给函数</span></span><br><span class="line">ComPtr&lt;ID3D12RootSignature&gt; mRootSignature;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//SetGraphicsRootSignature需要获取ID3D12RootSignature*类型的参数</span></span><br><span class="line">    mCommandList-&gt;<span class="built_in">SetGraphicsRootSignature</span>(mRootSignature.<span class="built_in">Get</span>());</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GetAddressOf:返回指向此底层COM接口指针的地址，此函数可以利用函数参数返回COM接口的指针</span></span><br><span class="line">ComPtr&lt;ID3D12CommandAlllocator&gt; mDirectCmdListAlloc;</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommandAllocator</span>(</span><br><span class="line">        D3D12_COMMAND_LIST_TYPE_DIRECT,</span><br><span class="line">    mDirectCmdListAlloc.<span class="built_in">GetAddressOf</span>());</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Reset:将此ComPtr实例设置为nullptr释放与之相关的所有引用，同时减少COM接口引用次数，此方法功能与将ComPtr目标实例赋值nullptr效果相同</span></span><br></pre></td></tr></table></figure>

<h5 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h5><p>2D纹理是一种由数据元素构成的矩阵，每个元素存储的都是一个像素的颜色</p>
<ul>
<li><p><strong>DXGI_FORMAT_R32G32B32_FLOAT</strong>:每个元素由2个32位无符号整数分量构成，<strong>存储的不一定是颜色信息</strong></p>
</li>
<li><p><strong>DXGI_FORMAT_R16G16B16A16_UNORM</strong>:每个元素由4个8位无符号分量构成，每个分量都被映射到**[0，1]**的区间</p>
</li>
<li><p><strong>DXGI_FORMAT_R32G32_UINT</strong>:每个元素由2个32位无符号整数分量构成</p>
</li>
<li><p><strong>DXGI_FORMAT_R8G8B8A8_UNORM</strong>:每个元素由4个8位无符号分量构成，每个分量都被映射到**[0，1]**的区间</p>
</li>
<li><p><strong>DXGI_FORMAT_R8G8B8A8_SNORM</strong>:每个元素由4个8位无符号分量构成，每个分量都被映射到**[-1，1]**的区间</p>
</li>
<li><p><strong>DXGI_FORMAT_R9G9B9A9_SINT</strong>:每个元素由4个8位无符号分量构成，每个分量都被映射到**[-128，127]**的区间</p>
</li>
<li><p><strong>DXGI_FORMAT_R8G8B8A8_UINT</strong>:每个元素由4个8位无符号分量构成，每个分量都被映射到**[0，255]**的区间</p>
</li>
</ul>
<p>其他格式</p>
<ul>
<li>DXGI_FORMAT_R16G16B16A16_TYPELESS:每个元素由4个16位无符号分量构成，<strong>但是没有指出数据类型</strong></li>
</ul>
<h5 id="交换链和页面翻转"><a href="#交换链和页面翻转" class="headerlink" title="交换链和页面翻转"></a>交换链和页面翻转</h5><p><img src="https://img.supervj.top/img/PathOptimization/image-20200122072822631.png"></p>
<ul>
<li>前台缓冲区和后台缓冲区在绘制渲染过程中互换，这种操作称为：<strong>呈现（presenting，亦有译作提交、显示）</strong></li>
<li>前后台缓冲区构成了交换链，Direct3D中用==<code>IDXGISwapChain</code>==接口来表示</li>
<li>这个接口不仅储存了前后台缓冲区的纹理，还提供了修改缓冲区大小(<em><strong>IDXGISwapChain::ResiezeBuffers</strong></em>)和呈现缓冲区内容(<em><strong>IDXGISwapChain::Present</strong></em>)的方法</li>
<li>使用2个缓冲区的情况称为<em><strong>双缓冲(double buffering,亦有译作双重缓冲、双倍缓冲等)</strong></em></li>
<li>还可以用更多的缓冲区，使用3个缓冲区就叫作<em><strong>三重缓冲（triple buffering）</strong></em></li>
</ul>
<h5 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h5><p><strong>深度缓冲区（depth buffer）</strong>：存储的非图像数据，而是特定像素的深度信息</p>
<ul>
<li>深度值范围 <em><strong>0.0-1.0</strong></em></li>
<li><strong>0.0</strong>代表观察者在<em><strong>视锥体</strong></em>（视域体、视景体、视截体、视体），即观察者能看到的空间范围</li>
<li><strong>1.0</strong>代表观察者在视锥体中嫩通过看到的离自己最远的像素</li>
<li>如果后台缓冲区的分辨率位<em>1280x1024</em>,那么深度缓冲去也应当由<em>1280x1024</em></li>
</ul>
<p><strong>深度缓冲区的原理</strong>：计算每个像素的深度值，并执行<em><strong>深度测试（depth test）</strong></em>，具有最小深度值的像素会最终写入后台缓冲</p>
<p>深度缓冲区也是一种纹理，用如下格式来创建</p>
<ol>
<li>DXGI_FORMAT_D32_FLOAT_S8X24_UINT:占用64位，取其中的32位指定一个浮点型深度缓冲区，另有8位无符号整数分配给<em><strong>模板缓冲区(stencil buffer)</strong></em>,并且将该元素映射到[<em><strong>0,255</strong></em>]</li>
<li> DXGI_FORMAT_D32_FLOAT:指定一个32位浮点型深度缓冲区</li>
<li> DXGI_FORMAT_D24_UNORM_指定一个无符号的24位深度缓冲区，并将该元素映射到[<em><strong>0,1</strong></em>]区间；另有8位无符号整数分配给<em><strong>模板缓冲区(stencil buffer)</strong></em>,并且将该元素映射到[<em><strong>0,255</strong></em>]</li>
<li>DXGI_FORMAT_D16_UNORM:指定一个16位浮点型深度缓冲区，并将该元素映射到[<em><strong>0,1</strong></em>]区间</li>
</ol>
<h5 id="资源与描述符"><a href="#资源与描述符" class="headerlink" title="资源与描述符"></a>资源与描述符</h5><blockquote>
<p>资源-&gt;中间层（即描述符）-&gt;GPU</p>
</blockquote>
<p><strong>描述符</strong></p>
<ul>
<li>一种把送往GPU的资源进行描述的轻量级结构；</li>
<li> 绘制所需的资源通过描述符绑定到渲染流水线上；</li>
<li> 为GPU解释资源，如告知Direct3D某个资源如何使用（绑定到流水线的哪个阶段）；</li>
<li> 指定欲绑定资源中的局部数据</li>
</ul>
<h6 id="常见描述符"><a href="#常见描述符" class="headerlink" title="常见描述符"></a>常见描述符</h6><ol>
<li><em><strong>CBV/SRV/UAV</strong></em> ：分表表示常量缓冲区(constant buffer view)、着色器资源视图(shader resource view)和无序访问试图(unordered access view)3种资源；</li>
<li>***采样器(sampler，亦有译作取样器)***：表示采样器资源（用于纹理）</li>
<li><em><strong>RTV</strong></em>:渲染目标视图资源(render target view)</li>
<li><em><strong>DSV</strong></em>：深度/模板视图资源(depth/stencil view)</li>
</ol>
<p><strong>描述符堆</strong>：存放某种特定类描述符的内存，可以看作是描述符数组</p>
<h5 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h5><h6 id="超级采样（SSAA）"><a href="#超级采样（SSAA）" class="headerlink" title="超级采样（SSAA）"></a>超级采样（SSAA）</h6><p>超级采样：反走样技术</p>
<ul>
<li>使用4倍于屏幕分辨率大小的后台缓冲区和深度缓冲去；</li>
<li>3D场景以这种更大的分辨率渲染到后台缓冲区中；</li>
<li>当数据要从后台缓冲区调往屏幕显示的时候，会将后台缓冲区按4个像素一组进行解析（降采样,downsample），把放大的采样点数降低回原来采样点数每组用求平均值的方法得到相对平滑的像素颜色</li>
<li>实际上是通过软件的方式提升了画面分辨率</li>
<li>超级采样是高开销的操作，因为限速处理数量和占用内存大小都增加到了4倍，因此Direct3D支持一种<strong>性能和效果</strong>折中的反走样技术：<em><strong>多重采样(multisampling)</strong></em>,记作<em><strong>MSAA</strong></em></li>
</ul>
<h6 id="多重采样（MSAA）"><a href="#多重采样（MSAA）" class="headerlink" title="多重采样（MSAA）"></a>多重采样（MSAA）</h6><ul>
<li>多重采样不需要对每个子像素都进行计算</li>
<li>而是仅计算一次像素中心的颜色，在基于可视性和覆盖性将得到的颜色信息分享给其子像素</li>
</ul>
<h6 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h6><ul>
<li><p>超级采样：图像颜色要根据每一个像素来计算，因此每个子像素都可以各具不的颜色；开销更大但是更精确</p>
</li>
<li><p>多重采样：每个像素只需要计算一次，最后假尼姑得到的颜色数据复制到多边形覆盖的所有可见子像素中</p>
</li>
</ul>
<h5 id="用Direct3D进行多重采样"><a href="#用Direct3D进行多重采样" class="headerlink" title="用Direct3D进行多重采样"></a>用Direct3D进行多重采样</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_SAMPLE_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UINT count;<span class="comment">//指定了每个像素的采样次数，采样次数越多，代价越高</span></span><br><span class="line">    UINT Quality;;<span class="comment">//指示用户期望的图像质量级别，不同厂家而言，这个参数相差很多</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据给定的纹理格式和采样数量，用<code>ID3D12Device::CheckFeatureSupport</code>方法查询对应的质量级别</p>
<ul>
<li>考虑到多重采样会占用内存资源，又为了保证程序性能等原因，通常会把采样数量设定位 <em><strong>4 或 8</strong></em></li>
<li>如果不希望使用多重采样，可以设置采样数量位1，质量设置为0</li>
</ul>
<h5 id="功能级别"><a href="#功能级别" class="headerlink" title="功能级别"></a>功能级别</h5><p>Direct3D 11开始引用了<em><strong>功能级别(feature level)</strong></em>,代码里用 <code>D3D_FEATURE_LEVEL</code>表示</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">D3D_FEATURE_LEVEL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    D3D_FEATURE_LEVEL_9_1 = <span class="number">0x9100</span>,</span><br><span class="line">    D3D_FEATURE_LEVEL_9_2 = <span class="number">0x9200</span>,</span><br><span class="line">    D3D_FEATURE_LEVEL_9_3 = <span class="number">0x9300</span>,</span><br><span class="line">    D3D_FEATURE_LEVEL_10_0 = <span class="number">0xa000</span>,</span><br><span class="line">    D3D_FEATURE_LEVEL_10_1 = <span class="number">0xa100</span>,</span><br><span class="line">    D3D_FEATURE_LEVEL_11_0 = <span class="number">0xb000</span>,</span><br><span class="line">    D3D_FEATURE_LEVEL_11_1 = <span class="number">0xb100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能级别为不同级别所支持的功能进行严格界定</li>
</ul>
<h5 id="DirectX图形学基础结构"><a href="#DirectX图形学基础结构" class="headerlink" title="DirectX图形学基础结构"></a>DirectX图形学基础结构</h5><p>DirectX图形学基础结构(DXGI)是一种与<em><strong>Direct3D配合使用的API</strong></em></p>
<p>如，<code>IDXGIFactory</code>是DXGI中的关键接口之一，用于创建<code>IDXGISwapChain</code>接口以及枚举<strong>显示适配器</strong></p>
<p>一个系统可能由数个显示设备，我们称每一台显示设备都是一个<strong>显示输出</strong>，用<code>IDXGIOutput</code>接口来表示</p>
<h5 id="功能支持的检测"><a href="#功能支持的检测" class="headerlink" title="功能支持的检测"></a>功能支持的检测</h5><p><code>ID3D12Device::CheckFeatureSupport</code>方法是检测当前图形驱动对多重过采样的支持，圆形如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">ID3D12Device::CheckFeatureSupport</span><span class="params">(D3D12_FEATURE Feature,<span class="keyword">void</span>* pFeatureSuportData,UINT FeatureSupportDataSize)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>***Feature:***枚举类型<code>D3D12_FEATURE</code>中的成员之一，用于指定我们希望检测的功能支持类型，具体如下</p>
<ul>
<li>D2D12_FEATURE_D3D12_OPTIONS:检测当前图形驱动对Direct3D 12各种功能的支持情况</li>
<li>D3D12_FEATURE_ARCHITECTURE:检测图形适配器中GPU的硬件体系架构特性</li>
<li>D3D12_FEATURE_FEATURE_LEVELS:检测对功能级别的支持情况</li>
<li>D3D12_FEATURE_FORMAT_SUPPORT:检测对给定纹理格式的支持情况</li>
<li>D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS:检测对多重采样功能的支持情况</li>
</ul>
</li>
<li><p><em><strong>pFeatureSuportData</strong></em>：指向某种数据结构的指针，该结构中存有检索到的特定功能支持的信息，<strong>此结构体的具体类型取决于Feature参数</strong></p>
<ul>
<li>D3D12_FEATURE_D3D12_OPTIONS:返回一个D3D12_FEATURE_DATA_D3D12_OPTIONS实例</li>
<li>D3D12_FEATURE_ARCHITECTURE:返回D3D12_FEATURE_ARCHITECTURE实例</li>
<li>D3D12_FEATURE_FEATURE_LEVELS:同上类推</li>
<li>D3D12_FEATURE_FORMAT_SUPPORT：同上类推</li>
<li>D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS：同上类推</li>
</ul>
</li>
<li><p>FeatureSupportDataSize：传回<em><strong>pFeatureSuportData</strong></em>参数中的数据结构大小</p>
</li>
</ul>
<h5 id="资源驻留"><a href="#资源驻留" class="headerlink" title="资源驻留"></a>资源驻留</h5><p>Direct3D12中，应用程序通过控制资源在显存中的去留，主动管理资源的驻留情况（<code>Direct3D11中则有系统自动管理</code>）</p>
<p>一般情况，资源创建时就会驻留在显存中，被销毁时则清出。但是通过下面方法我们可以自己管理资源的驻留</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">ID3D12Device::MakeResident</span><span class="params">(UINT NumObjects,ID3D12Pageable* <span class="keyword">const</span> *ppObjects)</span></span>;</span><br><span class="line"><span class="function">HRESULT <span class="title">ID3D12Device::Evict</span><span class="params">(UINT NumObjects,ID3D12Pageable* <span class="keyword">const</span> *ppObjects)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个方法的第二个参数都是<code>ID3D12Pageable</code>资源数组，第一个参数表示该数组资源的数量</p>
<h3 id="CPU和GPU的交互"><a href="#CPU和GPU的交互" class="headerlink" title="CPU和GPU的交互"></a>CPU和GPU的交互</h3><ul>
<li>每个GPU都至少维护这一个命令队列(command queue，本质上是环形缓冲区，即ring buffer)。</li>
<li>借助Direct3D API，CPU可以用命令列表(command list)将命令提交到这个队列中去</li>
<li>新加入的命令不会立即执行</li>
<li>假如命令列表空空如也，那么GPU会闲置</li>
<li>假如命令列表填满，那么CPU会在某个时刻保持空闲</li>
</ul>
<p>在Direct3D 12中，命令队列被抽象为==<code>ID3D12CommandQueue</code>==接口来表示，通过填写<code>D3D12_COMMAND_QUEUE_DESC</code>结构体来表示队列，在通过调用<code>ID3D12Device::CreateCommandQueue</code>方法来创建。</p>
<h5 id="命令队列"><a href="#命令队列" class="headerlink" title="命令队列"></a>命令队列</h5><h6 id="创建命令队列"><a href="#创建命令队列" class="headerlink" title="创建命令队列"></a>创建命令队列</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建队列智能指针</span></span><br><span class="line">Microsoft::WRL::ComPtr&lt;ID3D12CommandQueue&gt; mCommandQueue;</span><br><span class="line">...;</span><br><span class="line"></span><br><span class="line">D3D12_COMMAND_QUEUE_DESC queueDesc = &#123;&#125;;</span><br><span class="line">queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;</span><br><span class="line">queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;</span><br><span class="line"><span class="comment">//创建队列方法</span></span><br><span class="line"> <span class="comment">//IID_PPV_ARGS辅助宏本质是将ppType强制转换为void**类型</span></span><br><span class="line"><span class="comment">//Direct3D 12中创建接口实例的API时，大多数都有一个参数是类型void**的待创接口COM ID</span></span><br><span class="line"><span class="built_in">ThrowIfFailed</span>(md3dDevice&gt;<span class="built_in">CreateCommandQueue</span>(&amp;queueDesc,<span class="built_in">IID_PPV_ARGS</span>(&amp;mCommandQueue))); </span><br><span class="line"></span><br><span class="line">...;</span><br><span class="line"><span class="comment">//添加命令到命令列表里</span></span><br><span class="line"><span class="comment">//第一个参数是待执行的命令列表数组的数量</span></span><br><span class="line"><span class="comment">//第二个参数是待执行的命令列表数组</span></span><br><span class="line"> mCommandQueue-&gt;<span class="built_in">ExecuteCommandLists</span>(_countof(cmdsLists), cmdsLists);</span><br><span class="line"><span class="comment">//下列两个方法不是执行命令，而是将命令添加到命令列表里，还是需要通过ExecuteCommandLists方法才将命令真正加入到命令列表</span></span><br><span class="line"> mCommandQueue-&gt;<span class="built_in">DrawIndexedInstanced</span>(<span class="number">36</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"> mCommandQueue-&gt;<span class="built_in">RSSetViewports</span>(<span class="number">1</span>,&amp;mScreenViewport);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结束记录命令</span></span><br><span class="line"><span class="comment">//必须在调用ExecuteCommandLists方法之前先关闭</span></span><br><span class="line"> mCommandQueue-&gt;<span class="built_in">Close</span>();</span><br></pre></td></tr></table></figure>

<h6 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h6><p>内存分配器：存储命令列表里的命令，执行<code>ID3D12CommandQueue::ExecuteCommandLists</code>方法时，<strong>命令队列</strong>就会引用<strong>分配器里的命令</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">CreateCommandAllocator</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">            _In_  D3D12_COMMAND_LIST_TYPE type,</span></span></span><br><span class="line"><span class="params"><span class="function">            REFIID riid,</span></span></span><br><span class="line"><span class="params"><span class="function">            _COM_Outptr_  <span class="keyword">void</span> **ppCommandAllocator)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>type</code>:命令列表类型<ul>
<li><code>D3D12_COMMAND_LIST_TYPE_DIRECT</code>:GPU可直接执行的命令</li>
<li><code>D3D12_COMMAND_LIST_TYPE_BUNDLE</code>:打包的命令列表，一般不用</li>
</ul>
</li>
<li><code>riid</code>：适配接口的COM ID</li>
<li><code>ppCommandAllocator</code>:输出指向所建命令分配器的指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存管理指针</span></span><br><span class="line">Microsoft::WRL::ComPtr&lt;ID3D12CommandAllocator&gt; mDirectCmdListAlloc;</span><br><span class="line">...;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数：此命令分配器相关联的命令列表类型，具体见下图</span></span><br><span class="line"><span class="comment">//第二个参数：内存分配器地址</span></span><br><span class="line"><span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommandAllocator</span>(</span><br><span class="line">		D3D12_COMMAND_LIST_TYPE_DIRECT,</span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(mDirectCmdListAlloc.<span class="built_in">GetAddressOf</span>())));</span><br></pre></td></tr></table></figure>





<h6 id="创建命令列表"><a href="#创建命令列表" class="headerlink" title="创建命令列表"></a>创建命令列表</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">CreateCommandList</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">            _In_  UINT nodeMask,</span></span></span><br><span class="line"><span class="params"><span class="function">            _In_  D3D12_COMMAND_LIST_TYPE type,</span></span></span><br><span class="line"><span class="params"><span class="function">            _In_  ID3D12CommandAllocator *pCommandAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">            _In_opt_  ID3D12PipelineState *pInitialState,</span></span></span><br><span class="line"><span class="params"><span class="function">            REFIID riid,</span></span></span><br><span class="line"><span class="params"><span class="function">            _COM_Outptr_  <span class="keyword">void</span> **ppCommandList)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommandList</span>(</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		D3D12_COMMAND_LIST_TYPE_DIRECT,</span><br><span class="line">		mDirectCmdListAlloc.<span class="built_in">Get</span>(), <span class="comment">// Associated command allocator</span></span><br><span class="line">		<span class="literal">nullptr</span>,                   <span class="comment">// Initial PipelineStateObject</span></span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(mCommandList.<span class="built_in">GetAddressOf</span>())));</span><br></pre></td></tr></table></figure>

<ol>
<li>nodeMask:如果只有1个GPU，设置成0；多个GPU用于关联的物理GPU</li>
<li>type:命令列表类型</li>
<li>pCommandAllocator:所建命令列表关联的命令分配器，类型必须匹配</li>
<li>pInitialState:指定命令列表的渲染流水线初始状态，一般可以设置为<code>nullptr</code></li>
<li>riid:待创建的<code>ID3D12CommandList</code>接口的<code>COM ID</code></li>
<li>ppCommandList:输出指向所建命令列表的指针</li>
</ol>
<h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><ul>
<li>可以创建多个关联同一个命令分配器的命令列表</li>
<li>但是不能同时用他们记录命令</li>
<li>其中一个命令列表在记录命令时，必须关闭同一分配器的其他命令列表</li>
<li>要保证命令列表中的所有命令都会按顺序连续的添加到命令分配器内</li>
<li>当创建或重置一个命令列表时，它会处于“<em><strong>打开</strong></em> ”状态，所以同时为同一命令列表分配器创建两个命令列表会报错</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ID3D12CommandQueue::<span class="built_in">ExecuteCommandList</span>(C)；<span class="comment">//把命令添加到命令列表</span></span><br><span class="line">    <span class="comment">/*将命令列表恢复到初始状态，借此继续复用其底层内存；</span></span><br><span class="line"><span class="comment">    重置列表不会影响命令队列的命令，内存分配器在当中维护</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ID3D12GraphicsCommandLIst::<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPU提交了一整帧的渲染命令后，我们可能还要为了绘制下一帧服用命令分配器的内存</span></span><br><span class="line"><span class="comment">//注意：在没有确定GPU执行完命令分配器的所有命令之前，千万不要重置命令分配器</span></span><br><span class="line">ID3D12CommandAllocator::<span class="built_in">Reset</span>();</span><br></pre></td></tr></table></figure>

<h5 id="GPU与CPU的同步"><a href="#GPU与CPU的同步" class="headerlink" title="GPU与CPU的同步"></a>GPU与CPU的同步</h5><p><strong>刷新命令队列</strong>：CPU会等待GPU完成所有命令处理，直到到达指定的***围栏点(fence point)***为止。</p>
<p>创建围栏</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">ID3D12Device::CreateFence</span><span class="params">(UINT64 InitialValue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  D3D12_FENSE_FLAGS Flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 REFIID riid,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">void</span>** ppFence)</span></span>;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"> Microsoft::WRL::ComPtr&lt;ID3D12Fence&gt; mFence;</span><br><span class="line"><span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateFence</span>(<span class="number">0</span>, D3D12_FENCE_FLAG_NONE,</span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(&amp;mFence)));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D3DApp::FlushCommandQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 增加围栏值，接下来将命令标记到此围栏点</span></span><br><span class="line">    mCurrentFence++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向命令队列添加一条用来设置新围栏点的命令</span></span><br><span class="line">    <span class="comment">//由于这条命令有交给GPU处理，所以在GPU处理完命令队列中此Signal()的所有命令之前</span></span><br><span class="line">    <span class="comment">//它不会设置新的围栏点</span></span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(mCommandQueue-&gt;<span class="built_in">Signal</span>(mFence.<span class="built_in">Get</span>(), mCurrentFence));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在CPU等待GPU，直到后者执行完这个围栏点之前的所有命令</span></span><br><span class="line">    <span class="keyword">if</span>(mFence-&gt;<span class="built_in">GetCompletedValue</span>() &lt; mCurrentFence)</span><br><span class="line">	&#123;</span><br><span class="line">		HANDLE eventHandle = <span class="built_in">CreateEventEx</span>(<span class="literal">nullptr</span>, <span class="literal">false</span>, <span class="literal">false</span>, EVENT_ALL_ACCESS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若GPU命令中当前的围栏点（即执行到Signal()指令，修改了围栏点），则激发预定事件 </span></span><br><span class="line">        <span class="built_in">ThrowIfFailed</span>(mFence-&gt;<span class="built_in">SetEventOnCompletion</span>(mCurrentFence, eventHandle));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待GPU命中围栏，激发事件</span></span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(eventHandle, INFINITE);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(eventHandle);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="资源转换"><a href="#资源转换" class="headerlink" title="资源转换"></a>资源转换</h5><p><strong>资源冒险</strong>：当GPU的写操作还没有完成或者还没有开始，却开始读取资源的情况</p>
<p>为了解决资源冒险问题，Direct3D设计了一组相关状态，如资源在创建的时候会初一默认状态，直到应用程序通过方法将其转换为另一种状态。</p>
<p><strong>转换资源屏障(<em>transition resource barrier</em></strong>):通过一个API调用来转换多个资源要用到的数组</p>
<h3 id="初始化Direct3D"><a href="#初始化Direct3D" class="headerlink" title="初始化Direct3D"></a>初始化Direct3D</h3><ul>
<li>初始化流程</li>
</ul>
<ol>
<li>用<code>D3D12CreateDevice</code>函数创建<code>ID3D12Device</code>接口实例</li>
<li>创建一个<code>ID3D12Fence</code>对象，并且查询描述符的大小</li>
<li>检测用户设备对<code>4X MSAA</code>质量级别的支持情况</li>
<li>一次创建命令队列、命令列表分配器和主命令列表</li>
<li>描述并创建交换链</li>
<li>创建应用程序所需的描述符堆</li>
<li>调整后台缓冲区的大小，并为它创建渲染图标视图</li>
<li>创建深度/模板缓冲区及与之关联的深度/模板视图</li>
<li>设置视口(viewport)和裁剪矩形(scissor rectangle)</li>
</ol>
<h5 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT WINAPI <span class="title">D3D12CreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ IUnknown* pAdapter,</span></span></span><br><span class="line"><span class="params"><span class="function">    D3D_FEATURE_LEVEL MinimumFeatureLevel,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ REFIID riid, <span class="comment">// Expected: ID3D12Device</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _COM_Outptr_opt_ <span class="keyword">void</span>** ppDevice )</span></span>;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Try to create hardware device.</span></span><br><span class="line">HRESULT hardwareResult = <span class="built_in">D3D12CreateDevice</span>(</span><br><span class="line">	<span class="literal">nullptr</span>,             <span class="comment">// default adapter</span></span><br><span class="line">	D3D_FEATURE_LEVEL_11_0,</span><br><span class="line">	<span class="built_in">IID_PPV_ARGS</span>(&amp;md3dDevice));</span><br></pre></td></tr></table></figure>

<ol>
<li><code>pAdapte</code>r:使用的显示适配器，如果空，则使用主显示适配器</li>
<li><code>MinimumFeatureLevele</code>:应用程序需要硬件所支持的最低功能级别，如果适配器不支持此功能级别，则设备创建失败</li>
<li><code>riid</code>:<code>ID3D12Device</code>接口的COM ID</li>
<li><code>ppDevice</code>:返回创建的Direct3D 12设备</li>
</ol>
<blockquote>
<p>创建失败的话会尝试创建<code>WARP</code>设备</p>
</blockquote>
<h5 id="创建围栏"><a href="#创建围栏" class="headerlink" title="创建围栏"></a>创建围栏</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateFence</span>(<span class="number">0</span>, D3D12_FENCE_FLAG_NONE,</span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(&amp;mFence)));</span><br><span class="line"><span class="comment">//查询并保存描述符信息，方便后面使用</span></span><br><span class="line">	mRtvDescriptorSize = md3dDevice-&gt;<span class="built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);</span><br><span class="line">	mDsvDescriptorSize = md3dDevice-&gt;<span class="built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);</span><br><span class="line">	mCbvSrvUavDescriptorSize = md3dDevice-&gt;<span class="built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);</span><br></pre></td></tr></table></figure>

<h5 id="检测4X-MSAA支持"><a href="#检测4X-MSAA支持" class="headerlink" title="检测4X MSAA支持"></a>检测4X MSAA支持</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Check 4X MSAA quality support for our back buffer format.</span></span><br><span class="line">   <span class="comment">// All Direct3D 11 capable devices support 4X MSAA for all render </span></span><br><span class="line">   <span class="comment">// target formats, so we only need to check quality support.</span></span><br><span class="line"></span><br><span class="line">D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS msQualityLevels;</span><br><span class="line">msQualityLevels.Format = mBackBufferFormat;</span><br><span class="line">msQualityLevels.SampleCount = <span class="number">4</span>;</span><br><span class="line">msQualityLevels.Flags = D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE;</span><br><span class="line">msQualityLevels.NumQualityLevels = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CheckFeatureSupport</span>(</span><br><span class="line">	D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS,</span><br><span class="line">	&amp;msQualityLevels,</span><br><span class="line">	<span class="built_in"><span class="keyword">sizeof</span></span>(msQualityLevels)));</span><br><span class="line"></span><br><span class="line">   m4xMsaaQuality = msQualityLevels.NumQualityLevels;</span><br><span class="line"><span class="built_in">assert</span>(m4xMsaaQuality &gt; <span class="number">0</span> &amp;&amp; <span class="string">&quot;Unexpected MSAA quality level.&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="创建命令队列和命令列表"><a href="#创建命令队列和命令列表" class="headerlink" title="创建命令队列和命令列表"></a>创建命令队列和命令列表</h5><ul>
<li><p>命令队列：<code>ID3D12CommandQueue</code></p>
</li>
<li><p>命令分配器：<code>ID3D12CommandAllocator</code></p>
</li>
<li><p>命令列表：<code>ID3D12GraphicsCommandList</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h申明</span></span><br><span class="line">Microsoft::WRL::ComPtr&lt;ID3D12CommandQueue&gt; mCommandQueue;</span><br><span class="line">    Microsoft::WRL::ComPtr&lt;ID3D12CommandAllocator&gt; mDirectCmdListAlloc;</span><br><span class="line">    Microsoft::WRL::ComPtr&lt;ID3D12GraphicsCommandList&gt; mCommandList;</span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D3DApp::CreateCommandObjects</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D3D12_COMMAND_QUEUE_DESC queueDesc = &#123;&#125;;</span><br><span class="line">	queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;</span><br><span class="line">	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommandQueue</span>(&amp;queueDesc, <span class="built_in">IID_PPV_ARGS</span>(&amp;mCommandQueue)));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommandAllocator</span>(</span><br><span class="line">		D3D12_COMMAND_LIST_TYPE_DIRECT,</span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(mDirectCmdListAlloc.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommandList</span>(</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		D3D12_COMMAND_LIST_TYPE_DIRECT,</span><br><span class="line">		mDirectCmdListAlloc.<span class="built_in">Get</span>(), <span class="comment">// 关联的命令分配器</span></span><br><span class="line">		<span class="literal">nullptr</span>,                   <span class="comment">//初始的PipelineStateObject</span></span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(mCommandList.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line"></span><br><span class="line"><span class="comment">//从关闭状态开始。 这是因为我们第一次提到</span></span><br><span class="line"><span class="comment">//在命令列表中，我们将对其进行重置，并且需要先关闭它</span></span><br><span class="line"><span class="comment">//调用Reset。</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="创建交换链"><a href="#创建交换链" class="headerlink" title="创建交换链"></a>创建交换链</h5><ul>
<li><code>DXGI_SWAP_CHAIN_DESC</code>结构体定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_SWAP_CHAIN_DESC</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    DXGI_MODE_DESC BufferDesc;</span><br><span class="line">    DXGI_SAMPLE_DESC SampleDesc;</span><br><span class="line">    DXGI_USAGE BufferUsage;</span><br><span class="line">    UINT BufferCount;</span><br><span class="line">    HWND OutputWindow;</span><br><span class="line">    BOOL Windowed;</span><br><span class="line">    DXGI_SWAP_EFFECT SwapEffect;</span><br><span class="line">    UINT Flags;</span><br><span class="line">    &#125; 	DXGI_SWAP_CHAIN_DESC;</span><br></pre></td></tr></table></figure>

<ol>
<li>BufferDesc:后台缓冲区的属性，主要是高度、宽度和像素格式</li>
<li>SampleDesc：多重采样的质量级别以及对每个像素的采样次数</li>
<li>BufferUsage：如果要将数据渲染到后台缓冲区，则设置为<code>DXGI_USAGE_RENDER_TARGET_OUTPUT</code></li>
<li>BufferCount:缓冲区数量，指定为2即双缓冲</li>
<li>OutputWindow：渲染窗口的句柄</li>
<li>Windowed：true则窗口模式运行，否则全屏</li>
<li>SwapEffect：指定为<code>DXGI_SWAP_EFFECT_FLIP_DISCARD</code></li>
<li>Flags：可选；如果指定为<code>DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH</code>则程序切换为全屏时，将选择适用于当前窗口尺寸的显示模式；否则就采用当前桌面的显示模式</li>
</ol>
<ul>
<li><code>DXGI_MODE_DESC</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_MODE_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UINT Width;<span class="comment">//缓冲区分辨率的宽度</span></span><br><span class="line">    UINT Height;<span class="comment">//高度</span></span><br><span class="line">    DXGI_RATIONAL RefreshRate;</span><br><span class="line">    DXGI_FORMAT Format;<span class="comment">//显示格式</span></span><br><span class="line">    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;<span class="comment">//逐行扫面vs.隔行扫描</span></span><br><span class="line">    DXGI_MODE_SCALING Scaling;<span class="comment">//如何进行拉升</span></span><br><span class="line">&#125; DXGI_MODE_DESC;</span><br></pre></td></tr></table></figure>

<h6 id="执行创建交换链"><a href="#执行创建交换链" class="headerlink" title="执行创建交换链"></a>执行创建交换链</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D3DApp::CreateSwapChain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 释放我们将重新创建的先前的交换链。</span></span><br><span class="line">    mSwapChain.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">    DXGI_SWAP_CHAIN_DESC sd;</span><br><span class="line">    sd.BufferDesc.Width = mClientWidth;</span><br><span class="line">    sd.BufferDesc.Height = mClientHeight;</span><br><span class="line">    sd.BufferDesc.RefreshRate.Numerator = <span class="number">60</span>;</span><br><span class="line">    sd.BufferDesc.RefreshRate.Denominator = <span class="number">1</span>;</span><br><span class="line">    sd.BufferDesc.Format = mBackBufferFormat;</span><br><span class="line">    sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;</span><br><span class="line">    sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;</span><br><span class="line">    sd.SampleDesc.Count = m4xMsaaState ? <span class="number">4</span> : <span class="number">1</span>;</span><br><span class="line">    sd.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;</span><br><span class="line">    sd.BufferCount = SwapChainBufferCount;</span><br><span class="line">    sd.OutputWindow = mhMainWnd;</span><br><span class="line">    sd.Windowed = <span class="literal">true</span>;</span><br><span class="line">	sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;</span><br><span class="line">    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note: 交换链使用队列执行刷新。</span></span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(mdxgiFactory-&gt;<span class="built_in">CreateSwapChain</span>(</span><br><span class="line">		mCommandQueue.<span class="built_in">Get</span>(),</span><br><span class="line">		&amp;sd, </span><br><span class="line">		mSwapChain.<span class="built_in">GetAddressOf</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="创建描述符堆"><a href="#创建描述符堆" class="headerlink" title="创建描述符堆"></a>创建描述符堆</h5><p>创建描述符堆来存储程序中要用到的<strong>描述符/视图</strong>，本例中需要创建两个描述符堆来存储<code>SwapChainBufferCount</code>个<code>RTV</code> ,另外一个存储1个<code>DSV</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12DescriptorHeap&gt; mRtvHeap;</span><br><span class="line">    Microsoft::WRL::ComPtr&lt;ID3D12DescriptorHeap&gt; mDsvHeap;</span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D3DApp::CreateRtvAndDsvDescriptorHeaps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc;</span><br><span class="line">    rtvHeapDesc.NumDescriptors = SwapChainBufferCount;<span class="comment">//static value=2</span></span><br><span class="line">    rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;</span><br><span class="line">    rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;</span><br><span class="line">	rtvHeapDesc.NodeMask = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateDescriptorHeap</span>(</span><br><span class="line">        &amp;rtvHeapDesc, <span class="built_in">IID_PPV_ARGS</span>(mRtvHeap.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc;</span><br><span class="line">    dsvHeapDesc.NumDescriptors = <span class="number">1</span>;</span><br><span class="line">    dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;</span><br><span class="line">    dsvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;</span><br><span class="line">	dsvHeapDesc.NodeMask = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateDescriptorHeap</span>(</span><br><span class="line">        &amp;dsvHeapDesc, <span class="built_in">IID_PPV_ARGS</span>(mDsvHeap.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建以后需要通过方法来获得描述符的句柄</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">D3D12_CPU_DESCRIPTOR_HANDLE <span class="title">D3DApp::CurrentBackBufferView</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//构造函数根据给定的偏移量找到当前后台缓冲区的RTV</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">CD3DX12_CPU_DESCRIPTOR_HANDLE</span>(</span><br><span class="line">		mRtvHeap-&gt;<span class="built_in">GetCPUDescriptorHandleForHeapStart</span>(),<span class="comment">//堆中的首个句柄</span></span><br><span class="line">		mCurrBackBuffer,<span class="comment">//偏移至后台缓冲区描述符句柄的索引</span></span><br><span class="line">		mRtvDescriptorSize);<span class="comment">//描述符所占字节大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">D3D12_CPU_DESCRIPTOR_HANDLE <span class="title">D3DApp::DepthStencilView</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mDsvHeap-&gt;<span class="built_in">GetCPUDescriptorHandleForHeapStart</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建渲染目标视图"><a href="#创建渲染目标视图" class="headerlink" title="创建渲染目标视图"></a>创建渲染目标视图</h5><blockquote>
<p>资源不能与渲染流水线中的阶段直接绑定，所以必须先为资源创建视图（描述符），并将其绑定到流水线阶段</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">GetBuffer</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="comment">/* [in] */</span> UINT Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="comment">/* [annotation][in] */</span> </span></span></span><br><span class="line"><span class="params"><span class="function">           _In_  REFIID riid,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="comment">/* [annotation][out][in] */</span> </span></span></span><br><span class="line"><span class="params"><span class="function">           _COM_Outptr_  <span class="keyword">void</span> **ppSurface)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>Buffer:后台缓冲区索引</li>
<li>riid:COM ID</li>
<li>ppSurface:返回<code>ID3D12Resource</code>接口的指针，即后台缓冲区</li>
</ol>
<blockquote>
<p>调用此方法后会增加计数，所以使用后需要释放，需通过ComPtr</p>
</blockquote>
<p>然后获得后台缓冲区创建的渲染目标视图</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> STDMETHODCALLTYPE <span class="title">CreateRenderTargetView</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">           _In_opt_  ID3D12Resource *pResource,</span></span></span><br><span class="line"><span class="params"><span class="function">           _In_opt_  <span class="keyword">const</span> D3D12_RENDER_TARGET_VIEW_DESC *pDesc,</span></span></span><br><span class="line"><span class="params"><span class="function">           _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>pResource:指定用作渲染目标的资源</li>
<li>pDesc:指向<code>D3D12_RENDER_TARGET_VIEW_DESC</code>数组结构体的指针</li>
<li>DestDescriptor:引用所创建渲染目标视图的描述符句柄</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="title">rtvHeapHandle</span><span class="params">(mRtvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; SwapChainBufferCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//获得交换链中的第 i 个缓冲区</span></span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(mSwapChain-&gt;<span class="built_in">GetBuffer</span>(i, <span class="built_in">IID_PPV_ARGS</span>(&amp;mSwapChainBuffer[i])));</span><br><span class="line">        <span class="comment">//为此缓冲区创建一个RTV</span></span><br><span class="line">		md3dDevice-&gt;<span class="built_in">CreateRenderTargetView</span>(mSwapChainBuffer[i].<span class="built_in">Get</span>(), <span class="literal">nullptr</span>, rtvHeapHandle);</span><br><span class="line">        <span class="comment">//偏移到下一个缓冲区</span></span><br><span class="line">		rtvHeapHandle.<span class="built_in">Offset</span>(<span class="number">1</span>, mRtvDescriptorSize);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h5 id="创建深度-模板缓冲区及其视图"><a href="#创建深度-模板缓冲区及其视图" class="headerlink" title="创建深度/模板缓冲区及其视图"></a>创建深度/模板缓冲区及其视图</h5><p>因为深度缓冲区就是一种2D纹理，所以我们通过填写<code>D3D12_RESOURCE_DESC</code>结构体来描述纹理资源</p>
<p>再用<code>ID3D12Device::CreateCommittedResource</code>方法来创建它</p>
<ul>
<li>D3D12_RESOURCE_DESC</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_RESOURCE_DESC</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    D3D12_RESOURCE_DIMENSION Dimension;</span><br><span class="line">    UINT64 Alignment;</span><br><span class="line">    UINT64 Width;</span><br><span class="line">    UINT Height;</span><br><span class="line">    UINT16 DepthOrArraySize;</span><br><span class="line">    UINT16 MipLevels;</span><br><span class="line">    DXGI_FORMAT Format;</span><br><span class="line">    DXGI_SAMPLE_DESC SampleDesc;</span><br><span class="line">    D3D12_TEXTURE_LAYOUT Layout;</span><br><span class="line">    D3D12_RESOURCE_FLAGS Flags;</span><br><span class="line">    &#125; 	D3D12_RESOURCE_DESC;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>D3D12_RESOURCE_DIMENSION Dimension：资源的维度</p>
<ol>
<li>```cpp<br>enum D3D12_RESOURCE_DIMENSION<pre><code>&#123;
    D3D12_RESOURCE_DIMENSION_UNKNOWN    = 0,
    D3D12_RESOURCE_DIMENSION_BUFFER    = 1,
    D3D12_RESOURCE_DIMENSION_TEXTURE1D    = 2,
    D3D12_RESOURCE_DIMENSION_TEXTURE2D    = 3,
    D3D12_RESOURCE_DIMENSION_TEXTURE3D    = 4
&#125;     D3D12_RESOURCE_DIMENSION;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. Width:像素单位的纹理宽度。对于缓冲区，此项是占用的字节数</span><br><span class="line"></span><br><span class="line">3. Height:同上</span><br><span class="line"></span><br><span class="line">4. DepthOrArraySize:纹素为单位的纹理深度，或者是纹理数组的大小</span><br><span class="line"></span><br><span class="line">5. MipLevels：mipmap层级的数量</span><br><span class="line"></span><br><span class="line">6. Format:DXGI_FORMAT枚举成员之一</span><br><span class="line"></span><br><span class="line">7. SampleDesc：多重采样级别和每个像素的采样次数</span><br><span class="line"></span><br><span class="line">8. Layout：D3D12_TEXTURE_LAYOUT枚举成员之一，用于指定纹理布局</span><br><span class="line"></span><br><span class="line">9. Flags：杂项标记，对于深度/模板缓冲区资源，设置为`D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; `GPU`资源都存储在`堆`中，本质是具有特定属性的`GPU`显存快</span><br><span class="line">&gt;</span><br><span class="line">&gt; `ID3D12Device::CreateCommitedResource`方法根据提供的属性创建一个资源和一个堆，把资源提交到这个堆</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### CreateCommittedResource</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">virtual HRESULT STDMETHODCALLTYPE CreateCommittedResource( </span><br><span class="line">            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,//资源提交到的堆的属性，见下</span><br><span class="line">            D3D12_HEAP_FLAGS HeapFlags,//额外标记，一般是D3D12_HEAP_FLAG_NONE</span><br><span class="line">            _In_  const D3D12_RESOURCE_DESC *pDesc,//描述待创建的资源</span><br><span class="line">            D3D12_RESOURCE_STATES InitialResourceState,//此参数来设置资源的初始状态</span><br><span class="line">            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,//清楚资源的优化值，不需要就选择nullptr</span><br><span class="line">            REFIID riidResource,//COM ID</span><br><span class="line">            _COM_Outptr_opt_  void **ppvResource) = 0;//新创建的资源，指向ID3D12Resource的指针</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h6 id="D3D12-HEAP-PROPERTIES"><a href="#D3D12-HEAP-PROPERTIES" class="headerlink" title="D3D12_HEAP_PROPERTIES"></a>D3D12_HEAP_PROPERTIES</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_HEAP_PROPERTIES</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    D3D12_HEAP_TYPE Type;</span><br><span class="line">    D3D12_CPU_PAGE_PROPERTY CPUPageProperty;</span><br><span class="line">    D3D12_MEMORY_POOL MemoryPoolPreference;</span><br><span class="line">    UINT CreationNodeMask;</span><br><span class="line">    UINT VisibleNodeMask;</span><br><span class="line">    &#125; 	D3D12_HEAP_PROPERTIES;</span><br></pre></td></tr></table></figure>

<h6 id="D3D12-HEAP-TYPE"><a href="#D3D12-HEAP-TYPE" class="headerlink" title="D3D12_HEAP_TYPE"></a>D3D12_HEAP_TYPE</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">D3D12_HEAP_TYPE</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        D3D12_HEAP_TYPE_DEFAULT	= <span class="number">1</span>,<span class="comment">//默认堆</span></span><br><span class="line">        D3D12_HEAP_TYPE_UPLOAD	= <span class="number">2</span>,<span class="comment">//上传堆</span></span><br><span class="line">        D3D12_HEAP_TYPE_READBACK	= <span class="number">3</span>,<span class="comment">//回读堆</span></span><br><span class="line">        D3D12_HEAP_TYPE_CUSTOM	= <span class="number">4</span><span class="comment">//高级场景使用</span></span><br><span class="line">    &#125; 	D3D12_HEAP_TYPE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Create the depth/stencil buffer and view.</span></span><br><span class="line">  D3D12_RESOURCE_DESC depthStencilDesc;</span><br><span class="line">  depthStencilDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;</span><br><span class="line">  depthStencilDesc.Alignment = <span class="number">0</span>;</span><br><span class="line">  depthStencilDesc.Width = mClientWidth;</span><br><span class="line">  depthStencilDesc.Height = mClientHeight;</span><br><span class="line">  depthStencilDesc.DepthOrArraySize = <span class="number">1</span>;</span><br><span class="line">  depthStencilDesc.MipLevels = <span class="number">1</span>;</span><br><span class="line">  depthStencilDesc.Format = mDepthStencilFormat;</span><br><span class="line">  depthStencilDesc.SampleDesc.Count = m4xMsaaState ? <span class="number">4</span> : <span class="number">1</span>;</span><br><span class="line">  depthStencilDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">  depthStencilDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;</span><br><span class="line">  depthStencilDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;</span><br><span class="line"></span><br><span class="line">  D3D12_CLEAR_VALUE optClear;</span><br><span class="line">  optClear.Format = mDepthStencilFormat;</span><br><span class="line">  optClear.DepthStencil.Depth = <span class="number">1.0f</span>;</span><br><span class="line">  optClear.DepthStencil.Stencil = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommittedResource</span>(</span><br><span class="line">      &amp;<span class="built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),</span><br><span class="line">D3D12_HEAP_FLAG_NONE,</span><br><span class="line">      &amp;depthStencilDesc,</span><br><span class="line">D3D12_RESOURCE_STATE_COMMON,</span><br><span class="line">      &amp;optClear,</span><br><span class="line">      <span class="built_in">IID_PPV_ARGS</span>(mDepthStencilBuffer.<span class="built_in">GetAddressOf</span>())));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 使用资源格式将描述符创建为整个资源的MIP级别0。</span></span><br><span class="line">   md3dDevice-&gt;<span class="built_in">CreateDepthStencilView</span>(mDepthStencilBuffer.<span class="built_in">Get</span>(), <span class="literal">nullptr</span>, <span class="built_in">DepthStencilView</span>());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将资源从其初始状态转换为深度缓冲区。</span></span><br><span class="line">mCommandList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(mDepthStencilBuffer.<span class="built_in">Get</span>(),</span><br><span class="line">	D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_DEPTH_WRITE));</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="设置视口"><a href="#设置视口" class="headerlink" title="设置视口"></a>设置视口</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">D3D12_VIEWPORT mScreenViewport; </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_VIEWPORT</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    FLOAT TopLeftX;</span><br><span class="line">    FLOAT TopLeftY;</span><br><span class="line">    FLOAT Width;</span><br><span class="line">    FLOAT Height;</span><br><span class="line">    FLOAT MinDepth;<span class="comment">//负责从区间0-1转化为MinDepth-MaxDepth</span></span><br><span class="line">    FLOAT MaxDepth;</span><br><span class="line">    &#125; 	D3D12_VIEWPORT;</span><br></pre></td></tr></table></figure>



<p>填好结构体以后通过函数<code>ID3D12GraphicsCommandList::RSSetViewports</code>方法来设置视口</p>
<h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mScreenViewport.TopLeftX = <span class="number">0</span>;</span><br><span class="line">	mScreenViewport.TopLeftY = <span class="number">0</span>;</span><br><span class="line">	mScreenViewport.Width    = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mClientWidth);</span><br><span class="line">	mScreenViewport.Height   = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mClientHeight);</span><br><span class="line">	mScreenViewport.MinDepth = <span class="number">0.0f</span>;</span><br><span class="line">	mScreenViewport.MaxDepth = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> mCommandList-&gt;<span class="built_in">RSSetViewports</span>(<span class="number">1</span>, &amp;mScreenViewport);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>不能为同一个渲染目标指定多个视口</p>
<p>而多个视口则是一种用于对多个渲染目标同时进行渲染的高级技术</p>
<p>命令列表重置，视口也要重置</p>
</blockquote>
<h5 id="设置裁剪矩形"><a href="#设置裁剪矩形" class="headerlink" title="设置裁剪矩形"></a>设置裁剪矩形</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRECT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LONG    left;</span><br><span class="line">    LONG    top;</span><br><span class="line">    LONG    right;</span><br><span class="line">    LONG    bottom;</span><br><span class="line">&#125; RECT, *PRECT, NEAR *NPRECT, FAR *LPRECT;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mScissorRect = &#123; <span class="number">0</span>, <span class="number">0</span>, mClientWidth, mClientHeight &#125;;</span><br><span class="line"></span><br><span class="line">mCommandList-&gt;<span class="built_in">RSSetScissorRects</span>(<span class="number">1</span>, &amp;mScissorRect);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不能为同一个渲染目标指定多个裁剪矩形。</p>
<p>多裁剪矩形是以各种用于同时对多个渲染目标进行渲染的高级技术</p>
<p>裁剪矩形需要随着命令列表重置而重置</p>
</blockquote>
<h3 id="计时与动画"><a href="#计时与动画" class="headerlink" title="计时与动画"></a>计时与动画</h3><h5 id="性能计时器"><a href="#性能计时器" class="headerlink" title="性能计时器"></a>性能计时器</h5><p><code>QueryPerformanceCounter</code>函数来活得性能计时器测量的当前时刻值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__int64 countsPerSec;</span><br><span class="line">	<span class="built_in">QueryPerformanceFrequency</span>((LARGE_INTEGER*)&amp;countsPerSec);</span><br><span class="line">	mSecondsPerCount = <span class="number">1.0</span> / (<span class="keyword">double</span>)countsPerSec;</span><br></pre></td></tr></table></figure>

<p>通过如下方式转换为秒</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">valueInSecs=valueInCounts * mSecondsPercount;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用2次<code>QueryPerformanceCounter</code>函数得到两个时间戳的相对插值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__int64 A;</span><br><span class="line">	<span class="built_in">QueryPerformanceFrequency</span>((LARGE_INTEGER*)&amp;A);</span><br><span class="line">__int64 B;</span><br><span class="line">	<span class="built_in">QueryPerformanceFrequency</span>((LARGE_INTEGER*)&amp;B);</span><br></pre></td></tr></table></figure>

<p><code>B-A</code>即可获得执行期间的计数值，或者<code>(B-1)*mSecondsPerCount</code>获得代码运行期间所花费的秒数</p>
<h5 id="游戏计时器类"><a href="#游戏计时器类" class="headerlink" title="游戏计时器类"></a>游戏计时器类</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameTimer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">GameTimer</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">TotalTime</span><span class="params">()</span><span class="keyword">const</span></span>; <span class="comment">//秒为单位</span></span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">DeltaTime</span><span class="params">()</span><span class="keyword">const</span></span>; <span class="comment">//秒为单位</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>; <span class="comment">// 开始循环之前调用</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span>; <span class="comment">// 接触计时器暂停时调用</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;  <span class="comment">// 暂停计时器调用</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Tick</span><span class="params">()</span></span>;  <span class="comment">//每帧都要调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> mSecondsPerCount;</span><br><span class="line">	<span class="keyword">double</span> mDeltaTime;</span><br><span class="line"></span><br><span class="line">	__int64 mBaseTime;</span><br><span class="line">	__int64 mPausedTime;</span><br><span class="line">	__int64 mStopTime;</span><br><span class="line">	__int64 mPrevTime;</span><br><span class="line">	__int64 mCurrTime;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> mStopped;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="帧与帧之间的时间间隔"><a href="#帧与帧之间的时间间隔" class="headerlink" title="帧与帧之间的时间间隔"></a>帧与帧之间的时间间隔</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GameTimer::Tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( mStopped )</span><br><span class="line">	&#123;</span><br><span class="line">		mDeltaTime = <span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得本帧开始的时刻</span></span><br><span class="line">	__int64 currTime;</span><br><span class="line">	<span class="built_in">QueryPerformanceCounter</span>((LARGE_INTEGER*)&amp;currTime);</span><br><span class="line">	mCurrTime = currTime;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两帧的时间差</span></span><br><span class="line">	mDeltaTime = (mCurrTime - mPrevTime)*mSecondsPerCount;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把当前时间设置为下一次的开始时间</span></span><br><span class="line">	mPrevTime = mCurrTime;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保证时间差为非负值；</span></span><br><span class="line">    <span class="comment">//在处理器处于节能模式或者计算两次时间差的过程中切换到了另一个处理器可能会得到负值</span></span><br><span class="line">	<span class="keyword">if</span>(mDeltaTime &lt; <span class="number">0.0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mDeltaTime = <span class="number">0.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>次<code>Tick</code>函数被调用在<code>D3DApp::Run</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D3DApp::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MSG msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">	mTimer.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(msg.message != WM_QUIT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// If there are Window messages then process them.</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">PeekMessage</span>( &amp;msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE ))</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="built_in">TranslateMessage</span>( &amp;msg );</span><br><span class="line">            <span class="built_in">DispatchMessage</span>( &amp;msg );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Otherwise, do animation/game stuff.</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">        &#123;	</span><br><span class="line">			mTimer.<span class="built_in">Tick</span>();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>( !mAppPaused )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">CalculateFrameStats</span>();</span><br><span class="line">				<span class="built_in">Update</span>(mTimer);	</span><br><span class="line">                <span class="built_in">Draw</span>(mTimer);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)msg.wParam;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Reset</code>方法初始化第一帧的数据，因为第一帧没有之前的帧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GameTimer::Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__int64 currTime;</span><br><span class="line">	<span class="built_in">QueryPerformanceCounter</span>((LARGE_INTEGER*)&amp;currTime);</span><br><span class="line"></span><br><span class="line">	mBaseTime = currTime;</span><br><span class="line">	mPrevTime = currTime;</span><br><span class="line">	mStopTime = <span class="number">0</span>;</span><br><span class="line">	mStopped  = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总时间"><a href="#总时间" class="headerlink" title="总时间"></a>总时间</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GameTimer::TotalTime</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们停止了，请勿计算自停止以来经过的时间。</span></span><br><span class="line">    <span class="comment">//此外，如果我们之前已经停顿了一下</span></span><br><span class="line">    <span class="comment">// mStopTime-mBaseTime包含暂停时间，我们不想计算。</span></span><br><span class="line">    <span class="comment">//要纠正此问题，我们可以从mStopTime中减去暂停时间： </span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//                     |&lt;--paused time--&gt;|</span></span><br><span class="line">	<span class="comment">// ----*---------------*-----------------*------------*------------*------&gt; time</span></span><br><span class="line">	<span class="comment">//  mBaseTime       mStopTime        startTime     mStopTime    mCurrTime</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( mStopped )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">float</span>)(((mStopTime - mPausedTime)-mBaseTime)*mSecondsPerCount);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//距离mCurrTime-mBaseTime包括暂停时间，</span></span><br><span class="line">    <span class="comment">//我们不想计算。 要纠正这一点，我们可以减去</span></span><br><span class="line">    <span class="comment">//从mCurrTime暂停的时间： </span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  (mCurrTime - mPausedTime) - mBaseTime </span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//                     |&lt;--paused time--&gt;|</span></span><br><span class="line">	<span class="comment">// ----*---------------*-----------------*------------*------&gt; time</span></span><br><span class="line">	<span class="comment">//  mBaseTime       mStopTime        startTime     mCurrTime</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">return</span></span> (<span class="keyword">float</span>)(((mCurrTime-mPausedTime)-mBaseTime)*mSecondsPerCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="应用程序框架示例"><a href="#应用程序框架示例" class="headerlink" title="应用程序框架示例"></a>应用程序框架示例</h3><p>自己模仿框架的代码</p>
<h6 id="DXApp-h"><a href="#DXApp-h" class="headerlink" title="DXApp.h"></a>DXApp.h</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../Common/d3dUtil.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../Common/d3dx12.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../Common/GameTimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG) || defined(_DEBUG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRTDBG_MAP_ALLOC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dxgiformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Link necessary d3d12 libraries.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;d3dcompiler.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;D3D12.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;dxgi.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DXApp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DXApp</span>(HINSTANCE nInstance);</span><br><span class="line">	<span class="built_in">DXApp</span>(<span class="keyword">const</span> DXApp&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">	DXApp&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DXApp&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">DXApp</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnResize</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateRtvAndDsvDescriptorHeaps</span><span class="params">()</span></span>;<span class="comment">//创建描述符堆</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">InitMainWindow</span><span class="params">()</span></span>;<span class="comment">//初始化窗口</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">InitDirect3D</span><span class="params">()</span></span>;<span class="comment">//初始化DX</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">FlushCommandQueue</span><span class="params">()</span></span>;<span class="comment">//齐平命令队列</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreateSwapChain</span><span class="params">()</span></span>;<span class="comment">//创建交换链</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreateCommandObjects</span><span class="params">()</span></span>;<span class="comment">//创建命令队列、命令适配器、命令列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">ID3D12Resource* <span class="title">CurrentBackBuffer</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">D3D12_CPU_DESCRIPTOR_HANDLE <span class="title">CurrentBackBufferView</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">D3D12_CPU_DESCRIPTOR_HANDLE <span class="title">DepthStencilView</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LogAdapters</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LogAdapterOutputs</span><span class="params">(IDXGIAdapter* adapter)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LogOutputDisplayModes</span><span class="params">(IDXGIOutput* output, DXGI_FORMAT format)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> DXApp* <span class="title">GetApp</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">HINSTANCE <span class="title">AppInst</span><span class="params">()</span><span class="keyword">const</span></span>;<span class="comment">//得到应用程序实例</span></span><br><span class="line">	<span class="function">HWND      <span class="title">MainWnd</span><span class="params">()</span><span class="keyword">const</span></span>;<span class="comment">//得到窗口</span></span><br><span class="line">	<span class="function"><span class="keyword">float</span>     <span class="title">AspectRatio</span><span class="params">()</span><span class="keyword">const</span></span>;<span class="comment">//长宽比</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Get4xMsaaState</span><span class="params">()</span><span class="keyword">const</span></span>;<span class="comment">//4XMSAA开启与否</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set4xMsaaState</span><span class="params">(<span class="keyword">bool</span> value)</span></span>;<span class="comment">//设置4XMSAA</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CalculateFrameStats</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	HWND hwnd; //窗口句柄 </span></span><br><span class="line"><span class="comment">	UINT message; //消息常量标识符 </span></span><br><span class="line"><span class="comment">	WPARAM wParam; //32位消息的特定附加信息,具体表示什么处决于message </span></span><br><span class="line"><span class="comment">	LPARAM lParam; //32位消息的特定附加信息,具体表示什么处决于message </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> LRESULT <span class="title">MsgProc</span><span class="params">(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//鼠标输入</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseDown</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseUp</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseMove</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> DXApp* mApp;</span><br><span class="line"></span><br><span class="line">	HINSTANCE mhAppInst = <span class="literal">nullptr</span>; <span class="comment">// 应用程序实例句柄</span></span><br><span class="line">	HWND      mhMainWnd = <span class="literal">nullptr</span>; <span class="comment">// 主窗口句柄</span></span><br><span class="line">	<span class="keyword">bool</span>      mAppPaused = <span class="literal">false</span>;  <span class="comment">// 应用程序是否已暂停？</span></span><br><span class="line">	<span class="keyword">bool</span>      mMinimized = <span class="literal">false</span>;  <span class="comment">// 将应用程序最小化?</span></span><br><span class="line">	<span class="keyword">bool</span>      mMaximized = <span class="literal">false</span>;  <span class="comment">// 应用程序是否已最大化？</span></span><br><span class="line">	<span class="keyword">bool</span>      mResizing = <span class="literal">false</span>;   <span class="comment">// 是否拖动了大小调整栏？</span></span><br><span class="line">	<span class="keyword">bool</span>      mFullscreenState = <span class="literal">false</span>;<span class="comment">// 启用全屏</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否启用 4X MSAA (?.1.8).  The default is false.</span></span><br><span class="line">	<span class="keyword">bool</span>      m4xMsaaState = <span class="literal">false</span>;    <span class="comment">// 启用 4X MSAA </span></span><br><span class="line">	UINT      m4xMsaaQuality = <span class="number">0</span>;      <span class="comment">// 4倍MSAA的质量水平</span></span><br><span class="line"></span><br><span class="line">	GameTimer mTimer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//COM</span></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12Device&gt; md3dDevice; <span class="comment">//设备接口</span></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;IDXGIFactory4&gt; mdxgiFactory;</span><br><span class="line">	Microsoft::WRL::ComPtr&lt;IDXGISwapChain&gt; mSwapChain;<span class="comment">//交换链</span></span><br><span class="line"></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12Fence&gt; mFence;<span class="comment">//围栏</span></span><br><span class="line">	UINT64 mCurrentFence = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12CommandQueue&gt; mCommandQueue;<span class="comment">//命令队列</span></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12CommandAllocator&gt; mDirectCmdListAlloc;<span class="comment">//适配器</span></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12GraphicsCommandList&gt; mCommandList;<span class="comment">//列表</span></span><br><span class="line">	<span class="comment">//描述符</span></span><br><span class="line">	UINT mRtvDescriptorSize = <span class="number">0</span>;</span><br><span class="line">	UINT mDsvDescriptorSize = <span class="number">0</span>;</span><br><span class="line">	UINT mCbvSrvUavDescriptorSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SwapChainBufferCount = <span class="number">2</span>;<span class="comment">//双重缓冲</span></span><br><span class="line">	<span class="keyword">int</span> mCurrBackBuffer = <span class="number">0</span>;</span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; mSwapChainBuffer[SwapChainBufferCount];<span class="comment">//交换链缓冲区数组</span></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; mDepthStencilBuffer;<span class="comment">//深度模板缓冲区</span></span><br><span class="line">	</span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12DescriptorHeap&gt; mRtvHeap;<span class="comment">//RTV描述符堆</span></span><br><span class="line">	Microsoft::WRL::ComPtr&lt;ID3D12DescriptorHeap&gt; mDsvHeap;<span class="comment">//DSV描述符堆</span></span><br><span class="line"></span><br><span class="line">	std::wstring mMainWndCaption = <span class="string">L&quot;DX App&quot;</span>;</span><br><span class="line">	D3D_DRIVER_TYPE md3dDriverType = D3D_DRIVER_TYPE_HARDWARE;</span><br><span class="line">	DXGI_FORMAT mBackBufferFormat = DXGI_FORMAT_R8G8B8A8_UNORM;</span><br><span class="line">	DXGI_FORMAT mDepthStencilFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;</span><br><span class="line"></span><br><span class="line">	D3D12_VIEWPORT mScreenViewport;<span class="comment">//视口</span></span><br><span class="line">	D3D12_RECT mScissorRect;<span class="comment">//裁剪</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mClientWidth = <span class="number">800</span>;</span><br><span class="line">	<span class="keyword">int</span> mClientHeight = <span class="number">600</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="DXApp-cpp"><a href="#DXApp-cpp" class="headerlink" title="DXApp.cpp"></a>DXApp.cpp</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DXApp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;WindowsX.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winuser.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dxgi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Microsoft::WRL::ComPtr;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DXApp* DXApp::mApp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK</span></span><br><span class="line"><span class="function"><span class="title">MainWndProc</span><span class="params">(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;test&quot;;</span></span><br><span class="line">	<span class="keyword">return</span> DXApp::<span class="built_in">GetApp</span>()-&gt;<span class="built_in">MsgProc</span>(hwnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DXApp::<span class="built_in">DXApp</span>(HINSTANCE nInstance):<span class="built_in">mhAppInst</span>(nInstance)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">assert</span>(mApp == <span class="literal">nullptr</span>);</span><br><span class="line">	mApp = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DXApp::~<span class="built_in">DXApp</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (mhAppInst != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">FlushCommandQueue</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DXApp::OnResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(md3dDevice);</span><br><span class="line">	<span class="built_in">assert</span>(mSwapChain);</span><br><span class="line">	<span class="built_in">assert</span>(mDirectCmdListAlloc);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FlushCommandQueue</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Reset</span>(mDirectCmdListAlloc.<span class="built_in">Get</span>(),<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放我们将重新创建的先前资源。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SwapChainBufferCount;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		mSwapChainBuffer[i].<span class="built_in">Reset</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	mDepthStencilBuffer.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//调整交换链的大小。</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mSwapChain-&gt;<span class="built_in">ResizeBuffers</span>(</span><br><span class="line">	SwapChainBufferCount,</span><br><span class="line">	mClientWidth,</span><br><span class="line">	mClientHeight,</span><br><span class="line">	mBackBufferFormat,</span><br><span class="line">	DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH));</span><br><span class="line"></span><br><span class="line">	mCurrBackBuffer=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="title">rtvHeapHandle</span><span class="params">(mRtvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; SwapChainBufferCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//构造函数根据给定的偏移量找到当前后台缓冲区的RTV</span></span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(mSwapChain-&gt;<span class="built_in">GetBuffer</span>(i, <span class="built_in">IID_PPV_ARGS</span>(&amp;mSwapChainBuffer[i])));</span><br><span class="line">		md3dDevice-&gt;<span class="built_in">CreateRenderTargetView</span>(mSwapChainBuffer[i].<span class="built_in">Get</span>(), <span class="literal">nullptr</span>, rtvHeapHandle);<span class="comment">//堆中的首个句柄</span></span><br><span class="line">		rtvHeapHandle.<span class="built_in">Offset</span>(<span class="number">1</span>, mRtvDescriptorSize);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建深度/模板缓冲区和视口</span></span><br><span class="line">	D3D12_RESOURCE_DESC depthStencilDesc;</span><br><span class="line">	depthStencilDesc.Dimension= D3D12_RESOURCE_DIMENSION_TEXTURE2D;</span><br><span class="line">	depthStencilDesc.Alignment=<span class="number">0</span>;</span><br><span class="line">	depthStencilDesc.Width=mClientWidth;</span><br><span class="line">	depthStencilDesc.Height=mClientHeight;</span><br><span class="line">	depthStencilDesc.DepthOrArraySize=<span class="number">1</span>;</span><br><span class="line">	depthStencilDesc.MipLevels=<span class="number">1</span>;</span><br><span class="line">	depthStencilDesc.Format=mDepthStencilFormat;</span><br><span class="line">	depthStencilDesc.SampleDesc.Count=m4xMsaaState?<span class="number">4</span>:<span class="number">1</span>;</span><br><span class="line">	depthStencilDesc.SampleDesc.Quality=m4xMsaaState?(m4xMsaaQuality<span class="number">-1</span>):<span class="number">0</span>;</span><br><span class="line">	depthStencilDesc.Layout=D3D12_TEXTURE_LAYOUT_UNKNOWN;</span><br><span class="line">	depthStencilDesc.Flags=D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;</span><br><span class="line"></span><br><span class="line">	D3D12_CLEAR_VALUE optClear;</span><br><span class="line">	optClear.Format=mDepthStencilFormat;</span><br><span class="line">	optClear.DepthStencil.Depth=<span class="number">1.0f</span>;</span><br><span class="line">	optClear.DepthStencil.Stencil=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommittedResource</span>(</span><br><span class="line">		&amp;<span class="built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),</span><br><span class="line">		D3D12_HEAP_FLAG_NONE,</span><br><span class="line">		&amp;depthStencilDesc,</span><br><span class="line">		D3D12_RESOURCE_STATE_COMMON,</span><br><span class="line">		&amp;optClear,</span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(mDepthStencilBuffer.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//使用资源的格式将描述符创建为整个资源的MIP级别0。</span></span><br><span class="line">	md3dDevice-&gt;<span class="built_in">CreateDepthStencilView</span>(mDepthStencilBuffer.<span class="built_in">Get</span>(),<span class="literal">nullptr</span>, <span class="built_in">DepthStencilView</span>());</span><br><span class="line">	<span class="comment">//将资源从其初始状态转换为深度缓冲区。</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>,&amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(mDepthStencilBuffer.<span class="built_in">Get</span>(),D3D12_RESOURCE_STATE_COMMON,D3D12_RESOURCE_STATE_DEPTH_WRITE));</span><br><span class="line">	<span class="comment">//执行resize命令</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Close</span>());</span><br><span class="line">	ID3D12CommandList* cmdsLists[]=&#123;mCommandList.<span class="built_in">Get</span>()&#125;;</span><br><span class="line">	mCommandQueue-&gt;<span class="built_in">ExecuteCommandLists</span>(_countof(cmdsLists),cmdsLists);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待到resize完成</span></span><br><span class="line">	<span class="built_in">FlushCommandQueue</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新视口变换以覆盖客户区域。</span></span><br><span class="line">	mScreenViewport.TopLeftX = <span class="number">0</span>;</span><br><span class="line">	mScreenViewport.TopLeftY = <span class="number">0</span>;</span><br><span class="line">	mScreenViewport.Width = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mClientWidth);</span><br><span class="line">	mScreenViewport.Height = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mClientHeight);</span><br><span class="line">	mScreenViewport.MinDepth = <span class="number">0.0f</span>;</span><br><span class="line">	mScreenViewport.MaxDepth = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">	mScissorRect=&#123;<span class="number">0</span>,<span class="number">0</span>,mClientWidth,mClientHeight&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DXApp::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">InitMainWindow</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">InitDirect3D</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">OnResize</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DXApp::CreateRtvAndDsvDescriptorHeaps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc;</span><br><span class="line">	rtvHeapDesc.NumDescriptors=SwapChainBufferCount;</span><br><span class="line">	rtvHeapDesc.Type=D3D12_DESCRIPTOR_HEAP_TYPE_RTV;</span><br><span class="line">	rtvHeapDesc.Flags=D3D12_DESCRIPTOR_HEAP_FLAG_NONE;</span><br><span class="line">	rtvHeapDesc.NodeMask=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateDescriptorHeap</span>(&amp;rtvHeapDesc,<span class="built_in">IID_PPV_ARGS</span>(mRtvHeap.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line"></span><br><span class="line">	D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc;</span><br><span class="line">	dsvHeapDesc.NumDescriptors = SwapChainBufferCount;</span><br><span class="line">	dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;</span><br><span class="line">	dsvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;</span><br><span class="line">	dsvHeapDesc.NodeMask = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateDescriptorHeap</span>(&amp;dsvHeapDesc, <span class="built_in">IID_PPV_ARGS</span>(mDsvHeap.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DXApp::InitMainWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WNDCLASS wc;</span><br><span class="line">	wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	wc.lpfnWndProc = MainWndProc;</span><br><span class="line">	wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">	wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">	wc.hInstance = mhAppInst;</span><br><span class="line">	wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="number">0</span>, IDI_APPLICATION);</span><br><span class="line">	wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="number">0</span>, IDC_ARROW);</span><br><span class="line">	wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(NULL_BRUSH);</span><br><span class="line">	wc.lpszMenuName = <span class="number">0</span>;</span><br><span class="line">	wc.lpszClassName = <span class="string">L&quot;MainWnd&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">RegisterClass</span>(&amp;wc))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBox</span>(<span class="number">0</span>, <span class="string">L&quot;RegisterClass Failed.&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute window rectangle dimensions based on requested client area dimensions.</span></span><br><span class="line">	RECT R = &#123; <span class="number">0</span>, <span class="number">0</span>, mClientWidth, mClientHeight &#125;;</span><br><span class="line">	<span class="built_in">AdjustWindowRect</span>(&amp;R, WS_OVERLAPPEDWINDOW, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> width = R.right - R.left;</span><br><span class="line">	<span class="keyword">int</span> height = R.bottom - R.top;</span><br><span class="line"></span><br><span class="line">	mhMainWnd = <span class="built_in">CreateWindow</span>(<span class="string">L&quot;MainWnd&quot;</span>, mMainWndCaption.<span class="built_in">c_str</span>(),</span><br><span class="line">		WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, width, height, <span class="number">0</span>, <span class="number">0</span>, mhAppInst, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!mhMainWnd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBox</span>(<span class="number">0</span>, <span class="string">L&quot;CreateWindow Failed.&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ShowWindow</span>(mhMainWnd, SW_SHOW);</span><br><span class="line">	<span class="built_in">UpdateWindow</span>(mhMainWnd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DXApp::InitDirect3D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//#if defined(DEBUG) || defined(_DEBUG) </span></span><br><span class="line"><span class="comment">//		// Enable the D3D12 debug layer.</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			ComPtr&lt;ID3D12Debug&gt; debugController;</span></span><br><span class="line"><span class="comment">//			ThrowIfFailed(D3D12GetDebugInterface(IID_PPV_ARGS(&amp;debugController)));</span></span><br><span class="line"><span class="comment">//			debugController-&gt;EnableDebugLayer();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(<span class="built_in">CreateDXGIFactory</span>(<span class="built_in">IID_PPV_ARGS</span>(&amp;mdxgiFactory)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建硬件设备</span></span><br><span class="line">	HRESULT hardwareResult = <span class="built_in">D3D12CreateDevice</span>(<span class="literal">nullptr</span>, D3D_FEATURE_LEVEL_11_0, <span class="built_in">IID_PPV_ARGS</span>(&amp;md3dDevice));<span class="comment">//第一个参数是空则使用默认显示器</span></span><br><span class="line">	<span class="comment">//回退至WARP设备</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">FAILED</span>(hardwareResult))</span><br><span class="line">	&#123;</span><br><span class="line">		ComPtr&lt;IDXGIAdapter&gt; pWarpAdapter;</span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(mdxgiFactory-&gt;<span class="built_in">EnumWarpAdapter</span>(<span class="built_in">IID_PPV_ARGS</span>(&amp;pWarpAdapter)));</span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(<span class="built_in">D3D12CreateDevice</span>(pWarpAdapter.<span class="built_in">Get</span>(), D3D_FEATURE_LEVEL_11_0, <span class="built_in">IID_PPV_ARGS</span>(&amp;md3dDevice)));</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateFence</span>(<span class="number">0</span>, D3D12_FENCE_FLAG_NONE, <span class="built_in">IID_PPV_ARGS</span>(&amp;mFence)));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//描述符信息，方便以后使用</span></span><br><span class="line">		mRtvDescriptorSize = md3dDevice-&gt;<span class="built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);</span><br><span class="line">		mDsvDescriptorSize = md3dDevice-&gt;<span class="built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);</span><br><span class="line">		mCbvSrvUavDescriptorSize = md3dDevice-&gt;<span class="built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//检查4X MSAA质量对我们的后缓冲区格式的支持。</span></span><br><span class="line">		 <span class="comment">//所有支持Direct3D 11的设备都对所有渲染支持4倍MSAA</span></span><br><span class="line">		 <span class="comment">//目标格式，因此我们只需要检查质量支持。</span></span><br><span class="line">		D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS msQualityLevels;</span><br><span class="line">		msQualityLevels.Format = mBackBufferFormat;</span><br><span class="line">		msQualityLevels.SampleCount = <span class="number">4</span>;</span><br><span class="line">		msQualityLevels.Flags = D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE;</span><br><span class="line">		msQualityLevels.NumQualityLevels = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CheckFeatureSupport</span>(D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS, &amp;msQualityLevels, <span class="built_in"><span class="keyword">sizeof</span></span>(msQualityLevels)));</span><br><span class="line">		m4xMsaaQuality = msQualityLevels.NumQualityLevels;</span><br><span class="line">		<span class="built_in">assert</span>(m4xMsaaQuality &gt; <span class="number">0</span> &amp;&amp; <span class="string">&quot;Unexpected MSAA quality level.&quot;</span>);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		<span class="built_in">CreateCommandObjects</span>();</span><br><span class="line">		<span class="built_in">CreateSwapChain</span>();</span><br><span class="line">		<span class="built_in">CreateRtvAndDsvDescriptorHeaps</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DXApp::FlushCommandQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//提升围栏值以将命令标记到该围栏点。</span></span><br><span class="line">	mCurrentFence++;</span><br><span class="line">	<span class="comment">//将指令添加到命令队列以设置新的防护点。 因为我们</span></span><br><span class="line">	<span class="comment">//在GPU时间轴上，直到GPU完成后才会设置新的围栏点</span></span><br><span class="line">	<span class="comment">//处理此Signal（）之前的所有命令。</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandQueue-&gt;<span class="built_in">Signal</span>(mFence.<span class="built_in">Get</span>(),mCurrentFence));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待直到GPU完成命令为止。</span></span><br><span class="line">	<span class="keyword">if</span> (mFence-&gt;<span class="built_in">GetCompletedValue</span>() &lt; mCurrentFence)</span><br><span class="line">	&#123;</span><br><span class="line">		HANDLE eventHandle=<span class="built_in">CreateEventEx</span>(<span class="literal">nullptr</span>,<span class="literal">false</span>,<span class="literal">false</span>,EVENT_ALL_ACCESS);</span><br><span class="line">		<span class="comment">//GPU击中当前围墙时触发事件。</span></span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(mFence-&gt;<span class="built_in">SetEventOnCompletion</span>(mCurrentFence,eventHandle));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//等到GPU击中当前的fence事件后再触发。</span></span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(eventHandle,INFINITE);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(eventHandle);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DXApp::CreateSwapChain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mSwapChain.<span class="built_in">Reset</span>();</span><br><span class="line">	DXGI_SWAP_CHAIN_DESC sd;</span><br><span class="line">	sd.BufferDesc.Width = mClientWidth;</span><br><span class="line">	sd.BufferDesc.Height = mClientHeight;</span><br><span class="line">	sd.BufferDesc.RefreshRate.Numerator = <span class="number">60</span>;</span><br><span class="line">	sd.BufferDesc.RefreshRate.Denominator = <span class="number">1</span>;</span><br><span class="line">	sd.BufferDesc.Format = mBackBufferFormat;</span><br><span class="line">	sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;</span><br><span class="line">	sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;</span><br><span class="line">	sd.SampleDesc.Count = m4xMsaaState ? <span class="number">4</span> : <span class="number">1</span>;</span><br><span class="line">	sd.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;</span><br><span class="line">	sd.BufferCount = SwapChainBufferCount;</span><br><span class="line">	sd.OutputWindow = mhMainWnd;</span><br><span class="line">	sd.Windowed = <span class="literal">true</span>;</span><br><span class="line">	sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;</span><br><span class="line">	sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note: Swap chain uses queue to perform flush.</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mdxgiFactory-&gt;<span class="built_in">CreateSwapChain</span>(</span><br><span class="line">		mCommandQueue.<span class="built_in">Get</span>(),</span><br><span class="line">		&amp;sd,</span><br><span class="line">		mSwapChain.<span class="built_in">GetAddressOf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DXApp::CreateCommandObjects</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D3D12_COMMAND_QUEUE_DESC queueDesc = &#123;&#125;;</span><br><span class="line">	queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;</span><br><span class="line">	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommandQueue</span>(&amp;queueDesc, <span class="built_in">IID_PPV_ARGS</span>(&amp;mCommandQueue)));</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="built_in">IID_PPV_ARGS</span>(mDirectCmdListAlloc.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateCommandList</span>(<span class="number">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, mDirectCmdListAlloc.<span class="built_in">Get</span>(), <span class="literal">nullptr</span>, <span class="built_in">IID_PPV_ARGS</span>(mCommandList.<span class="built_in">ReleaseAndGetAddressOf</span>())));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从关闭状态开始。 这是因为我们第一次提到</span></span><br><span class="line">	<span class="comment">//在命令列表中，我们将对其进行重置，并且需要先关闭它</span></span><br><span class="line">	<span class="comment">//调用Reset。</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ID3D12Resource* <span class="title">DXApp::CurrentBackBuffer</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mSwapChainBuffer[mCurrBackBuffer].<span class="built_in">Get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">D3D12_CPU_DESCRIPTOR_HANDLE <span class="title">DXApp::CurrentBackBufferView</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">CD3DX12_CPU_DESCRIPTOR_HANDLE</span>(</span><br><span class="line">		mRtvHeap-&gt;<span class="built_in">GetCPUDescriptorHandleForHeapStart</span>(),</span><br><span class="line">		mCurrBackBuffer,</span><br><span class="line">		mRtvDescriptorSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">D3D12_CPU_DESCRIPTOR_HANDLE <span class="title">DXApp::DepthStencilView</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mDsvHeap-&gt;<span class="built_in">GetCPUDescriptorHandleForHeapStart</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DXApp::LogAdapters</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT i = <span class="number">0</span>;</span><br><span class="line">	IDXGIAdapter* adapter = <span class="literal">nullptr</span>;</span><br><span class="line">	std::vector&lt;IDXGIAdapter*&gt; adapterList;</span><br><span class="line">	<span class="keyword">while</span> (mdxgiFactory-&gt;<span class="built_in">EnumAdapters</span>(i, &amp;adapter) != DXGI_ERROR_NOT_FOUND)</span><br><span class="line">	&#123;</span><br><span class="line">		DXGI_ADAPTER_DESC desc;</span><br><span class="line">		adapter-&gt;<span class="built_in">GetDesc</span>(&amp;desc);</span><br><span class="line"></span><br><span class="line">		std::wstring text = <span class="string">L&quot;***Adapter: &quot;</span>;</span><br><span class="line">		text += desc.Description;</span><br><span class="line">		text += <span class="string">L&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">OutputDebugString</span>(text.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">		adapterList.<span class="built_in">push_back</span>(adapter);</span><br><span class="line"></span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; adapterList.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">LogAdapterOutputs</span>(adapterList[i]);</span><br><span class="line">		<span class="built_in">ReleaseCom</span>(adapterList[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DXApp::LogAdapterOutputs</span><span class="params">(IDXGIAdapter* adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT i = <span class="number">0</span>;</span><br><span class="line">	IDXGIOutput* output = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span> (adapter-&gt;<span class="built_in">EnumOutputs</span>(i, &amp;output) != DXGI_ERROR_NOT_FOUND)</span><br><span class="line">	&#123;</span><br><span class="line">		DXGI_OUTPUT_DESC desc;</span><br><span class="line">		output-&gt;<span class="built_in">GetDesc</span>(&amp;desc);</span><br><span class="line"></span><br><span class="line">		std::wstring text = <span class="string">L&quot;***Output: &quot;</span>;</span><br><span class="line">		text += desc.DeviceName;</span><br><span class="line">		text += <span class="string">L&quot;\n&quot;</span>;</span><br><span class="line">		<span class="built_in">OutputDebugString</span>(text.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">		<span class="built_in">LogOutputDisplayModes</span>(output, mBackBufferFormat);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ReleaseCom</span>(output);</span><br><span class="line"></span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DXApp::LogOutputDisplayModes</span><span class="params">(IDXGIOutput* output, DXGI_FORMAT format)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT count = <span class="number">0</span>;</span><br><span class="line">	UINT flags = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call with nullptr to get list count.</span></span><br><span class="line">	output-&gt;<span class="built_in">GetDisplayModeList</span>(format, flags, &amp;count, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function">std::vector&lt;DXGI_MODE_DESC&gt; <span class="title">modeList</span><span class="params">(count)</span></span>;</span><br><span class="line">	output-&gt;<span class="built_in">GetDisplayModeList</span>(format, flags, &amp;count, &amp;modeList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : modeList)</span><br><span class="line">	&#123;</span><br><span class="line">		UINT n = x.RefreshRate.Numerator;</span><br><span class="line">		UINT d = x.RefreshRate.Denominator;</span><br><span class="line">		std::wstring text =</span><br><span class="line">			<span class="string">L&quot;Width = &quot;</span> + std::<span class="built_in">to_wstring</span>(x.Width) + <span class="string">L&quot; &quot;</span> +</span><br><span class="line">			<span class="string">L&quot;Height = &quot;</span> + std::<span class="built_in">to_wstring</span>(x.Height) + <span class="string">L&quot; &quot;</span> +</span><br><span class="line">			<span class="string">L&quot;Refresh = &quot;</span> + std::<span class="built_in">to_wstring</span>(n) + <span class="string">L&quot;/&quot;</span> + std::<span class="built_in">to_wstring</span>(d) +</span><br><span class="line">			<span class="string">L&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">		::<span class="built_in">OutputDebugString</span>(text.<span class="built_in">c_str</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DXApp* <span class="title">DXApp::GetApp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mApp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HINSTANCE <span class="title">DXApp::AppInst</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mhAppInst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HWND <span class="title">DXApp::MainWnd</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mhMainWnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">DXApp::AspectRatio</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mClientWidth) / mClientHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DXApp::Get4xMsaaState</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m4xMsaaState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DXApp::Set4xMsaaState</span><span class="params">(<span class="keyword">bool</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m4xMsaaState!=value)</span><br><span class="line">	&#123;</span><br><span class="line">		m4xMsaaState = value;</span><br><span class="line">		<span class="comment">//重置4xmasaa需要重新创建交换链和刷新尺寸</span></span><br><span class="line">		<span class="built_in">CreateSwapChain</span>();</span><br><span class="line">		<span class="built_in">OnResize</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DXApp::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	mTimer.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (msg.message != WM_QUIT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// If there are Window messages then process them.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">PeekMessage</span>(&amp;msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">			<span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Otherwise, do animation/game stuff.</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			mTimer.<span class="built_in">Tick</span>();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!mAppPaused)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">CalculateFrameStats</span>();</span><br><span class="line">				<span class="built_in">Update</span>(mTimer);</span><br><span class="line">				<span class="built_in">Draw</span>(mTimer);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)msg.wParam;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DXApp::CalculateFrameStats</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Code computes the average frames per second, and also the </span></span><br><span class="line">		<span class="comment">// average time it takes to render one frame.  These stats </span></span><br><span class="line">		<span class="comment">// are appended to the window caption bar.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> frameCnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">float</span> timeElapsed = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">	frameCnt++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute averages over one second period.</span></span><br><span class="line">	<span class="keyword">if</span> ((mTimer.<span class="built_in">TotalTime</span>() - timeElapsed) &gt;= <span class="number">1.0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">float</span> fps = (<span class="keyword">float</span>)frameCnt; <span class="comment">// fps = frameCnt / 1</span></span><br><span class="line">		<span class="keyword">float</span> mspf = <span class="number">1000.0f</span> / fps;</span><br><span class="line"></span><br><span class="line">		wstring fpsStr = <span class="built_in">to_wstring</span>(fps);</span><br><span class="line">		wstring mspfStr = <span class="built_in">to_wstring</span>(mspf);</span><br><span class="line"></span><br><span class="line">		wstring windowText = mMainWndCaption +</span><br><span class="line">			<span class="string">L&quot;    fps: &quot;</span> + fpsStr +</span><br><span class="line">			<span class="string">L&quot;   mspf: &quot;</span> + mspfStr;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">SetWindowText</span>(mhMainWnd, <span class="string">L&quot;window text&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Reset for next average.</span></span><br><span class="line">		frameCnt = <span class="number">0</span>;</span><br><span class="line">		timeElapsed += <span class="number">1.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT <span class="title">DXApp::MsgProc</span><span class="params">(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (msg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//激活或停用窗口时发送WM_ACTIVATE。</span></span><br><span class="line">		<span class="comment">//当停用窗口时我们暂停游戏</span></span><br><span class="line">		<span class="comment">//当它变为活动状态时取消暂停</span></span><br><span class="line">	<span class="keyword">case</span> WM_ACTIVATE:</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">LOWORD</span>(wParam)==WA_INACTIVE)</span><br><span class="line">		&#123;</span><br><span class="line">			mAppPaused = <span class="literal">true</span>;</span><br><span class="line">			mTimer.<span class="built_in">Stop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			mAppPaused = <span class="literal">false</span>;</span><br><span class="line">			mTimer.<span class="built_in">Start</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 当用户调整窗口大小时，发送WM_SIZE。</span></span><br><span class="line">	<span class="keyword">case</span> WM_SIZE:</span><br><span class="line">		<span class="comment">// 保存新的客户区域尺寸。</span></span><br><span class="line">		mClientWidth = <span class="built_in">LOWORD</span>(lParam);</span><br><span class="line">		mClientHeight = <span class="built_in">HIWORD</span>(lParam);</span><br><span class="line">		<span class="keyword">if</span> (md3dDevice)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (wParam == SIZE_MINIMIZED)</span><br><span class="line">			&#123;</span><br><span class="line">				mAppPaused = <span class="literal">true</span>;</span><br><span class="line">				mMinimized = <span class="literal">true</span>;</span><br><span class="line">				mMaximized = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (wParam == SIZE_MAXIMIZED)</span><br><span class="line">			&#123;</span><br><span class="line">				mAppPaused = <span class="literal">false</span>;</span><br><span class="line">				mMinimized = <span class="literal">false</span>;</span><br><span class="line">				mMaximized = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">OnResize</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (wParam == SIZE_RESTORED)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Restoring from minimized state?</span></span><br><span class="line">				<span class="keyword">if</span> (mMinimized)</span><br><span class="line">				&#123;</span><br><span class="line">					mAppPaused = <span class="literal">false</span>;</span><br><span class="line">					mMinimized = <span class="literal">false</span>;</span><br><span class="line">					<span class="built_in">OnResize</span>();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Restoring from maximized state?</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (mMaximized)</span><br><span class="line">				&#123;</span><br><span class="line">					mAppPaused = <span class="literal">false</span>;</span><br><span class="line">					mMaximized = <span class="literal">false</span>;</span><br><span class="line">					<span class="built_in">OnResize</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (mResizing)</span><br><span class="line">				&#123;</span><br><span class="line">				<span class="comment">//如果用户拖动调整大小栏，我们不会调整大小</span></span><br><span class="line">				<span class="comment">//这里的缓冲区，因为随着用户的不断前进</span></span><br><span class="line">				<span class="comment">//拖动调整大小条，WM_SIZE消息流是</span></span><br><span class="line">				<span class="comment">//发送到窗口，它将毫无意义（而且很慢）</span></span><br><span class="line">				<span class="comment">//为从拖动中收到的每个WM_SIZE消息调整大小</span></span><br><span class="line">				<span class="comment">//调整尺寸栏。 因此，我们在用户</span></span><br><span class="line">				<span class="comment">//完成调整窗口大小并释放大小调整条</span></span><br><span class="line">				<span class="comment">//发送WM_EXITSIZEMOVE消息。</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="comment">// API call such as SetWindowPos or mSwapChain-&gt;SetFullscreenState.</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">OnResize</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当用户抓住调整大小条时，将发送WM_EXITSIZEMOVE。</span></span><br><span class="line">	<span class="keyword">case</span> WM_ENTERSIZEMOVE:</span><br><span class="line">		mAppPaused = <span class="literal">true</span>;</span><br><span class="line">		mResizing = <span class="literal">true</span>;</span><br><span class="line">		mTimer.<span class="built_in">Stop</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//当用户释放大小调整条时，发送WM_EXITSIZEMOVE。</span></span><br><span class="line">		<span class="comment">//在这里，我们根据新窗口的尺寸重置所有内容。</span></span><br><span class="line">	<span class="keyword">case</span> WM_EXITSIZEMOVE:</span><br><span class="line">		mAppPaused = <span class="literal">false</span>;</span><br><span class="line">		mResizing = <span class="literal">false</span>;</span><br><span class="line">		mTimer.<span class="built_in">Start</span>();</span><br><span class="line">		<span class="built_in">OnResize</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//销毁窗口时发送WM_DESTROY。</span></span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		<span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 当菜单处于活动状态并且用户按下时，将发送WM_MENUCHAR消息与任何助记键或加速键都不对应的键。</span></span><br><span class="line">	<span class="keyword">case</span> WM_MENUCHAR:</span><br><span class="line">		<span class="comment">// 进入时不要发出哔声。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">MAKELRESULT</span>(<span class="number">0</span>, MNC_CLOSE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//捕获此消息，以防止窗口变得太小。</span></span><br><span class="line">	<span class="keyword">case</span> WM_GETMINMAXINFO:</span><br><span class="line">		((MINMAXINFO*)lParam)-&gt;ptMinTrackSize.x = <span class="number">200</span>;</span><br><span class="line">		((MINMAXINFO*)lParam)-&gt;ptMinTrackSize.y = <span class="number">200</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">	<span class="keyword">case</span> WM_MBUTTONDOWN:</span><br><span class="line">	<span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">		<span class="built_in">OnMouseDown</span>(wParam, <span class="built_in">GET_X_LPARAM</span>(lParam), <span class="built_in">GET_Y_LPARAM</span>(lParam));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">	<span class="keyword">case</span> WM_MBUTTONUP:</span><br><span class="line">	<span class="keyword">case</span> WM_RBUTTONUP:</span><br><span class="line">		<span class="built_in">OnMouseUp</span>(wParam, <span class="built_in">GET_X_LPARAM</span>(lParam), <span class="built_in">GET_Y_LPARAM</span>(lParam));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">		<span class="built_in">OnMouseMove</span>(wParam, <span class="built_in">GET_X_LPARAM</span>(lParam), <span class="built_in">GET_Y_LPARAM</span>(lParam));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">		<span class="keyword">if</span> (wParam == VK_ESCAPE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)wParam == VK_F2)</span><br><span class="line">			<span class="built_in">Set4xMsaaState</span>(!m4xMsaaState);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>DirectX</tag>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DX学习笔记（五）：绘制几何体2</title>
    <url>/2020/07/13/LearnDX12_DrawGeo2/</url>
    <content><![CDATA[<h3 id="帧资源"><a href="#帧资源" class="headerlink" title="帧资源"></a>帧资源</h3><p>上一篇在绘制每一帧都会进行一次CPU与GPU的同步,目的是</p>
<ol>
<li>GPU未结束命令分配器中所有命令执行之前,不能重置,如果重置,那么GPU当前还未处理的命令就会被清除</li>
<li>对于常量缓冲区的数据而言,不同步的话会导致数据异常</li>
</ol>
<p>所以我们用<code>FlushCommandQueue</code>来保持同步</p>
<p>但是有2个缺点导致性能浪费</p>
<ol>
<li>每一帧起始阶段GPU无任务,处于闲置状态</li>
<li>帧结尾CPU处于闲置状态等待GPU完成绘制</li>
</ol>
<h5 id="帧资源-1"><a href="#帧资源-1" class="headerlink" title="帧资源"></a>帧资源</h5><p>CPU会比GPU提前两帧工作,以保持GPU可持续工作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存有CPU为构建美珍命令列表所需的资源</span></span><br><span class="line"><span class="comment">//其中的数据将依程序而异,取决于实际绘制所需的资源</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FrameResource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FrameResource</span>(ID3D12Device* device, UINT passCount, UINT objectCount);</span><br><span class="line">    <span class="built_in">FrameResource</span>(<span class="keyword">const</span> FrameResource&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    FrameResource&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> FrameResource&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">FrameResource</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU未结束命令分配器中所有命令执行之前,不能重置</span></span><br><span class="line">    <span class="comment">//因此每一帧都要有他们自己的命令分配器</span></span><br><span class="line">    Microsoft::WRL::ComPtr&lt;ID3D12CommandAllocator&gt; CmdListAlloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在GPU完成引用此常量缓冲区的命令之前,我们不能对他进行更新</span></span><br><span class="line">    <span class="comment">//因此每一帧都要有他们自己的常量缓冲区</span></span><br><span class="line">    std::unique_ptr&lt;UploadBuffer&lt;PassConstants&gt;&gt; PassCB = <span class="literal">nullptr</span>;</span><br><span class="line">    std::unique_ptr&lt;UploadBuffer&lt;ObjectConstants&gt;&gt; ObjectCB = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过围栏值将命令标记到此围栏点,这是我们可以检测到GPU是否还在使用这些帧资源</span></span><br><span class="line">    UINT64 Fence = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FrameResource::<span class="built_in">FrameResource</span>(ID3D12Device* device, UINT passCount, UINT objectCount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(device-&gt;<span class="built_in">CreateCommandAllocator</span>(</span><br><span class="line">        D3D12_COMMAND_LIST_TYPE_DIRECT,</span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(CmdListAlloc.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line"></span><br><span class="line">    PassCB = std::make_unique&lt;UploadBuffer&lt;PassConstants&gt;&gt;(device, passCount, <span class="literal">true</span>);</span><br><span class="line">    ObjectCB = std::make_unique&lt;UploadBuffer&lt;ObjectConstants&gt;&gt;(device, objectCount, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们的应用程序类将用一个vector容器实例化3个帧资源对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> gNumFrameResources = <span class="number">3</span>;</span><br><span class="line">std::vector&lt;std::unique_ptr&lt;FrameResource&gt;&gt; mFrameResources;</span><br><span class="line"> FrameResource* mCurrFrameResource = <span class="literal">nullptr</span>;</span><br><span class="line"> <span class="keyword">int</span> mCurrFrameResourceIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::BuildFrameResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gNumFrameResources; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        mFrameResources.<span class="built_in">push_back</span>(std::make_unique&lt;FrameResource&gt;(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">            <span class="number">1</span>, (UINT)mAllRitems.<span class="built_in">size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在CPU处理第n帧的算法是如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::Update</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环获取帧资源数组中的元素</span></span><br><span class="line">    mCurrFrameResourceIndex = (mCurrFrameResourceIndex + <span class="number">1</span>) % gNumFrameResources;</span><br><span class="line">    mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//GPU是否执行完所有命令?</span></span><br><span class="line">    <span class="comment">//如果还没有就令CPU等待,直到GPU完成所有命令的执行并且抵达这个围栏点</span></span><br><span class="line">     <span class="keyword">if</span>(mCurrFrameResource-&gt;Fence != <span class="number">0</span> &amp;&amp; mFence-&gt;<span class="built_in">GetCompletedValue</span>() &lt; mCurrFrameResource-&gt;Fence)</span><br><span class="line">    &#123;</span><br><span class="line">        HANDLE eventHandle = <span class="built_in">CreateEventEx</span>(<span class="literal">nullptr</span>, <span class="literal">false</span>, <span class="literal">false</span>, EVENT_ALL_ACCESS);</span><br><span class="line">        <span class="built_in">ThrowIfFailed</span>(mFence-&gt;<span class="built_in">SetEventOnCompletion</span>(mCurrFrameResource-&gt;Fence, eventHandle));</span><br><span class="line">        <span class="built_in">WaitForSingleObject</span>(eventHandle, INFINITE);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(eventHandle);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::Draw</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//.....构建命令列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加围栏点,将命令标记到此围栏点</span></span><br><span class="line">     mCurrFrameResource-&gt;Fence = ++mCurrentFence;</span><br><span class="line">    <span class="comment">//向命令列表添加一条指令来设置一个新的围栏点</span></span><br><span class="line">    <span class="comment">//由于当前的GPU正在执行绘制命令,所以在GPU处理完Signal()函数之前的所有命令以前,并不会设置新的围栏点</span></span><br><span class="line">     mCommandQueue-&gt;<span class="built_in">Signal</span>(mFence.<span class="built_in">Get</span>(), mCurrentFence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种处理无法完全避免等待的发生</p>
<p>如果GPU速度远大于CPU,,则GPU会处于空闲</p>
<p>反之,CPU会空闲,但是CPU空闲是有利的,因为CPU还需要处理其他算法</p>
<p>采用多帧资源的方法目的是让命令队列一直处于非空状态,即GPU一直有事情可以做</p>
</blockquote>
<h3 id="渲染项"><a href="#渲染项" class="headerlink" title="渲染项"></a>渲染项</h3><p>单次绘制调用过程中,需要向渲染流水线提交的数据集成为<code>渲染项</code></p>
<p>我们用一个轻量级的结构体来存储绘制物体所需的数据 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RenderItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">RenderItem</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述了局部空间相对于世界空间的矩阵</span></span><br><span class="line">    <span class="comment">//定义了物体位于世界空间的位置,朝向和大小</span></span><br><span class="line">    XMFLOAT4X4 World = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用dirty flag来标志物体的相关数据已经发生改变,意味着我们次数需要更新常量缓冲区</span></span><br><span class="line">    <span class="comment">// 由于每个帧资源中都有一个物体常量缓冲区,所以需要对每个帧资源进行更新</span></span><br><span class="line">    <span class="comment">//即,当修改物体数据时,应当按NumFramesDirty= gNumFrameReousreces进行设置,从而使每个帧资源都更新</span></span><br><span class="line">	<span class="keyword">int</span> NumFramesDirty = gNumFrameResources;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该索引指向的GPU常量缓冲区对应当前渲染项中的物体常量缓冲区</span></span><br><span class="line">	UINT ObjCBIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	MeshGeometry* Geo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图元拓扑</span></span><br><span class="line">    D3D12_PRIMITIVE_TOPOLOGY PrimitiveType = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DrawIndexedInstanced方法的参数</span></span><br><span class="line">    UINT IndexCount = <span class="number">0</span>;</span><br><span class="line">    UINT StartIndexLocation = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> BaseVertexLocation = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="渲染过程中所用到的常量数据"><a href="#渲染过程中所用到的常量数据" class="headerlink" title="渲染过程中所用到的常量数据"></a>渲染过程中所用到的常量数据</h3><ul>
<li>扩展常量缓冲区</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//着色器</span></span><br><span class="line">cbuffer cbPass : <span class="built_in"><span class="keyword">register</span></span>(b1)</span><br><span class="line">&#123;</span><br><span class="line">    float4x4 gView;</span><br><span class="line">    float4x4 gInvView;</span><br><span class="line">    float4x4 gProj;</span><br><span class="line">    float4x4 gInvProj;</span><br><span class="line">    float4x4 gViewProj;</span><br><span class="line">    float4x4 gInvViewProj;</span><br><span class="line">    float3 gEyePosW;</span><br><span class="line">    <span class="keyword">float</span> cbPerObjectPad1;</span><br><span class="line">    float2 gRenderTargetSize;</span><br><span class="line">    float2 gInvRenderTargetSize;</span><br><span class="line">    <span class="keyword">float</span> gNearZ;</span><br><span class="line">    <span class="keyword">float</span> gFarZ;</span><br><span class="line">    <span class="keyword">float</span> gTotalTime;</span><br><span class="line">    <span class="keyword">float</span> gDeltaTime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//与之对应的常量缓冲区数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassConstants</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DirectX::XMFLOAT4X4 View = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">    DirectX::XMFLOAT4X4 InvView = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">    DirectX::XMFLOAT4X4 Proj = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">    DirectX::XMFLOAT4X4 InvProj = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">    DirectX::XMFLOAT4X4 ViewProj = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">    DirectX::XMFLOAT4X4 InvViewProj = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">    DirectX::XMFLOAT3 EyePosW = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> cbPerObjectPad1 = <span class="number">0.0f</span>;</span><br><span class="line">    DirectX::XMFLOAT2 RenderTargetSize = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    DirectX::XMFLOAT2 InvRenderTargetSize = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> NearZ = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> FarZ = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> TotalTime = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> DeltaTime = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>刷新常量缓冲区</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::UpdateObjectCBs</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> currObjectCB = mCurrFrameResource-&gt;ObjectCB.<span class="built_in">get</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : mAllRitems)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 只对发生常量改变的缓冲区刷新</span></span><br><span class="line">		<span class="keyword">if</span>(e-&gt;NumFramesDirty &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			XMMATRIX world = <span class="built_in">XMLoadFloat4x4</span>(&amp;e-&gt;World);</span><br><span class="line"></span><br><span class="line">			ObjectConstants objConstants;</span><br><span class="line">			<span class="built_in">XMStoreFloat4x4</span>(&amp;objConstants.World, <span class="built_in">XMMatrixTranspose</span>(world));</span><br><span class="line"></span><br><span class="line">			currObjectCB-&gt;<span class="built_in">CopyData</span>(e-&gt;ObjCBIndex, objConstants);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 还需要对下一个FrameResource更新</span></span><br><span class="line">			e-&gt;NumFramesDirty--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::UpdateMainPassCB</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XMMATRIX view = <span class="built_in">XMLoadFloat4x4</span>(&amp;mView);</span><br><span class="line">	XMMATRIX proj = <span class="built_in">XMLoadFloat4x4</span>(&amp;mProj);</span><br><span class="line"></span><br><span class="line">	XMMATRIX viewProj = <span class="built_in">XMMatrixMultiply</span>(view, proj);</span><br><span class="line">	XMMATRIX invView = <span class="built_in">XMMatrixInverse</span>(&amp;<span class="built_in">XMMatrixDeterminant</span>(view), view);</span><br><span class="line">	XMMATRIX invProj = <span class="built_in">XMMatrixInverse</span>(&amp;<span class="built_in">XMMatrixDeterminant</span>(proj), proj);</span><br><span class="line">	XMMATRIX invViewProj = <span class="built_in">XMMatrixInverse</span>(&amp;<span class="built_in">XMMatrixDeterminant</span>(viewProj), viewProj);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.View, <span class="built_in">XMMatrixTranspose</span>(view));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.InvView, <span class="built_in">XMMatrixTranspose</span>(invView));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.Proj, <span class="built_in">XMMatrixTranspose</span>(proj));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.InvProj, <span class="built_in">XMMatrixTranspose</span>(invProj));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.ViewProj, <span class="built_in">XMMatrixTranspose</span>(viewProj));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.InvViewProj, <span class="built_in">XMMatrixTranspose</span>(invViewProj));</span><br><span class="line">	mMainPassCB.EyePosW = mEyePos;</span><br><span class="line">	mMainPassCB.RenderTargetSize = <span class="built_in">XMFLOAT2</span>((<span class="keyword">float</span>)mClientWidth, (<span class="keyword">float</span>)mClientHeight);</span><br><span class="line">	mMainPassCB.InvRenderTargetSize = <span class="built_in">XMFLOAT2</span>(<span class="number">1.0f</span> / mClientWidth, <span class="number">1.0f</span> / mClientHeight);</span><br><span class="line">	mMainPassCB.NearZ = <span class="number">1.0f</span>;</span><br><span class="line">	mMainPassCB.FarZ = <span class="number">1000.0f</span>;</span><br><span class="line">	mMainPassCB.TotalTime = gt.<span class="built_in">TotalTime</span>();</span><br><span class="line">	mMainPassCB.DeltaTime = gt.<span class="built_in">DeltaTime</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> currPassCB = mCurrFrameResource-&gt;PassCB.<span class="built_in">get</span>();</span><br><span class="line">	currPassCB-&gt;<span class="built_in">CopyData</span>(<span class="number">0</span>, mMainPassCB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>着色器改变</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VertexOut <span class="title">VS</span><span class="params">(VertexIn vin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VertexOut vout;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Transform to homogeneous clip space.</span></span><br><span class="line">    float4 posW = <span class="built_in">mul</span>(<span class="built_in">float4</span>(vin.PosL, <span class="number">1.0f</span>), gWorld);</span><br><span class="line">    vout.PosH = <span class="built_in">mul</span>(posW, gViewProj);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Just pass vertex color into the pixel shader.</span></span><br><span class="line">    vout.Color = vin.Color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调整根签名</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::BuildRootSignature</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建2个描述</span></span><br><span class="line">    CD3DX12_DESCRIPTOR_RANGE cbvTable0;</span><br><span class="line">    cbvTable0.<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CD3DX12_DESCRIPTOR_RANGE cbvTable1;</span><br><span class="line">    cbvTable1.<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2个成员的描述符表</span></span><br><span class="line">	CD3DX12_ROOT_PARAMETER slotRootParameter[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建根CBV</span></span><br><span class="line">    slotRootParameter[<span class="number">0</span>].<span class="built_in">InitAsDescriptorTable</span>(<span class="number">1</span>, &amp;cbvTable0);</span><br><span class="line">    slotRootParameter[<span class="number">1</span>].<span class="built_in">InitAsDescriptorTable</span>(<span class="number">1</span>, &amp;cbvTable1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">CD3DX12_ROOT_SIGNATURE_DESC <span class="title">rootSigDesc</span><span class="params">(<span class="number">2</span>, slotRootParameter, <span class="number">0</span>, <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</span></span>;</span><br><span class="line"><span class="comment">//*************************</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="不同形状的几何体"><a href="#不同形状的几何体" class="headerlink" title="不同形状的几何体"></a>不同形状的几何体</h3><h4 id="GeometryGenerator类"><a href="#GeometryGenerator类" class="headerlink" title="GeometryGenerator类"></a>GeometryGenerator类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeometryGenerator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> uint16 = std::<span class="keyword">uint16_t</span>;</span><br><span class="line">    <span class="keyword">using</span> uint32 = std::<span class="keyword">uint32_t</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="built_in">Vertex</span>()&#123;&#125;</span><br><span class="line">        <span class="built_in">Vertex</span>(</span><br><span class="line">            <span class="keyword">const</span> DirectX::XMFLOAT3&amp; p, </span><br><span class="line">            <span class="keyword">const</span> DirectX::XMFLOAT3&amp; n, </span><br><span class="line">            <span class="keyword">const</span> DirectX::XMFLOAT3&amp; t, </span><br><span class="line">            <span class="keyword">const</span> DirectX::XMFLOAT2&amp; uv) :</span><br><span class="line">            <span class="built_in">Position</span>(p), </span><br><span class="line">            <span class="built_in">Normal</span>(n), </span><br><span class="line">            <span class="built_in">TangentU</span>(t), </span><br><span class="line">            <span class="built_in">TexC</span>(uv)&#123;&#125;</span><br><span class="line">		<span class="built_in">Vertex</span>(</span><br><span class="line">			<span class="keyword">float</span> px, <span class="keyword">float</span> py, <span class="keyword">float</span> pz, </span><br><span class="line">			<span class="keyword">float</span> nx, <span class="keyword">float</span> ny, <span class="keyword">float</span> nz,</span><br><span class="line">			<span class="keyword">float</span> tx, <span class="keyword">float</span> ty, <span class="keyword">float</span> tz,</span><br><span class="line">			<span class="keyword">float</span> u, <span class="keyword">float</span> v) : </span><br><span class="line">            <span class="built_in">Position</span>(px,py,pz), </span><br><span class="line">            <span class="built_in">Normal</span>(nx,ny,nz),</span><br><span class="line">			<span class="built_in">TangentU</span>(tx, ty, tz), </span><br><span class="line">            <span class="built_in">TexC</span>(u,v)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        DirectX::XMFLOAT3 Position;</span><br><span class="line">        DirectX::XMFLOAT3 Normal;</span><br><span class="line">        DirectX::XMFLOAT3 TangentU;</span><br><span class="line">        DirectX::XMFLOAT2 TexC;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">MeshData</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		std::vector&lt;Vertex&gt; Vertices;</span><br><span class="line">        std::vector&lt;uint32&gt; Indices32;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::vector&lt;uint16&gt;&amp; <span class="title">GetIndices16</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(mIndices16.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				mIndices16.<span class="built_in">resize</span>(Indices32.<span class="built_in">size</span>());</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Indices32.<span class="built_in">size</span>(); ++i)</span><br><span class="line">					mIndices16[i] = <span class="keyword">static_cast</span>&lt;uint16&gt;(Indices32[i]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> mIndices16;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;uint16&gt; mIndices16;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建盒子</span></span><br><span class="line">    <span class="function">MeshData <span class="title">CreateBox</span><span class="params">(<span class="keyword">float</span> width, <span class="keyword">float</span> height, <span class="keyword">float</span> depth, uint32 numSubdivisions)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建球体</span></span><br><span class="line">    <span class="function">MeshData <span class="title">CreateSphere</span><span class="params">(<span class="keyword">float</span> radius, uint32 sliceCount, uint32 stackCount)</span></span>;</span><br><span class="line"><span class="comment">//创建以给定的半径创建一个以原点为中心的地层</span></span><br><span class="line">    <span class="function">MeshData <span class="title">CreateGeosphere</span><span class="params">(<span class="keyword">float</span> radius, uint32 numSubdivisions)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///创建一个平行于y轴并以原点为中心的圆柱体。</span></span><br><span class="line"><span class="comment">///上下半径可以变化以形成各种圆锥形状，而不是真实的圆柱体。 切片和堆栈参数控制镶嵌的程度。</span></span><br><span class="line">    <span class="function">MeshData <span class="title">CreateCylinder</span><span class="params">(<span class="keyword">float</span> bottomRadius, <span class="keyword">float</span> topRadius, <span class="keyword">float</span> height, uint32 sliceCount, uint32 stackCount)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//在xz平面中以m行和n列为中心创建一个mxn网格,在具有指定宽度和深度的原点。</span></span><br><span class="line">    <span class="function">MeshData <span class="title">CreateGrid</span><span class="params">(<span class="keyword">float</span> width, <span class="keyword">float</span> depth, uint32 m, uint32 n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建与屏幕对齐的四边形。 这对于后期处理和屏幕效果很有用。</span></span><br><span class="line">    <span class="function">MeshData <span class="title">CreateQuad</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> w, <span class="keyword">float</span> h, <span class="keyword">float</span> depth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Subdivide</span><span class="params">(MeshData&amp; meshData)</span></span>;</span><br><span class="line">    <span class="function">Vertex <span class="title">MidPoint</span><span class="params">(<span class="keyword">const</span> Vertex&amp; v0, <span class="keyword">const</span> Vertex&amp; v1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildCylinderTopCap</span><span class="params">(<span class="keyword">float</span> bottomRadius, <span class="keyword">float</span> topRadius, <span class="keyword">float</span> height, uint32 sliceCount, uint32 stackCount, MeshData&amp; meshData)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildCylinderBottomCap</span><span class="params">(<span class="keyword">float</span> bottomRadius, <span class="keyword">float</span> topRadius, <span class="keyword">float</span> height, uint32 sliceCount, uint32 stackCount, MeshData&amp; meshData)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="细分"><a href="#细分" class="headerlink" title="细分"></a>细分</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GeometryGenerator::Subdivide</span><span class="params">(MeshData&amp; meshData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//       v1</span></span><br><span class="line">		<span class="comment">//       *</span></span><br><span class="line">		<span class="comment">//      / \</span></span><br><span class="line"><span class="comment">		//     /   \</span></span><br><span class="line"><span class="comment">		//  m0*-----*m1</span></span><br><span class="line">		<span class="comment">//   / \   / \</span></span><br><span class="line"><span class="comment">		//  /   \ /   \</span></span><br><span class="line"><span class="comment">		// *-----*-----*</span></span><br><span class="line">		<span class="comment">// v0    m2     v2</span></span><br><span class="line">		<span class="comment">//****我里个去*****</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//保存一份拷贝</span></span><br><span class="line">	MeshData inputCopy=meshData;</span><br><span class="line">	meshData.Vertices.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">	meshData.Indices32.<span class="built_in">reserve</span>(<span class="number">0</span>);<span class="comment">//清空</span></span><br><span class="line"></span><br><span class="line">	uint32 numTris =(uint32)inputCopy.Indices32.<span class="built_in">size</span>()/<span class="number">3</span>; <span class="comment">//三角形数量</span></span><br><span class="line">	<span class="keyword">for</span> (uint32 i=<span class="number">0</span>;i&lt;numTris;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Vertex v0 = inputCopy.Vertices[inputCopy.Indices32[i * <span class="number">3</span> + <span class="number">0</span>]];</span><br><span class="line">		Vertex v1 = inputCopy.Vertices[inputCopy.Indices32[i * <span class="number">3</span> + <span class="number">1</span>]];</span><br><span class="line">		Vertex v2 = inputCopy.Vertices[inputCopy.Indices32[i * <span class="number">3</span> + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建中间点</span></span><br><span class="line">		Vertex m0 = <span class="built_in">MidPoint</span>(v0, v1);</span><br><span class="line">		Vertex m1 = <span class="built_in">MidPoint</span>(v1, v2);</span><br><span class="line">		Vertex m2 = <span class="built_in">MidPoint</span>(v0, v2);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//添加新的几何体</span></span><br><span class="line">		meshData.Vertices.<span class="built_in">push_back</span>(v0); <span class="comment">// 0</span></span><br><span class="line">		meshData.Vertices.<span class="built_in">push_back</span>(v1); <span class="comment">// 1</span></span><br><span class="line">		meshData.Vertices.<span class="built_in">push_back</span>(v2); <span class="comment">// 2</span></span><br><span class="line">		meshData.Vertices.<span class="built_in">push_back</span>(m0); <span class="comment">// 3</span></span><br><span class="line">		meshData.Vertices.<span class="built_in">push_back</span>(m1); <span class="comment">// 4</span></span><br><span class="line">		meshData.Vertices.<span class="built_in">push_back</span>(m2); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">0</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">3</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">3</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">4</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">5</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">4</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">3</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i * <span class="number">6</span> + <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="中间点的生成"><a href="#中间点的生成" class="headerlink" title="中间点的生成"></a>中间点的生成</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Vertex <span class="title">GeometryGenerator::MidPoint</span><span class="params">(<span class="keyword">const</span> Vertex&amp; v0, <span class="keyword">const</span> Vertex&amp; v1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XMVECTOR p0 = <span class="built_in">XMLoadFloat3</span>(&amp;v0.Position);</span><br><span class="line">	XMVECTOR p1 = <span class="built_in">XMLoadFloat3</span>(&amp;v1.Position);</span><br><span class="line"></span><br><span class="line">	XMVECTOR n0 = <span class="built_in">XMLoadFloat3</span>(&amp;v0.Normal);</span><br><span class="line">	XMVECTOR n1 = <span class="built_in">XMLoadFloat3</span>(&amp;v1.Normal);</span><br><span class="line">	</span><br><span class="line">	XMVECTOR tan0 = <span class="built_in">XMLoadFloat3</span>(&amp;v0.TangentU);</span><br><span class="line">	XMVECTOR tan1 = <span class="built_in">XMLoadFloat3</span>(&amp;v1.TangentU);</span><br><span class="line"></span><br><span class="line">	XMVECTOR tex0 = <span class="built_in">XMLoadFloat2</span>(&amp;v0.TexC);</span><br><span class="line">	XMVECTOR tex1 = <span class="built_in">XMLoadFloat2</span>(&amp;v1.TexC);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算中间数据</span></span><br><span class="line">	XMVECTOR pos=<span class="number">0.5f</span>*(p0+p1);</span><br><span class="line">	XMVECTOR normal=<span class="built_in">XMVector3Normalize</span>(<span class="number">0.5f</span>*(n0+n1));</span><br><span class="line">	XMVECTOR tangent = <span class="built_in">XMVector3Normalize</span>(<span class="number">0.5f</span>*(tan0 + tan1));</span><br><span class="line">	XMVECTOR tex = <span class="number">0.5f</span>*(tex0 + tex1);</span><br><span class="line"></span><br><span class="line">	Vertex v;</span><br><span class="line">	<span class="built_in">XMStoreFloat3</span>(&amp;v.Position,pos);</span><br><span class="line">	<span class="built_in">XMStoreFloat3</span>(&amp;v.Normal, normal);</span><br><span class="line">	<span class="built_in">XMStoreFloat3</span>(&amp;v.TangentU, tangent);</span><br><span class="line">	<span class="built_in">XMStoreFloat2</span>(&amp;v.TexC, tex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GeometryGenerator::MeshData <span class="title">GeometryGenerator::CreateBox</span><span class="params">(<span class="keyword">float</span> width, <span class="keyword">float</span> height, <span class="keyword">float</span> depth, uint32 numSubdivisions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MeshData meshData;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	构建顶点</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	Vertex v[<span class="number">24</span>];</span><br><span class="line">	<span class="keyword">float</span> w2 = <span class="number">0.5f</span>*width;</span><br><span class="line">	<span class="keyword">float</span> h2 = <span class="number">0.5f</span>*height;</span><br><span class="line">	<span class="keyword">float</span> d2 = <span class="number">0.5f</span>*depth;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前面</span></span><br><span class="line">	v[<span class="number">0</span>] = <span class="built_in">Vertex</span>(-w2, -h2, -d2, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	v[<span class="number">1</span>] = <span class="built_in">Vertex</span>(-w2, +h2, -d2, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	v[<span class="number">2</span>] = <span class="built_in">Vertex</span>(+w2, +h2, -d2, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	v[<span class="number">3</span>] = <span class="built_in">Vertex</span>(+w2, -h2, -d2, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后面</span></span><br><span class="line">	v[<span class="number">4</span>] = <span class="built_in">Vertex</span>(-w2, -h2, +d2, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	v[<span class="number">5</span>] = <span class="built_in">Vertex</span>(+w2, -h2, +d2, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	v[<span class="number">6</span>] = <span class="built_in">Vertex</span>(+w2, +h2, +d2, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	v[<span class="number">7</span>] = <span class="built_in">Vertex</span>(-w2, +h2, +d2, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 顶部面</span></span><br><span class="line">	v[<span class="number">8</span>] = <span class="built_in">Vertex</span>(-w2, +h2, -d2, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	v[<span class="number">9</span>] = <span class="built_in">Vertex</span>(-w2, +h2, +d2, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	v[<span class="number">10</span>] = <span class="built_in">Vertex</span>(+w2, +h2, +d2, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	v[<span class="number">11</span>] = <span class="built_in">Vertex</span>(+w2, +h2, -d2, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 底部面</span></span><br><span class="line">	v[<span class="number">12</span>] = <span class="built_in">Vertex</span>(-w2, -h2, -d2, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	v[<span class="number">13</span>] = <span class="built_in">Vertex</span>(+w2, -h2, -d2, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	v[<span class="number">14</span>] = <span class="built_in">Vertex</span>(+w2, -h2, +d2, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	v[<span class="number">15</span>] = <span class="built_in">Vertex</span>(-w2, -h2, +d2, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 左边面</span></span><br><span class="line">	v[<span class="number">16</span>] = <span class="built_in">Vertex</span>(-w2, -h2, +d2, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	v[<span class="number">17</span>] = <span class="built_in">Vertex</span>(-w2, +h2, +d2, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	v[<span class="number">18</span>] = <span class="built_in">Vertex</span>(-w2, +h2, -d2, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	v[<span class="number">19</span>] = <span class="built_in">Vertex</span>(-w2, -h2, -d2, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 右边面</span></span><br><span class="line">	v[<span class="number">20</span>] = <span class="built_in">Vertex</span>(+w2, -h2, -d2, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	v[<span class="number">21</span>] = <span class="built_in">Vertex</span>(+w2, +h2, -d2, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	v[<span class="number">22</span>] = <span class="built_in">Vertex</span>(+w2, +h2, +d2, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	v[<span class="number">23</span>] = <span class="built_in">Vertex</span>(+w2, -h2, +d2, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	meshData.Vertices.<span class="built_in">assign</span>(&amp;v[<span class="number">0</span>],&amp;v[<span class="number">24</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	构建序列</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	uint32 i[<span class="number">36</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill in the front face index data</span></span><br><span class="line">	i[<span class="number">0</span>] = <span class="number">0</span>; i[<span class="number">1</span>] = <span class="number">1</span>; i[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	i[<span class="number">3</span>] = <span class="number">0</span>; i[<span class="number">4</span>] = <span class="number">2</span>; i[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill in the back face index data</span></span><br><span class="line">	i[<span class="number">6</span>] = <span class="number">4</span>; i[<span class="number">7</span>] = <span class="number">5</span>; i[<span class="number">8</span>] = <span class="number">6</span>;</span><br><span class="line">	i[<span class="number">9</span>] = <span class="number">4</span>; i[<span class="number">10</span>] = <span class="number">6</span>; i[<span class="number">11</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill in the top face index data</span></span><br><span class="line">	i[<span class="number">12</span>] = <span class="number">8</span>; i[<span class="number">13</span>] = <span class="number">9</span>; i[<span class="number">14</span>] = <span class="number">10</span>;</span><br><span class="line">	i[<span class="number">15</span>] = <span class="number">8</span>; i[<span class="number">16</span>] = <span class="number">10</span>; i[<span class="number">17</span>] = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill in the bottom face index data</span></span><br><span class="line">	i[<span class="number">18</span>] = <span class="number">12</span>; i[<span class="number">19</span>] = <span class="number">13</span>; i[<span class="number">20</span>] = <span class="number">14</span>;</span><br><span class="line">	i[<span class="number">21</span>] = <span class="number">12</span>; i[<span class="number">22</span>] = <span class="number">14</span>; i[<span class="number">23</span>] = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill in the left face index data</span></span><br><span class="line">	i[<span class="number">24</span>] = <span class="number">16</span>; i[<span class="number">25</span>] = <span class="number">17</span>; i[<span class="number">26</span>] = <span class="number">18</span>;</span><br><span class="line">	i[<span class="number">27</span>] = <span class="number">16</span>; i[<span class="number">28</span>] = <span class="number">18</span>; i[<span class="number">29</span>] = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill in the right face index data</span></span><br><span class="line">	i[<span class="number">30</span>] = <span class="number">20</span>; i[<span class="number">31</span>] = <span class="number">21</span>; i[<span class="number">32</span>] = <span class="number">22</span>;</span><br><span class="line">	i[<span class="number">33</span>] = <span class="number">20</span>; i[<span class="number">34</span>] = <span class="number">22</span>; i[<span class="number">35</span>] = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">	meshData.Indices32.<span class="built_in">assign</span>(&amp;i[<span class="number">0</span>],&amp;i[<span class="number">36</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//细分</span></span><br><span class="line">	numSubdivisions = std::min&lt;uint32&gt;(numSubdivisions,<span class="number">6u</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (uint32 i = <span class="number">0</span>;i&lt;numSubdivisions;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Subdivide</span>(meshData);<span class="comment">//细分</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> meshData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="球体"><a href="#球体" class="headerlink" title="球体"></a>球体</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GeometryGenerator::MeshData <span class="title">GeometryGenerator::CreateSphere</span><span class="params">(<span class="keyword">float</span> radius, uint32 sliceCount, uint32 stackCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	MeshData meshData;</span><br><span class="line"></span><br><span class="line">	<span class="function">Vertex <span class="title">topVertex</span><span class="params">(<span class="number">0.0f</span>,+radius, <span class="number">0.0f</span>, <span class="number">0.0f</span>, +<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;<span class="comment">//顶部顶点</span></span><br><span class="line">	<span class="function">Vertex <span class="title">bottomVertex</span><span class="params">(<span class="number">0.0f</span>, -radius, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;<span class="comment">//底部顶点</span></span><br><span class="line"></span><br><span class="line">	meshData.Vertices.<span class="built_in">push_back</span>(topVertex);<span class="comment">//添加顶部顶点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> phiStep = XM_PI/stackCount;<span class="comment">//水平面分段</span></span><br><span class="line">	<span class="keyword">float</span> thetaStep=<span class="number">2.0f</span>*XM_PI/sliceCount;<span class="comment">//竖直面分段</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (uint32 i=<span class="number">0</span>;i&lt;=stackCount<span class="number">-1</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">float</span> phi = i*phiStep;<span class="comment">//yaw角度</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (uint32 j = <span class="number">0</span> ;j&lt;=sliceCount;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> theta=j*thetaStep;<span class="comment">//pitch角度</span></span><br><span class="line">			</span><br><span class="line">			Vertex v;</span><br><span class="line"></span><br><span class="line">			v.Position.x = radius*<span class="built_in">sinf</span>(phi)*<span class="built_in">cosf</span>(theta);</span><br><span class="line">			v.Position.y = radius * <span class="built_in">cosf</span>(phi);</span><br><span class="line">			v.Position.z = radius * <span class="built_in">sinf</span>(phi)*<span class="built_in">sinf</span>(theta);</span><br><span class="line"></span><br><span class="line">			v.TangentU.x = -radius * <span class="built_in">sinf</span>(phi)*<span class="built_in">sinf</span>(theta);</span><br><span class="line">			v.TangentU.y = <span class="number">0.0f</span>;</span><br><span class="line">			v.TangentU.z = +radius * <span class="built_in">sinf</span>(phi)*<span class="built_in">cosf</span>(theta);</span><br><span class="line"></span><br><span class="line">			XMVECTOR T = <span class="built_in">XMLoadFloat3</span>(&amp;v.TangentU);</span><br><span class="line">			<span class="built_in">XMStoreFloat3</span>(&amp;v.TangentU, <span class="built_in">XMVector3Normalize</span>(T));</span><br><span class="line"></span><br><span class="line">			XMVECTOR p = <span class="built_in">XMLoadFloat3</span>(&amp;v.Position);</span><br><span class="line">			<span class="built_in">XMStoreFloat3</span>(&amp;v.Normal, <span class="built_in">XMVector3Normalize</span>(p));</span><br><span class="line"></span><br><span class="line">			v.TexC.x = theta / XM_2PI;</span><br><span class="line">			v.TexC.y = phi / XM_PI;</span><br><span class="line"></span><br><span class="line">			meshData.Vertices.<span class="built_in">push_back</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//最底下一个顶点</span></span><br><span class="line">	meshData.Vertices.<span class="built_in">push_back</span>(bottomVertex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//顶部面所有点的索引</span></span><br><span class="line">	<span class="keyword">for</span> (uint32 i = <span class="number">1</span>; i &lt;= sliceCount; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uint32 baseIndex = <span class="number">1</span>;</span><br><span class="line">	uint32 ringVertexCount = sliceCount + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//高度细分数量-2，因为顶部底部不算在内</span></span><br><span class="line">	<span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; stackCount - <span class="number">2</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (uint32 j = <span class="number">0</span>; j &lt; sliceCount; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + i * ringVertexCount + j);</span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + i * ringVertexCount + j + <span class="number">1</span>);</span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + (i + <span class="number">1</span>)*ringVertexCount + j);</span><br><span class="line"></span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + (i + <span class="number">1</span>)*ringVertexCount + j);</span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + i * ringVertexCount + j + <span class="number">1</span>);</span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + (i + <span class="number">1</span>)*ringVertexCount + j + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//底部的点的序号</span></span><br><span class="line">	uint32 southPoleIndex = (uint32)meshData.Vertices.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	baseIndex = southPoleIndex - ringVertexCount;</span><br><span class="line">	<span class="comment">//底部面所有索引</span></span><br><span class="line">	<span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; sliceCount; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(southPoleIndex);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + i);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> meshData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="柱体网格"><a href="#柱体网格" class="headerlink" title="柱体网格"></a>柱体网格</h5><p><img src="https://img.supervj.top/img/DX/image-20200704142449983.png" alt="image-20200704142449983"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GeometryGenerator::MeshData <span class="title">GeometryGenerator::CreateCylinder</span><span class="params">(<span class="keyword">float</span> bottomRadius, <span class="keyword">float</span> topRadius, <span class="keyword">float</span> height, uint32 sliceCount, uint32 stackCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	MeshData meshData;</span><br><span class="line">	<span class="comment">//高度递增</span></span><br><span class="line">	<span class="keyword">float</span> stackHeight = height / stackCount;</span><br><span class="line">	<span class="comment">//从底部开始，每一次半径递增</span></span><br><span class="line">	<span class="keyword">float</span> radiusStep = (topRadius - bottomRadius) / stackCount;</span><br><span class="line">	<span class="comment">//环数</span></span><br><span class="line">	uint32 rightCount = stackCount +<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (uint32 i=<span class="number">0</span>;i&lt;rightCount;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">float</span> y = <span class="number">-0.5f</span>*height + i*stackHeight;<span class="comment">//从底部开始往上加高度</span></span><br><span class="line">		<span class="keyword">float</span> r = bottomRadius+i*radiusStep;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> dTheta= <span class="number">2.0f</span>*XM_PI/sliceCount;<span class="comment">//360角度范围的弧度,水平角度yaw</span></span><br><span class="line">		<span class="keyword">for</span> (uint32 j=<span class="number">0</span>;j&lt;=sliceCount;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			Vertex vertex;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">float</span> c = <span class="built_in">cosf</span>(j*dTheta);</span><br><span class="line">			<span class="keyword">float</span> s = <span class="built_in">sinf</span>(j*dTheta);</span><br><span class="line"></span><br><span class="line">			vertex.Position=<span class="built_in">XMFLOAT3</span>(r*c,y,r*s);</span><br><span class="line">			vertex.TexC.x = (<span class="keyword">float</span>)j/sliceCount;</span><br><span class="line">			vertex.TexC.y = <span class="number">1.0f</span> - (<span class="keyword">float</span>)i / stackCount;</span><br><span class="line">			vertex.TangentU = <span class="built_in">XMFLOAT3</span>(-s, <span class="number">0.0f</span>, c);</span><br><span class="line">			<span class="keyword">float</span> dr = bottomRadius - topRadius;</span><br><span class="line">			<span class="function">XMFLOAT3 <span class="title">bitangent</span><span class="params">(dr*c, -height, dr*s)</span></span>;</span><br><span class="line">			XMVECTOR T = <span class="built_in">XMLoadFloat3</span>(&amp;vertex.TangentU);</span><br><span class="line">			XMVECTOR B = <span class="built_in">XMLoadFloat3</span>(&amp;bitangent);</span><br><span class="line">			XMVECTOR N = <span class="built_in">XMVector3Normalize</span>(<span class="built_in">XMVector3Cross</span>(T, B));</span><br><span class="line">			<span class="built_in">XMStoreFloat3</span>(&amp;vertex.Normal, N);</span><br><span class="line"></span><br><span class="line">			meshData.Vertices.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	uint32 ringVertexCount = sliceCount + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; stackCount; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (uint32 j = <span class="number">0</span>; j &lt; sliceCount; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>(i*ringVertexCount + j);</span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>((i + <span class="number">1</span>)*ringVertexCount + j);</span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>((i + <span class="number">1</span>)*ringVertexCount + j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>(i*ringVertexCount + j);</span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>((i + <span class="number">1</span>)*ringVertexCount + j + <span class="number">1</span>);</span><br><span class="line">			meshData.Indices32.<span class="built_in">push_back</span>(i*ringVertexCount + j + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BuildCylinderTopCap</span>(bottomRadius, topRadius, height, sliceCount, stackCount, meshData);</span><br><span class="line">	<span class="built_in">BuildCylinderBottomCap</span>(bottomRadius, topRadius, height, sliceCount, stackCount, meshData);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> meshData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每一个环最后一个顶点与第一个顶点是重合的,但是纹理坐标不同,只有这样才能保证绘制正确纹理</p>
</blockquote>
<h6 id="构建顶部和底部"><a href="#构建顶部和底部" class="headerlink" title="构建顶部和底部"></a>构建顶部和底部</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GeometryGenerator::BuildCylinderTopCap</span><span class="params">(<span class="keyword">float</span> bottomRadius, <span class="keyword">float</span> topRadius, <span class="keyword">float</span> height, uint32 sliceCount, uint32 stackCount, MeshData&amp; meshData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint32 baseIndex = (uint32)meshData.Vertices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> y = <span class="number">0.5f</span>*height;</span><br><span class="line">	<span class="keyword">float</span> dTheta = <span class="number">2.0f</span>*XM_PI / sliceCount;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//顶点重复，因为纹理坐标和法线不同。</span></span><br><span class="line">	<span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt;= sliceCount; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">float</span> x = topRadius * <span class="built_in">cosf</span>(i*dTheta);</span><br><span class="line">		<span class="keyword">float</span> z = topRadius * <span class="built_in">sinf</span>(i*dTheta);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//按高度缩小以尝试使顶盖纹理坐标区域与底面成比例？？</span></span><br><span class="line">		<span class="keyword">float</span> u = x / height + <span class="number">0.5f</span>;</span><br><span class="line">		<span class="keyword">float</span> v = z / height + <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">		meshData.Vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(x, y, z, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, u, v));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 中心点</span></span><br><span class="line">	meshData.Vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">0.0f</span>, y, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 中心序号</span></span><br><span class="line">	uint32 centerIndex = (uint32)meshData.Vertices.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; sliceCount; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(centerIndex);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + i + <span class="number">1</span>);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GeometryGenerator::BuildCylinderBottomCap</span><span class="params">(<span class="keyword">float</span> bottomRadius, <span class="keyword">float</span> topRadius, <span class="keyword">float</span> height, uint32 sliceCount, uint32 stackCount, MeshData&amp; meshData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint32 baseIndex = (uint32)meshData.Vertices.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">float</span> y = <span class="number">-0.5f</span>*height;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> dTheta = <span class="number">2.0f</span>*XM_PI / sliceCount;</span><br><span class="line">	<span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt;= sliceCount; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">float</span> x = bottomRadius * <span class="built_in">cosf</span>(i*dTheta);</span><br><span class="line">		<span class="keyword">float</span> z = bottomRadius * <span class="built_in">sinf</span>(i*dTheta);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> u = x / height + <span class="number">0.5f</span>;</span><br><span class="line">		<span class="keyword">float</span> v = z / height + <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">		meshData.Vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(x, y, z, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, u, v));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	meshData.Vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">0.0f</span>, y, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">	uint32 centerIndex = (uint32)meshData.Vertices.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; sliceCount; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(centerIndex);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + i);</span><br><span class="line">		meshData.Indices32.<span class="built_in">push_back</span>(baseIndex + i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="几何球体"><a href="#几何球体" class="headerlink" title="几何球体"></a>几何球体</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GeometryGenerator::MeshData <span class="title">GeometryGenerator::CreateGeosphere</span><span class="params">(<span class="keyword">float</span> radius, uint32 numSubdivisions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MeshData meshData;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为细分数设置上限。</span></span><br><span class="line">    numSubdivisions = std::min&lt;uint32&gt;(numSubdivisions, <span class="number">6u</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过镶嵌二十面体来近似一个球体。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> X = <span class="number">0.525731f</span>; </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> Z = <span class="number">0.850651f</span>;</span><br><span class="line"></span><br><span class="line">	XMFLOAT3 pos[<span class="number">12</span>] = </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">XMFLOAT3</span>(-X, <span class="number">0.0f</span>, Z),  <span class="built_in">XMFLOAT3</span>(X, <span class="number">0.0f</span>, Z),  </span><br><span class="line">		<span class="built_in">XMFLOAT3</span>(-X, <span class="number">0.0f</span>, -Z), <span class="built_in">XMFLOAT3</span>(X, <span class="number">0.0f</span>, -Z),    </span><br><span class="line">		<span class="built_in">XMFLOAT3</span>(<span class="number">0.0f</span>, Z, X),   <span class="built_in">XMFLOAT3</span>(<span class="number">0.0f</span>, Z, -X), </span><br><span class="line">		<span class="built_in">XMFLOAT3</span>(<span class="number">0.0f</span>, -Z, X),  <span class="built_in">XMFLOAT3</span>(<span class="number">0.0f</span>, -Z, -X),    </span><br><span class="line">		<span class="built_in">XMFLOAT3</span>(Z, X, <span class="number">0.0f</span>),   <span class="built_in">XMFLOAT3</span>(-Z, X, <span class="number">0.0f</span>), </span><br><span class="line">		<span class="built_in">XMFLOAT3</span>(Z, -X, <span class="number">0.0f</span>),  <span class="built_in">XMFLOAT3</span>(-Z, -X, <span class="number">0.0f</span>)</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    uint32 k[<span class="number">60</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">1</span>,<span class="number">4</span>,<span class="number">0</span>,  <span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,  <span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,  <span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>,  <span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,    </span><br><span class="line">		<span class="number">1</span>,<span class="number">10</span>,<span class="number">8</span>, <span class="number">10</span>,<span class="number">3</span>,<span class="number">8</span>, <span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,  <span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,  <span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,    </span><br><span class="line">		<span class="number">3</span>,<span class="number">10</span>,<span class="number">7</span>, <span class="number">10</span>,<span class="number">6</span>,<span class="number">7</span>, <span class="number">6</span>,<span class="number">11</span>,<span class="number">7</span>, <span class="number">6</span>,<span class="number">0</span>,<span class="number">11</span>, <span class="number">6</span>,<span class="number">1</span>,<span class="number">0</span>, </span><br><span class="line">		<span class="number">10</span>,<span class="number">1</span>,<span class="number">6</span>, <span class="number">11</span>,<span class="number">0</span>,<span class="number">9</span>, <span class="number">2</span>,<span class="number">11</span>,<span class="number">9</span>, <span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>,  <span class="number">11</span>,<span class="number">2</span>,<span class="number">7</span> </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    meshData.Vertices.<span class="built_in">resize</span>(<span class="number">12</span>);</span><br><span class="line">    meshData.Indices32.<span class="built_in">assign</span>(&amp;k[<span class="number">0</span>], &amp;k[<span class="number">60</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(uint32 i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">		meshData.Vertices[i].Position = pos[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(uint32 i = <span class="number">0</span>; i &lt; numSubdivisions; ++i)</span><br><span class="line">		<span class="built_in">Subdivide</span>(meshData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将顶点投影到球体和比例上。</span></span><br><span class="line">	<span class="keyword">for</span>(uint32 i = <span class="number">0</span>; i &lt; meshData.Vertices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 投影到单位球体上。</span></span><br><span class="line">		XMVECTOR n = <span class="built_in">XMVector3Normalize</span>(<span class="built_in">XMLoadFloat3</span>(&amp;meshData.Vertices[i].Position));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 投影到球体上。</span></span><br><span class="line">		XMVECTOR p = radius*n;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">XMStoreFloat3</span>(&amp;meshData.Vertices[i].Position, p);</span><br><span class="line">		<span class="built_in">XMStoreFloat3</span>(&amp;meshData.Vertices[i].Normal, n);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从球坐标导出纹理坐标。</span></span><br><span class="line">        <span class="keyword">float</span> theta = <span class="built_in">atan2f</span>(meshData.Vertices[i].Position.z, meshData.Vertices[i].Position.x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入[0，2pi]。</span></span><br><span class="line">        <span class="keyword">if</span>(theta &lt; <span class="number">0.0f</span>)</span><br><span class="line">            theta += XM_2PI;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> phi = <span class="built_in">acosf</span>(meshData.Vertices[i].Position.y / radius);</span><br><span class="line"></span><br><span class="line">		meshData.Vertices[i].TexC.x = theta/XM_2PI;</span><br><span class="line">		meshData.Vertices[i].TexC.y = phi/XM_PI;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// P关于theta的偏导数</span></span><br><span class="line">		meshData.Vertices[i].TangentU.x = -radius*<span class="built_in">sinf</span>(phi)*<span class="built_in">sinf</span>(theta);</span><br><span class="line">		meshData.Vertices[i].TangentU.y = <span class="number">0.0f</span>;</span><br><span class="line">		meshData.Vertices[i].TangentU.z = +radius*<span class="built_in">sinf</span>(phi)*<span class="built_in">cosf</span>(theta);</span><br><span class="line"></span><br><span class="line">		XMVECTOR T = <span class="built_in">XMLoadFloat3</span>(&amp;meshData.Vertices[i].TangentU);</span><br><span class="line">		<span class="built_in">XMStoreFloat3</span>(&amp;meshData.Vertices[i].TangentU, <span class="built_in">XMVector3Normalize</span>(T));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> meshData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="绘制几何体示例"><a href="#绘制几何体示例" class="headerlink" title="绘制几何体示例"></a>绘制几何体示例</h3><blockquote>
<p>我们已经创建一个由FrameResource类型元素所构成的向量，每个FrameReousrce中都有上传缓冲区，用于为场景中每一个渲染项存储渲染过程常量和物体常量数据。</p>
<p>如果有3个帧资源和n个渲染项，那么我们需要创建3n个物体常量缓冲区（object constant buffer）以及3个渲染过程常量缓冲区（pass 从constant buffer），因此我们需要创建3(n+1)个常量缓冲区视图。所以我们要修改CBV堆以容纳额外的描述符</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../Common/UploadBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DXApp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../Common/MathHelper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GeometryGenerator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;FrameResource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Microsoft::WRL::ComPtr;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX::PackedVector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> gNumFrameResources = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RenderItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">RenderItem</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 描述了局部空间相对于世界空间的矩阵</span></span><br><span class="line">	<span class="comment">//定义了物体位于世界空间的位置,朝向和大小</span></span><br><span class="line">	XMFLOAT4X4 World = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用dirty flag来标志物体的相关数据已经发生改变,意味着我们次数需要更新常量缓冲区</span></span><br><span class="line">	<span class="comment">// 由于每个帧资源中都有一个物体常量缓冲区,所以需要对每个帧资源进行更新</span></span><br><span class="line">	<span class="comment">//即,当修改物体数据时,应当按NumFramesDirty= gNumFrameReousreces进行设置,从而使每个帧资源都更新</span></span><br><span class="line">	<span class="keyword">int</span> NumFramesDirty = gNumFrameResources;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//索引到此渲染项目对应于ObjectCB的GPU常量缓冲区。</span></span><br><span class="line">	UINT ObjCBIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	MeshGeometry* Geo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//图元拓扑</span></span><br><span class="line">	D3D12_PRIMITIVE_TOPOLOGY PrimitiveType = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DrawIndexedInstanced方法的参数</span></span><br><span class="line">	UINT IndexCount = <span class="number">0</span>;</span><br><span class="line">	UINT StartIndexLocation = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> BaseVertexLocation = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapesApp</span> :</span> <span class="keyword">public</span> DXApp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ShapesApp</span>(HINSTANCE hInstance);</span><br><span class="line">	<span class="built_in">ShapesApp</span>(<span class="keyword">const</span> ShapesApp&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">	ShapesApp&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ShapesApp&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">ShapesApp</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnResize</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseDown</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseUp</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseMove</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnKeyboardInput</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateCamera</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateObjectCBs</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateMainPassCB</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildDescriptorHeaps</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildConstantBufferViews</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildRootSignature</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildShadersAndInputLayout</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildShapeGeometry</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildPSOs</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildFrameResources</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BuildRenderItems</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DrawRenderItems</span><span class="params">(ID3D12GraphicsCommandList* cmdList, <span class="keyword">const</span> std::vector&lt;RenderItem*&gt;&amp; ritems)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::unique_ptr&lt;FrameResource&gt;&gt; mFrameResources;<span class="comment">//帧资源数组</span></span><br><span class="line">	FrameResource* mCurrFrameResource = <span class="literal">nullptr</span>;<span class="comment">//当前帧资源</span></span><br><span class="line">	<span class="keyword">int</span> mCurrFrameResourceIndex = <span class="number">0</span>;<span class="comment">//当前帧资源序号</span></span><br><span class="line"></span><br><span class="line">	ComPtr&lt;ID3D12RootSignature&gt; mRootSignature = <span class="literal">nullptr</span>;<span class="comment">//根签名</span></span><br><span class="line">	ComPtr&lt;ID3D12DescriptorHeap&gt; mCbvHeap = <span class="literal">nullptr</span>;</span><br><span class="line">	ComPtr&lt;ID3D12DescriptorHeap&gt; mSrvDescriptorHeap = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	std::unordered_map&lt;std::string, std::unique_ptr&lt;MeshGeometry&gt;&gt; mGeometries;<span class="comment">//几何体哈希表</span></span><br><span class="line">	std::unordered_map&lt;std::string, ComPtr&lt;ID3DBlob&gt;&gt; mShaders;<span class="comment">//着色器表</span></span><br><span class="line">	std::unordered_map&lt;std::string, ComPtr&lt;ID3D12PipelineState&gt;&gt; mPSOs;<span class="comment">//流水线对象表</span></span><br><span class="line"></span><br><span class="line">	std::vector&lt;D3D12_INPUT_ELEMENT_DESC&gt; mInputLayout;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::unique_ptr&lt;RenderItem&gt;&gt; mAllRitems;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;RenderItem*&gt; mOpaqueRitems;</span><br><span class="line"></span><br><span class="line">	PassConstants mMainPassCB;</span><br><span class="line"></span><br><span class="line">	UINT mPassCbvOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> mIsWireframe = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	XMFLOAT3 mEyePos = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">	XMFLOAT4X4 mView = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">	XMFLOAT4X4 mProj = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> mTheta = <span class="number">1.5f</span>*XM_PI;</span><br><span class="line">	<span class="keyword">float</span> mPhi = <span class="number">0.2f</span>*XM_PI;</span><br><span class="line">	<span class="keyword">float</span> mRadius = <span class="number">15.0f</span>;</span><br><span class="line"></span><br><span class="line">	POINT mLastMousePos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ShapesApp::<span class="built_in">ShapesApp</span>(HINSTANCE hInstance):<span class="built_in">DXApp</span>(hInstance)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShapesApp::~<span class="built_in">ShapesApp</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (md3dDevice!=<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">FlushCommandQueue</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ShapesApp::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!DXApp::<span class="built_in">Initialize</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Reset</span>(mDirectCmdListAlloc.<span class="built_in">Get</span>(), <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BuildRootSignature</span>();</span><br><span class="line">	<span class="built_in">BuildShadersAndInputLayout</span>();</span><br><span class="line">	<span class="built_in">BuildShapeGeometry</span>();</span><br><span class="line">	<span class="built_in">BuildRenderItems</span>();</span><br><span class="line">	<span class="built_in">BuildFrameResources</span>();</span><br><span class="line">	<span class="built_in">BuildDescriptorHeaps</span>();</span><br><span class="line">	<span class="built_in">BuildConstantBufferViews</span>();</span><br><span class="line">	<span class="built_in">BuildPSOs</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Close</span>());</span><br><span class="line">	ID3D12CommandList* cmdsLists[] = &#123; mCommandList.<span class="built_in">Get</span>() &#125;;</span><br><span class="line">	mCommandQueue-&gt;<span class="built_in">ExecuteCommandLists</span>(_countof(cmdsLists), cmdsLists);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FlushCommandQueue</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::OnResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DXApp::<span class="built_in">OnResize</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	XMMATRIX P = <span class="built_in">XMMatrixPerspectiveFovLH</span>(<span class="number">0.25f</span>*MathHelper::Pi, <span class="built_in">AspectRatio</span>(), <span class="number">1.0f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mProj, P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::Update</span><span class="params">(<span class="keyword">const</span> GameTimer &amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">OnKeyboardInput</span>(gt);</span><br><span class="line">	<span class="built_in">UpdateCamera</span>(gt);</span><br><span class="line">	mCurrFrameResourceIndex = (mCurrFrameResourceIndex + <span class="number">1</span>) % gNumFrameResources;</span><br><span class="line">	mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GPU是否执行完所有命令?</span></span><br><span class="line">   <span class="comment">//如果还没有就令CPU等待,直到GPU完成所有命令的执行并且抵达这个围栏点</span></span><br><span class="line">	<span class="keyword">if</span> (mCurrFrameResource-&gt;Fence != <span class="number">0</span> &amp;&amp; mFence-&gt;<span class="built_in">GetCompletedValue</span>() &lt; mCurrFrameResource-&gt;Fence)</span><br><span class="line">	&#123;</span><br><span class="line">		HANDLE eventHandle = <span class="built_in">CreateEventEx</span>(<span class="literal">nullptr</span>, <span class="literal">false</span>, <span class="literal">false</span>, EVENT_ALL_ACCESS);</span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(mFence-&gt;<span class="built_in">SetEventOnCompletion</span>(mCurrFrameResource-&gt;Fence, eventHandle));</span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(eventHandle, INFINITE);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(eventHandle);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UpdateObjectCBs</span>(gt);</span><br><span class="line">	<span class="built_in">UpdateMainPassCB</span>(gt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::Draw</span><span class="params">(<span class="keyword">const</span> GameTimer &amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> cmdListAlloc = mCurrFrameResource-&gt;CmdListAlloc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reuse the memory associated with command recording.</span></span><br><span class="line">	<span class="comment">// We can only reset when the associated command lists have finished execution on the GPU.</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(cmdListAlloc-&gt;<span class="built_in">Reset</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A command list can be reset after it has been added to the command queue via ExecuteCommandList.</span></span><br><span class="line">	<span class="comment">// Reusing the command list reuses memory.</span></span><br><span class="line">	<span class="keyword">if</span> (mIsWireframe)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Reset</span>(cmdListAlloc.<span class="built_in">Get</span>(), mPSOs[<span class="string">&quot;opaque_wireframe&quot;</span>].<span class="built_in">Get</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Reset</span>(cmdListAlloc.<span class="built_in">Get</span>(), mPSOs[<span class="string">&quot;opaque&quot;</span>].<span class="built_in">Get</span>()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mCommandList-&gt;<span class="built_in">RSSetViewports</span>(<span class="number">1</span>, &amp;mScreenViewport);</span><br><span class="line">	mCommandList-&gt;<span class="built_in">RSSetScissorRects</span>(<span class="number">1</span>, &amp;mScissorRect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指示资源使用情况的状态转换。</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(<span class="built_in">CurrentBackBuffer</span>(),</span><br><span class="line">		D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清除后缓冲区和深度缓冲区。</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">ClearRenderTargetView</span>(<span class="built_in">CurrentBackBufferView</span>(), Colors::LightSteelBlue, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	mCommandList-&gt;<span class="built_in">ClearDepthStencilView</span>(<span class="built_in">DepthStencilView</span>(), D3D12_CLEAR_FLAG_DEPTH | D3D12_CLEAR_FLAG_STENCIL, <span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定我们要渲染到的缓冲区。</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">OMSetRenderTargets</span>(<span class="number">1</span>, &amp;<span class="built_in">CurrentBackBufferView</span>(), <span class="literal">true</span>, &amp;<span class="built_in">DepthStencilView</span>());</span><br><span class="line"></span><br><span class="line">	ID3D12DescriptorHeap* descriptorHeaps[] = &#123; mCbvHeap.<span class="built_in">Get</span>() &#125;;</span><br><span class="line">	mCommandList-&gt;<span class="built_in">SetDescriptorHeaps</span>(_countof(descriptorHeaps), descriptorHeaps);</span><br><span class="line"></span><br><span class="line">	mCommandList-&gt;<span class="built_in">SetGraphicsRootSignature</span>(mRootSignature.<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> passCbvIndex = mPassCbvOffset + mCurrFrameResourceIndex;</span><br><span class="line">	<span class="keyword">auto</span> passCbvHandle = <span class="built_in">CD3DX12_GPU_DESCRIPTOR_HANDLE</span>(mCbvHeap-&gt;<span class="built_in">GetGPUDescriptorHandleForHeapStart</span>());</span><br><span class="line">	passCbvHandle.<span class="built_in">Offset</span>(passCbvIndex, mCbvSrvUavDescriptorSize);</span><br><span class="line">	mCommandList-&gt;<span class="built_in">SetGraphicsRootDescriptorTable</span>(<span class="number">1</span>, passCbvHandle);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DrawRenderItems</span>(mCommandList.<span class="built_in">Get</span>(), mOpaqueRitems);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指示资源使用情况的状态转换。</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(<span class="built_in">CurrentBackBuffer</span>(),</span><br><span class="line">		D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Close</span>());</span><br><span class="line">	ID3D12CommandList* cmdsLists[] = &#123; mCommandList.<span class="built_in">Get</span>() &#125;;</span><br><span class="line">	mCommandQueue-&gt;<span class="built_in">ExecuteCommandLists</span>(_countof(cmdsLists), cmdsLists);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mSwapChain-&gt;<span class="built_in">Present</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	mCurrBackBuffer = (mCurrBackBuffer + <span class="number">1</span>) % SwapChainBufferCount;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扩展围栏值以将命令标记到该围栏点。</span></span><br><span class="line">	mCurrFrameResource-&gt;Fence = ++mCurrentFence;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将指令添加到命令队列以设置新的围栏点。</span></span><br><span class="line">	<span class="comment">//因为我们在GPU时间轴上，所以新的隔离点将不会</span></span><br><span class="line">	<span class="comment">//设置直到GPU完成处理此Signal（）之前的所有命令为止。</span></span><br><span class="line">	mCommandQueue-&gt;<span class="built_in">Signal</span>(mFence.<span class="built_in">Get</span>(), mCurrentFence);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::OnMouseDown</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mLastMousePos.x = x;</span><br><span class="line">	mLastMousePos.y = y;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SetCapture</span>(mhMainWnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::OnMouseUp</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ReleaseCapture</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::OnMouseMove</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((btnState &amp; MK_LBUTTON) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> dx = <span class="built_in">XMConvertToRadians</span>(<span class="number">0.25f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x - mLastMousePos.x));</span><br><span class="line">		<span class="keyword">float</span> dy = <span class="built_in">XMConvertToRadians</span>(<span class="number">0.25f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(y - mLastMousePos.y));</span><br><span class="line"></span><br><span class="line">		mTheta -= dx;</span><br><span class="line">		mPhi -= dy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		mPhi = MathHelper::<span class="built_in">Clamp</span>(mPhi, <span class="number">0.1f</span>, MathHelper::Pi - <span class="number">0.1f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((btnState &amp; MK_RBUTTON) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> dx = <span class="number">0.05f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x - mLastMousePos.x);</span><br><span class="line">		<span class="keyword">float</span> dy = <span class="number">0.05f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(y - mLastMousePos.y);</span><br><span class="line"></span><br><span class="line">		mRadius += dx - dy;</span><br><span class="line"></span><br><span class="line">		mRadius = MathHelper::<span class="built_in">Clamp</span>(mRadius, <span class="number">5.0f</span>, <span class="number">150.0f</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mLastMousePos.x = x;</span><br><span class="line">	mLastMousePos.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::OnKeyboardInput</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(<span class="string">&#x27;1&#x27;</span>) &amp; <span class="number">0x8000</span>)</span><br><span class="line">		mIsWireframe = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		mIsWireframe = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::UpdateCamera</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mEyePos.x = mRadius * <span class="built_in">sinf</span>(mPhi)*<span class="built_in">cosf</span>(mTheta);</span><br><span class="line">	mEyePos.z = mRadius * <span class="built_in">sinf</span>(mPhi)*<span class="built_in">sinf</span>(mTheta);</span><br><span class="line">	mEyePos.y = mRadius * <span class="built_in">cosf</span>(mPhi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build the view matrix.</span></span><br><span class="line">	XMVECTOR pos = <span class="built_in">XMVectorSet</span>(mEyePos.x, mEyePos.y, mEyePos.z, <span class="number">1.0f</span>);</span><br><span class="line">	XMVECTOR target = <span class="built_in">XMVectorZero</span>();</span><br><span class="line">	XMVECTOR up = <span class="built_in">XMVectorSet</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	XMMATRIX view = <span class="built_in">XMMatrixLookAtLH</span>(pos, target, up);</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mView, view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::UpdateObjectCBs</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> currObjectCB = mCurrFrameResource-&gt;ObjectCB.<span class="built_in">get</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : mAllRitems)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//仅在常量更改后才更新cbuffer数据。</span></span><br><span class="line">		<span class="comment">//需要针对每个框架资源进行跟踪。</span></span><br><span class="line">		<span class="keyword">if</span> (e-&gt;NumFramesDirty &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			XMMATRIX world = <span class="built_in">XMLoadFloat4x4</span>(&amp;e-&gt;World);</span><br><span class="line"></span><br><span class="line">			ObjectConstants objConstants;</span><br><span class="line">			<span class="built_in">XMStoreFloat4x4</span>(&amp;objConstants.World, <span class="built_in">XMMatrixTranspose</span>(world));</span><br><span class="line"></span><br><span class="line">			currObjectCB-&gt;<span class="built_in">CopyData</span>(e-&gt;ObjCBIndex, objConstants);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">			e-&gt;NumFramesDirty--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::UpdateMainPassCB</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XMMATRIX view = <span class="built_in">XMLoadFloat4x4</span>(&amp;mView);</span><br><span class="line">	XMMATRIX proj = <span class="built_in">XMLoadFloat4x4</span>(&amp;mProj);</span><br><span class="line"></span><br><span class="line">	XMMATRIX viewProj = <span class="built_in">XMMatrixMultiply</span>(view, proj);</span><br><span class="line">	XMMATRIX invView = <span class="built_in">XMMatrixInverse</span>(&amp;<span class="built_in">XMMatrixDeterminant</span>(view), view);</span><br><span class="line">	XMMATRIX invProj = <span class="built_in">XMMatrixInverse</span>(&amp;<span class="built_in">XMMatrixDeterminant</span>(proj), proj);</span><br><span class="line">	XMMATRIX invViewProj = <span class="built_in">XMMatrixInverse</span>(&amp;<span class="built_in">XMMatrixDeterminant</span>(viewProj), viewProj);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.View, <span class="built_in">XMMatrixTranspose</span>(view));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.InvView, <span class="built_in">XMMatrixTranspose</span>(invView));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.Proj, <span class="built_in">XMMatrixTranspose</span>(proj));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.InvProj, <span class="built_in">XMMatrixTranspose</span>(invProj));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.ViewProj, <span class="built_in">XMMatrixTranspose</span>(viewProj));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.InvViewProj, <span class="built_in">XMMatrixTranspose</span>(invViewProj));</span><br><span class="line">	mMainPassCB.EyePosW = mEyePos;</span><br><span class="line">	mMainPassCB.RenderTargetSize = <span class="built_in">XMFLOAT2</span>((<span class="keyword">float</span>)mClientWidth, (<span class="keyword">float</span>)mClientHeight);</span><br><span class="line">	mMainPassCB.InvRenderTargetSize = <span class="built_in">XMFLOAT2</span>(<span class="number">1.0f</span> / mClientWidth, <span class="number">1.0f</span> / mClientHeight);</span><br><span class="line">	mMainPassCB.NearZ = <span class="number">1.0f</span>;</span><br><span class="line">	mMainPassCB.FarZ = <span class="number">1000.0f</span>;</span><br><span class="line">	mMainPassCB.TotalTime = gt.<span class="built_in">TotalTime</span>();</span><br><span class="line">	mMainPassCB.DeltaTime = gt.<span class="built_in">DeltaTime</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> currPassCB = mCurrFrameResource-&gt;PassCB.<span class="built_in">get</span>();</span><br><span class="line">	currPassCB-&gt;<span class="built_in">CopyData</span>(<span class="number">0</span>, mMainPassCB);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*我们已经创建一个由FrameResource类型元素所构成的向量，每个FrameReousrce中都有上传缓冲区，用于为场景中每一个渲染项存储渲染过程常量和物体常量数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果有3个帧资源和n个渲染项，那么我们需要创建3n个物体常量缓冲区（object constant buffer）以及3个渲染过程常量缓冲区（pass 从constant buffer），因此我们需要创建3(n+1)个常量缓冲区视图。所以我们要修改CBV堆以容纳额外的描述符*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::BuildDescriptorHeaps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT objCount = (UINT)mOpaqueRitems.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">//每个帧资源的每个对象都需要一个CBV描述符，每个帧资源的perPass CBV +1。</span></span><br><span class="line">	UINT numDescriptors = (objCount+<span class="number">1</span>)*gNumFrameResources;</span><br><span class="line">	<span class="comment">//将偏移量保存到通过CBV的起点。 这是最后3个描述符。</span></span><br><span class="line">	mPassCbvOffset=objCount*gNumFrameResources;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建描述符堆</span></span><br><span class="line">	D3D12_DESCRIPTOR_HEAP_DESC cbvHeapDesc;</span><br><span class="line">	cbvHeapDesc.NumDescriptors = numDescriptors;</span><br><span class="line">	cbvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;</span><br><span class="line">	cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;</span><br><span class="line">	cbvHeapDesc.NodeMask = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateDescriptorHeap</span>(&amp;cbvHeapDesc,</span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(&amp;mCbvHeap)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们可以使用下列代码来填充CBV堆了，其中0-n-1描述符为第0个帧资源的物体CBV……3n、3n + 1、3n + 2分别为帧资源的渲染过程CBV</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::BuildConstantBufferViews</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT objCBByteSize = d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ObjectConstants));</span><br><span class="line"></span><br><span class="line">	UINT objCount = (UINT)mOpaqueRitems.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">//每个帧资源的每个对象都需要一个CBV描述符。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> frameIndex = <span class="number">0</span>; frameIndex &lt; gNumFrameResources; ++frameIndex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> objectCB = mFrameResources[frameIndex]-&gt;ObjectCB-&gt;<span class="built_in">Resource</span>();</span><br><span class="line">		<span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; objCount; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			D3D12_GPU_VIRTUAL_ADDRESS cbAddress = objectCB-&gt;<span class="built_in">GetGPUVirtualAddress</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//缓冲区中第i个对象常量缓冲区的偏移量。</span></span><br><span class="line">			cbAddress += i * objCBByteSize;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//偏移量到描述符堆中的对象cbv。</span></span><br><span class="line">			<span class="keyword">int</span> heapIndex = frameIndex * objCount + i;</span><br><span class="line">			<span class="keyword">auto</span> handle = <span class="built_in">CD3DX12_CPU_DESCRIPTOR_HANDLE</span>(mCbvHeap-&gt;<span class="built_in">GetCPUDescriptorHandleForHeapStart</span>());</span><br><span class="line">            <span class="comment">//通过调用ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart方法可以获得堆中的第一个描述符的句柄，但是现在堆中存储的不是一个描述符了，如果想要访问到堆中的其他描述符，必须进行偏移</span></span><br><span class="line">			handle.<span class="built_in">Offset</span>(heapIndex, mCbvSrvUavDescriptorSize);</span><br><span class="line"></span><br><span class="line">			D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc;</span><br><span class="line">			cbvDesc.BufferLocation = cbAddress;</span><br><span class="line">			cbvDesc.SizeInBytes = objCBByteSize;</span><br><span class="line"></span><br><span class="line">			md3dDevice-&gt;<span class="built_in">CreateConstantBufferView</span>(&amp;cbvDesc, handle);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UINT passCBByteSize = d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(PassConstants));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//最后三个描述符是每个帧资源的传递CBV。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> frameIndex = <span class="number">0</span>; frameIndex &lt; gNumFrameResources; ++frameIndex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> passCB = mFrameResources[frameIndex]-&gt;PassCB-&gt;<span class="built_in">Resource</span>();</span><br><span class="line">		D3D12_GPU_VIRTUAL_ADDRESS cbAddress = passCB-&gt;<span class="built_in">GetGPUVirtualAddress</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 偏移到描述符堆中的传递cbv。</span></span><br><span class="line">		<span class="keyword">int</span> heapIndex = mPassCbvOffset + frameIndex;</span><br><span class="line">		<span class="keyword">auto</span> handle = <span class="built_in">CD3DX12_CPU_DESCRIPTOR_HANDLE</span>(mCbvHeap-&gt;<span class="built_in">GetCPUDescriptorHandleForHeapStart</span>());</span><br><span class="line">		handle.<span class="built_in">Offset</span>(heapIndex, mCbvSrvUavDescriptorSize);</span><br><span class="line"></span><br><span class="line">		D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc;</span><br><span class="line">		cbvDesc.BufferLocation = cbAddress;</span><br><span class="line">		cbvDesc.SizeInBytes = passCBByteSize;</span><br><span class="line"></span><br><span class="line">		md3dDevice-&gt;<span class="built_in">CreateConstantBufferView</span>(&amp;cbvDesc, handle);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::BuildRootSignature</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建2个描述</span></span><br><span class="line">	CD3DX12_DESCRIPTOR_RANGE cbvTable0;</span><br><span class="line">	cbvTable0.<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	CD3DX12_DESCRIPTOR_RANGE cbvTable1;</span><br><span class="line">	cbvTable1.<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2个成员的描述符表</span></span><br><span class="line">	CD3DX12_ROOT_PARAMETER slotRootParameter[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create root CBVs.</span></span><br><span class="line">	slotRootParameter[<span class="number">0</span>].<span class="built_in">InitAsDescriptorTable</span>(<span class="number">1</span>, &amp;cbvTable0);</span><br><span class="line">	slotRootParameter[<span class="number">1</span>].<span class="built_in">InitAsDescriptorTable</span>(<span class="number">1</span>, &amp;cbvTable1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建根CBV</span></span><br><span class="line">	<span class="function">CD3DX12_ROOT_SIGNATURE_DESC <span class="title">rootSigDesc</span><span class="params">(<span class="number">2</span>, slotRootParameter, <span class="number">0</span>, <span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</span></span>;</span><br><span class="line"></span><br><span class="line">	ComPtr&lt;ID3DBlob&gt; serializedRootSig = <span class="literal">nullptr</span>;</span><br><span class="line">	ComPtr&lt;ID3DBlob&gt; errorBlob = <span class="literal">nullptr</span>;</span><br><span class="line">	HRESULT hr = <span class="built_in">D3D12SerializeRootSignature</span>(&amp;rootSigDesc, D3D_ROOT_SIGNATURE_VERSION_1,</span><br><span class="line">		serializedRootSig.<span class="built_in">GetAddressOf</span>(), errorBlob.<span class="built_in">GetAddressOf</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (errorBlob != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="built_in">OutputDebugStringA</span>((<span class="keyword">char</span>*)errorBlob-&gt;<span class="built_in">GetBufferPointer</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(hr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateRootSignature</span>(</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		serializedRootSig-&gt;<span class="built_in">GetBufferPointer</span>(),</span><br><span class="line">		serializedRootSig-&gt;<span class="built_in">GetBufferSize</span>(),</span><br><span class="line">		<span class="built_in">IID_PPV_ARGS</span>(mRootSignature.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::BuildShadersAndInputLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mShaders[<span class="string">&quot;standardVS&quot;</span>] = d3dUtil::<span class="built_in">CompileShader</span>(<span class="string">L&quot;Shaders\\color7.hlsl&quot;</span>, <span class="literal">nullptr</span>, <span class="string">&quot;VS&quot;</span>, <span class="string">&quot;vs_5_1&quot;</span>);</span><br><span class="line">	mShaders[<span class="string">&quot;opaquePS&quot;</span>] = d3dUtil::<span class="built_in">CompileShader</span>(<span class="string">L&quot;Shaders\\color7.hlsl&quot;</span>, <span class="literal">nullptr</span>, <span class="string">&quot;PS&quot;</span>, <span class="string">&quot;ps_5_1&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mInputLayout =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123; <span class="string">&quot;POSITION&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="number">0</span>, <span class="number">0</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">		&#123; <span class="string">&quot;COLOR&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::BuildShapeGeometry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GeometryGenerator geoGen;</span><br><span class="line">	GeometryGenerator::MeshData box = geoGen.<span class="built_in">CreateBox</span>(<span class="number">1.5f</span>, <span class="number">0.5f</span>, <span class="number">1.5f</span>, <span class="number">3</span>);</span><br><span class="line">	GeometryGenerator::MeshData grid = geoGen.<span class="built_in">CreateGrid</span>(<span class="number">20.0f</span>, <span class="number">30.0f</span>, <span class="number">60</span>, <span class="number">40</span>);</span><br><span class="line">	GeometryGenerator::MeshData sphere = geoGen.<span class="built_in">CreateSphere</span>(<span class="number">0.5f</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">	GeometryGenerator::MeshData cylinder = geoGen.<span class="built_in">CreateCylinder</span>(<span class="number">0.5f</span>, <span class="number">0.3f</span>, <span class="number">3.0f</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//顶点偏移量缓存到级联的顶点缓冲区中的每个对象。</span></span><br><span class="line">	UINT boxVertexOffset = <span class="number">0</span>;</span><br><span class="line">	UINT gridVertexOffset = (UINT)box.Vertices.<span class="built_in">size</span>();</span><br><span class="line">	UINT sphereVertexOffset = gridVertexOffset + (UINT)grid.Vertices.<span class="built_in">size</span>();</span><br><span class="line">	UINT cylinderVertexOffset = sphereVertexOffset + (UINT)sphere.Vertices.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">//将每个对象的起始索引缓存在串联索引缓冲区中。</span></span><br><span class="line">	UINT boxIndexOffset = <span class="number">0</span>;</span><br><span class="line">	UINT gridIndexOffset = (UINT)box.Indices32.<span class="built_in">size</span>();</span><br><span class="line">	UINT sphereIndexOffset = gridIndexOffset + (UINT)grid.Indices32.<span class="built_in">size</span>();</span><br><span class="line">	UINT cylinderIndexOffset = sphereIndexOffset + (UINT)sphere.Indices32.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	SubmeshGeometry boxSubmesh;</span><br><span class="line">	boxSubmesh.IndexCount = (UINT)box.Indices32.<span class="built_in">size</span>();</span><br><span class="line">	boxSubmesh.StartIndexLocation = boxIndexOffset;</span><br><span class="line">	boxSubmesh.BaseVertexLocation = boxVertexOffset;</span><br><span class="line"></span><br><span class="line">	SubmeshGeometry gridSubmesh;</span><br><span class="line">	gridSubmesh.IndexCount = (UINT)grid.Indices32.<span class="built_in">size</span>();</span><br><span class="line">	gridSubmesh.StartIndexLocation = gridIndexOffset;</span><br><span class="line">	gridSubmesh.BaseVertexLocation = gridVertexOffset;</span><br><span class="line"></span><br><span class="line">	SubmeshGeometry sphereSubmesh;</span><br><span class="line">	sphereSubmesh.IndexCount = (UINT)sphere.Indices32.<span class="built_in">size</span>();</span><br><span class="line">	sphereSubmesh.StartIndexLocation = sphereIndexOffset;</span><br><span class="line">	sphereSubmesh.BaseVertexLocation = sphereVertexOffset;</span><br><span class="line"></span><br><span class="line">	SubmeshGeometry cylinderSubmesh;</span><br><span class="line">	cylinderSubmesh.IndexCount = (UINT)cylinder.Indices32.<span class="built_in">size</span>();</span><br><span class="line">	cylinderSubmesh.StartIndexLocation = cylinderIndexOffset;</span><br><span class="line">	cylinderSubmesh.BaseVertexLocation = cylinderVertexOffset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//顶点数总计</span></span><br><span class="line">	<span class="keyword">auto</span> totalVertexCount =</span><br><span class="line">		box.Vertices.<span class="built_in">size</span>() +</span><br><span class="line">		grid.Vertices.<span class="built_in">size</span>() +</span><br><span class="line">		sphere.Vertices.<span class="built_in">size</span>() +</span><br><span class="line">		cylinder.Vertices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">std::vector&lt;Vertex&gt; <span class="title">vertices</span><span class="params">(totalVertexCount)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加所有顶点和颜色数据</span></span><br><span class="line">	UINT k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; box.Vertices.<span class="built_in">size</span>(); ++i, ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		vertices[k].Pos = box.Vertices[i].Position;</span><br><span class="line">		vertices[k].Color = <span class="built_in">XMFLOAT4</span>(DirectX::Colors::Blue);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; grid.Vertices.<span class="built_in">size</span>(); ++i, ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		vertices[k].Pos = grid.Vertices[i].Position;</span><br><span class="line">		vertices[k].Color = <span class="built_in">XMFLOAT4</span>(DirectX::Colors::ForestGreen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sphere.Vertices.<span class="built_in">size</span>(); ++i, ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		vertices[k].Pos = sphere.Vertices[i].Position;</span><br><span class="line">		vertices[k].Color = <span class="built_in">XMFLOAT4</span>(DirectX::Colors::Crimson);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cylinder.Vertices.<span class="built_in">size</span>(); ++i, ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		vertices[k].Pos = cylinder.Vertices[i].Position;</span><br><span class="line">		vertices[k].Color = <span class="built_in">XMFLOAT4</span>(DirectX::Colors::SteelBlue);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加所有索引</span></span><br><span class="line">	std::vector&lt;std::<span class="keyword">uint16_t</span>&gt; indices;</span><br><span class="line">	indices.<span class="built_in">insert</span>(indices.<span class="built_in">end</span>(), std::<span class="built_in">begin</span>(box.<span class="built_in">GetIndices16</span>()), std::<span class="built_in">end</span>(box.<span class="built_in">GetIndices16</span>()));</span><br><span class="line">	indices.<span class="built_in">insert</span>(indices.<span class="built_in">end</span>(), std::<span class="built_in">begin</span>(grid.<span class="built_in">GetIndices16</span>()), std::<span class="built_in">end</span>(grid.<span class="built_in">GetIndices16</span>()));</span><br><span class="line">	indices.<span class="built_in">insert</span>(indices.<span class="built_in">end</span>(), std::<span class="built_in">begin</span>(sphere.<span class="built_in">GetIndices16</span>()), std::<span class="built_in">end</span>(sphere.<span class="built_in">GetIndices16</span>()));</span><br><span class="line">	indices.<span class="built_in">insert</span>(indices.<span class="built_in">end</span>(), std::<span class="built_in">begin</span>(cylinder.<span class="built_in">GetIndices16</span>()), std::<span class="built_in">end</span>(cylinder.<span class="built_in">GetIndices16</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> UINT vbByteSize = (UINT)vertices.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line">	<span class="keyword">const</span> UINT ibByteSize = (UINT)indices.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(std::<span class="keyword">uint16_t</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> geo = std::make_unique&lt;MeshGeometry&gt;();</span><br><span class="line">	geo-&gt;Name = <span class="string">&quot;shapeGeo&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(<span class="built_in">D3DCreateBlob</span>(vbByteSize, &amp;geo-&gt;VertexBufferCPU));</span><br><span class="line">	<span class="built_in">CopyMemory</span>(geo-&gt;VertexBufferCPU-&gt;<span class="built_in">GetBufferPointer</span>(), vertices.<span class="built_in">data</span>(), vbByteSize);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(<span class="built_in">D3DCreateBlob</span>(ibByteSize, &amp;geo-&gt;IndexBufferCPU));</span><br><span class="line">	<span class="built_in">CopyMemory</span>(geo-&gt;IndexBufferCPU-&gt;<span class="built_in">GetBufferPointer</span>(), indices.<span class="built_in">data</span>(), ibByteSize);</span><br><span class="line"></span><br><span class="line">	geo-&gt;VertexBufferGPU = d3dUtil::<span class="built_in">CreateDefaultBuffer</span>(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">		mCommandList.<span class="built_in">Get</span>(), vertices.<span class="built_in">data</span>(), vbByteSize, geo-&gt;VertexBufferUploader);</span><br><span class="line"></span><br><span class="line">	geo-&gt;IndexBufferGPU = d3dUtil::<span class="built_in">CreateDefaultBuffer</span>(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">		mCommandList.<span class="built_in">Get</span>(), indices.<span class="built_in">data</span>(), ibByteSize, geo-&gt;IndexBufferUploader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	geo-&gt;VertexByteStride = <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line">	geo-&gt;VertexBufferByteSize = vbByteSize;</span><br><span class="line">	geo-&gt;IndexFormat = DXGI_FORMAT_R16_UINT;</span><br><span class="line">	geo-&gt;IndexBufferByteSize = ibByteSize;</span><br><span class="line"></span><br><span class="line">	geo-&gt;DrawArgs[<span class="string">&quot;box&quot;</span>] = boxSubmesh;</span><br><span class="line">	geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>] = gridSubmesh;</span><br><span class="line">	geo-&gt;DrawArgs[<span class="string">&quot;sphere&quot;</span>] = sphereSubmesh;</span><br><span class="line">	geo-&gt;DrawArgs[<span class="string">&quot;cylinder&quot;</span>] = cylinderSubmesh;</span><br><span class="line"></span><br><span class="line">	mGeometries[geo-&gt;Name] = std::<span class="built_in">move</span>(geo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::BuildPSOs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D3D12_GRAPHICS_PIPELINE_STATE_DESC opaquePsoDesc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;opaquePsoDesc, <span class="built_in"><span class="keyword">sizeof</span></span>(D3D12_GRAPHICS_PIPELINE_STATE_DESC));</span><br><span class="line">	opaquePsoDesc.InputLayout = &#123; mInputLayout.<span class="built_in">data</span>(), (UINT)mInputLayout.<span class="built_in">size</span>() &#125;;</span><br><span class="line">	opaquePsoDesc.pRootSignature = mRootSignature.<span class="built_in">Get</span>();</span><br><span class="line">	opaquePsoDesc.VS =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;BYTE*&gt;(mShaders[<span class="string">&quot;standardVS&quot;</span>]-&gt;<span class="built_in">GetBufferPointer</span>()),</span><br><span class="line">		mShaders[<span class="string">&quot;standardVS&quot;</span>]-&gt;<span class="built_in">GetBufferSize</span>()</span><br><span class="line">	&#125;;</span><br><span class="line">	opaquePsoDesc.PS =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;BYTE*&gt;(mShaders[<span class="string">&quot;opaquePS&quot;</span>]-&gt;<span class="built_in">GetBufferPointer</span>()),</span><br><span class="line">		mShaders[<span class="string">&quot;opaquePS&quot;</span>]-&gt;<span class="built_in">GetBufferSize</span>()</span><br><span class="line">	&#125;;</span><br><span class="line">	opaquePsoDesc.RasterizerState = <span class="built_in">CD3DX12_RASTERIZER_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">	opaquePsoDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID;</span><br><span class="line">	opaquePsoDesc.BlendState = <span class="built_in">CD3DX12_BLEND_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">	opaquePsoDesc.DepthStencilState = <span class="built_in">CD3DX12_DEPTH_STENCIL_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">	opaquePsoDesc.SampleMask = UINT_MAX;</span><br><span class="line">	opaquePsoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;</span><br><span class="line">	opaquePsoDesc.NumRenderTargets = <span class="number">1</span>;</span><br><span class="line">	opaquePsoDesc.RTVFormats[<span class="number">0</span>] = mBackBufferFormat;</span><br><span class="line">	opaquePsoDesc.SampleDesc.Count = m4xMsaaState ? <span class="number">4</span> : <span class="number">1</span>;</span><br><span class="line">	opaquePsoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">	opaquePsoDesc.DSVFormat = mDepthStencilFormat;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateGraphicsPipelineState</span>(&amp;opaquePsoDesc, <span class="built_in">IID_PPV_ARGS</span>(&amp;mPSOs[<span class="string">&quot;opaque&quot;</span>])));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	D3D12_GRAPHICS_PIPELINE_STATE_DESC opaqueWireframePsoDesc = opaquePsoDesc;</span><br><span class="line">	opaqueWireframePsoDesc.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;<span class="comment">//网格显示</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateGraphicsPipelineState</span>(&amp;opaqueWireframePsoDesc, <span class="built_in">IID_PPV_ARGS</span>(&amp;mPSOs[<span class="string">&quot;opaque_wireframe&quot;</span>])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::BuildFrameResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gNumFrameResources; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		mFrameResources.<span class="built_in">push_back</span>(std::make_unique&lt;FrameResource&gt;(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">			<span class="number">1</span>, (UINT)mAllRitems.<span class="built_in">size</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::BuildRenderItems</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> boxRitem = std::make_unique&lt;RenderItem&gt;();</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;boxRitem-&gt;World, <span class="built_in">XMMatrixScaling</span>(<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>)*<span class="built_in">XMMatrixTranslation</span>(<span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	boxRitem-&gt;ObjCBIndex = <span class="number">0</span>;</span><br><span class="line">	boxRitem-&gt;Geo = mGeometries[<span class="string">&quot;shapeGeo&quot;</span>].<span class="built_in">get</span>();</span><br><span class="line">	boxRitem-&gt;PrimitiveType = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line">	boxRitem-&gt;IndexCount = boxRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;box&quot;</span>].IndexCount;</span><br><span class="line">	boxRitem-&gt;StartIndexLocation = boxRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;box&quot;</span>].StartIndexLocation;</span><br><span class="line">	boxRitem-&gt;BaseVertexLocation = boxRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;box&quot;</span>].BaseVertexLocation;</span><br><span class="line">	mAllRitems.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(boxRitem));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> gridRitem = std::make_unique&lt;RenderItem&gt;();</span><br><span class="line">	gridRitem-&gt;World = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">	gridRitem-&gt;ObjCBIndex = <span class="number">1</span>;</span><br><span class="line">	gridRitem-&gt;Geo = mGeometries[<span class="string">&quot;shapeGeo&quot;</span>].<span class="built_in">get</span>();</span><br><span class="line">	gridRitem-&gt;PrimitiveType = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line">	gridRitem-&gt;IndexCount = gridRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>].IndexCount;</span><br><span class="line">	gridRitem-&gt;StartIndexLocation = gridRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>].StartIndexLocation;</span><br><span class="line">	gridRitem-&gt;BaseVertexLocation = gridRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>].BaseVertexLocation;</span><br><span class="line">	mAllRitems.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(gridRitem));</span><br><span class="line"></span><br><span class="line">	UINT objCBIndex = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> leftCylRitem = std::make_unique&lt;RenderItem&gt;();</span><br><span class="line">		<span class="keyword">auto</span> rightCylRitem = std::make_unique&lt;RenderItem&gt;();</span><br><span class="line">		<span class="keyword">auto</span> leftSphereRitem = std::make_unique&lt;RenderItem&gt;();</span><br><span class="line">		<span class="keyword">auto</span> rightSphereRitem = std::make_unique&lt;RenderItem&gt;();</span><br><span class="line"></span><br><span class="line">		XMMATRIX leftCylWorld = <span class="built_in">XMMatrixTranslation</span>(<span class="number">-5.0f</span>, <span class="number">1.5f</span>, <span class="number">-10.0f</span> + i * <span class="number">5.0f</span>);</span><br><span class="line">		XMMATRIX rightCylWorld = <span class="built_in">XMMatrixTranslation</span>(+<span class="number">5.0f</span>, <span class="number">1.5f</span>, <span class="number">-10.0f</span> + i * <span class="number">5.0f</span>);</span><br><span class="line"></span><br><span class="line">		XMMATRIX leftSphereWorld = <span class="built_in">XMMatrixTranslation</span>(<span class="number">-5.0f</span>, <span class="number">3.5f</span>, <span class="number">-10.0f</span> + i * <span class="number">5.0f</span>);</span><br><span class="line">		XMMATRIX rightSphereWorld = <span class="built_in">XMMatrixTranslation</span>(+<span class="number">5.0f</span>, <span class="number">3.5f</span>, <span class="number">-10.0f</span> + i * <span class="number">5.0f</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">XMStoreFloat4x4</span>(&amp;leftCylRitem-&gt;World, rightCylWorld);</span><br><span class="line">		leftCylRitem-&gt;ObjCBIndex = objCBIndex++;</span><br><span class="line">		leftCylRitem-&gt;Geo = mGeometries[<span class="string">&quot;shapeGeo&quot;</span>].<span class="built_in">get</span>();</span><br><span class="line">		leftCylRitem-&gt;PrimitiveType = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line">		leftCylRitem-&gt;IndexCount = leftCylRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;cylinder&quot;</span>].IndexCount;</span><br><span class="line">		leftCylRitem-&gt;StartIndexLocation = leftCylRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;cylinder&quot;</span>].StartIndexLocation;</span><br><span class="line">		leftCylRitem-&gt;BaseVertexLocation = leftCylRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;cylinder&quot;</span>].BaseVertexLocation;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">XMStoreFloat4x4</span>(&amp;rightCylRitem-&gt;World, leftCylWorld);</span><br><span class="line">		rightCylRitem-&gt;ObjCBIndex = objCBIndex++;</span><br><span class="line">		rightCylRitem-&gt;Geo = mGeometries[<span class="string">&quot;shapeGeo&quot;</span>].<span class="built_in">get</span>();</span><br><span class="line">		rightCylRitem-&gt;PrimitiveType = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line">		rightCylRitem-&gt;IndexCount = rightCylRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;cylinder&quot;</span>].IndexCount;</span><br><span class="line">		rightCylRitem-&gt;StartIndexLocation = rightCylRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;cylinder&quot;</span>].StartIndexLocation;</span><br><span class="line">		rightCylRitem-&gt;BaseVertexLocation = rightCylRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;cylinder&quot;</span>].BaseVertexLocation;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">XMStoreFloat4x4</span>(&amp;leftSphereRitem-&gt;World, leftSphereWorld);</span><br><span class="line">		leftSphereRitem-&gt;ObjCBIndex = objCBIndex++;</span><br><span class="line">		leftSphereRitem-&gt;Geo = mGeometries[<span class="string">&quot;shapeGeo&quot;</span>].<span class="built_in">get</span>();</span><br><span class="line">		leftSphereRitem-&gt;PrimitiveType = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line">		leftSphereRitem-&gt;IndexCount = leftSphereRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;sphere&quot;</span>].IndexCount;</span><br><span class="line">		leftSphereRitem-&gt;StartIndexLocation = leftSphereRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;sphere&quot;</span>].StartIndexLocation;</span><br><span class="line">		leftSphereRitem-&gt;BaseVertexLocation = leftSphereRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;sphere&quot;</span>].BaseVertexLocation;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">XMStoreFloat4x4</span>(&amp;rightSphereRitem-&gt;World, rightSphereWorld);</span><br><span class="line">		rightSphereRitem-&gt;ObjCBIndex = objCBIndex++;</span><br><span class="line">		rightSphereRitem-&gt;Geo = mGeometries[<span class="string">&quot;shapeGeo&quot;</span>].<span class="built_in">get</span>();</span><br><span class="line">		rightSphereRitem-&gt;PrimitiveType = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line">		rightSphereRitem-&gt;IndexCount = rightSphereRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;sphere&quot;</span>].IndexCount;</span><br><span class="line">		rightSphereRitem-&gt;StartIndexLocation = rightSphereRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;sphere&quot;</span>].StartIndexLocation;</span><br><span class="line">		rightSphereRitem-&gt;BaseVertexLocation = rightSphereRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;sphere&quot;</span>].BaseVertexLocation;</span><br><span class="line"></span><br><span class="line">		mAllRitems.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(leftCylRitem));</span><br><span class="line">		mAllRitems.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(rightCylRitem));</span><br><span class="line">		mAllRitems.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(leftSphereRitem));</span><br><span class="line">		mAllRitems.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(rightSphereRitem));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All the render items are opaque.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : mAllRitems)</span><br><span class="line">		mOpaqueRitems.<span class="built_in">push_back</span>(e.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该步骤中，最复杂的一个部分便是为了绘制物体而根据偏移量找到它在描述符堆中对应的CBV了：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShapesApp::DrawRenderItems</span><span class="params">(ID3D12GraphicsCommandList* cmdList, <span class="keyword">const</span> std::vector&lt;RenderItem*&gt;&amp; ritems)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT objCBByteSize = d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ObjectConstants));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> objectCB = mCurrFrameResource-&gt;ObjectCB-&gt;<span class="built_in">Resource</span>();</span><br><span class="line">	<span class="comment">//遍历RenderItem</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ritems.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> ri = ritems[i];</span><br><span class="line"></span><br><span class="line">		cmdList-&gt;<span class="built_in">IASetVertexBuffers</span>(<span class="number">0</span>, <span class="number">1</span>, &amp;ri-&gt;Geo-&gt;<span class="built_in">VertexBufferView</span>());</span><br><span class="line">		cmdList-&gt;<span class="built_in">IASetIndexBuffer</span>(&amp;ri-&gt;Geo-&gt;<span class="built_in">IndexBufferView</span>());</span><br><span class="line">		cmdList-&gt;<span class="built_in">IASetPrimitiveTopology</span>(ri-&gt;PrimitiveType);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 此对象和此帧资源的描述符堆中的CBV偏移。</span></span><br><span class="line">		UINT cbvIndex = mCurrFrameResourceIndex * (UINT)mOpaqueRitems.<span class="built_in">size</span>() + ri-&gt;ObjCBIndex;</span><br><span class="line">		<span class="keyword">auto</span> cbvHandle = <span class="built_in">CD3DX12_GPU_DESCRIPTOR_HANDLE</span>(mCbvHeap-&gt;<span class="built_in">GetGPUDescriptorHandleForHeapStart</span>());</span><br><span class="line">		cbvHandle.<span class="built_in">Offset</span>(cbvIndex, mCbvSrvUavDescriptorSize);</span><br><span class="line"></span><br><span class="line">		cmdList-&gt;<span class="built_in">SetGraphicsRootDescriptorTable</span>(<span class="number">0</span>, cbvHandle);</span><br><span class="line"></span><br><span class="line">		cmdList-&gt;<span class="built_in">DrawIndexedInstanced</span>(ri-&gt;IndexCount, <span class="number">1</span>, ri-&gt;StartIndexLocation, ri-&gt;BaseVertexLocation, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ <span class="keyword">int</span> nShowCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG) | defined(_DEBUG)</span></span><br><span class="line">	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">ShapesApp <span class="title">theApp</span><span class="params">(hInstance)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (!theApp.<span class="built_in">Initialize</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> theApp.<span class="built_in">Run</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (DxException&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBox</span>(<span class="literal">nullptr</span>, e.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>(), <span class="string">L&quot;HR Failed&quot;</span>, MB_OK);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="根签名"><a href="#根签名" class="headerlink" title="根签名"></a>根签名</h3><h5 id="根参数"><a href="#根参数" class="headerlink" title="根参数"></a>根参数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_ROOT_PARAMETER</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    D3D12_ROOT_PARAMETER_TYPE ParameterType;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">        D3D12_ROOT_DESCRIPTOR_TABLE DescriptorTable;<span class="comment">//指定类型,如描述符表,根常量,CBV,SRV,UAV</span></span><br><span class="line">        D3D12_ROOT_CONSTANTS Constants;</span><br><span class="line">        D3D12_ROOT_DESCRIPTOR Descriptor;</span><br><span class="line">        &#125; 	;</span><br><span class="line">    D3D12_SHADER_VISIBILITY ShaderVisibility;<span class="comment">//指定着色器可见性</span></span><br><span class="line">    &#125; 	D3D12_ROOT_PARAMETER;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">D3D12_ROOT_PARAMETER_TYPE</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE	= <span class="number">0</span>,</span><br><span class="line">        D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS	= ( D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE + <span class="number">1</span> ) ,</span><br><span class="line">        D3D12_ROOT_PARAMETER_TYPE_CBV	= ( D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS + <span class="number">1</span> ) ,</span><br><span class="line">        D3D12_ROOT_PARAMETER_TYPE_SRV	= ( D3D12_ROOT_PARAMETER_TYPE_CBV + <span class="number">1</span> ) ,</span><br><span class="line">        D3D12_ROOT_PARAMETER_TYPE_UAV	= ( D3D12_ROOT_PARAMETER_TYPE_SRV + <span class="number">1</span> ) </span><br><span class="line">    &#125; 	D3D12_ROOT_PARAMETER_TYPE;</span><br></pre></td></tr></table></figure>

<ol>
<li>描述符表:引用的是描述符堆种的一块连续范围,用于确定要绑定的资源.每个描述符表占用1DWORD</li>
<li>跟描述符:通过直接设置跟描述符即可指示要绑定的资源,而且无需将它存于描述符中,但是只有常量缓冲区<code>CBV</code>,以及缓冲区的<code>SRV/UAV</code>才可以根据描述符的身份进行绑定.而纹理<code>SRV</code>不可以.每个描述符占用2DWORD</li>
<li>根常量:借助根常量直接绑定一系列的32位的常量值.每个常量32位,占用1个DWORD</li>
</ol>
<h5 id="描述符表"><a href="#描述符表" class="headerlink" title="描述符表"></a>描述符表</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_DESCRIPTOR_RANGE</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    D3D12_DESCRIPTOR_RANGE_TYPE RangeType;<span class="comment">//类型,如...SRV,...CBV</span></span><br><span class="line">    UINT NumDescriptors;<span class="comment">//描述符的数量</span></span><br><span class="line">    UINT BaseShaderRegister;<span class="comment">//绑定的寄存器槽</span></span><br><span class="line">    UINT RegisterSpace;<span class="comment">//空间,默认=0</span></span><br><span class="line">    UINT OffsetInDescriptorsFromTableStart;<span class="comment">//此描述符距离表其实地址的偏移量</span></span><br><span class="line">    &#125; 	</span><br></pre></td></tr></table></figure>

<p><code>CD3D12_DESCRIPTOR_RANGE</code>是封装了一些便捷方法,通过<code>Init</code>方法初始化</p>
<p>如果<code>NumDescriptors</code>设置为3,<code>BaseShaderRegister</code>设置为1,类型为CBV,那么对应的HLSL就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cbuffer cbA : <span class="built_in"><span class="keyword">register</span></span>(b1)&#123;&#125;;<span class="comment">//从1开始</span></span><br><span class="line">cbuffer cbB : <span class="built_in"><span class="keyword">register</span></span>(b2)&#123;&#125;;</span><br><span class="line">cbuffer cbC : <span class="built_in"><span class="keyword">register</span></span>(b3)&#123;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CD3DX12_DESCRIPTOR_RANGE descRange[<span class="number">3</span>];</span><br><span class="line">descRange[<span class="number">0</span>].<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">descRange[<span class="number">1</span>].<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span><span class="comment">/*起始偏移量*/</span>);</span><br><span class="line">descRange[<span class="number">2</span>].<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span><span class="comment">/*起始偏移量*/</span>);</span><br><span class="line"></span><br><span class="line">slotRootParameter[<span class="number">0</span>].<span class="built_in">InitAsDescriptorTable</span>(<span class="number">3</span>, descRange, D3D12_SHADER_VISIBILITY_ALL);</span><br></pre></td></tr></table></figure>



<h5 id="根描述符"><a href="#根描述符" class="headerlink" title="根描述符"></a>根描述符</h5><p>填写<code>D3D12_ROOT_PARAMETER</code>中的<code>Descriptor</code>,可以定义为<code>根描述符</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_ROOT_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    UINT ShaderRegister;</span><br><span class="line">    UINT RegisterSpace;</span><br><span class="line">    &#125; 	D3D12_ROOT_DESCRIPTOR;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>ShaderRegister:如果设置为2,类型为CBV,那么对应的常量缓冲区是<code>register(b2)</code></li>
<li>RegisterSpace:空间</li>
</ol>
<blockquote>
<p>与描述符表需要在描述符堆中设置对应的描述符句柄不同,根描述符只需要直接绑定资源的虚拟地址就可以</p>
</blockquote>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UINT objCBByteSize = d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ObjectConstants));</span><br><span class="line">D3D12_GPU_VIRTUAL_ADDRESS objCBAddress = objectCB-&gt;<span class="built_in">GetGPUVirtualAddress</span>();</span><br><span class="line">objCBAddress += ri-&gt;ObjCBIndex*objCBByteSize;</span><br><span class="line">cmdList-&gt;<span class="built_in">SetGraphicsRootConstantBufferView</span>(<span class="number">0</span>, objCBAddress);</span><br></pre></td></tr></table></figure>



<h5 id="根常量"><a href="#根常量" class="headerlink" title="根常量"></a>根常量</h5> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_ROOT_CONSTANTS</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    UINT ShaderRegister;</span><br><span class="line">    UINT RegisterSpace;</span><br><span class="line">    UINT Num32BitValues;<span class="comment">//根常量所需的32位常量的个数</span></span><br><span class="line">    &#125; 	D3D12_ROOT_CONSTANTS;</span><br></pre></td></tr></table></figure>

<ul>
<li> 示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CD3DX12_ROOT_PARAMETER slotRootParameter[<span class="number">1</span>];</span><br><span class="line">slotRootParameter[<span class="number">0</span>].<span class="built_in">InitAsConstants</span>(<span class="number">12</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function">CD3DX12_ROOT_SIGNATURE_DESC <span class="title">rootSigDesc</span><span class="params">(<span class="number">1</span>, slotRootParameter, <span class="number">0</span>, <span class="literal">nullptr</span>, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</span></span>;</span><br><span class="line"><span class="comment">//应用程序部分</span></span><br><span class="line"><span class="keyword">auto</span> weights = <span class="built_in">CalcGaussWeights</span>(<span class="number">2.5f</span>);</span><br><span class="line"><span class="keyword">int</span> blurRadius = (<span class="keyword">int</span>)weights.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">cmdList-&gt;<span class="built_in">SetGraphicsRoot32BitConstant</span>(<span class="number">0</span>,<span class="number">1</span>,&amp;blurRadius,<span class="number">0</span>);</span><br><span class="line">cmdList-&gt;<span class="built_in">SetGraphicsRoot32BitConstant</span>(<span class="number">0</span>,(UINT)weights.<span class="built_in">size</span>(),weights.<span class="built_in">data</span>(),<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>HLSL代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cbuffer cbSetting : <span class="built_in"><span class="keyword">register</span></span>(b0)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> gBlurRadius;</span><br><span class="line">    <span class="comment">//11种模糊值</span></span><br><span class="line">    <span class="keyword">float</span> w0;</span><br><span class="line">    <span class="keyword">float</span> w1;</span><br><span class="line">    <span class="keyword">float</span> w2;</span><br><span class="line">    <span class="keyword">float</span> w3;</span><br><span class="line">    <span class="keyword">float</span> w4;</span><br><span class="line">    <span class="keyword">float</span> w5;</span><br><span class="line">    <span class="keyword">float</span> w6;</span><br><span class="line">    <span class="keyword">float</span> w7;</span><br><span class="line">    <span class="keyword">float</span> w8;</span><br><span class="line">    <span class="keyword">float</span> w9;</span><br><span class="line">    <span class="keyword">float</span> w10;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与根描述符一i杨,根常量无需涉及描述符堆</p>
</blockquote>
<h5 id="根签名复杂示例"><a href="#根签名复杂示例" class="headerlink" title="根签名复杂示例"></a>根签名复杂示例</h5><ul>
<li>着色器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Texture2D gDiffuseMap : <span class="built_in"><span class="keyword">register</span></span>(t0);</span><br><span class="line"></span><br><span class="line">cbuffer cbPerObject :  <span class="built_in"><span class="keyword">register</span></span>(b0)</span><br><span class="line">&#123;</span><br><span class="line">    float4x4 gWorld;</span><br><span class="line">    float4x4 gTexTransform;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cbuffer cbPass : <span class="built_in"><span class="keyword">register</span></span>(b1)</span><br><span class="line">&#123;</span><br><span class="line">  float4x4 gView;</span><br><span class="line">  float4x4 gInvView;</span><br><span class="line">    float4x4 gProj;</span><br><span class="line">    float4x4 gInvProj;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cbuffer cbMaterial : <span class="built_in"><span class="keyword">register</span></span>(b2)</span><br><span class="line">&#123;</span><br><span class="line">    float4 gDiffuseAlbedo;</span><br><span class="line">    float3 gFresnelR0;</span><br><span class="line">    <span class="keyword">float</span> gRoughness;</span><br><span class="line">    float4x4 gMatTransform;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>根签名</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CD3DX12_DESCRIPTOR_RANGE texTable;</span><br><span class="line">texTable.<span class="built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_SRV,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">CD3DX12_ROOT_PARAMETER slotRootParameter[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">slotRootParameter[<span class="number">0</span>].<span class="built_in">InitAsDescriptorTable</span>(<span class="number">1</span>, texTable, D3D12_SHADER_VISIBILITY_PIXEL);</span><br><span class="line">slotRootParameter[<span class="number">1</span>].<span class="built_in">InitAsConstantBufferView</span>(<span class="number">0</span>);<span class="comment">//寄存器b0</span></span><br><span class="line">slotRootParameter[<span class="number">2</span>].<span class="built_in">InitAsConstantBufferView</span>(<span class="number">1</span>);<span class="comment">//寄存器b1</span></span><br><span class="line">slotRootParameter[<span class="number">3</span>].<span class="built_in">InitAsConstantBufferView</span>(<span class="number">2</span>);<span class="comment">//寄存器b2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">CD3DX12_ROOT_SIGNATURE_DESC <span class="title">rootSigDesc</span><span class="params">(<span class="number">2</span>, slotRootParameter, <span class="number">0</span>, <span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</span></span>;</span><br></pre></td></tr></table></figure>





<h3 id="陆地与波浪演示程序"><a href="#陆地与波浪演示程序" class="headerlink" title="陆地与波浪演示程序"></a>陆地与波浪演示程序</h3><h5 id="栅格坐标"><a href="#栅格坐标" class="headerlink" title="栅格坐标"></a>栅格坐标</h5><blockquote>
<p>构建一个<code>m*n</code>个顶点组成的栅格，意味着具有<code>(m-1)*(n-1)</code>个四边形，即2倍的三角形</p>
<p>如果宽度为<code>w</code>,深度为<code>d</code>，那么x和y轴方向上的间距分别为<code>dx=w/(n-1)</code>和<code>dz=d/(m-1)</code></p>
<p>那么第<code>i</code>行，第<code>j</code>列的最坐标为<code>Vij=[-0.5w+j*dx, 0.0, 0.5d-i*dz]</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uint32 vertexCount = m*n;</span><br><span class="line">uint32 faceCount   = (m<span class="number">-1</span>)*(n<span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> halfWidth = <span class="number">0.5f</span>*width;</span><br><span class="line"><span class="keyword">float</span> halfDepth = <span class="number">0.5f</span>*depth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> dx = width / (n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">float</span> dz = depth / (m<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> du = <span class="number">1.0f</span> / (n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">float</span> dv = <span class="number">1.0f</span> / (m<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">meshData.Vertices.<span class="built_in">resize</span>(vertexCount);</span><br><span class="line"><span class="keyword">for</span>(uint32 i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">float</span> z = halfDepth - i*dz;</span><br><span class="line">	<span class="keyword">for</span>(uint32 j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">float</span> x = -halfWidth + j*dx;</span><br><span class="line"></span><br><span class="line">		meshData.Vertices[i*n+j].Position = <span class="built_in">XMFLOAT3</span>(x, <span class="number">0.0f</span>, z);</span><br><span class="line">		meshData.Vertices[i*n+j].Normal   = <span class="built_in">XMFLOAT3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">		meshData.Vertices[i*n+j].TangentU = <span class="built_in">XMFLOAT3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">		meshData.Vertices[i*n+j].TexC.x = j*du;</span><br><span class="line">		meshData.Vertices[i*n+j].TexC.y = i*dv;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="栅格索引"><a href="#栅格索引" class="headerlink" title="栅格索引"></a>栅格索引</h5><p>三角形ABC的索引<code>(i*n+j, i*n+j+1, (i+1)*n+j)</code></p>
<p>三角形CBD的索引<code>((i+1)*n+j, i*n+j+1, (i+1)*n+j+1)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">meshData.Indices32.<span class="built_in">resize</span>(faceCount*<span class="number">3</span>); <span class="comment">// 3 indices per face</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	uint32 k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(uint32 i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(uint32 j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			meshData.Indices32[k]   = i*n+j;</span><br><span class="line">			meshData.Indices32[k+<span class="number">1</span>] = i*n+j+<span class="number">1</span>;</span><br><span class="line">			meshData.Indices32[k+<span class="number">2</span>] = (i+<span class="number">1</span>)*n+j;</span><br><span class="line"></span><br><span class="line">			meshData.Indices32[k+<span class="number">3</span>] = (i+<span class="number">1</span>)*n+j;</span><br><span class="line">			meshData.Indices32[k+<span class="number">4</span>] = i*n+j+<span class="number">1</span>;</span><br><span class="line">			meshData.Indices32[k+<span class="number">5</span>] = (i+<span class="number">1</span>)*n+j+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			k += <span class="number">6</span>; <span class="comment">// next quad</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top/img/other/image-20200713060500724.png" alt="image-20200713060500724"></p>
<h5 id="构建山体"><a href="#构建山体" class="headerlink" title="构建山体"></a>构建山体</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::BuildWavesGeometryBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::vector&lt;std::<span class="keyword">uint16_t</span>&gt; <span class="title">indices</span><span class="params">(<span class="number">3</span> * mWaves-&gt;TriangleCount())</span></span>; <span class="comment">// 3 indices per face</span></span><br><span class="line">	<span class="built_in">assert</span>(mWaves-&gt;<span class="built_in">VertexCount</span>() &lt; <span class="number">0x0000ffff</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate over each quad.</span></span><br><span class="line">	<span class="keyword">int</span> m = mWaves-&gt;<span class="built_in">RowCount</span>();</span><br><span class="line">	<span class="keyword">int</span> n = mWaves-&gt;<span class="built_in">ColumnCount</span>();</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			indices[k] = i*n + j;</span><br><span class="line">			indices[k + <span class="number">1</span>] = i*n + j + <span class="number">1</span>;</span><br><span class="line">			indices[k + <span class="number">2</span>] = (i + <span class="number">1</span>)*n + j;</span><br><span class="line"></span><br><span class="line">			indices[k + <span class="number">3</span>] = (i + <span class="number">1</span>)*n + j;</span><br><span class="line">			indices[k + <span class="number">4</span>] = i*n + j + <span class="number">1</span>;</span><br><span class="line">			indices[k + <span class="number">5</span>] = (i + <span class="number">1</span>)*n + j + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			k += <span class="number">6</span>; <span class="comment">// next quad</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UINT vbByteSize = mWaves-&gt;<span class="built_in">VertexCount</span>()*<span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line">	UINT ibByteSize = (UINT)indices.<span class="built_in">size</span>()*<span class="built_in"><span class="keyword">sizeof</span></span>(std::<span class="keyword">uint16_t</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> geo = std::make_unique&lt;MeshGeometry&gt;();</span><br><span class="line">	geo-&gt;Name = <span class="string">&quot;waterGeo&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set dynamically.</span></span><br><span class="line">	geo-&gt;VertexBufferCPU = <span class="literal">nullptr</span>;</span><br><span class="line">	geo-&gt;VertexBufferGPU = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(<span class="built_in">D3DCreateBlob</span>(ibByteSize, &amp;geo-&gt;IndexBufferCPU));</span><br><span class="line">	<span class="built_in">CopyMemory</span>(geo-&gt;IndexBufferCPU-&gt;<span class="built_in">GetBufferPointer</span>(), indices.<span class="built_in">data</span>(), ibByteSize);</span><br><span class="line"></span><br><span class="line">	geo-&gt;IndexBufferGPU = d3dUtil::<span class="built_in">CreateDefaultBuffer</span>(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">		mCommandList.<span class="built_in">Get</span>(), indices.<span class="built_in">data</span>(), ibByteSize, geo-&gt;IndexBufferUploader);</span><br><span class="line"></span><br><span class="line">	geo-&gt;VertexByteStride = <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line">	geo-&gt;VertexBufferByteSize = vbByteSize;</span><br><span class="line">	geo-&gt;IndexFormat = DXGI_FORMAT_R16_UINT;</span><br><span class="line">	geo-&gt;IndexBufferByteSize = ibByteSize;</span><br><span class="line"></span><br><span class="line">	SubmeshGeometry submesh;</span><br><span class="line">	submesh.IndexCount = (UINT)indices.<span class="built_in">size</span>();</span><br><span class="line">	submesh.StartIndexLocation = <span class="number">0</span>;</span><br><span class="line">	submesh.BaseVertexLocation = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>] = submesh;</span><br><span class="line"></span><br><span class="line">	mGeometries[<span class="string">&quot;waterGeo&quot;</span>] = std::<span class="built_in">move</span>(geo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="动态顶点缓冲区"><a href="#动态顶点缓冲区" class="headerlink" title="动态顶点缓冲区"></a>动态顶点缓冲区</h5><p>动态顶点缓冲区即有可以频繁修改其中顶点数据的资源</p>
<p>如我们可以得到随着时间流走根性三角形的顶点高度，将此数据创建为动态顶点缓冲区</p>
<p>另外比如执行复杂的物理模拟和碰撞检测的粒子系统也需要用到</p>
<h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><ul>
<li>waves</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WAVES_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WAVES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DirectXMath.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waves</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Waves</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">float</span> dx, <span class="keyword">float</span> dt, <span class="keyword">float</span> speed, <span class="keyword">float</span> damping);</span><br><span class="line">	<span class="built_in">Waves</span>(<span class="keyword">const</span> Waves&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">	Waves&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Waves&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">Waves</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">RowCount</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ColumnCount</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">VertexCount</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">TriangleCount</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">Width</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">Depth</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第i个点的坐标</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> DirectX::XMFLOAT3&amp; <span class="title">Position</span><span class="params">(<span class="keyword">int</span> i)</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mCurrSolution[i]; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第i个点的法线</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> DirectX::XMFLOAT3&amp; <span class="title">Normal</span><span class="params">(<span class="keyword">int</span> i)</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mNormals[i]; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第i个点的切线</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> DirectX::XMFLOAT3&amp; <span class="title">TangentX</span><span class="params">(<span class="keyword">int</span> i)</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mTangentX[i]; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">float</span> dt)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Disturb</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">float</span> magnitude)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mNumRows = <span class="number">0</span>;<span class="comment">//行数</span></span><br><span class="line">	<span class="keyword">int</span> mNumCols = <span class="number">0</span>;<span class="comment">//列数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mVertexCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> mTriangleCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预先计算仿真常数。</span></span><br><span class="line">	<span class="keyword">float</span> mK1 = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="keyword">float</span> mK2 = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="keyword">float</span> mK3 = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> mTimeStep = <span class="number">0.0f</span>;<span class="comment">//时间步长</span></span><br><span class="line">	<span class="keyword">float</span> mSpatialStep = <span class="number">0.0f</span>;<span class="comment">//空间步长</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	std::vector&lt;DirectX::XMFLOAT3&gt; mPrevSolution;<span class="comment">//上一个解决方案</span></span><br><span class="line">	std::vector&lt;DirectX::XMFLOAT3&gt; mCurrSolution;<span class="comment">//当前解决方案</span></span><br><span class="line">	std::vector&lt;DirectX::XMFLOAT3&gt; mNormals;</span><br><span class="line">	std::vector&lt;DirectX::XMFLOAT3&gt; mTangentX;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Waves.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DirectXMath.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ppl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Waves::<span class="built_in">Waves</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">float</span> dx, <span class="keyword">float</span> dt, <span class="keyword">float</span> speed, <span class="keyword">float</span> damping)</span><br><span class="line">&#123;</span><br><span class="line">	mNumRows = m;</span><br><span class="line">	mNumCols = n;</span><br><span class="line"></span><br><span class="line">	mVertexCount = m * n;</span><br><span class="line">	mTriangleCount = (m - <span class="number">1</span>)*(n - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	mTimeStep = dt;</span><br><span class="line">	mSpatialStep = dx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> d = damping * dt + <span class="number">2.0f</span>;</span><br><span class="line">	<span class="keyword">float</span> e = (speed*speed)*(dt*dt) / (dx*dx);</span><br><span class="line"></span><br><span class="line">	mK1 = (damping*dt - <span class="number">2.0f</span>) / d;</span><br><span class="line">	mK2 = (<span class="number">4.0f</span> - <span class="number">8.0f</span>*e) / d;</span><br><span class="line">	mK3 = (<span class="number">2.0f</span>*e) / d;</span><br><span class="line"></span><br><span class="line">	mPrevSolution.<span class="built_in">resize</span>(m*n);</span><br><span class="line">	mCurrSolution.<span class="built_in">resize</span>(m*n);</span><br><span class="line">	mNormals.<span class="built_in">resize</span>(m*n);</span><br><span class="line">	mTangentX.<span class="built_in">resize</span>(m*n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> halfWidth = (n - <span class="number">1</span>)*dx*<span class="number">0.5f</span>;</span><br><span class="line">	<span class="keyword">float</span> halfDepth = (m - <span class="number">1</span>)*dx*<span class="number">0.5f</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">float</span> z = halfDepth - i * dx;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> x = -halfWidth + j * dx;</span><br><span class="line"></span><br><span class="line">			mPrevSolution[i*n + j] = <span class="built_in">XMFLOAT3</span>(x, <span class="number">0.0f</span>, z);</span><br><span class="line">			mCurrSolution[i*n + j] = <span class="built_in">XMFLOAT3</span>(x, <span class="number">0.0f</span>, z);</span><br><span class="line">			mNormals[i*n + j] = <span class="built_in">XMFLOAT3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">			mTangentX[i*n + j] = <span class="built_in">XMFLOAT3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Waves::~<span class="built_in">Waves</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Waves::RowCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mNumRows;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Waves::ColumnCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mNumCols;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Waves::VertexCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mVertexCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Waves::TriangleCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mTriangleCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Waves::Width</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mNumRows*mSpatialStep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Waves::Depth</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mNumCols*mSpatialStep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Waves::Update</span><span class="params">(<span class="keyword">float</span> dt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">float</span> t =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t&gt;=mTimeStep)</span><br><span class="line">	&#123;</span><br><span class="line">		concurrency::<span class="built_in">parallel_for</span>(<span class="number">1</span>, mNumRows - <span class="number">1</span>, [<span class="keyword">this</span>](<span class="keyword">int</span> i)</span><br><span class="line">		&#123;</span><br><span class="line">	<span class="comment">//此更新后，我们将丢弃旧的旧版本缓冲区，因此请使用新的更新覆盖该缓冲区。</span></span><br><span class="line">	<span class="comment">//注意我们如何就地执行此操作（读/写同一元素）</span></span><br><span class="line">	<span class="comment">//因为我们不再需要prev_ij，并且赋值最后发生。</span></span><br><span class="line">	<span class="comment">//注意j索引x和i索引z：h（x_j，z_i，t_k）</span></span><br><span class="line">	<span class="comment">//此外，我们的+ z轴会“向下”； 这只是为了与行索引下降保持一致。</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; mNumCols - <span class="number">1</span>; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				mPrevSolution[i*mNumCols + j].y =</span><br><span class="line">					mK1 * mPrevSolution[i*mNumCols + j].y +</span><br><span class="line">					mK2 * mCurrSolution[i*mNumCols + j].y +</span><br><span class="line">					mK3 * (mCurrSolution[(i + <span class="number">1</span>)*mNumCols + j].y +</span><br><span class="line">						mCurrSolution[(i - <span class="number">1</span>)*mNumCols + j].y +</span><br><span class="line">						mCurrSolution[i*mNumCols + j + <span class="number">1</span>].y +</span><br><span class="line">						mCurrSolution[i*mNumCols + j - <span class="number">1</span>].y);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">//我们只是用新数据覆盖了先前的缓冲区，所以此数据需要成为当前的解决方案和旧的</span></span><br><span class="line">		<span class="comment">//当前解决方案成为新的先前解决方案。</span></span><br><span class="line">		std::<span class="built_in">swap</span>(mPrevSolution, mCurrSolution);</span><br><span class="line"></span><br><span class="line">		t = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//计算法线</span></span><br><span class="line">		concurrency::<span class="built_in">parallel_for</span>(<span class="number">1</span>, mNumRows - <span class="number">1</span>, [<span class="keyword">this</span>](<span class="keyword">int</span> i)</span><br><span class="line">			<span class="comment">//for(int i = 1; i &lt; mNumRows - 1; ++i)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; mNumCols - <span class="number">1</span>; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">float</span> l = mCurrSolution[i*mNumCols + j - <span class="number">1</span>].y;</span><br><span class="line">				<span class="keyword">float</span> r = mCurrSolution[i*mNumCols + j + <span class="number">1</span>].y;</span><br><span class="line">				<span class="keyword">float</span> t = mCurrSolution[(i - <span class="number">1</span>)*mNumCols + j].y;</span><br><span class="line">				<span class="keyword">float</span> b = mCurrSolution[(i + <span class="number">1</span>)*mNumCols + j].y;</span><br><span class="line">				mNormals[i*mNumCols + j].x = -r + l;</span><br><span class="line">				mNormals[i*mNumCols + j].y = <span class="number">2.0f</span>*mSpatialStep;</span><br><span class="line">				mNormals[i*mNumCols + j].z = b - t;</span><br><span class="line"></span><br><span class="line">				XMVECTOR n = <span class="built_in">XMVector3Normalize</span>(<span class="built_in">XMLoadFloat3</span>(&amp;mNormals[i*mNumCols + j]));</span><br><span class="line">				<span class="built_in">XMStoreFloat3</span>(&amp;mNormals[i*mNumCols + j], n);</span><br><span class="line"></span><br><span class="line">				mTangentX[i*mNumCols + j] = <span class="built_in">XMFLOAT3</span>(<span class="number">2.0f</span>*mSpatialStep, r - l, <span class="number">0.0f</span>);</span><br><span class="line">				XMVECTOR T = <span class="built_in">XMVector3Normalize</span>(<span class="built_in">XMLoadFloat3</span>(&amp;mTangentX[i*mNumCols + j]));</span><br><span class="line">				<span class="built_in">XMStoreFloat3</span>(&amp;mTangentX[i*mNumCols + j], T);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Waves::Disturb</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">float</span> magnitude)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(i &gt; <span class="number">1</span> &amp;&amp; i &lt; mNumRows - <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">assert</span>(j &gt; <span class="number">1</span> &amp;&amp; j &lt; mNumCols - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> halfMag = <span class="number">0.5f</span>*magnitude;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绕顶第i个顶点高度及其相邻点。</span></span><br><span class="line">	mCurrSolution[i*mNumCols + j].y += magnitude;</span><br><span class="line">	mCurrSolution[i*mNumCols + j + <span class="number">1</span>].y += halfMag;</span><br><span class="line">	mCurrSolution[i*mNumCols + j - <span class="number">1</span>].y += halfMag;</span><br><span class="line">	mCurrSolution[(i + <span class="number">1</span>)*mNumCols + j].y += halfMag;</span><br><span class="line">	mCurrSolution[(i - <span class="number">1</span>)*mNumCols + j].y += halfMag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>LandAndWaves</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//***************************************************************************************</span></span><br><span class="line"><span class="comment">// LandAndWavesApp.cpp by Frank Luna (C) 2015 All Rights Reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hold down &#x27;1&#x27; key to view scene in wireframe mode.</span></span><br><span class="line"><span class="comment">//***************************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../Common/d3dApp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../Common/MathHelper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../Common/UploadBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../Common/GeometryGenerator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;FrameResource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Waves.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Microsoft::WRL::ComPtr;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX::PackedVector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> gNumFrameResources = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lightweight structure stores parameters to draw a shape.  This will</span></span><br><span class="line"><span class="comment">// vary from app-to-app.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RenderItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">RenderItem</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// World matrix of the shape that describes the object&#x27;s local space</span></span><br><span class="line">	<span class="comment">// relative to the world space, which defines the position, orientation,</span></span><br><span class="line">	<span class="comment">// and scale of the object in the world.</span></span><br><span class="line">	XMFLOAT4X4 World = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Dirty flag indicating the object data has changed and we need to update the constant buffer.</span></span><br><span class="line">	<span class="comment">// Because we have an object cbuffer for each FrameResource, we have to apply the</span></span><br><span class="line">	<span class="comment">// update to each FrameResource.  Thus, when we modify obect data we should set </span></span><br><span class="line">	<span class="comment">// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.</span></span><br><span class="line">	<span class="keyword">int</span> NumFramesDirty = gNumFrameResources;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Index into GPU constant buffer corresponding to the ObjectCB for this render item.</span></span><br><span class="line">	UINT ObjCBIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	MeshGeometry* Geo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Primitive topology.</span></span><br><span class="line">	D3D12_PRIMITIVE_TOPOLOGY PrimitiveType = D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DrawIndexedInstanced parameters.</span></span><br><span class="line">	UINT IndexCount = <span class="number">0</span>;</span><br><span class="line">	UINT StartIndexLocation = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> BaseVertexLocation = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">RenderLayer</span> :</span> <span class="keyword">int</span></span><br><span class="line">&#123;</span><br><span class="line">	Opaque = <span class="number">0</span>,</span><br><span class="line">	Count</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandAndWavesApp</span> :</span> <span class="keyword">public</span> D3DApp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LandAndWavesApp</span>(HINSTANCE hInstance);</span><br><span class="line">    <span class="built_in">LandAndWavesApp</span>(<span class="keyword">const</span> LandAndWavesApp&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    LandAndWavesApp&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> LandAndWavesApp&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">LandAndWavesApp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnResize</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span><span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseDown</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseUp</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseMove</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnKeyboardInput</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateCamera</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateObjectCBs</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateMainPassCB</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateWaves</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildRootSignature</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildShadersAndInputLayout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildLandGeometry</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildWavesGeometryBuffers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildPSOs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildFrameResources</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildRenderItems</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DrawRenderItems</span><span class="params">(ID3D12GraphicsCommandList* cmdList, <span class="keyword">const</span> std::vector&lt;RenderItem*&gt;&amp; ritems)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetHillsHeight</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> z)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">XMFLOAT3 <span class="title">GetHillsNormal</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> z)</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;FrameResource&gt;&gt; mFrameResources;</span><br><span class="line">    FrameResource* mCurrFrameResource = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> mCurrFrameResourceIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    UINT mCbvSrvDescriptorSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ComPtr&lt;ID3D12RootSignature&gt; mRootSignature = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	std::unordered_map&lt;std::string, std::unique_ptr&lt;MeshGeometry&gt;&gt; mGeometries;</span><br><span class="line">	std::unordered_map&lt;std::string, ComPtr&lt;ID3DBlob&gt;&gt; mShaders;</span><br><span class="line">	std::unordered_map&lt;std::string, ComPtr&lt;ID3D12PipelineState&gt;&gt; mPSOs;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;D3D12_INPUT_ELEMENT_DESC&gt; mInputLayout;</span><br><span class="line"></span><br><span class="line">	RenderItem* mWavesRitem = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// List of all the render items.</span></span><br><span class="line">	std::vector&lt;std::unique_ptr&lt;RenderItem&gt;&gt; mAllRitems;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Render items divided by PSO.</span></span><br><span class="line">	std::vector&lt;RenderItem*&gt; mRitemLayer[(<span class="keyword">int</span>)RenderLayer::Count];</span><br><span class="line"></span><br><span class="line">	std::unique_ptr&lt;Waves&gt; mWaves;</span><br><span class="line"></span><br><span class="line">    PassConstants mMainPassCB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> mIsWireframe = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	XMFLOAT3 mEyePos = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">	XMFLOAT4X4 mView = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">	XMFLOAT4X4 mProj = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> mTheta = <span class="number">1.5f</span>*XM_PI;</span><br><span class="line">    <span class="keyword">float</span> mPhi = XM_PIDIV2 - <span class="number">0.1f</span>;</span><br><span class="line">    <span class="keyword">float</span> mRadius = <span class="number">50.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> mSunTheta = <span class="number">1.25f</span>*XM_PI;</span><br><span class="line">	<span class="keyword">float</span> mSunPhi = XM_PIDIV4;</span><br><span class="line"></span><br><span class="line">    POINT mLastMousePos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE prevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    PSTR cmdLine, <span class="keyword">int</span> showCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Enable run-time memory check for debug builds.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG) | defined(_DEBUG)</span></span><br><span class="line">    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">LandAndWavesApp <span class="title">theApp</span><span class="params">(hInstance)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!theApp.<span class="built_in">Initialize</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> theApp.<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(DxException&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">nullptr</span>, e.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>(), <span class="string">L&quot;HR Failed&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LandAndWavesApp::<span class="built_in">LandAndWavesApp</span>(HINSTANCE hInstance)</span><br><span class="line">    : <span class="built_in">D3DApp</span>(hInstance)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LandAndWavesApp::~<span class="built_in">LandAndWavesApp</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(md3dDevice != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">FlushCommandQueue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LandAndWavesApp::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!D3DApp::<span class="built_in">Initialize</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the command list to prep for initialization commands.</span></span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Reset</span>(mDirectCmdListAlloc.<span class="built_in">Get</span>(), <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">	mWaves = std::make_unique&lt;Waves&gt;(<span class="number">128</span>, <span class="number">128</span>, <span class="number">1.0f</span>, <span class="number">0.03f</span>, <span class="number">4.0f</span>, <span class="number">0.2f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BuildRootSignature</span>();</span><br><span class="line">    <span class="built_in">BuildShadersAndInputLayout</span>();</span><br><span class="line">	<span class="built_in">BuildLandGeometry</span>();</span><br><span class="line">    <span class="built_in">BuildWavesGeometryBuffers</span>();</span><br><span class="line">    <span class="built_in">BuildRenderItems</span>();</span><br><span class="line">	<span class="built_in">BuildRenderItems</span>();</span><br><span class="line">    <span class="built_in">BuildFrameResources</span>();</span><br><span class="line">	<span class="built_in">BuildPSOs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the initialization commands.</span></span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Close</span>());</span><br><span class="line">    ID3D12CommandList* cmdsLists[] = &#123; mCommandList.<span class="built_in">Get</span>() &#125;;</span><br><span class="line">    mCommandQueue-&gt;<span class="built_in">ExecuteCommandLists</span>(_countof(cmdsLists), cmdsLists);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until initialization is complete.</span></span><br><span class="line">    <span class="built_in">FlushCommandQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::OnResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D3DApp::<span class="built_in">OnResize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The window resized, so update the aspect ratio and recompute the projection matrix.</span></span><br><span class="line">    XMMATRIX P = <span class="built_in">XMMatrixPerspectiveFovLH</span>(<span class="number">0.25f</span>*MathHelper::Pi, <span class="built_in">AspectRatio</span>(), <span class="number">1.0f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">    <span class="built_in">XMStoreFloat4x4</span>(&amp;mProj, P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::Update</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">OnKeyboardInput</span>(gt);</span><br><span class="line">	<span class="built_in">UpdateCamera</span>(gt);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cycle through the circular frame resource array.</span></span><br><span class="line">	mCurrFrameResourceIndex = (mCurrFrameResourceIndex + <span class="number">1</span>) % gNumFrameResources;</span><br><span class="line">	mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Has the GPU finished processing the commands of the current frame resource?</span></span><br><span class="line">	<span class="comment">// If not, wait until the GPU has completed commands up to this fence point.</span></span><br><span class="line">	<span class="keyword">if</span>(mCurrFrameResource-&gt;Fence != <span class="number">0</span> &amp;&amp; mFence-&gt;<span class="built_in">GetCompletedValue</span>() &lt; mCurrFrameResource-&gt;Fence)</span><br><span class="line">	&#123;</span><br><span class="line">		HANDLE eventHandle = <span class="built_in">CreateEventEx</span>(<span class="literal">nullptr</span>, <span class="literal">false</span>, <span class="literal">false</span>, EVENT_ALL_ACCESS);</span><br><span class="line">		<span class="built_in">ThrowIfFailed</span>(mFence-&gt;<span class="built_in">SetEventOnCompletion</span>(mCurrFrameResource-&gt;Fence, eventHandle));</span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(eventHandle, INFINITE);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(eventHandle);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UpdateObjectCBs</span>(gt);</span><br><span class="line">	<span class="built_in">UpdateMainPassCB</span>(gt);</span><br><span class="line">	<span class="built_in">UpdateWaves</span>(gt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::Draw</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> cmdListAlloc = mCurrFrameResource-&gt;CmdListAlloc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reuse the memory associated with command recording.</span></span><br><span class="line">	<span class="comment">// We can only reset when the associated command lists have finished execution on the GPU.</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(cmdListAlloc-&gt;<span class="built_in">Reset</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A command list can be reset after it has been added to the command queue via ExecuteCommandList.</span></span><br><span class="line">	<span class="comment">// Reusing the command list reuses memory.</span></span><br><span class="line">    <span class="keyword">if</span>(mIsWireframe)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Reset</span>(cmdListAlloc.<span class="built_in">Get</span>(), mPSOs[<span class="string">&quot;opaque_wireframe&quot;</span>].<span class="built_in">Get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Reset</span>(cmdListAlloc.<span class="built_in">Get</span>(), mPSOs[<span class="string">&quot;opaque&quot;</span>].<span class="built_in">Get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	mCommandList-&gt;<span class="built_in">RSSetViewports</span>(<span class="number">1</span>, &amp;mScreenViewport);</span><br><span class="line">	mCommandList-&gt;<span class="built_in">RSSetScissorRects</span>(<span class="number">1</span>, &amp;mScissorRect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Indicate a state transition on the resource usage.</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(<span class="built_in">CurrentBackBuffer</span>(),</span><br><span class="line">		D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear the back buffer and depth buffer.</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">ClearRenderTargetView</span>(<span class="built_in">CurrentBackBufferView</span>(), Colors::LightSteelBlue, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	mCommandList-&gt;<span class="built_in">ClearDepthStencilView</span>(<span class="built_in">DepthStencilView</span>(), D3D12_CLEAR_FLAG_DEPTH | D3D12_CLEAR_FLAG_STENCIL, <span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Specify the buffers we are going to render to.</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">OMSetRenderTargets</span>(<span class="number">1</span>, &amp;<span class="built_in">CurrentBackBufferView</span>(), <span class="literal">true</span>, &amp;<span class="built_in">DepthStencilView</span>());</span><br><span class="line"></span><br><span class="line">	mCommandList-&gt;<span class="built_in">SetGraphicsRootSignature</span>(mRootSignature.<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind per-pass constant buffer.  We only need to do this once per-pass.</span></span><br><span class="line">	<span class="keyword">auto</span> passCB = mCurrFrameResource-&gt;PassCB-&gt;<span class="built_in">Resource</span>();</span><br><span class="line">	mCommandList-&gt;<span class="built_in">SetGraphicsRootConstantBufferView</span>(<span class="number">1</span>, passCB-&gt;<span class="built_in">GetGPUVirtualAddress</span>());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DrawRenderItems</span>(mCommandList.<span class="built_in">Get</span>(), mRitemLayer[(<span class="keyword">int</span>)RenderLayer::Opaque]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Indicate a state transition on the resource usage.</span></span><br><span class="line">	mCommandList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(<span class="built_in">CurrentBackBuffer</span>(),</span><br><span class="line">		D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Done recording commands.</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mCommandList-&gt;<span class="built_in">Close</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add the command list to the queue for execution.</span></span><br><span class="line">	ID3D12CommandList* cmdsLists[] = &#123; mCommandList.<span class="built_in">Get</span>() &#125;;</span><br><span class="line">	mCommandQueue-&gt;<span class="built_in">ExecuteCommandLists</span>(_countof(cmdsLists), cmdsLists);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Swap the back and front buffers</span></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(mSwapChain-&gt;<span class="built_in">Present</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	mCurrBackBuffer = (mCurrBackBuffer + <span class="number">1</span>) % SwapChainBufferCount;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Advance the fence value to mark commands up to this fence point.</span></span><br><span class="line">	mCurrFrameResource-&gt;Fence = ++mCurrentFence;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add an instruction to the command queue to set a new fence point. </span></span><br><span class="line">    <span class="comment">// Because we are on the GPU timeline, the new fence point won&#x27;t be </span></span><br><span class="line">    <span class="comment">// set until the GPU finishes processing all the commands prior to this Signal().</span></span><br><span class="line">	mCommandQueue-&gt;<span class="built_in">Signal</span>(mFence.<span class="built_in">Get</span>(), mCurrentFence);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::OnMouseDown</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mLastMousePos.x = x;</span><br><span class="line">    mLastMousePos.y = y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetCapture</span>(mhMainWnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::OnMouseUp</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ReleaseCapture</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::OnMouseMove</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((btnState &amp; MK_LBUTTON) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Make each pixel correspond to a quarter of a degree.</span></span><br><span class="line">        <span class="keyword">float</span> dx = <span class="built_in">XMConvertToRadians</span>(<span class="number">0.25f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x - mLastMousePos.x));</span><br><span class="line">        <span class="keyword">float</span> dy = <span class="built_in">XMConvertToRadians</span>(<span class="number">0.25f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(y - mLastMousePos.y));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update angles based on input to orbit camera around box.</span></span><br><span class="line">        mTheta += dx;</span><br><span class="line">        mPhi += dy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Restrict the angle mPhi.</span></span><br><span class="line">        mPhi = MathHelper::<span class="built_in">Clamp</span>(mPhi, <span class="number">0.1f</span>, MathHelper::Pi - <span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((btnState &amp; MK_RBUTTON) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Make each pixel correspond to 0.2 unit in the scene.</span></span><br><span class="line">        <span class="keyword">float</span> dx = <span class="number">0.2f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x - mLastMousePos.x);</span><br><span class="line">        <span class="keyword">float</span> dy = <span class="number">0.2f</span>*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(y - mLastMousePos.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the camera radius based on input.</span></span><br><span class="line">        mRadius += dx - dy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Restrict the radius.</span></span><br><span class="line">        mRadius = MathHelper::<span class="built_in">Clamp</span>(mRadius, <span class="number">5.0f</span>, <span class="number">150.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastMousePos.x = x;</span><br><span class="line">    mLastMousePos.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::OnKeyboardInput</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetAsyncKeyState</span>(<span class="string">&#x27;1&#x27;</span>) &amp; <span class="number">0x8000</span>)</span><br><span class="line">        mIsWireframe = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mIsWireframe = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::UpdateCamera</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Convert Spherical to Cartesian coordinates.</span></span><br><span class="line">	mEyePos.x = mRadius*<span class="built_in">sinf</span>(mPhi)*<span class="built_in">cosf</span>(mTheta);</span><br><span class="line">	mEyePos.z = mRadius*<span class="built_in">sinf</span>(mPhi)*<span class="built_in">sinf</span>(mTheta);</span><br><span class="line">	mEyePos.y = mRadius*<span class="built_in">cosf</span>(mPhi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build the view matrix.</span></span><br><span class="line">	XMVECTOR pos = <span class="built_in">XMVectorSet</span>(mEyePos.x, mEyePos.y, mEyePos.z, <span class="number">1.0f</span>);</span><br><span class="line">	XMVECTOR target = <span class="built_in">XMVectorZero</span>();</span><br><span class="line">	XMVECTOR up = <span class="built_in">XMVectorSet</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	XMMATRIX view = <span class="built_in">XMMatrixLookAtLH</span>(pos, target, up);</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mView, view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::UpdateObjectCBs</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> currObjectCB = mCurrFrameResource-&gt;ObjectCB.<span class="built_in">get</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : mAllRitems)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Only update the cbuffer data if the constants have changed.  </span></span><br><span class="line">		<span class="comment">// This needs to be tracked per frame resource.</span></span><br><span class="line">		<span class="keyword">if</span>(e-&gt;NumFramesDirty &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			XMMATRIX world = <span class="built_in">XMLoadFloat4x4</span>(&amp;e-&gt;World);</span><br><span class="line"></span><br><span class="line">			ObjectConstants objConstants;</span><br><span class="line">			<span class="built_in">XMStoreFloat4x4</span>(&amp;objConstants.World, <span class="built_in">XMMatrixTranspose</span>(world));</span><br><span class="line"></span><br><span class="line">			currObjectCB-&gt;<span class="built_in">CopyData</span>(e-&gt;ObjCBIndex, objConstants);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Next FrameResource need to be updated too.</span></span><br><span class="line">			e-&gt;NumFramesDirty--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::UpdateMainPassCB</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XMMATRIX view = <span class="built_in">XMLoadFloat4x4</span>(&amp;mView);</span><br><span class="line">	XMMATRIX proj = <span class="built_in">XMLoadFloat4x4</span>(&amp;mProj);</span><br><span class="line"></span><br><span class="line">	XMMATRIX viewProj = <span class="built_in">XMMatrixMultiply</span>(view, proj);</span><br><span class="line">	XMMATRIX invView = <span class="built_in">XMMatrixInverse</span>(&amp;<span class="built_in">XMMatrixDeterminant</span>(view), view);</span><br><span class="line">	XMMATRIX invProj = <span class="built_in">XMMatrixInverse</span>(&amp;<span class="built_in">XMMatrixDeterminant</span>(proj), proj);</span><br><span class="line">	XMMATRIX invViewProj = <span class="built_in">XMMatrixInverse</span>(&amp;<span class="built_in">XMMatrixDeterminant</span>(viewProj), viewProj);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.View, <span class="built_in">XMMatrixTranspose</span>(view));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.InvView, <span class="built_in">XMMatrixTranspose</span>(invView));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.Proj, <span class="built_in">XMMatrixTranspose</span>(proj));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.InvProj, <span class="built_in">XMMatrixTranspose</span>(invProj));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.ViewProj, <span class="built_in">XMMatrixTranspose</span>(viewProj));</span><br><span class="line">	<span class="built_in">XMStoreFloat4x4</span>(&amp;mMainPassCB.InvViewProj, <span class="built_in">XMMatrixTranspose</span>(invViewProj));</span><br><span class="line">	mMainPassCB.EyePosW = mEyePos;</span><br><span class="line">	mMainPassCB.RenderTargetSize = <span class="built_in">XMFLOAT2</span>((<span class="keyword">float</span>)mClientWidth, (<span class="keyword">float</span>)mClientHeight);</span><br><span class="line">	mMainPassCB.InvRenderTargetSize = <span class="built_in">XMFLOAT2</span>(<span class="number">1.0f</span> / mClientWidth, <span class="number">1.0f</span> / mClientHeight);</span><br><span class="line">	mMainPassCB.NearZ = <span class="number">1.0f</span>;</span><br><span class="line">	mMainPassCB.FarZ = <span class="number">1000.0f</span>;</span><br><span class="line">	mMainPassCB.TotalTime = gt.<span class="built_in">TotalTime</span>();</span><br><span class="line">	mMainPassCB.DeltaTime = gt.<span class="built_in">DeltaTime</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> currPassCB = mCurrFrameResource-&gt;PassCB.<span class="built_in">get</span>();</span><br><span class="line">	currPassCB-&gt;<span class="built_in">CopyData</span>(<span class="number">0</span>, mMainPassCB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::UpdateWaves</span><span class="params">(<span class="keyword">const</span> GameTimer&amp; gt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Every quarter second, generate a random wave.</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">float</span> t_base = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="keyword">if</span>((mTimer.<span class="built_in">TotalTime</span>() - t_base) &gt;= <span class="number">0.25f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		t_base += <span class="number">0.25f</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i = MathHelper::<span class="built_in">Rand</span>(<span class="number">4</span>, mWaves-&gt;<span class="built_in">RowCount</span>() - <span class="number">5</span>);</span><br><span class="line">		<span class="keyword">int</span> j = MathHelper::<span class="built_in">Rand</span>(<span class="number">4</span>, mWaves-&gt;<span class="built_in">ColumnCount</span>() - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> r = MathHelper::<span class="built_in">RandF</span>(<span class="number">0.2f</span>, <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">		mWaves-&gt;<span class="built_in">Disturb</span>(i, j, r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the wave simulation.</span></span><br><span class="line">	mWaves-&gt;<span class="built_in">Update</span>(gt.<span class="built_in">DeltaTime</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the wave vertex buffer with the new solution.</span></span><br><span class="line">	<span class="keyword">auto</span> currWavesVB = mCurrFrameResource-&gt;WavesVB.<span class="built_in">get</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mWaves-&gt;<span class="built_in">VertexCount</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Vertex v;</span><br><span class="line"></span><br><span class="line">		v.Pos = mWaves-&gt;<span class="built_in">Position</span>(i);</span><br><span class="line">        v.Color = <span class="built_in">XMFLOAT4</span>(DirectX::Colors::Blue);</span><br><span class="line"></span><br><span class="line">		currWavesVB-&gt;<span class="built_in">CopyData</span>(i, v);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the dynamic VB of the wave renderitem to the current frame VB.</span></span><br><span class="line">	mWavesRitem-&gt;Geo-&gt;VertexBufferGPU = currWavesVB-&gt;<span class="built_in">Resource</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::BuildRootSignature</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Root parameter can be a table, root descriptor or root constants.</span></span><br><span class="line">    CD3DX12_ROOT_PARAMETER slotRootParameter[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create root CBV.</span></span><br><span class="line">    slotRootParameter[<span class="number">0</span>].<span class="built_in">InitAsConstantBufferView</span>(<span class="number">0</span>);</span><br><span class="line">    slotRootParameter[<span class="number">1</span>].<span class="built_in">InitAsConstantBufferView</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A root signature is an array of root parameters.</span></span><br><span class="line">	<span class="function">CD3DX12_ROOT_SIGNATURE_DESC <span class="title">rootSigDesc</span><span class="params">(<span class="number">2</span>, slotRootParameter, <span class="number">0</span>, <span class="literal">nullptr</span>, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer</span></span><br><span class="line">    ComPtr&lt;ID3DBlob&gt; serializedRootSig = <span class="literal">nullptr</span>;</span><br><span class="line">    ComPtr&lt;ID3DBlob&gt; errorBlob = <span class="literal">nullptr</span>;</span><br><span class="line">    HRESULT hr = <span class="built_in">D3D12SerializeRootSignature</span>(&amp;rootSigDesc, D3D_ROOT_SIGNATURE_VERSION_1,</span><br><span class="line">        serializedRootSig.<span class="built_in">GetAddressOf</span>(), errorBlob.<span class="built_in">GetAddressOf</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(errorBlob != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">OutputDebugStringA</span>((<span class="keyword">char</span>*)errorBlob-&gt;<span class="built_in">GetBufferPointer</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(hr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateRootSignature</span>(</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">        serializedRootSig-&gt;<span class="built_in">GetBufferPointer</span>(),</span><br><span class="line">        serializedRootSig-&gt;<span class="built_in">GetBufferSize</span>(),</span><br><span class="line">        <span class="built_in">IID_PPV_ARGS</span>(mRootSignature.<span class="built_in">GetAddressOf</span>())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::BuildShadersAndInputLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mShaders[<span class="string">&quot;standardVS&quot;</span>] = d3dUtil::<span class="built_in">CompileShader</span>(<span class="string">L&quot;Shaders\\color.hlsl&quot;</span>, <span class="literal">nullptr</span>, <span class="string">&quot;VS&quot;</span>, <span class="string">&quot;vs_5_0&quot;</span>);</span><br><span class="line">	mShaders[<span class="string">&quot;opaquePS&quot;</span>] = d3dUtil::<span class="built_in">CompileShader</span>(<span class="string">L&quot;Shaders\\color.hlsl&quot;</span>, <span class="literal">nullptr</span>, <span class="string">&quot;PS&quot;</span>, <span class="string">&quot;ps_5_0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mInputLayout =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; <span class="string">&quot;POSITION&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="number">0</span>, <span class="number">0</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;COLOR&quot;</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::BuildLandGeometry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GeometryGenerator geoGen;</span><br><span class="line">	GeometryGenerator::MeshData grid = geoGen.<span class="built_in">CreateGrid</span>(<span class="number">160.0f</span>, <span class="number">160.0f</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Extract the vertex elements we are interested and apply the height function to</span></span><br><span class="line">	<span class="comment">// each vertex.  In addition, color the vertices based on their height so we have</span></span><br><span class="line">	<span class="comment">// sandy looking beaches, grassy low hills, and snow mountain peaks.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="function">std::vector&lt;Vertex&gt; <span class="title">vertices</span><span class="params">(grid.Vertices.size())</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; grid.Vertices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; p = grid.Vertices[i].Position;</span><br><span class="line">		vertices[i].Pos = p;</span><br><span class="line">		vertices[i].Pos.y = <span class="built_in">GetHillsHeight</span>(p.x, p.z);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Color the vertex based on its height.</span></span><br><span class="line">        <span class="keyword">if</span>(vertices[i].Pos.y &lt; <span class="number">-10.0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Sandy beach color.</span></span><br><span class="line">            vertices[i].Color = <span class="built_in">XMFLOAT4</span>(<span class="number">1.0f</span>, <span class="number">0.96f</span>, <span class="number">0.62f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vertices[i].Pos.y &lt; <span class="number">5.0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Light yellow-green.</span></span><br><span class="line">            vertices[i].Color = <span class="built_in">XMFLOAT4</span>(<span class="number">0.48f</span>, <span class="number">0.77f</span>, <span class="number">0.46f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vertices[i].Pos.y &lt; <span class="number">12.0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Dark yellow-green.</span></span><br><span class="line">            vertices[i].Color = <span class="built_in">XMFLOAT4</span>(<span class="number">0.1f</span>, <span class="number">0.48f</span>, <span class="number">0.19f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vertices[i].Pos.y &lt; <span class="number">20.0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Dark brown.</span></span><br><span class="line">            vertices[i].Color = <span class="built_in">XMFLOAT4</span>(<span class="number">0.45f</span>, <span class="number">0.39f</span>, <span class="number">0.34f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// White snow.</span></span><br><span class="line">            vertices[i].Color = <span class="built_in">XMFLOAT4</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">const</span> UINT vbByteSize = (UINT)vertices.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::<span class="keyword">uint16_t</span>&gt; indices = grid.<span class="built_in">GetIndices16</span>();</span><br><span class="line">	<span class="keyword">const</span> UINT ibByteSize = (UINT)indices.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(std::<span class="keyword">uint16_t</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> geo = std::make_unique&lt;MeshGeometry&gt;();</span><br><span class="line">	geo-&gt;Name = <span class="string">&quot;landGeo&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(<span class="built_in">D3DCreateBlob</span>(vbByteSize, &amp;geo-&gt;VertexBufferCPU));</span><br><span class="line">	<span class="built_in">CopyMemory</span>(geo-&gt;VertexBufferCPU-&gt;<span class="built_in">GetBufferPointer</span>(), vertices.<span class="built_in">data</span>(), vbByteSize);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(<span class="built_in">D3DCreateBlob</span>(ibByteSize, &amp;geo-&gt;IndexBufferCPU));</span><br><span class="line">	<span class="built_in">CopyMemory</span>(geo-&gt;IndexBufferCPU-&gt;<span class="built_in">GetBufferPointer</span>(), indices.<span class="built_in">data</span>(), ibByteSize);</span><br><span class="line"></span><br><span class="line">	geo-&gt;VertexBufferGPU = d3dUtil::<span class="built_in">CreateDefaultBuffer</span>(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">		mCommandList.<span class="built_in">Get</span>(), vertices.<span class="built_in">data</span>(), vbByteSize, geo-&gt;VertexBufferUploader);</span><br><span class="line"></span><br><span class="line">	geo-&gt;IndexBufferGPU = d3dUtil::<span class="built_in">CreateDefaultBuffer</span>(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">		mCommandList.<span class="built_in">Get</span>(), indices.<span class="built_in">data</span>(), ibByteSize, geo-&gt;IndexBufferUploader);</span><br><span class="line"></span><br><span class="line">	geo-&gt;VertexByteStride = <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line">	geo-&gt;VertexBufferByteSize = vbByteSize;</span><br><span class="line">	geo-&gt;IndexFormat = DXGI_FORMAT_R16_UINT;</span><br><span class="line">	geo-&gt;IndexBufferByteSize = ibByteSize;</span><br><span class="line"></span><br><span class="line">	SubmeshGeometry submesh;</span><br><span class="line">	submesh.IndexCount = (UINT)indices.<span class="built_in">size</span>();</span><br><span class="line">	submesh.StartIndexLocation = <span class="number">0</span>;</span><br><span class="line">	submesh.BaseVertexLocation = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>] = submesh;</span><br><span class="line"></span><br><span class="line">	mGeometries[<span class="string">&quot;landGeo&quot;</span>] = std::<span class="built_in">move</span>(geo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::BuildWavesGeometryBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::vector&lt;std::<span class="keyword">uint16_t</span>&gt; <span class="title">indices</span><span class="params">(<span class="number">3</span> * mWaves-&gt;TriangleCount())</span></span>; <span class="comment">// 3 indices per face</span></span><br><span class="line">	<span class="built_in">assert</span>(mWaves-&gt;<span class="built_in">VertexCount</span>() &lt; <span class="number">0x0000ffff</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate over each quad.</span></span><br><span class="line">	<span class="keyword">int</span> m = mWaves-&gt;<span class="built_in">RowCount</span>();</span><br><span class="line">	<span class="keyword">int</span> n = mWaves-&gt;<span class="built_in">ColumnCount</span>();</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			indices[k] = i*n + j;</span><br><span class="line">			indices[k + <span class="number">1</span>] = i*n + j + <span class="number">1</span>;</span><br><span class="line">			indices[k + <span class="number">2</span>] = (i + <span class="number">1</span>)*n + j;</span><br><span class="line"></span><br><span class="line">			indices[k + <span class="number">3</span>] = (i + <span class="number">1</span>)*n + j;</span><br><span class="line">			indices[k + <span class="number">4</span>] = i*n + j + <span class="number">1</span>;</span><br><span class="line">			indices[k + <span class="number">5</span>] = (i + <span class="number">1</span>)*n + j + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			k += <span class="number">6</span>; <span class="comment">// next quad</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UINT vbByteSize = mWaves-&gt;<span class="built_in">VertexCount</span>()*<span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line">	UINT ibByteSize = (UINT)indices.<span class="built_in">size</span>()*<span class="built_in"><span class="keyword">sizeof</span></span>(std::<span class="keyword">uint16_t</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> geo = std::make_unique&lt;MeshGeometry&gt;();</span><br><span class="line">	geo-&gt;Name = <span class="string">&quot;waterGeo&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set dynamically.</span></span><br><span class="line">	geo-&gt;VertexBufferCPU = <span class="literal">nullptr</span>;</span><br><span class="line">	geo-&gt;VertexBufferGPU = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(<span class="built_in">D3DCreateBlob</span>(ibByteSize, &amp;geo-&gt;IndexBufferCPU));</span><br><span class="line">	<span class="built_in">CopyMemory</span>(geo-&gt;IndexBufferCPU-&gt;<span class="built_in">GetBufferPointer</span>(), indices.<span class="built_in">data</span>(), ibByteSize);</span><br><span class="line"></span><br><span class="line">	geo-&gt;IndexBufferGPU = d3dUtil::<span class="built_in">CreateDefaultBuffer</span>(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">		mCommandList.<span class="built_in">Get</span>(), indices.<span class="built_in">data</span>(), ibByteSize, geo-&gt;IndexBufferUploader);</span><br><span class="line"></span><br><span class="line">	geo-&gt;VertexByteStride = <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex);</span><br><span class="line">	geo-&gt;VertexBufferByteSize = vbByteSize;</span><br><span class="line">	geo-&gt;IndexFormat = DXGI_FORMAT_R16_UINT;</span><br><span class="line">	geo-&gt;IndexBufferByteSize = ibByteSize;</span><br><span class="line"></span><br><span class="line">	SubmeshGeometry submesh;</span><br><span class="line">	submesh.IndexCount = (UINT)indices.<span class="built_in">size</span>();</span><br><span class="line">	submesh.StartIndexLocation = <span class="number">0</span>;</span><br><span class="line">	submesh.BaseVertexLocation = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>] = submesh;</span><br><span class="line"></span><br><span class="line">	mGeometries[<span class="string">&quot;waterGeo&quot;</span>] = std::<span class="built_in">move</span>(geo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::BuildPSOs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D3D12_GRAPHICS_PIPELINE_STATE_DESC opaquePsoDesc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// PSO for opaque objects.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;opaquePsoDesc, <span class="built_in"><span class="keyword">sizeof</span></span>(D3D12_GRAPHICS_PIPELINE_STATE_DESC));</span><br><span class="line">	opaquePsoDesc.InputLayout = &#123; mInputLayout.<span class="built_in">data</span>(), (UINT)mInputLayout.<span class="built_in">size</span>() &#125;;</span><br><span class="line">	opaquePsoDesc.pRootSignature = mRootSignature.<span class="built_in">Get</span>();</span><br><span class="line">	opaquePsoDesc.VS =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;BYTE*&gt;(mShaders[<span class="string">&quot;standardVS&quot;</span>]-&gt;<span class="built_in">GetBufferPointer</span>()),</span><br><span class="line">		mShaders[<span class="string">&quot;standardVS&quot;</span>]-&gt;<span class="built_in">GetBufferSize</span>()</span><br><span class="line">	&#125;;</span><br><span class="line">	opaquePsoDesc.PS =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;BYTE*&gt;(mShaders[<span class="string">&quot;opaquePS&quot;</span>]-&gt;<span class="built_in">GetBufferPointer</span>()),</span><br><span class="line">		mShaders[<span class="string">&quot;opaquePS&quot;</span>]-&gt;<span class="built_in">GetBufferSize</span>()</span><br><span class="line">	&#125;;</span><br><span class="line">	opaquePsoDesc.RasterizerState = <span class="built_in">CD3DX12_RASTERIZER_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">	opaquePsoDesc.BlendState = <span class="built_in">CD3DX12_BLEND_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">	opaquePsoDesc.DepthStencilState = <span class="built_in">CD3DX12_DEPTH_STENCIL_DESC</span>(D3D12_DEFAULT);</span><br><span class="line">	opaquePsoDesc.SampleMask = UINT_MAX;</span><br><span class="line">	opaquePsoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;</span><br><span class="line">	opaquePsoDesc.NumRenderTargets = <span class="number">1</span>;</span><br><span class="line">	opaquePsoDesc.RTVFormats[<span class="number">0</span>] = mBackBufferFormat;</span><br><span class="line">	opaquePsoDesc.SampleDesc.Count = m4xMsaaState ? <span class="number">4</span> : <span class="number">1</span>;</span><br><span class="line">	opaquePsoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">	opaquePsoDesc.DSVFormat = mDepthStencilFormat;</span><br><span class="line">	<span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateGraphicsPipelineState</span>(&amp;opaquePsoDesc, <span class="built_in">IID_PPV_ARGS</span>(&amp;mPSOs[<span class="string">&quot;opaque&quot;</span>])));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// PSO for opaque wireframe objects.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    D3D12_GRAPHICS_PIPELINE_STATE_DESC opaqueWireframePsoDesc = opaquePsoDesc;</span><br><span class="line">    opaqueWireframePsoDesc.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="built_in">CreateGraphicsPipelineState</span>(&amp;opaqueWireframePsoDesc, <span class="built_in">IID_PPV_ARGS</span>(&amp;mPSOs[<span class="string">&quot;opaque_wireframe&quot;</span>])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::BuildFrameResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gNumFrameResources; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        mFrameResources.<span class="built_in">push_back</span>(std::make_unique&lt;FrameResource&gt;(md3dDevice.<span class="built_in">Get</span>(),</span><br><span class="line">            <span class="number">1</span>, (UINT)mAllRitems.<span class="built_in">size</span>(), mWaves-&gt;<span class="built_in">VertexCount</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::BuildRenderItems</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> wavesRitem = std::make_unique&lt;RenderItem&gt;();</span><br><span class="line">	wavesRitem-&gt;World = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">	wavesRitem-&gt;ObjCBIndex = <span class="number">0</span>;</span><br><span class="line">	wavesRitem-&gt;Geo = mGeometries[<span class="string">&quot;waterGeo&quot;</span>].<span class="built_in">get</span>();</span><br><span class="line">	wavesRitem-&gt;PrimitiveType = D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line">	wavesRitem-&gt;IndexCount = wavesRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>].IndexCount;</span><br><span class="line">	wavesRitem-&gt;StartIndexLocation = wavesRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>].StartIndexLocation;</span><br><span class="line">	wavesRitem-&gt;BaseVertexLocation = wavesRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>].BaseVertexLocation;</span><br><span class="line"></span><br><span class="line">	mWavesRitem = wavesRitem.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">	mRitemLayer[(<span class="keyword">int</span>)RenderLayer::Opaque].<span class="built_in">push_back</span>(wavesRitem.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> gridRitem = std::make_unique&lt;RenderItem&gt;();</span><br><span class="line">	gridRitem-&gt;World = MathHelper::<span class="built_in">Identity4x4</span>();</span><br><span class="line">	gridRitem-&gt;ObjCBIndex = <span class="number">1</span>;</span><br><span class="line">	gridRitem-&gt;Geo = mGeometries[<span class="string">&quot;landGeo&quot;</span>].<span class="built_in">get</span>();</span><br><span class="line">	gridRitem-&gt;PrimitiveType = D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST;</span><br><span class="line">	gridRitem-&gt;IndexCount = gridRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>].IndexCount;</span><br><span class="line">	gridRitem-&gt;StartIndexLocation = gridRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>].StartIndexLocation;</span><br><span class="line">	gridRitem-&gt;BaseVertexLocation = gridRitem-&gt;Geo-&gt;DrawArgs[<span class="string">&quot;grid&quot;</span>].BaseVertexLocation;</span><br><span class="line"></span><br><span class="line">	mRitemLayer[(<span class="keyword">int</span>)RenderLayer::Opaque].<span class="built_in">push_back</span>(gridRitem.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">	mAllRitems.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(wavesRitem));</span><br><span class="line">	mAllRitems.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(gridRitem));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LandAndWavesApp::DrawRenderItems</span><span class="params">(ID3D12GraphicsCommandList* cmdList, <span class="keyword">const</span> std::vector&lt;RenderItem*&gt;&amp; ritems)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT objCBByteSize = d3dUtil::<span class="built_in">CalcConstantBufferByteSize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ObjectConstants));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> objectCB = mCurrFrameResource-&gt;ObjectCB-&gt;<span class="built_in">Resource</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For each render item...</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ritems.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> ri = ritems[i];</span><br><span class="line"></span><br><span class="line">		cmdList-&gt;<span class="built_in">IASetVertexBuffers</span>(<span class="number">0</span>, <span class="number">1</span>, &amp;ri-&gt;Geo-&gt;<span class="built_in">VertexBufferView</span>());</span><br><span class="line">		cmdList-&gt;<span class="built_in">IASetIndexBuffer</span>(&amp;ri-&gt;Geo-&gt;<span class="built_in">IndexBufferView</span>());</span><br><span class="line">		cmdList-&gt;<span class="built_in">IASetPrimitiveTopology</span>(ri-&gt;PrimitiveType);</span><br><span class="line"></span><br><span class="line">        D3D12_GPU_VIRTUAL_ADDRESS objCBAddress = objectCB-&gt;<span class="built_in">GetGPUVirtualAddress</span>();</span><br><span class="line">        objCBAddress += ri-&gt;ObjCBIndex*objCBByteSize;</span><br><span class="line"></span><br><span class="line">		cmdList-&gt;<span class="built_in">SetGraphicsRootConstantBufferView</span>(<span class="number">0</span>, objCBAddress);</span><br><span class="line"></span><br><span class="line">		cmdList-&gt;<span class="built_in">DrawIndexedInstanced</span>(ri-&gt;IndexCount, <span class="number">1</span>, ri-&gt;StartIndexLocation, ri-&gt;BaseVertexLocation, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">LandAndWavesApp::GetHillsHeight</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> z)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.3f</span>*(z*<span class="built_in">sinf</span>(<span class="number">0.1f</span>*x) + x*<span class="built_in">cosf</span>(<span class="number">0.1f</span>*z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">XMFLOAT3 <span class="title">LandAndWavesApp::GetHillsNormal</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> z)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// n = (-df/dx, 1, -df/dz)</span></span><br><span class="line">    <span class="function">XMFLOAT3 <span class="title">n</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">-0.03f</span>*z*cosf(<span class="number">0.1f</span>*x) - <span class="number">0.3f</span>*cosf(<span class="number">0.1f</span>*z),</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">1.0f</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">-0.3f</span>*sinf(<span class="number">0.1f</span>*x) + <span class="number">0.03f</span>*x*sinf(<span class="number">0.1f</span>*z))</span></span>;</span><br><span class="line"></span><br><span class="line">    XMVECTOR unitNormal = <span class="built_in">XMVector3Normalize</span>(<span class="built_in">XMLoadFloat3</span>(&amp;n));</span><br><span class="line">    <span class="built_in">XMStoreFloat3</span>(&amp;n, unitNormal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>DirectX</tag>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DX学习笔记（三）：渲染流水线</title>
    <url>/2020/06/24/LearnDX12_RenderPipline/</url>
    <content><![CDATA[<h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><p>平行线最终会相交于<code>消失点</code>，又称为<code>灭点</code></p>
<p><code>物体重叠</code>：即不同命的物体能够遮挡住其后侧物体的局部</p>
<p>3D实体对象是通过<code>三角形网格</code>来近似表示的</p>
<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>分量式乘法:<code>(r,g,b)*(a,b,c)=(ra,gb,bc)</code></p>
<h5 id="128位颜色"><a href="#128位颜色" class="headerlink" title="128位颜色"></a>128位颜色</h5><p>每个分量用浮点表示，即4D向量 (r,g,b,a)</p>
<p><em><strong>0&lt;=r,g,b,a&lt;=1</strong></em></p>
<p><code>DirectXMath</code>库对分量式乘法的支持</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">XMVECTOR XM_CAKKCIBV <span class="title">XMColorModulate</span> <span class="params">(FXMVECTOR C1,FXMVECTOR C2)</span></span>;<span class="comment">//返回C1*C2</span></span><br></pre></td></tr></table></figure>

<h5 id="32位颜色"><a href="#32位颜色" class="headerlink" title="32位颜色"></a>32位颜色</h5><p>每个分量仅分配1个字节，因此每个占用8字节的颜色分量就分别描述256种不同的颜色强度</p>
<p>即0代表无强度，256代表最大强度</p>
<p><code>DirectXMath</code>库<code>(include&lt;DirectXPackedVector.h&gt;)</code>在<code>DirectX::PackedVector</code>命名空间提供了相应函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> DirectX</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> PackedVector</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">XMCOLOR</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                    <span class="keyword">uint8_t</span> b;  <span class="comment">// Blue:    0/255 to 255/255</span></span><br><span class="line">            		<span class="keyword">uint8_t</span> g;  <span class="comment">// Green:   0/255 to 255/255</span></span><br><span class="line">            		<span class="keyword">uint8_t</span> r;  <span class="comment">// Red:     0/255 to 255/255</span></span><br><span class="line">            		<span class="keyword">uint8_t</span> a;  <span class="comment">// Alpha:   0/255 to 255/255</span></span><br><span class="line">                    </span><br><span class="line">                &#125;;<span class="keyword">uint32_t</span> c;</span><br><span class="line">                <span class="built_in">XMCOLOR</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    			<span class="built_in">XMCOLOR</span>(<span class="keyword">const</span> XMCOLOR&amp;) = <span class="keyword">default</span>;</span><br><span class="line">                XMCOLOR&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> XMCOLOR&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">XMCOLOR</span>(XMCOLOR&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">                XMCOLOR&amp; <span class="keyword">operator</span>=(XMCOLOR&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">                <span class="function">XM_CONSTEXPR <span class="title">XMCOLOR</span><span class="params">(<span class="keyword">uint32_t</span> Color)</span> : c(Color) &#123;</span>&#125;</span><br><span class="line">                <span class="built_in">XMCOLOR</span>(<span class="keyword">float</span> _r, <span class="keyword">float</span> _g, <span class="keyword">float</span> _b, <span class="keyword">float</span> _a);</span><br><span class="line">                <span class="function"><span class="keyword">explicit</span> <span class="title">XMCOLOR</span><span class="params">(_In_reads_(<span class="number">4</span>) <span class="keyword">const</span> <span class="keyword">float</span> *pArray)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">operator</span> <span class="title">uint32_t</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c; &#125;</span><br><span class="line"></span><br><span class="line">                XMCOLOR&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> <span class="keyword">uint32_t</span> Color) &#123; c = Color; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过将<code>[0,255]</code>映射到<code>[0,1]</code>即可完成32位到128位的转换</p>
<p>转换函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">XMVECTOR XM_CALLCONV <span class="title">XMLoadColor</span><span class="params">( <span class="keyword">const</span> XMCOLOR* pSource)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> XM_CALLCONV <span class="title">XMStoreColor</span><span class="params">( XMCOLOR* pDestination, FXMVECTOR V )</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="渲染流水线概述"><a href="#渲染流水线概述" class="headerlink" title="渲染流水线概述"></a>渲染流水线概述</h3><p>渲染流水线(rendering pipeline)是以摄像机位观察视角而生成的2D图像的一系列完整步骤</p>
<p>​     </p>
<p><img src="https://img.supervj.top/xuanran.png"></p>
<h3 id="输入装配阶段"><a href="#输入装配阶段" class="headerlink" title="输入装配阶段"></a>输入装配阶段</h3><p>输入装配阶段：从显存中读取集合数据(顶点和索引，vertex and index)</p>
<p>再装配为几何图元（几何基元），如三角形和线条</p>
<ul>
<li>顶点缓冲区：将顶点与渲染流水线绑定的特殊结构体</li>
</ul>
<h5 id="图元拓扑-primitive-topology"><a href="#图元拓扑-primitive-topology" class="headerlink" title="图元拓扑(primitive topology)"></a>图元拓扑(primitive topology)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> STDMETHODCALLTYPE <span class="title">IASetPrimitiveTopology</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">            _In_  D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">D3D_PRIMITIVE_TOPOLOGY</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_UNDEFINED	= <span class="number">0</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_POINTLIST	= <span class="number">1</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_LINELIST	= <span class="number">2</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_LINESTRIP	= <span class="number">3</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST	= <span class="number">4</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP	= <span class="number">5</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ	= <span class="number">10</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ	= <span class="number">11</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ	= <span class="number">12</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ	= <span class="number">13</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST	= <span class="number">33</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST	= <span class="number">34</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST	= <span class="number">35</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST	= <span class="number">36</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST	= <span class="number">37</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST	= <span class="number">38</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST	= <span class="number">39</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST	= <span class="number">40</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST	= <span class="number">41</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST	= <span class="number">42</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST	= <span class="number">43</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST	= <span class="number">44</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST	= <span class="number">45</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST	= <span class="number">46</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST	= <span class="number">47</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST	= <span class="number">48</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST	= <span class="number">49</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST	= <span class="number">50</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST	= <span class="number">51</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST	= <span class="number">52</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST	= <span class="number">53</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST	= <span class="number">54</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST	= <span class="number">55</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST	= <span class="number">56</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST	= <span class="number">57</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST	= <span class="number">58</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST	= <span class="number">59</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST	= <span class="number">60</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST	= <span class="number">61</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST	= <span class="number">62</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST	= <span class="number">63</span>,</span><br><span class="line">        D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST	= <span class="number">64</span>,</span><br><span class="line">        D3D10_PRIMITIVE_TOPOLOGY_UNDEFINED	= D3D_PRIMITIVE_TOPOLOGY_UNDEFINED,</span><br><span class="line">        D3D10_PRIMITIVE_TOPOLOGY_POINTLIST	= D3D_PRIMITIVE_TOPOLOGY_POINTLIST,</span><br><span class="line">        D3D10_PRIMITIVE_TOPOLOGY_LINELIST	= D3D_PRIMITIVE_TOPOLOGY_LINELIST,</span><br><span class="line">        D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP	= D3D_PRIMITIVE_TOPOLOGY_LINESTRIP,</span><br><span class="line">        D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST	= D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST,</span><br><span class="line">        D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP	= D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP,</span><br><span class="line">        D3D10_PRIMITIVE_TOPOLOGY_LINELIST_ADJ	= D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ,</span><br><span class="line">        D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ	= D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ,</span><br><span class="line">        D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ	= D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ,</span><br><span class="line">        D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ	= D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED	= D3D_PRIMITIVE_TOPOLOGY_UNDEFINED,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_POINTLIST	= D3D_PRIMITIVE_TOPOLOGY_POINTLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_LINELIST	= D3D_PRIMITIVE_TOPOLOGY_LINELIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP	= D3D_PRIMITIVE_TOPOLOGY_LINESTRIP,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST	= D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP	= D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_LINELIST_ADJ	= D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ	= D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ	= D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ	= D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST,</span><br><span class="line">        D3D11_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST	= D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST</span><br><span class="line">    &#125; 	D3D_PRIMITIVE_TOPOLOGY;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过线列表来绘制对象</span></span><br><span class="line">mCommandList-&gt;<span class="built_in">IASetPrimitiveTopology</span>(D3D_PRIMITIVE_TOPOLOGY_LINELIST);</span><br><span class="line"><span class="comment">//通过三角形列表来绘制对象</span></span><br><span class="line">mCommandList-&gt;<span class="built_in">IASetPrimitiveTopology</span>(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);</span><br><span class="line"><span class="comment">//通过三角形带来绘制对象</span></span><br><span class="line">mCommandList-&gt;<span class="built_in">IASetPrimitiveTopology</span>(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);</span><br></pre></td></tr></table></figure>

<ul>
<li>点列表 <code>D3D_PRIMITIVE_TOPOLOGY_POINTLIST</code></li>
<li>线条带 <code>D3D_PRIMITIVE_TOPOLOGY_LINESTRIP</code></li>
<li>线列表 <code>D3D_PRIMITIVE_TOPOLOGY_LINELIST</code></li>
<li>三角形带 <code>D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP</code></li>
</ul>
<p><img src="https://img.supervj.top/img/tuyuantuopu_1.jpg"></p>
<ul>
<li>剔除(culling)问题：奇数与偶数三角形的绕序(环绕顺序)即装配图元的顶点顺序是不同的</li>
</ul>
<p>CPU会对偶数三角形的<code>前两个顶点</code>顺序进行调换已达到有奇数三角形绕序相同</p>
<blockquote>
<p>正确的应该是后<strong>两个顶点</strong>顺序调换，而OpenGL中才是前两个顶点调换</p>
</blockquote>
<ul>
<li>三角形列表</li>
</ul>
<p><code>D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST</code></p>
<p>三角形列表与三角形带的区别是，三角形列表的三角形可以彼此分离，所以每n*3个顶点组成n个三角形</p>
<ul>
<li>具有邻接数据的图元拓扑</li>
</ul>
<p>对于有邻接数据的三角形列表，每个三角形都有3个与之相邻的<code>邻接三角形</code></p>
<p>借助<code>顶点缓冲区</code>和<code>索引缓冲区</code>将它们随主三角形一并提交至渲染流水线</p>
<p>并且要把拓扑类型指定为<code>D3D12_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ</code>让渲染流水线知道如何以顶点缓冲区的顶点来构建主三角形和其邻接三角形；</p>
<p>邻接图元的顶点只作为集合着色器的输入数据，并不会被绘制</p>
<p><img src="https://img.supervj.top/img/DX/tuyuantuopu_2.jpg"></p>
<h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vertex quad[<span class="number">6</span>]=&#123;</span><br><span class="line">    v0,v1,v2,<span class="comment">//三角形0</span></span><br><span class="line">    v0,v2,v3 <span class="comment">//三角形1</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>绕序</strong>：为三角形指定顶点顺序</li>
</ul>
<p>用<code>顶点列表</code>和<code>索引列表</code>组合起来构成三角形</p>
<p>如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vertex v[<span class="number">9</span>]=&#123;v0,v1,v2,v3,v4,v5,v6,v7,v8&#125;;</span><br><span class="line">UINT indexList[<span class="number">24</span>]=&#123;</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">7</span>,<span class="number">8</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">8</span>,<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="顶点着色阶段"><a href="#顶点着色阶段" class="headerlink" title="顶点着色阶段"></a>顶点着色阶段</h3><ul>
<li>世界变换：将局部坐标系内的坐标转换到世界坐标系</li>
<li>世界矩阵：上述变换的矩阵</li>
</ul>
<p>$$<br>W=SRT<br>$$</p>
<ul>
<li>观察空间:相机的局部坐标系，亦称视觉空间、摄像机空间等</li>
<li>取景变换：世界空间至观察空间的变换；此变换的矩阵叫做<code>观察矩阵</code></li>
</ul>
<p>观察矩阵函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> XMMATRIX XM_CALLCONV <span class="title">XMMatrixLookAtLH</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FXMVECTOR EyePosition, </span></span></span><br><span class="line"><span class="params"><span class="function">    FXMVECTOR FocusPosition, </span></span></span><br><span class="line"><span class="params"><span class="function">    FXMVECTOR UpDirection</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">XMVECTOR eyePos=<span class="built_in">XMVectorSet</span>(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">XMVECTOR target=<span class="built_in">XMVectorZero</span>();</span><br><span class="line">XMVECTOR up=<span class="built_in">XMVectorSet</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">XMMATRIX V=<span class="built_in">XMMatrixLookAtLH</span>(eyePos,target,up);<span class="comment">//返回观察矩阵</span></span><br><span class="line">XMVECTOR v2=<span class="built_in">XMVector3TransformCoord</span>(target,V);</span><br><span class="line">cout&lt;&lt;v2;<span class="comment">//输出得到(0,0,173.2),即在观察空间的坐标</span></span><br></pre></td></tr></table></figure>

<ul>
<li>顶点的投影线：顶点到观察点的连线</li>
<li>透视投影变换：3D顶点<strong>v</strong>变换至其投影线与3D投影平面的交点<strong>v<sup>、</sup></strong></li>
</ul>
<blockquote>
<p>近平面(近裁剪面)<code>n</code>,远平面<code>f</code>，垂直视场角<code>α</code>，纵横比<code>r</code>，4个参数定义了以原点作为投影的中心，以<code>Z</code>轴进行观察的平截头体</p>
</blockquote>
<p>纵横比<br>$$<br>r=w/h<br>$$<br>w:投影窗口的宽度</p>
<p>h:投影窗口的高度</p>
<blockquote>
<p>如果后台缓冲区与投影窗口纵横比不一致，在映射的过程中会产生非均匀缩放（不等比例缩放），导致图像拉伸</p>
</blockquote>
<ul>
<li><p>NDC：规格化设备坐标(Normalized Device Coordinates)</p>
</li>
<li><p>透视除法（齐次除法）：顶点与投影矩阵相乘以后，对每个坐标除以<code>w=z</code></p>
</li>
<li><p>归一化深度值：通过函数 <code>g(z)</code>把<code>z</code>坐标从<code>[n,f]</code>映射到区间<code>[0,1]</code></p>
</li>
</ul>
<p>$$<br>g(z)=A+ {B \over z}<br>$$</p>
<ul>
<li>透视投影矩阵</li>
</ul>
<p>$$<br>P=\begin{bmatrix}1\over rtan({\alpha \over 2}) &amp; 0 &amp; 0 &amp; 0\<br>0 &amp; 1\over{tan({\alpha\over 2})} &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; f\over {f-n} &amp; 1 \<br>0 &amp; &amp; 0 &amp; -nf\over{f-n} &amp; 0<br>\end{bmatrix}<br>$$</p>
<blockquote>
<p>在顶点乘以投影矩阵后，集合体会处于所谓的<code>齐次裁剪空间</code>或者<code>投影空间</code></p>
<p>完成<strong>透视除法</strong>以后，便是**规格化设备坐标(NDC)**了</p>
</blockquote>
<ul>
<li>XMMatrixPerspectiveFovLH</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> XMMATRIX XM_CALLCONV <span class="title">XMMatrixPerspectiveFovLH</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">float</span> FovAngleY, <span class="comment">//用弧度值表示的垂直视场角</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">float</span> AspectRatio, <span class="comment">//纵横比：宽度/高度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">float</span> NearZ, <span class="comment">//近平面距离</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">float</span> FarZ<span class="comment">//到远平面距离</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">XMMATRIX M2=<span class="built_in">XMMatrixPerspectiveFovLH</span>(<span class="number">0.25f</span>*XM_PI,<span class="number">1092</span>/<span class="number">1080</span>,<span class="number">1.0</span>,<span class="number">1000</span>);</span><br><span class="line">	cout&lt;&lt;M2;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.41421 0       0       0<br>0       2.41421 0       0<br>0       0       1.001   1<br>0       0       -1.001  0</p>
</blockquote>
<h3 id="曲面细分阶段"><a href="#曲面细分阶段" class="headerlink" title="曲面细分阶段"></a>曲面细分阶段</h3><p>利用镶嵌化处理技术对网格中的三角形进行细分，以此来增加物体表面上的三角形数量。</p>
<p>再将这些新增的三角形偏移到适当的位置，使网格表现出更加细腻的细节</p>
<ul>
<li>曲面细分的优点</li>
</ul>
<ol>
<li>实现LOD</li>
<li>在内存中只维护<strong>低模</strong>，在有需求时动态增添三角形，从而节省资源</li>
<li>处理动画和物理时使用低模，渲染时使用处理过的高模</li>
</ol>
<h3 id="几何着色器阶段"><a href="#几何着色器阶段" class="headerlink" title="几何着色器阶段"></a>几何着色器阶段</h3><p>几何着色器阶段接受输入是完整的图元</p>
<p>与顶点着色器相比，几何着色器可以创建或者修改几何体</p>
<p>比如，将一个点或者一条线扩展为一个四边形</p>
<h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p>对视锥体之外的物体进行裁剪</p>
<blockquote>
<p>苏泽兰-霍奇曼裁剪算法</p>
</blockquote>
<h3 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h3><p>光栅化阶段(RS,栅格化)：投影主屏幕上的3D三角形计算出对应的像素颜色</p>
<ul>
<li>视口变换：裁剪完成后，硬件通过透视除法将物体从齐次空间变换为规格化设备坐标（NDC）。此后顶点<code>x、y</code>坐标会以像素单位表示</li>
<li>背面剔除：将背面朝向的三角形从渲染流水线中除去</li>
<li>透视矫正插值：为得到2D空间的顶点的插值属性，对3D空间的三角形属性进行线性插值，即利用三角形属性计算出内部像素的属性</li>
<li>像素着色器阶段(pixel shader)：针对每个像素片段进行处理，根据顶点的差值属性作为输入来计算像素颜色，亦可实现如逐像素光照(per-pixel lighting)、反射以及阴影等复杂效果</li>
<li>输入合并阶段：上述阶段生成的像素片段送至渲染流水线的输出合并阶段(OM)。丢弃部分像素(如未通过深度测试等)，剩下的写入后台缓冲区，执行混合(blend)操作（透明效果也混合实现的）</li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>DirectX</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Lyra技术分析:输入方式与GAS技能触发</title>
    <url>/2023/11/16/Lyra%E6%8A%80%E8%83%BD%E8%BE%93%E5%85%A5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文研究一下Lyra技能系统的输入方式触发方式</p>
<span id="more"></span>



<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="传统的GAS技能触发方式"><a href="#传统的GAS技能触发方式" class="headerlink" title="传统的GAS技能触发方式"></a>传统的GAS技能触发方式</h2><p>GAS中每个技能(GA)通过<code>UAbilitySystemComponent::GiveAbility(const FGameplayAbilitySpec&amp; Spec)</code>添加</p>
<p>在这个spec里面有一个<code>int32   InputID;</code>成员变量, 这个是用来快捷触发技能用的</p>
<p>然后看技能组件内的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAbilitySystemComponent::BindAbilityActivationToInputComponent</span><span class="params">(UInputComponent* InputComponent, FGameplayAbilityInputBinds BindInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UEnum* EnumBinds = BindInfo.<span class="built_in">GetBindEnum</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SetBlockAbilityBindingsArray</span>(BindInfo);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(int32 idx=<span class="number">0</span>; idx &lt; EnumBinds-&gt;<span class="built_in">NumEnums</span>(); ++idx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> FString FullStr = EnumBinds-&gt;<span class="built_in">GetNameStringByIndex</span>(idx);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Pressed event</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">FInputActionBinding <span class="title">AB</span><span class="params">(FName(*FullStr), IE_Pressed)</span></span>;</span><br><span class="line">			AB.ActionDelegate.<span class="built_in">GetDelegateForManualSet</span>().<span class="built_in">BindUObject</span>(<span class="keyword">this</span>, &amp;UAbilitySystemComponent::AbilityLocalInputPressed, idx);</span><br><span class="line">			InputComponent-&gt;<span class="built_in">AddActionBinding</span>(AB);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Released event</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">FInputActionBinding <span class="title">AB</span><span class="params">(FName(*FullStr), IE_Released)</span></span>;</span><br><span class="line">			AB.ActionDelegate.<span class="built_in">GetDelegateForManualSet</span>().<span class="built_in">BindUObject</span>(<span class="keyword">this</span>, &amp;UAbilitySystemComponent::AbilityLocalInputReleased, idx);</span><br><span class="line">			InputComponent-&gt;<span class="built_in">AddActionBinding</span>(AB);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>将一个枚举转换为int绑定到每个技能触发按键事件上</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116152815806.png" alt="image-20231116152815806"></p>
<p>在收到回调事件后会进行判定并触发对应的inputID的技能</p>
<p>在UE4中, 可以直接将InputAction名称与这个枚举对应起来, 可以达到直接触发</p>
<h2 id="EnhancedInput与GAS技能触发"><a href="#EnhancedInput与GAS技能触发" class="headerlink" title="EnhancedInput与GAS技能触发"></a>EnhancedInput与GAS技能触发</h2><p>UE5以后, 传统的InputAction已经被废弃,  这套绑定系统需要调整一下才能触发</p>
<p>实际上我们只需要将EnhancedInput的InputAction与一个枚举对应起来即可</p>
<p>比如建立一个TMap关系</p>
<p><code>TMap&lt;EAbilityInputKey, UInputAction*&gt;</code></p>
<p>然后重载<code>BindAbilityActivationToInputComponent</code>事件, 如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116153314078.png" alt="image-20231116153314078"></p>
<p>记得, 这个事件是需要手动去触发的, 比如在角色中触发</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116153352887.png" alt="image-20231116153352887"></p>
<p>当然需要将技能与这个枚举建立起对应关系, 或者是在CDO中赋予成员变量, 或者再建立一个索引关系, 在注册技能的时候添加进去即可</p>
<p>那么这样以后, 配置好映射, 就可以正常触发对应的技能了</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116153514678.png" alt="image-20231116153514678"></p>
<h2 id="Lyra的技能触发方式"><a href="#Lyra的技能触发方式" class="headerlink" title="Lyra的技能触发方式"></a>Lyra的技能触发方式</h2><p> Lyra的技能触发是围绕Tag的,  即每个技能触发对应一个tag, 这样比枚举更加灵活</p>
<p>Lyra的角色配置使用的是一个叫PawnData的DataAsset</p>
<p>里面保存了<code>ULyraInputConfig</code>用于配置输入</p>
<p>然后这个配置内保存了两组输入配置, 一组用于触发传统的比如移动的输入配置, 另一组用于技能, 我们重点就看技能</p>
<p><code>TArray&lt;FLyraInputAction&gt; AbilityInputActions;</code></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116153953690.png" alt="image-20231116153953690"></p>
<p>Lyra使用了自定义的<code>InputCompnent</code>, 添加了几个扩展的模板函数, 比如</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116154102472.png" alt="image-20231116154102472"></p>
<p>因为源生的BindAction模板函数支持动态参数, Lyra就用此扩展了一个支持tag的输入绑定函数</p>
<p>在设置PawnData的时候就把输入配置注册好</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116154213522.png" alt="image-20231116154213522"></p>
<p>在回调函数里直接调用自定义的ASC的对应事件</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116154246898.png" alt="image-20231116154246898"></p>
<p>在ASC中, 输入事件过去的时候会将对应的技能句柄保存到一个数组中</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116154333779.png" alt="image-20231116154333779"></p>
<p>然后在Controller驱动的<code>ULyraAbilitySystemComponent::ProcessAbilityInput</code>函数中做统一处理</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116154721926.png" alt="image-20231116154721926"></p>
<p>Lyra的GA类有一个成员变量用于定义这个技能的触发方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">ELyraAbilityActivationPolicy</span> :</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Try to activate the ability when the input is triggered.</span></span><br><span class="line">	OnInputTriggered,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Continually try to activate the ability while the input is active.</span></span><br><span class="line">	WhileInputActive,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try to activate the ability when an avatar is assigned.</span></span><br><span class="line">	OnSpawn</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>字面意思即可理解, 举个例子, reload技能是<code>OnInputTriggered</code>在按下的时候只触发一次, 开火技能是按下以后一直触发直到松开按键,  被动技能可以设置为<code>OnSpawn</code>在ASC初始化之后就可以触发</p>
]]></content>
      <categories>
        <category>gameplay</category>
      </categories>
      <tags>
        <tag>gameplay</tag>
      </tags>
  </entry>
  <entry>
    <title>Lyra技术分析：GameExperience</title>
    <url>/2024/03/25/Lyra_GameExperience/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如何基于Lyra的项目快速配置一个角色，该流程的起点是GameExperience对象，本文对此进行简单的分析</p>
<span id="more"></span>



<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li>ULyraExperienceDefinition ：主要的配置资源，继承自<code>PrimaryDataAsset</code>，简称DA</li>
<li>ULyraPawnData: DA, 角色的配置,包含角色class类型以及技能和输入设置等</li>
<li>GameFeature: UE4.27新加的，一种基于插件的模块化的可以热插拔的功能</li>
<li>ULyraAbilitySet：DA, Gas技能配置, 另外也包含初始化的GE效果和额外属性集（关于Gas的篇幅太大，这里不展开）</li>
<li>ULyraInputConfig：DA, 输入配置，基于EnhancedInput框架结合gas的配置，核心思路是用用Tag来触发技能Ga<br><a href="https://supervj.top/2023/11/16/Lyra%E6%8A%80%E8%83%BD%E8%BE%93%E5%85%A5/">Lyra技术分析:输入方式与GAS技能触发</a>这里有详细说明</li>
<li>ULyraControllerComponent_CharacterParts: 挂载在controller上的组件, 本文中作为添加角色子actor的发起者</li>
<li>ULyraPawnComponent_CharacterParts: 挂载在玩家角色上的组件,用于接受前者的事件并修改角色模型</li>
<li>ULyraExperienceManagerComponent： 挂载在GameState的组件，用于保存和管理<code>ULyraExperienceDefinition</code>数据</li>
</ul>
<h2 id="流程简析"><a href="#流程简析" class="headerlink" title="流程简析"></a>流程简析</h2><h3 id="1-创建GameExperience"><a href="#1-创建GameExperience" class="headerlink" title="1.创建GameExperience"></a><code>1.创建GameExperience</code></h3><p>第一步需要创建<code>GameExperience</code>对象， 配置GaemFeatureToEnable为当前插件名称，目的是让该模块自动加载</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325173307302.png" alt="image-20240325173307302"></p>
<p>Lyra用<code>GameExperience</code> 来配置角色基础信息, 这个变量放在<code>WorldSetting</code>中, 如下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325171904535.png" alt="image-20240325171904535"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>需要在项目设置中自定义一个自己的<code>WorldSetting</code></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325170903194.png" alt="image-20240325170903194"></p>
<p>然后在GameMode对象启动并执行Init的时候, 从<code>WorldSetting</code>中找到这个配置并保存到GameState中的<code>ULyraExperienceManagerComponent</code>组件中</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325172239075.png" alt="image-20240325172239075"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325172306933.png" alt="image-20240325172306933"></p>
<h4 id="ULyraExperienceManagerComponent"><a href="#ULyraExperienceManagerComponent" class="headerlink" title="ULyraExperienceManagerComponent"></a><code>ULyraExperienceManagerComponent</code></h4><p>这个组件用来维护<code>ULyraExperienceDefinition</code>数据, 很多对象的初始化都依赖这个数据的初始化完成， 在<code>ULyraExperienceManagerComponent</code>中有<code>CallOrRegister_OnExperienceLoaded()</code>这个方法用于其他对象的注册或监听</p>
<p>比如</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325173033439.png" alt="image-20240325173033439"></p>
<h3 id="2-配置PawnData"><a href="#2-配置PawnData" class="headerlink" title="2. 配置PawnData"></a>2. 配置PawnData</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325173258458.png" alt="image-20240325173258458"></p>
<p>PawnData配置了角色的类型,以及所有技能,属性(通过AbilitySet)以及输入方式(通过InputConfig)</p>
<p>这个不算很难, 不一一展开</p>
<p>相机模式也在这里配置, 使用默认的TP即可, 关于相机模式未来有机会分析一下</p>
<h3 id="3-添加Actions"><a href="#3-添加Actions" class="headerlink" title="3. 添加Actions"></a>3. 添加Actions</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325173656070.png" alt="image-20240325173656070"></p>
<p>这个Actions目的是在这个GameFeature加载后在所有指定的Actor上执行某个操作比如挂载某个组件, 当然在GameFeature卸载以后也会相应的卸载这个组件</p>
<p>这一步我们给所有Controller添加继承自LyraControllerComponentChracterParts的组件, 并在组件开始时执行下图操作</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325173918558.png" alt="image-20240325173918558"></p>
<h3 id="4-创建玩家角色并添加组件B-MannequinPawnCosmetics"><a href="#4-创建玩家角色并添加组件B-MannequinPawnCosmetics" class="headerlink" title="4. 创建玩家角色并添加组件B_MannequinPawnCosmetics"></a>4. 创建玩家角色并添加组件<code>B_MannequinPawnCosmetics</code></h3><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325174657365.png" alt="image-20240325174657365"></p>
<p>B_MannequinPawnCosmetics组件继承自LyraPawnComponent_CharacterParts</p>
<p>配置了2组MeshRules数据以及默认的模型和物理资产，这些是与<code>LyraControllerComponentChracterParts</code>需要配合使用</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="LyraControllerComponentChracterParts"><a href="#LyraControllerComponentChracterParts" class="headerlink" title="LyraControllerComponentChracterParts"></a>LyraControllerComponentChracterParts</h4><p>这个组件挂载到Cotroller上, 如前面在游戏开始的时候我们添加一个B_Manny类型的Part,这一个操作的目的是啥呢?</p>
<p><strong><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325174010110.png" alt="image-20240325174010110"></strong></p>
<p>这个controller版本的组件只是作为发起者, 将这个part数据（核心就是这个class对象）添加到pawn版本的组件中去</p>
<h4 id="LyraPawnComponent-CharacterParts"><a href="#LyraPawnComponent-CharacterParts" class="headerlink" title="LyraPawnComponent_CharacterParts"></a>LyraPawnComponent_CharacterParts</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325174335749.png" alt="image-20240325174335749"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325174453559.png" alt="image-20240325174453559"></p>
<p>核心的代码就在上面两图</p>
<ul>
<li>SpawnActorForEntry</li>
</ul>
<p>创建一个ChildActor并attach到角色mesh上</p>
<ul>
<li>BroadcastChanged</li>
</ul>
<p>从<code>LyraControllerComponentChracterParts</code>添加进来的parts中的tag去查找组件中符合的对象，然后更新角色模型和物理资产</p>
<p>Lyra 的2个part角色有一个容易忽略的细节， 2个对象配置了2个tag，如下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325175202941.png" alt="image-20240325175202941"></p>
<p>这个就是上面所说的查找所需的tag</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>默认的角色类，即PawnData中配置的类是负责逻辑的，真正用于显示角色模型的是这个part对象</p>
</li>
<li><p>所有使用PawnData的对象都需要去监听<code>ULyraExperienceManagerComponent</code>的回调事件保证时序</p>
</li>
</ul>
<h2 id="如何换皮"><a href="#如何换皮" class="headerlink" title="如何换皮"></a>如何换皮</h2><p>既然是通过part来确定我们渲染的角色的，那么就可以使用一个新的 part对象来换皮</p>
<p>创建继承自TaggedActor的对象TesetMan，设置UE4小白人为模型，添加角色组件中男性空骨骼模型一样的tag</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325182359136.png" alt="image-20240325182359136"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325182435434.png" alt="image-20240325182435434"></p>
<p>指定这个Mesh组件的ABP为一个特殊的ABP</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240325182507579.png" alt="image-20240325182507579"></p>
<p>在运行时进行重定向运算</p>
]]></content>
      <categories>
        <category>gameplay</category>
      </categories>
      <tags>
        <tag>lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>Lyra技术分析:角色动画</title>
    <url>/2023/11/14/Lyra_%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录一下笔者分析并模仿制作Lyra动画系统的过程和心得, 由于系统非常庞大, 所以会逐步更新记录</p>
<p>下面所有图片均来自自制工程(自己做一遍才能更好的了解当中的细节)</p>
<span id="more"></span>

<ul>
<li>2023.11.16 包含8方向位移, Turn In Place,Jump, Aim</li>
</ul>
<h2 id="动画框架"><a href="#动画框架" class="headerlink" title="动画框架"></a>动画框架</h2><p>首先要围绕几个动画类来展开(名称可能有出入)</p>
<ul>
<li>ABP_CharacterBase : 基础角色动画蓝图, 模型上指定的就是他</li>
<li>ALI_AnimLayer: 动画Link接口, 挂载到ABP_CharacterBase 和其他Link动画蓝图类</li>
<li>ABP_LinkBase: 实现Link逻辑的基类<ul>
<li>ABP_Link_Pistol : 派生的用于配置手枪的link类</li>
<li>ABP_Link_Rifle:  同上类推</li>
</ul>
</li>
</ul>
<p>所以, 基础动画蓝图类里面是搭建好基础的状态机, 但是几乎不配置动画资源</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116160139071.png" alt="image-20231116160139071"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116160146096.png" alt="image-20231116160146096"></p>
<p>而LInk基类里去处理每一层的逻辑</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116160215057.png" alt="image-20231116160215057"></p>
<p>但是动画资源都是通过变量配置</p>
<p>然后每一个派生的Link类就负责配置这些变量</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116160450502.png" alt="image-20231116160450502"></p>
<blockquote>
<p>此举比较好的解决了动画蓝图不容易解耦和协作开发的缺点, 同时也非常方便后期的扩展</p>
</blockquote>
<p>还需要强调的一个技术点</p>
<p>Lyra的动画蓝图更新都放在线程安全函数里, 所有依赖的函数都是线程安全函数(不会出现以前在极端情况下的游戏线程的属性与动画线程的竞争), 同时使用了大量的动画节点回调函数和动态参数绑定技术</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116163929946.png" alt="image-20231116163929946"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116163830409.png" alt="image-20231116163830409"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116163750593.png"></p>
<h2 id="基础移动部分"><a href="#基础移动部分" class="headerlink" title="基础移动部分"></a>基础移动部分</h2><p>首先关注关键的一点, Lyra的8方向位移<strong>不依赖动画混合空间</strong></p>
<p>然后需要开启目前5.3还处于beta的移动库插件</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116163538283.png" alt="image-20231116163538283"></p>
<p><strong>重点: 使用的是4个方向的动画序列</strong>, 动画的选择来自方向枚举的判定</p>
<p>比如start的动画选择在动画序列的On Become阶段</p>
<blockquote>
<p>start和stop都是Sequence Evaluator, cycle是Sequence player</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116162006754.png" alt="image-20231116162006754"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116161955623.png" alt="image-20231116161955623"></p>
<p>Lyra的start和stop动画只会选择一次, cycle动画会持续更换, 注意这个就需要用到惯性混合</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116162134218.png" alt="image-20231116162134218"></p>
<p>这里就非常容易忘记加上Inertialization节点, 为了防止出现问题无从查找(笔者找了很长时间就是没发现为什么循环动画跳帧), 那么就在一开始就在主动画蓝图的最后面加上这个节点</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116162300701.png" alt="image-20231116162300701"></p>
<p>归纳一下start/cycle/stop 3个动画的机制</p>
<ul>
<li>start<ul>
<li>setup : 根据方向确认动画, 设置动画时间为0</li>
<li>update: 驱动Distance Matching</li>
</ul>
</li>
<li>cycle<ul>
<li>update: 根据方向刷新动画, 根据速度缩放动画速率(Distance Matching)</li>
</ul>
</li>
<li>stop<ul>
<li>setup: 同start</li>
<li>stop: 预测停止距离并根据需求进行Distance Matching或者推进动画</li>
</ul>
</li>
</ul>
<h2 id="脚步适配"><a href="#脚步适配" class="headerlink" title="脚步适配"></a>脚步适配</h2><p>一切的运动适配都是为了解决滑步的问题, 从起步到循环到停步都是如此</p>
<p>这里建议先看一下UE官方讲解高级动画移动技术的<a href="https://docs.unrealengine.com/5.3/zh-CN/locomotion-in-unreal-engine/">文档</a></p>
<p>或者笔者旧版本的笔记</p>
<ul>
<li><a href="https://supervj.top/2021/08/26/%E5%8A%A8%E7%94%BB%EF%BC%9AStrideWarping/?highlight=warping">动画：脚步适配/Strider Warping</a></li>
<li><a href="https://supervj.top/2021/09/02/%E5%8A%A8%E7%94%BB%EF%BC%9AOrientationWarping/?highlight=warping">动画:朝向适配OrientationWarping</a></li>
</ul>
<p>因为很多地方都有点晦涩难懂, 所以还是建议在有一定了解以后再来看Lyra的这部分内容</p>
<blockquote>
<p><strong>这套技术依赖Root Motion, 意味着所有动画都必须是Root Motion动画, 包括所有的循环动画</strong></p>
</blockquote>
<p>起步和停步动画必须生成曲线信息, 在插件中已经提供了动画修改器</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116170601868.png" alt="image-20231116170601868"></p>
<p>产生的曲线是如下图的</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116170642359.png" alt="image-20231116170642359"></p>
<p>有几点注意</p>
<ul>
<li>起步都是从0开始到最终的位移距离</li>
<li>停步都是从负值到0</li>
</ul>
<p>这样做的目的是也是为了方便计算</p>
<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>因为使用的是Evaluator, 时间需要我们自己推进, 所以初始化时一定不要忘记将时间设置为0(其他类似的类似)</p>
<p>我们需要计算出两帧之间的距离偏移, 然后将这个关键参数输入给<code>AdvanceTimeByDistanceMatching</code>函数</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116171608419.png" alt="image-20231116171608419"></p>
<blockquote>
<p>因为推进的是时间, 所以归根结底改动的是速率, 这一步没有对步伐进行调整</p>
</blockquote>
<p>而这个距离计算比较简单, 就是比较当前帧数与上一帧的位移偏差</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116171354361.png" alt="image-20231116171354361"></p>
<p>这里为什么自己计算而不用移动组件里的信息?  因为要考虑两边的时序问题和多线程问题</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116171412579.png" alt="image-20231116171412579"></p>
<p>然后在外面使用现在已经正式版本的两个适配节点, 用于计算身体旋转和步伐大小适配</p>
<p>前者后面讲, 后者就是用来弥补只有动画速率调整带来的问题, </p>
<p>所有Lyra的思路就是 在一定缩放动画速率的基础上加上步伐的适配, 两者结合来让脚步更好的表现</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116171642367.png" alt="image-20231116171642367"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116171637252.png" alt="image-20231116171637252"></p>
<p>循环与起步没太大的区别, 动画切换上面也提到过了</p>
<h3 id="停步"><a href="#停步" class="headerlink" title="停步"></a>停步</h3><p>停步相对复杂, 因为我们需要计算出我们停止的位置, 在插件库里封装了一个比较好用的函数(实现方式在移动组件内, 以前需要自己抄一遍出来)</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116171915158.png" alt="image-20231116171915158"></p>
<p>原理: 根据预测的停止距离, 找到合适的动画曲线上的时间点, 将动画直接推进到这个时间点开始播放</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116172241223.png" alt="image-20231116172241223"></p>
<p>比如剩余距离是45, 那么就在上图的时间点开始播放余下动画</p>
<blockquote>
<p>这一步有个前提, 你停止的距离要小于等于动画的最大移动距离, 所以停止动画适合做的比较长一点</p>
</blockquote>
<p>补充一下, 默认的第三人称角色的移动几乎是瞬间停止的, 需要调整下图几个参数保证有一定的刹车过程</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116172537227.png" alt="image-20231116172537227"></p>
<p>效果</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//stop1.gif" alt="stop1"></p>
<h2 id="旋转适配"><a href="#旋转适配" class="headerlink" title="旋转适配"></a>旋转适配</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116173938294.png" alt="image-20231116173938294"></p>
<p>旋转适配就是之前提到的节点 Orientation Warping做的事情, 目的是解决前后左右中间的4个角度问题</p>
<p>因为8方向混合空间一定会存在脚步穿帮现象, </p>
<p>ALS的方案是为左右移动的动画各准备了2个动画分别对应左脚在前和右脚在前(无法根本上解决脚步穿模问题)</p>
<p>使命召唤这类大作的方案是在ALS的基础上再准备一个扭胯的过渡动画处理脚步混合问题</p>
<p>而<code>Orientation Warping</code>做的其实就是控制中轴线的骨骼的旋转来让下半身进行一定的旋转, 讲向前动画匹配到左右45度, 向后动画匹配两个135度</p>
<p>这个角度计算通过已有接口就可以直接获取到, 取值范围是[-180,180]</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116173852513.png" alt="image-20231116173852513"></p>
<p>看一下效果</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//8dire.gif" alt="8dire"></p>
<h2 id="回转运动"><a href="#回转运动" class="headerlink" title="回转运动"></a>回转运动</h2><p>这个是比较特殊的一个机制, 很多案例里并没有这个机制的存在,</p>
<p>先看一下回转运动即Pivot的动画资源</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//pivot_seq.gif" alt="pivot_seq"></p>
<p>上图是往右边的pivot运动, 即朝向右边运动然后急刹车往左边运动</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116194200228.png" alt="image-20231116194200228"></p>
<p>看Distance曲线是从负值到正直的变化曲线</p>
<p>具体解释一下</p>
<p>回转运动即往一个方向运动时立马超对立方向给与加速度, 大白话就是按A向左运动的过程中立马切换成按D向右运动的短时间运动</p>
<p>很多时候我们不处理这个过程也无伤大雅, 毕竟没有谁一直会来回按A/D或者W/S</p>
<p>对比一下两者的视频</p>
<ul>
<li>有pivot</li>
</ul>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//pivot.gif" alt="pivot"></p>
<ul>
<li>没有pivot</li>
</ul>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//pivot_no.gif" alt="pivot_no"></p>
<p>下图是回转运动的状态机图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116192318701.png" alt="image-20231116192318701"></p>
<p>不得不提现在UE5的状态机确实非常优雅, Alias节点用的好可以避免很多蜘蛛网的产生</p>
<p>我们只在start和cycle状态会进入到pivot运动, 所以alias节点这样选择</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116192412289.png" alt="image-20231116192412289"></p>
<p>至于条件, 那么就是当前速度与加速度相反的时候</p>
<p>然后是回转运动的状态机</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116192504953.png" alt="image-20231116192504953"></p>
<p>这里就要解释一下了, 为什么要两个一模一样的状态机来回跳转</p>
<p>这个有点像有些案例里面的开火状态机,  你在这个pivot状态还没有结束的时候立马再触发一次pivot, 那么原有状态机是不能满足立马重新开始并很好的融合的</p>
<p>所以比较取巧的方法是用2个一样的pivot状态来回切换</p>
<p>重复触发的条件有两个</p>
<ul>
<li>速度与加速度相反</li>
<li>当前加速度与上一次加速度相反</li>
</ul>
<p>然后看状态机内部的实现, 初始化的时候选择动画序列, 并记录当前的加速度</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116192752428.png" alt="image-20231116192752428"></p>
<p>刷新的逻辑稍微多一点</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116192824998.png" alt="image-20231116192824998"></p>
<p>文字描述</p>
<ul>
<li>在速度与加速度相反的时候即pivot运动的时候, 用stop的方式做Distance  Matching</li>
<li>使用的预测终点的方法改成了 <code>Predict Ground Movement Pivot Location</code></li>
<li>在速度与加速度同方向以后改成常规的类似start的方式处理Distance Matching</li>
</ul>
<h2 id="原地转身"><a href="#原地转身" class="headerlink" title="原地转身"></a>原地转身</h2><p>原地转身即Turn In Place</p>
<p>Lyra也使用了常规手法, 即角色朝着Controller面朝方向转动, 模型用Rotation  Root Bone做反向补偿, 造成角色转动而模型不转的假象</p>
<p>核心就是计算一个动态的<code>RootYawOffset</code>变量</p>
<p>先看一下每一帧更新的计算逻辑</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116195419064.png" alt="image-20231116195419064"></p>
<p>不得不提这个枚举, 一共三个成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">ERsAnimTurnInPlaceRootOffsetMode</span>:</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">    Accumulate = <span class="number">0</span>,</span><br><span class="line">    HoldOn,</span><br><span class="line">    BlendOut</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>解释一下3个状态的作用</p>
<ul>
<li>Accumulate : 累计状态, 即需要转身的状态, 下半身要进行反补的状态, 根据你鼠标的转向得出插值, 反补给模型</li>
<li>Hold On: 意图是保持住, 这里没有用到, 应该是在一些情况下固定在一定角度然后再跟随鼠标移动的状态</li>
<li>Blend Out:  淡出状态, 身体慢慢插值到鼠标面朝方向的状态, 即Turn In Place播放转身动画时的状态</li>
</ul>
<p>核心就是<code>RootYawOffset</code>处于Accumulate的时候的计算</p>
<p>首先只要是Idle状态机没有处于Blend Out的时候, 都要把状态设置成Accumulate 并且刷新<code>RootYawOffset</code>的值</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116200935967.png" alt="image-20231116200935967"></p>
<p>看实现是围绕着两条曲线进行</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116202126967.png" alt="image-20231116202126967"></p>
<ul>
<li>RemainingTurnYaw: 旋转的角度变化</li>
<li>TurnYawWeight: 转身状态的权重</li>
</ul>
<p>曲线生成依赖Lyra项目的<code>TurnYawAnimModifier</code>修改器, 需要的话要把这个修改器导出来到自己项目</p>
<p>角度除权重得到曲线值, 非零的时候将每一帧的变化值对<code>RootYawOffset</code>进行修改</p>
<blockquote>
<p>这里有个问题, 为什么是除法? 而不是乘法</p>
</blockquote>
<p>然后就要看状态机</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116200001186.png" alt="image-20231116200001186"></p>
<p>在面朝方向与角色朝向插值达到一定角度以后开始进入Turn In Place Rotation状态机</p>
<p>Rotation状态机与下面的Recovery状态机是同一个动画资源, 只不过上面的播放的时间决定下面的起始时间,</p>
<p>用 Turn In Place Rotation Time变量记录</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116200610293.png" alt="image-20231116200610293"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116200106900.png" alt="image-20231116200106900"></p>
<p>Turn In Place Rotation状态机主要更新了这个变量</p>
<p>在重复达到触发转身动画的条件时会重复进入Rotation状态机</p>
<p>这里只有动画表现, 这个不是很难理解</p>
<p>看效果<img src="https://raw.githubusercontent.com/VJien/img/master//turn.gif" alt="turn"></p>
<h2 id="瞄准"><a href="#瞄准" class="headerlink" title="瞄准"></a>瞄准</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116203706745.png" alt="image-20231116203706745"></p>
<p>瞄准Lyra用了单独的一个叠加层来处理</p>
<p>计算非常简单</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116203752264.png" alt="image-20231116203752264"></p>
<p>因为前面已经计算了为了原地转身的<code>RootYawOffset</code>值, 这个反一下刚好是Aim的Yaw应该有的角度</p>
<h2 id="跳跃"><a href="#跳跃" class="headerlink" title="跳跃"></a>跳跃</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116204604030.png" alt="image-20231116204604030"></p>
<p>起跳区分了手动起跳和被动掉落</p>
<p>凭证是Z方向的速度</p>
<p>唯一需要重点看一下的是Land的状态</p>
<p>Land的动画也需要Distance Matching来适配动作, 但是方向不同, 他是Z方向的距离</p>
<p>计算得到的距离地面的距离来决定播放动画的位置</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116204817259.png" alt="image-20231116204817259"></p>
<p>这个距离比较特殊, 用到的是非线程安全的函数, 原因是需要用到移动组件的数据, 看来也是没办法</p>
<p>Lyra用的方法如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116204949461.png" alt="image-20231116204949461"></p>
<p>直接从移动组件拿数据, 不过如果你不想用代码, 蓝图又访问不到这个数据, 那么蓝图也有一个接口可以得到这个距离, 如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116204830867.png" alt="image-20231116204830867"></p>
<p>到此跳跃自己的状态机都可以了, 但是还需要一个落地的叠加状态</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116205137143.png" alt="image-20231116205137143"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116205145246.png" alt="image-20231116205145246"></p>
<p>重点就是落地时候的叠加动画</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116205243423.png" alt="image-20231116205243423"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231116205417818.png" alt="image-20231116205417818"></p>
<p>根据落地之前的计时来决定混合的权重, 意味着轻轻的一跳就叠加一点点, 反之更多</p>
<p>效果</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//jump.gif" alt="jump"></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>MMD动画在UE5的使用</title>
    <url>/2023/12/06/MMD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先科普一下啥是MMD, MMD全称<code>*MikumikuDance*</code>, 这个<code>Miku</code>就是初音未来, 再引用wiki介绍</p>
<blockquote>
<p><strong>MikuMikuDance</strong>（通常缩写为<strong>MMD</strong>）是一款<a href="https://en.wikipedia.org/wiki/Freeware">免费</a>动画程序，可让用户制作动画并创建 3D 动画电影，最初是为<a href="https://en.wikipedia.org/wiki/Vocaloid">Vocaloid</a>角色<a href="https://en.wikipedia.org/wiki/Hatsune_Miku">初音未来</a>制作的</p>
</blockquote>
<p>本文不过多介绍MMD, 有兴趣的同学可以自行谷歌, 本文主要针对如果在UE5中使用MMD素材进行分析</p>
<p>目标:  UE5标准骨架角色/第三方卡通角色使用MMD角色动画和镜头动画</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//3dance.gif" alt="3dance"></p>
<span id="more"></span>

<h3 id="涉及到的软件"><a href="#涉及到的软件" class="headerlink" title="涉及到的软件"></a>涉及到的软件</h3><ul>
<li>UE5</li>
<li>maya</li>
<li>Blender</li>
<li>PmxEditor/VmdEditor(非必须)</li>
</ul>
<h2 id="关于素材"><a href="#关于素材" class="headerlink" title="关于素材"></a>关于素材</h2><p>网上有很多优秀的MMD素材, 主要有模型,角色动画和相机动画</p>
<p>比如比较有名的<a href="https://www.aplaybox.com/model/action">模之屋</a>,  里面有大量的玩家自制mmd动画, 多数是可以二次修改或者商用的;</p>
<p>模之屋的模型基本都是国内知名游戏的模型, 比如米哈游系列, 这一类如果是自己把玩也是可以的, 如果要商用那么得自己准备合适的模型;</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231206091333430.png" alt="image-20231206091333430"></p>
<p>在二次元模型界有一个比较有名的日本网站: <a href="!%5B%5D(https://raw.githubusercontent.com/VJien/img/master//image-20231206091333430.png)">booth</a></p>
<p>这里面的模型基本是可以商用的, 很多游戏比如 知名VR游戏<code>VRChat</code>内的虚拟形象很多都用的是booth的角色</p>
<p>本文就使用booth中的角色进行MMD动画尝试</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231206091608190.png" alt="image-20231206091608190"></p>
<h2 id="导入MMD模型"><a href="#导入MMD模型" class="headerlink" title="导入MMD模型"></a>导入MMD模型</h2><p>隔壁unity有很多现成的插件直接导入mmd, 而且卡通材质球都可以覆盖完全; ue这方面稍微落后了一点, 在早期需要使用blender或者c4d安装相应的mmd插件然后再导出fbx到ue;</p>
<p>后面经过一些大佬的开发, 有一个相对完善的插件</p>
<p>UE4时代叫做 IM4U, UE5后这个插件的原作者似乎停更了,  然后其他大佬为爱发电基于此魔改了一个UE5版本的插件,链接在这里<a href="https://github.com/NaN-Name-bilbil/IVP5U/releases">IVP5U</a></p>
<p>虽然还是有很多bug, 但是基本能用</p>
<blockquote>
<p>mmd的模型资源一般是 pmx格式</p>
<p>动画资源一般是 vmd格式</p>
</blockquote>
<p>安装完插件以后, 直接将pmx文件拖动到content以后, 如果pmx文件没有问题就会弹出如下窗口</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207165049053.png" alt="image-20231207165049053"></p>
<p>点击导入,  会卡顿一会, 然后一般会创建很多材质球和贴图, 如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207165140632.png" alt="image-20231207165140632"></p>
<p>默认是无光模式, 在导入选项中可以选择勾选</p>
<h2 id="导入MMD角色动画"><a href="#导入MMD角色动画" class="headerlink" title="导入MMD角色动画"></a>导入MMD角色动画</h2><p>角色动画导入也是一键拖拽进来, </p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207172214950.png" alt="image-20231207172214950"></p>
<p>上面两个选项要填上, 下面两个无所谓</p>
<p>这里会出现一个大坑</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//ik%20bug.gif" alt="ik bug"></p>
<p>从网上下载的绝大多数(预计80%+)的动画导入以后都是上图这个鸟样</p>
<p>U管的QB老师说这种情况是因为动画数据异常导致</p>
<p>what!??</p>
<p>要么插件有问题, 要么动画本身没问题, 不可能这么高的比例的mmd动画有问题</p>
<p>死马当活马医到vmd view尝试预览一下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//vmd%20ed.gif" alt="vmd ed"></p>
<p>果然是正常的</p>
<p>想到mmd骨架是ik骨骼的, 莫非数据都在ik上??</p>
<p>尝试</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//ik.gif" alt="ik"></p>
<p>果然猜得没错!!!  [手动狗头]</p>
<p>那就用录制大法, 输出一个有FK数据的动画就可以重定向了</p>
<h2 id="导入MMD相机动画"><a href="#导入MMD相机动画" class="headerlink" title="导入MMD相机动画"></a>导入MMD相机动画</h2><p>相机动画即<code>Level Sequencer</code>动画, 不能再拖进来了</p>
<p>我们需要创建一个<code>Level Sequencer</code>资源</p>
<p>会发现多了一个按钮</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207173220189.png" alt="image-20231207173220189"></p>
<p>导入以后看点运气, 一般还是需要手动的对一下相机与角色的位置关系</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//dance1.gif" alt="dance1"></p>
<p>搞定!</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>MMD的骨架非常的奇怪,  关注核心骨骼, 会发现脊椎一条线跟UE标准小白人有比较大的差别</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207165359792.png" alt="image-20231207165359792"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207165441581.png" alt="image-20231207165441581"></p>
<p>pelvis对应的是腰这个问题不大, 但是MMD骨架的上下半身分别有一个相对的根骨骼, 这个跟小白人不一样</p>
<p>这样会导致重定向的时候无法很好的匹配骨骼链</p>
<p>找一个动画发现上下半身2个骨骼都是有动画信息的, 那么暂时先不管, 我们先设置ik</p>
<p>经过反复验证, 最理想的配置如下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207165833831.png" alt="image-20231207165833831"></p>
<p>然后下半身这个骨骼只能被单独空出来, 没有数据</p>
<p>测试一个带有转身的动画重定向表现, 截取转身过程的一帧, 很惨</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207165957130.png" alt="image-20231207165957130"></p>
<p>原因也不用猜,意料之中, 因为mmd骨架转身的时候他是同时动了上下半身2个骨骼, 而没有用<code>腰</code> 这个骨骼来转身, 虽然绝大多数情况, 上下半身2个骨骼的旋转数据非常接近</p>
<p>现在有2个思路, 原则是把全身的旋转想办法拷贝到pelvis/腰上去</p>
<ol>
<li>修复重定向后的小白人动画, 将spine旋转数据部分拷贝到pelvis中</li>
<li>将mmd动画的上下半身骨骼的信息拷贝到腰上去</li>
</ol>
<p><strong>方法1</strong></p>
<p>最简单粗暴的就是写一个动画修改器, 把spine_01的旋转信息拷贝到pelvis中去, </p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207171058350.png" alt="image-20231207171058350"></p>
<p>这里我只将spine_01的roll增量加到pelvis上去</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//UE5%201.gif" alt="UE5 1"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//UE5%20modify.gif" alt="UE5 modify"></p>
<p>只能说很勉强, 毕竟这个方式还有是有点粗暴, 而且考虑到另外两个轴以及位移的影响, 这个方案还是需要额外到maya中去处理动画细节, 有点惨</p>
<p><strong>方法2</strong></p>
<p>思路</p>
<ol>
<li>既然上下半身数据几乎一致, 那么将下半身的数据先拷贝到上半身</li>
<li>上半身的数据拷贝到一个临时对象</li>
<li>把上下半身2个骨骼的局部空间数据清零</li>
<li>临时对象的数据拷贝到腰上</li>
</ol>
<p>用最方便的方式测试</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207171410092.png" alt="image-20231207171410092"></p>
<blockquote>
<p>上面用一个跟腰平级的虚拟骨骼当做临时对象传递数据</p>
</blockquote>
<p>然后继续用录制的方式加装烘焙动画了</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207171811972.png" alt="image-20231207171811972"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207171818736.png" alt="image-20231207171818736"></p>
<p>数据确认无误已经到腰上了</p>
<p>测试重定向</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//rec.gif" alt="rec"></p>
<p>搞定!</p>
<h2 id="修复骨骼太大"><a href="#修复骨骼太大" class="headerlink" title="修复骨骼太大"></a>修复骨骼太大</h2><p>在导入fbx的后, 有些时候会发现骨骼异常的大, 如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207152357446.png" alt="image-20231207152357446"></p>
<p>这个是由于多种原因导致, 比较常见的是不同软件之间的单位不一致导致(一般就是差距100倍)</p>
<p>解决方法最简单的是把fbx导入到blender处理</p>
<p>导入之前, 先把blender的场景选项中的缩放单位设置到0.01</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207152510333.png" alt="image-20231207152510333"></p>
<p>导入fbx以后, 一般你会发现你的模型的最外层缩放是一个比较大的值, 比如</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207152613518.png" alt="image-20231207152613518"></p>
<p>按 ctrl+a , 点击下图按钮即可把缩放归一, 有点像maya的冻结变换</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20231207152700648.png" alt="image-20231207152700648"></p>
<p>这样再导入到UE以后就正常了</p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown(Typora)数学公式</title>
    <url>/2020/06/23/Mardown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>Ctrl+Shift+M激活公式</p>
</blockquote>
<h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p><code>a^2+\ b_&#123;y_3&#125;</code></p>
<p>$$<br>a^2+\ b_{y_3}<br>$$</p>
<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><ul>
<li>中小括号</li>
</ul>
<p><code>(a+b)*[c+2]</code><br>$$<br>(a+b)*[c+2]<br>$$</p>
<ul>
<li>大括号需要加<code>\</code></li>
</ul>
<p><code>\&#123;1,2,3 \&#125;</code><br>$$<br>{1,2,3 }<br>$$</p>
<ul>
<li>尖括号</li>
</ul>
<p><code>\langle x \rangle</code><br>$$<br>\langle x \rangle<br>$$</p>
<ul>
<li>上下取整</li>
</ul>
<p><code>\lceil x \rceil+\lfloor y\rfloor</code><br>$$<br>\lceil x \rceil+\lfloor y\rfloor<br>$$</p>
<ul>
<li>特殊括号</li>
</ul>
<p><code>\begin&#123;pmatrix&#125; 1\ 2\\ 3\ 4 \end&#123;pmatrix&#125;\\ \begin&#123;bmatrix&#125; 1\ 2\\ 3\ 4 \end&#123;bmatrix&#125;\\ \begin&#123;Bmatrix&#125; 1\ 2\\ 3\ 4 \end&#123;Bmatrix&#125;\\ \begin&#123;vmatrix&#125; 1&amp; 2\\ 3&amp; 4 \end&#123;vmatrix&#125;\\ \begin&#123;Vmatrix&#125; 1&amp; 2\\ 3&amp; 4 \end&#123;Vmatrix&#125;\\</code><br>$$<br>\begin{pmatrix} 1\ 2\ 3\ 4 \end{pmatrix}\<br>\begin{bmatrix} 1\ 2\ 3\ 4 \end{bmatrix}\<br>\begin{Bmatrix} 1\ 2\ 3\ 4 \end{Bmatrix}\<br>\begin{vmatrix} 1&amp; 2\ 3&amp; 4 \end{vmatrix}\<br>\begin{Vmatrix} 1 &amp; 2\ 3 &amp; 4 \end{Vmatrix}\<br>$$</p>
<h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><p><code>1.\alpha\ A\\ 2.\beta\ B\\ 3.\gamma\ \Gamma\\ 4.\delta\ \Delta\\ 5.\epsilon\ E\\ 6.\zeta\ Z\\ 7.\eta\ H\\ 8.\theta\ \Theta\\ 9.\iota\ I\\ 10.\kappa\ K\\ 11.\lambda\ \Lambda\\ 12.\mu\ M\\ 13.\nu\ N\\ 14.\xi\ \Xi\\ 15.\omicron\ O\\ 16.\pi\ \Pi\\ 17.\rho\ P\\ 18.\sigma\ \Sigma\\ 19.\tau\ T\\ 20.\upsilon\ \Upsilon\\ 21.\phi\ \Phi\\ 22.\chi\ X\\ 23.\psi\ \Psi\\ 24.\omega\ \Omega\\</code><br>$$<br>1.\alpha\ A\<br>2.\beta\ B\<br>3.\gamma\ \Gamma\<br>4.\delta\ \Delta\<br>5.\epsilon\ E\<br>6.\zeta\ Z\<br>7.\eta\ H\<br>8.\theta\ \Theta\<br>9.\iota\ I\<br>10.\kappa\ K\<br>11.\lambda\ \Lambda\<br>12.\mu\ M\<br>13.\nu\ N\<br>14.\xi\ \Xi\<br>15.\omicron\ O\<br>16.\pi\ \Pi\<br>17.\rho\ P\<br>18.\sigma\ \Sigma\<br>19.\tau\ T\<br>20.\upsilon\ \Upsilon\<br>21.\phi\ \Phi\<br>22.\chi\ X\<br>23.\psi\ \Psi\<br>24.\omega\ \Omega\<br>$$</p>
<h3 id="根式分式"><a href="#根式分式" class="headerlink" title="根式分式"></a>根式分式</h3><p><code>\sqrt[x+y]&#123;\frac ab&#125;+\sqrt&#123;c+2\over 50+x&#125;</code><br>$$<br>\sqrt[x+y]{\frac ab}+\sqrt{c+2\over 50+x}<br>$$</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><code>ABCabc+\ \mathbb&#123; ABCabc&#125;+\ \Bbb&#123; ABCabc黑板粗体&#125;\\ ABCabc+\mathbf&#123;ABCabc黑体&#125;\\ ABCabc+\mathtt&#123;ABCabc打印字体&#125; \\ ABCabc+\mathrm&#123;ABCabc罗马字体&#125; \\ ABCabc+\mathscr&#123;ABCabc手写字体&#125; \\ ABCabc+\mathfrak&#123;ABCabc德国字体Fraktur&#125; </code><br>$$<br>ABCabc+\ \mathbb{ ABCabc}+\ \Bbb{ ABCabc黑板粗体}\<br>ABCabc+\mathbf{ABCabc黑体}\<br>ABCabc+\mathtt{ABCabc打印字体} \<br>ABCabc+\mathrm{ABCabc罗马字体} \<br>ABCabc+\mathscr{ABCabc手写字体} \<br>ABCabc+\mathfrak{ABCabc德国字体Fraktur}<br>$$</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><code>\begin&#123;array&#125;&#123;c|lcr&#125; n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\ \hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\ 2 &amp; -1 &amp; 189 &amp; -8 \\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\ \end&#123;array&#125;</code><br>$$<br>\begin{array}{c|lcr} n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \ \hline 1 &amp; 0.24 &amp; 1 &amp; 125 \ 2 &amp; -1 &amp; 189 &amp; -8 \ 3 &amp; -20 &amp; 2000 &amp; 1+10i \ \end{array}<br>$$</p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><code>\begin&#123;matrix&#125; 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \end&#123;matrix&#125;</code><br>$$<br>\begin{matrix} 1 &amp; x &amp; x^2 \ 1 &amp; y &amp; y^2 \ 1 &amp; z &amp; z^2 \end{matrix}<br>$$</p>
<h3 id="向量等顶部符号"><a href="#向量等顶部符号" class="headerlink" title="向量等顶部符号"></a>向量等顶部符号</h3><p><code>\vec&#123;abc&#125; \ ,\overline b\ ,\overrightarrow&#123;cde&#125; \ ,\dot c\ , \dot &#123;adb&#125;\ ,\ddot&#123;acd&#125;\ ,\dddot&#123;adfe&#125;</code><br>$$<br>\vec{abc} \ ,\overline b\ ,\overrightarrow{cde} \ ,\dot c\ , \dot {adb}\ ,\ddot{acd}\ ,\dddot{adfe}<br>$$</p>
<h3 id="对其"><a href="#对其" class="headerlink" title="对其"></a>对其</h3><p>需要使用&amp;来指示需要对齐的位置</p>
<p><code>\begin&#123;align&#125; \sqrt&#123;37&#125; &amp; = \sqrt&#123;\frac&#123;73^2-1&#125;&#123;12^2&#125;&#125; \\ &amp; = \sqrt&#123;\frac&#123;73^2&#125;&#123;12^2&#125; \cdot \frac&#123;73^2-1&#125;&#123;73^2&#125;&#125; \\ &amp; = \frac&#123;73&#125;&#123;12&#125; \sqrt&#123;1 - \frac&#123;1&#125;&#123;73^2&#125;&#125; \\ &amp; \approx \frac&#123;73&#125;&#123;12&#125; \left( 1 - \frac&#123;1&#125;&#123;2 \cdot 73^2&#125; \right) \end&#123;align&#125;</code><br>$$<br>\begin{align} \sqrt{37} &amp; = \sqrt{\frac{73^2-1}{12^2}} \ &amp; = \sqrt{\frac{73^2}{12^2} \cdot \frac{73^2-1}{73^2}} \ &amp; = \frac{73}{12} \sqrt{1 - \frac{1}{73^2}} \ &amp; \approx \frac{73}{12} \left( 1 - \frac{1}{2 \cdot 73^2} \right) \end{align}<br>$$</p>
<h3 id="分类表达式"><a href="#分类表达式" class="headerlink" title="分类表达式"></a>分类表达式</h3><p><code>f(n) = \begin&#123;cases&#125; n/2, &amp; \text&#123;if $n$ is even&#125; \\ 3n+1, &amp; \text&#123;if $n$ is odd&#125; \end&#123;cases&#125;</code><br>$$<br>f(n) = \begin{cases} n/2, &amp; \text{if $n$ is even} \ 3n+1, &amp; \text{if $n$ is odd} \end{cases}<br>$$<br><code>\left. \begin&#123;array&#125;&#123;l&#125; \text&#123;if $n$ is even:&#125; &amp; n/2 \\ \text&#123;if $n$ is odd:&#125; &amp; 3n+1 \end&#123;array&#125; \right\&#125; = f(n)</code><br>$$<br>\left. \begin{array}{l} \text{if $n$ is even:} &amp; n/2 \ \text{if $n$ is odd:} &amp; 3n+1 \end{array} \right} = f(n)<br>$$</p>
<h3 id="公式标记与引用"><a href="#公式标记与引用" class="headerlink" title="公式标记与引用"></a>公式标记与引用</h3><p><code>a:= x^2-y^3 \tag&#123;公式1&#125;\label&#123;公式1&#125;</code><br>$$<br>a:= x^2-y^3 \tag{公式1}\label{公式1}<br>$$<br><code>a+y^3 \stackrel&#123;\eqref&#123;公式1&#125;&#125;=x^2</code></p>
<p>$$<br>a+y^3 \stackrel{\eqref{公式1}}=x^2<br>$$</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>\to \rightarrow \leftarrow \Rightarrow \Leftarrow \mapsto</code><br>$$<br>\to \rightarrow \leftarrow \Rightarrow \Leftarrow \mapsto<br>$$<br><code>\lt \gt \le \ge \neq</code><br>$$<br>\lt \gt \le \ge \neq<br>$$</p>
<p><code>\sin x\\ \arctan_y\\ \lim_&#123;1\to\infty&#125;\\</code><br>$$<br>\sin x\<br>\arctan_y\<br>\lim_{1\to\infty}\<br>$$<br><code>\sum_1^n\ ,\int_1^&#123;x+y&#125;\ </code><br>$$<br>\sum_1^n\ ,\int_1^{x+y}<br>$$</p>
<h3 id="合集图片"><a href="#合集图片" class="headerlink" title="合集图片"></a>合集图片</h3><p><img src="https://img.supervj.top/img/DX/20190703164359871.png" alt="20190703164359871"></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>公式</tag>
      </tags>
  </entry>
  <entry>
    <title>MotionWarping深度研究</title>
    <url>/2021/10/27/MotionWarping%E6%B7%B1%E5%BA%A6%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UE5新加了实验性的插件<code>MotionWarping</code>, 先前已经有很多大佬写过类似的文章, 本文主要针对部分源码进行其工作原理的深入理解和相关RootMotion的思考</p>
<p><img src="https://img.supervj.top/imgimage-20211027191359070.png" alt="image-20211027191359070"></p>
<p><img src="https://img.supervj.top/imgimage-20211027192501459.png" alt="image-20211027192501459"></p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_10_27_19_12_34_828.gif" alt="录制_2021_10_27_19_12_34_828"></p>
<span id="more"></span>



<h2 id="从哪里开始"><a href="#从哪里开始" class="headerlink" title="从哪里开始?"></a>从哪里开始?</h2><p>我们先从这里开始看, 我们需要找到这个模块是在哪里修改了RootMotion信息, 先看调用栈</p>
<p><img src="https://img.supervj.top/imgimage-20211026171303258.png" alt="image-20211026171303258"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FTransform <span class="title">UCharacterMovementComponent::ConvertLocalRootMotionToWorld</span><span class="params">(<span class="keyword">const</span> FTransform&amp; LocalRootMotionTransform, <span class="keyword">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> FTransform PreProcessedRootMotion = ProcessRootMotionPreConvertToWorld.<span class="built_in">IsBound</span>() ? ProcessRootMotionPreConvertToWorld.<span class="built_in">Execute</span>(LocalRootMotionTransform, <span class="keyword">this</span>, DeltaSeconds) : LocalRootMotionTransform;</span><br><span class="line">   <span class="keyword">const</span> FTransform WorldSpaceRootMotion = CharacterOwner-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">ConvertLocalRootMotionToWorld</span>(PreProcessedRootMotion);</span><br><span class="line">   <span class="keyword">return</span> ProcessRootMotionPostConvertToWorld.<span class="built_in">IsBound</span>() ? ProcessRootMotionPostConvertToWorld.<span class="built_in">Execute</span>(WorldSpaceRootMotion, <span class="keyword">this</span>, DeltaSeconds) : WorldSpaceRootMotion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>角色移动组件里有这个把RootMotion数据从本地转换成世界的方法</p>
<p>这里有两个带返回值的代理, 分别针对预处理Pre和后处理Post</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMotionWarpingComponent::InitializeComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//..............</span></span><br><span class="line">	<span class="keyword">if</span> (CharacterMovementComp)</span><br><span class="line">	&#123;</span><br><span class="line">		CharacterMovementComp-&gt;ProcessRootMotionPreConvertToWorld.<span class="built_in">BindUObject</span>(<span class="keyword">this</span>, &amp;UMotionWarpingComponent::ProcessRootMotionPreConvertToWorld);</span><br><span class="line">		CharacterMovementComp-&gt;ProcessRootMotionPostConvertToWorld.<span class="built_in">BindUObject</span>(<span class="keyword">this</span>, &amp;UMotionWarpingComponent::ProcessRootMotionPostConvertToWorld);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>MotionWarping</code>组件中绑定了移动组件的2个代理, 在Pre函数中调用了<code>Update()</code>函数(后面讲)来刷新修改类器<code>URootMotionModifier</code>信息</p>
<p> 然后统一都执行修改器类的虚函数<code>ProcessRootMotion()</code>修改变换信息</p>
<blockquote>
<p>小结: MotionWarping的思路就是对移动组件需要用到RootMotion数据的前后(Pre/Post)进行数据额外处理, 最终反馈给移动组件进行更进步的RootMotion的处理</p>
</blockquote>
<h2 id="动画通知"><a href="#动画通知" class="headerlink" title="动画通知"></a>动画通知</h2><p><img src="https://img.supervj.top/imgimage-20211026172347474.png" alt="image-20211026172347474"></p>
<p><img src="https://img.supervj.top/imgimage-20211026172613061.png" alt="image-20211026172613061"></p>
<p><code>MotionWarping</code>使用第一步就是往动画里添加动画通知</p>
<p>看了源码发现这个通知不按常理出牌, <code>Begin/Tick/End</code>虚函数都没重写, 所以, 这个通知就真的只是一个<strong>配置作用</strong></p>
<blockquote>
<p>如果动画通知是放在AnimSequence上的, 那么需要勾选MotionWarping组件的bSearchForWindowsInAnimsWithinMontage选项, 因为默认是只在蒙太奇内查找, 勾选以后会额外从蒙太奇的每个片段动画序列中去查找, 同时会增加开销</p>
</blockquote>
<p><img src="https://img.supervj.top/imgimage-20211026180158230.png" alt="image-20211026180158230"></p>
<h2 id="UMotionWarpingComponent"><a href="#UMotionWarpingComponent" class="headerlink" title="UMotionWarpingComponent"></a>UMotionWarpingComponent</h2><h3 id="Update"><a href="#Update" class="headerlink" title="Update()"></a>Update()</h3><p>看名字以为是<code>Tick()</code>函数, 实则是上面从移动组件监听的代理的回调事件, 在<code>Pre</code>过程中先调用<code>Update()</code>函数, 换句话说就是RootMotion有更新的时候会先调用到这里</p>
<p>用伪代码来描述这个过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(当前有播放蒙太奇)</span><br><span class="line">&#123;</span><br><span class="line">    遍历蒙太奇所有通知</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(当前播放位置在通知返回内)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(通知里的修改器对象骄傲没有添加到数组中)</span><br><span class="line">            &#123;</span><br><span class="line">                通过通知类激活修改器对象并添加到数组中</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要稍微看一下通知里的一个方法 <code>UAnimNotifyState_MotionWarping::OnBecomeRelevant()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAnimNotifyState_MotionWarping::OnBecomeRelevant</span><span class="params">(UMotionWarpingComponent* MotionWarpingComp, <span class="keyword">const</span> UAnimSequenceBase* Animation, <span class="keyword">float</span> StartTime, <span class="keyword">float</span> EndTime)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	URootMotionModifier* RootMotionModifierNew = <span class="built_in">AddRootMotionModifier</span>(MotionWarpingComp, Animation, StartTime, EndTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (RootMotionModifierNew)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!RootMotionModifierNew-&gt;OnActivateDelegate.<span class="built_in">IsBound</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			RootMotionModifierNew-&gt;OnActivateDelegate.<span class="built_in">BindDynamic</span>(<span class="keyword">this</span>, &amp;UAnimNotifyState_MotionWarping::OnRootMotionModifierActivate);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!RootMotionModifierNew-&gt;OnUpdateDelegate.<span class="built_in">IsBound</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			RootMotionModifierNew-&gt;OnUpdateDelegate.<span class="built_in">BindDynamic</span>(<span class="keyword">this</span>, &amp;UAnimNotifyState_MotionWarping::OnRootMotionModifierUpdate);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!RootMotionModifierNew-&gt;OnDeactivateDelegate.<span class="built_in">IsBound</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			RootMotionModifierNew-&gt;OnDeactivateDelegate.<span class="built_in">BindDynamic</span>(<span class="keyword">this</span>, &amp;UAnimNotifyState_MotionWarping::OnRootMotionModifierDeactivate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前说的动画通知啥也没干也不完全正确, 这里动画通知创建了修改器(Modifier)对象, 把动画数据塞给它, 同时监听修改器类的回调事件, 然后调用到是蓝图事件</p>
<p><img src="https://img.supervj.top/imgimage-20211026173754546.png" alt="image-20211026173754546"></p>
<blockquote>
<p>理论上可以进行蓝图扩展, 不过怎么感觉也不是很方便呢?  你给我一个const函数图我修改啥?</p>
</blockquote>
<hr>
<p>接下来就是遍历所有修改器对象刷新其状态, 如有必要广播修改器对象的内部代理事件,  然后移除标记为<code>MarkedForRemoval</code>的修改器对象</p>
<h3 id="WarpTargetMap"><a href="#WarpTargetMap" class="headerlink" title="WarpTargetMap"></a>WarpTargetMap</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">TMap&lt;FName, FMotionWarpingTarget&gt; WarpTargetMap;</span><br></pre></td></tr></table></figure>

<p>只用通知不能运行MotionWarping, 需要通过代码或者蓝图Api往组件内添加WarpTargetMap成员</p>
<p><img src="https://img.supervj.top/imgimage-20211026175825781.png" alt="image-20211026175825781"></p>
<p>每个动画通知都配置有一个FName用来查找WarpTarget, 在完成以后会标记为移除</p>
<h2 id="Modifier类"><a href="#Modifier类" class="headerlink" title="Modifier类"></a>Modifier类</h2><p>对RootMotion数据处理的核心就是这个类, 在插件内派生了下面几个类</p>
<p>URootMotionModifier</p>
<ul>
<li>URootMotionModifier_Warp<ul>
<li>URootMotionModifier_SkewWarp</li>
<li>URootMotionModifier_AdjustmentBlendWarp</li>
<li>UDEPRECATED_RootMotionModifier_SimpleWarp(这个在5.1中被作废了, 可以用SkewWarp代替)</li>
</ul>
</li>
<li>URootMotionModifier_Scale</li>
</ul>
<p>接下来逐一细看</p>
<blockquote>
<p><strong>下面这部分主要是数据和计算, 可以略过</strong></p>
</blockquote>
<h3 id="URootMotionModifier"><a href="#URootMotionModifier" class="headerlink" title="URootMotionModifier"></a>URootMotionModifier</h3><p>基类, 声明了与动画相关的基础数据, 如<strong>开始/结束时间</strong>, <strong>上一帧/当前帧的时间</strong>等等, 这些数据都不需要在动画通知中配置, 另外也定义了通知的状态枚举和相应的代理,  一部分声明属性如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TWeakObjectPtr&lt;const UAnimSequenceBase&gt; Animation = nullptr;</span><br><span class="line">float StartTime = 0.f;</span><br><span class="line">float EndTime = 0.f;</span><br><span class="line">float PreviousPosition = 0.f;</span><br><span class="line">float CurrentPosition = 0.f;</span><br><span class="line">float Weight = 0.f;</span><br><span class="line">FOnRootMotionModifierDelegate OnActivateDelegate;</span><br></pre></td></tr></table></figure>

<h3 id="FMotionWarpingTarget"><a href="#FMotionWarpingTarget" class="headerlink" title="FMotionWarpingTarget"></a>FMotionWarpingTarget</h3><p>作为适配目标信息的一个数据结构,   在MotionWarpingComponent中最为TMap存储起来, 主要属性如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FTransform Transform;</span><br><span class="line">TWeakObjectPtr&lt;const USceneComponent&gt; Component;</span><br><span class="line">FName BoneName;</span><br><span class="line">bool bFollowComponent;</span><br></pre></td></tr></table></figure>



<h3 id="URootMotionModifier-Warp"><a href="#URootMotionModifier-Warp" class="headerlink" title="URootMotionModifier_Warp"></a>URootMotionModifier_Warp</h3><p>我们在蓝图中可以配置的属性都在这个类中申明, 在UE5.1中额外增加了<code>WarpPointAnimProvider</code>以及于此相关属性</p>
<p>重写了<code>update()</code>函数, 主要增加了<code>EWarpPointAnimProvider</code>相关的逻辑</p>
<h4 id="EWarpPointAnimProvider"><a href="#EWarpPointAnimProvider" class="headerlink" title="EWarpPointAnimProvider"></a>EWarpPointAnimProvider</h4><p>主要用来定义目标Transform的空间,  默认为None, 即设定的目标Transform就是最终的目标, 可以选择静态或者骨骼两个类型来进行转换</p>
<ul>
<li>static</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (WarpPointAnimProvider == EWarpPointAnimProvider::Static)</span><br><span class="line">&#123;</span><br><span class="line">   RootTransform = MeshCompRelativeRotInverse * UMotionWarpingUtilities::<span class="built_in">ExtractRootTransformFromAnimation</span>(<span class="built_in">GetAnimation</span>(), EndTime);</span><br><span class="line">   WarpPointTransform = MeshCompRelativeRotInverse * WarpPointAnimTransform;</span><br><span class="line">&#125;</span><br><span class="line">CachedOffsetFromWarpPoint = RootTransform.<span class="built_in">GetRelativeTransform</span>(WarpPointTransform);</span><br><span class="line">TargetTransform = CachedOffsetFromWarpPoint.<span class="built_in">GetValue</span>() * WarpPointTransformGame;</span><br></pre></td></tr></table></figure>

<p>所以就是静态的目标TargetTransform 进行了一个偏移运算</p>
<ul>
<li>Bone</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RootTransform = MeshCompRelativeRotInverse * Pose.GetComponentSpaceTransform(FCompactPoseBoneIndex(0));</span><br><span class="line">WarpPointTransform = MeshCompRelativeRotInverse * Pose.GetComponentSpaceTransform(FCompactPoseBoneIndex(1));</span><br></pre></td></tr></table></figure>

<p>类似的省略, 主要就是上述两行代码, 选择设定的BoneName的骨骼以及下一级骨骼的空间作为参考进行Transform变换, 暂时没想到可以用于哪种场景</p>
<h4 id="EMotionWarpRotationType"><a href="#EMotionWarpRotationType" class="headerlink" title="EMotionWarpRotationType"></a>EMotionWarpRotationType</h4><p>旋转类型, 分<code>Default</code>和<code>Facing</code>两种</p>
<p>Default即保持原来的旋转</p>
<p>Facing即一直保持LookAt目标Location</p>
<h3 id="URootMotionModifier-SkewWarp"><a href="#URootMotionModifier-SkewWarp" class="headerlink" title="URootMotionModifier_SkewWarp"></a>URootMotionModifier_SkewWarp</h3><p>计算都放在函数<code>ProcessRootMotion()</code>中, 包括其他几个修改器类</p>
<p>用伪代码看看这个类怎么处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    从动画数据中获取最终的变换信息(Transform);</span><br><span class="line">    从动画数据中获取delta变换信息;</span><br><span class="line">    <span class="keyword">if</span>(开启位置适配 &amp;&amp; delta信息不为<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        最终变换信息转换到世界空间;</span><br><span class="line">        delta变换信息转换到世界空间;</span><br><span class="line">        计算原始的偏移和期望的偏移, 这里包括最终的和delta的;</span><br><span class="line">        计算出最适配的轴向并构造出最佳空间变换信息;</span><br><span class="line">        把前面的变换信息转换到最佳空间中;</span><br><span class="line">        计算yaw和pitch的偏移角度和缩放值;</span><br><span class="line">        把偏移角度和缩放更新到新的变换信息FinalRootMotion的Translation中;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(开启旋转适配)</span><br><span class="line">    &#123;</span><br><span class="line">        计算期望和当前旋转的偏移;</span><br><span class="line">        把偏移应用到FinalRootMotion的Rotation中;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>简单概括就是通过改变RootMotion的delta位置和旋转信息来达到期望目标  </p>
</blockquote>
<h3 id="URootMotionModifier-AdjustmentBlendWarp"><a href="#URootMotionModifier-AdjustmentBlendWarp" class="headerlink" title="URootMotionModifier_AdjustmentBlendWarp"></a>URootMotionModifier_AdjustmentBlendWarp</h3><p>计算比较复杂, 具体不展开, 参考知乎大佬的结论</p>
<blockquote>
<p>Adjustment Blend Warp缩放算法采用与Simple Warp完全不同的缩放思路。该算法是在第一次缩放时，就计算好窗口期间，root骨骼在组件空间下的缩放差值，也就是root骨骼的Mesh空间缩放叠加动画，每帧对RootMotion源动画并应用缩放叠加动画，从而实现缩放。采用这种算法，不仅可以针对root骨骼叠加动画数据进行缩放，理论还能针对骨架上的任意骨骼进行同样的缩放，因此Adjustment Blend Warp缩放支持配置，针对ik骨骼进行缩放。比如对带脚步移动的RootMotion动画应用Adjustment Blend Warp缩放，不仅能够灵活缩放位移，配合TwoBone IK，还能规避缩放位移导致的腿部滑步表现。</p>
</blockquote>
<h3 id="URootMotionModifier-Scale"><a href="#URootMotionModifier-Scale" class="headerlink" title="URootMotionModifier_Scale"></a>URootMotionModifier_Scale</h3><p>简单粗暴的在窗口期缩放RootMotion的数据, 适用场景有限</p>
<h2 id="关于RootMotion"><a href="#关于RootMotion" class="headerlink" title="关于RootMotion"></a>关于RootMotion</h2><p>可以从上面得知, MotionWarping从动画资源中获取RootMotion数据, 那么有必要看一下这个数据怎么获取</p>
<p>还是从移动组件的<code>PerformMovement()</code>开始</p>
<p>RootMotion数据是从下面代码中的<code>TickCharacterPose()</code>获取的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( CharacterOwner-&gt;<span class="built_in">IsPlayingRootMotion</span>() &amp;&amp; CharacterOwner-&gt;<span class="built_in">GetMesh</span>() )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">TickCharacterPose</span>(DeltaSeconds);</span><br><span class="line">   		&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要判断是否处于RootMotion中, 然而看代码到深处, 看到如果RootMotion模式使用的默认RootMotionFromMontagesOnly的情况下, 那就取决于当前的<code>MontageInstance</code>对象是否开启了RootMotion, 测试发现这个<code>MontageInstance</code>在蒙太奇BlendOut的时候已经被清理了, </p>
<p>这个要从Montage的刷新开始看</p>
<p><img src="https://img.supervj.top/imgimage-20211027155327565.png" alt="image-20211027155327565"></p>
<p>上图看调用栈, 重点是要看一下什么时候清理, 看下面代码, 位于<code>FAnimMontageInstance::Advance()</code>中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (PlayTimeToEnd &lt;= FMath::Max&lt;<span class="keyword">float</span>&gt;(BlendOutTriggerTime, KINDA_SMALL_NUMBER))</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">float</span> BlendOutTime = bCustomBlendOutTriggerTime ? DefaultBlendOutTime : PlayTimeToEnd;</span><br><span class="line">   <span class="built_in">Stop</span>(<span class="built_in">FAlphaBlend</span>(Montage-&gt;BlendOut, BlendOutTime), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以就解释清楚了</p>
<p>那么如果改成<code>RootMotionForEveryThing</code>呢?</p>
<p>测试发现可以正常的进行计算, 但是RootMotion数据会因为混合权重值而进行<strong>缩放</strong>, 大致可以看下面位于AnimInstance中的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blend in any montage-blended root motion that we now have correct weights for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> FQueuedRootMotionBlend&amp; RootMotionBlend : RootMotionBlendQueue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> RootMotionSlotWeight = <span class="built_in">GetSlotNodeGlobalWeight</span>(RootMotionBlend.SlotName);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> RootMotionInstanceWeight = RootMotionBlend.Weight * RootMotionSlotWeight;</span><br><span class="line">    ExtractedRootMotion.<span class="built_in">AccumulateWithBlend</span>(RootMotionBlend.Transform, RootMotionInstanceWeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>ExtractedRootMotion</code>是被提取的RootMotion数据, 那么即使Modifier对象能拿到数据, 这个数据也是被缩放过的</p>
<p>那么理论上来说, 如果能拿到数据, 即使缩放过, 再反向补偿回去是否可行?</p>
<p> 然而并不能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMotionWarpingComponent::Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> FAnimMontageInstance* RootMotionMontageInstance = <span class="built_in">GetCharacterOwner</span>()-&gt;<span class="built_in">GetRootMotionAnimMontageInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这一行代码已经把MotionWarping的处理可以终止了, 因为已经拿不到<code>MotionMontageInstance</code>对象了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>MotionWarping</code>改的是<code>CharacterMovementComponent</code>对RootMotion处理阶段的中间数据</li>
<li><code>MotionWarping</code>通过动态创建的Modifier修改器对象来修改</li>
<li><strong>动画通知</strong>用来配置时间窗口和修改器类型</li>
<li>需要配合动画通知窗口在通知运行之前设定目标位移/旋转</li>
<li><code>MotionWarping</code>依赖<code>RootMotionInstance</code>对象, 此对象在蒙太奇BlendOut的时候会被清理, 所以BlendOut过程中没有<code>MotionWarping</code>效果</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/378948277">知乎大佬</a></li>
<li><a href="https://www.youtube.com/watch?v=SM_AR-oZ-1k">油管InsideUnreal</a></li>
<li><a href="https://docs.unrealengine.com/5.0/zh-CN/AnimationFeatures/MotionWarping/">Epic官网</a></li>
</ol>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>PSO入门和踩坑史</title>
    <url>/2023/03/02/PSO/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>管线状态对象</strong>（PSO）缓存工具可用于减轻虚幻引擎4关卡加载内容块时出现的卡顿, </p>
<p>比如在进游戏第一次开枪, 开枪的火花特效就会造成卡顿</p>
<p>这些现象在性能较弱的移动端尤其明显</p>
<p>本文简单记录一下PSO的整个流程, 目标平台Meta Quest2(Android), 版本4.27-plus</p>
<p><a href="https://docs.unrealengine.com/4.27/zh-CN/SharingAndReleasing/PSOCaching/">官网链接(4.27)</a></p>
<span id="more"></span>

<p><img src="https://docs.unrealengine.com/4.27/Images/SharingAndReleasing/PSOCaching/PSO_Caching_Digramh.jpg"></p>
<p>借用官网的图, 下面开始整个流程, 当中踩了不少坑,  一部分要归功于不是很有条理的官方文档</p>
<p>建议严格按照本文的笔记进行, 当中有不少容易踩的坑</p>
<h2 id="收集缓存"><a href="#收集缓存" class="headerlink" title="收集缓存"></a>收集缓存</h2><p>要收集缓存的前提是为项目开启<code>ShaderStableKeys</code></p>
<p>我们是在安卓平台的, 那么就要在<code>Project\Config\Android\AndroidEngine.ini</code>文件(没有就新建)内添加下面2行</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[DevOptions.Shaders]</span></span><br><span class="line"><span class="attr">NeedsShaderStableKeys</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如果不添加, 那么这一步的数据就得不到, </p>
<p>这里不得不提一下第一个坑, 来自官网的错误, <strong>4.27已经将后缀为<code>scl.csv</code>的文件改成了<code>shk</code>了</strong></p>
<p>因为接下来要打包, 在打包之前添加几个渲染参数, 这个可以借鉴官网的方式</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230303141817574.png" alt="image-20230303141817574"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230303141922574.png" alt="image-20230303141922574"></p>
<p>选择对应平台, 添加console变量, 图上的是必须的</p>
<p>还可以用同样方式添加额外的2个变量, 用于开启相关日志</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">r.ShaderPipelineCache.LogPSO</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">r.ShaderPipelineCache.SaveBoundPSOLog</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>或者, 直接把这些控制变量添加到<code>DefaultEngine.ini</code>中</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">Config/DefaultEngine.ini</span><br><span class="line"><span class="section">[ConsoleVariables]</span></span><br><span class="line"><span class="attr">r.ShaderPipelineCache.Enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">r.ShaderPipelineCache.LogPSO</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">r.ShaderPipelineCache.SaveBoundPSOLog</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>





<p>接下来的目的是完成cook,  官网通过<code>ProjectLaunchuer</code>来cook, 如果你对此不熟悉, 那么完全可以用直接打包或者launcher游戏来进行</p>
<p>cook后会产生下面2个文件(项目图形api选的是vulkan)</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230303141502316.png" alt="image-20230303141502316"></p>
<h2 id="跑图"><a href="#跑图" class="headerlink" title="跑图"></a>跑图</h2><p>上面已经打包了, 接下来就是跑图, 尽量跑尽各个角落, 触发各个带材质的效果</p>
<p>然后就能在设备的游戏路劲内发现后缀为<code>.rec.upipelinecache</code>的一个文件, quest2的路径为下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230303142642280.png" alt="image-20230303142642280"></p>
<p>拷贝出来, 可以将前面的2个<code>,shk</code>和这个文件放一起, 本案例都放在了<code>E:\PSO</code>内</p>
<p>所以到这一步应该拥有下列3个文件</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230303142907062.png" alt="image-20230303142907062"></p>
<h2 id="生成csv"><a href="#生成csv" class="headerlink" title="生成csv"></a>生成csv</h2><p>这一步的<a href="https://docs.unrealengine.com/4.27/zh-CN/SharingAndReleasing/PSOCaching/BuildingPSOCache/">官方文档</a></p>
<p>接下来我们的利用引擎自己的command工具, 将上述3个文件生成一个新的<code>csv</code>文件, 这个文件记录了所有需要的<code>shader</code>信息</p>
<p>找到引擎<code> Engine\Binaries\Win64</code>下的<code>UE4Editor-Cmd.exe</code>, 创建快捷方式,建议把这个快捷方式一起丢到我们的数据文件目录</p>
<p>接下来就是给快捷方式添加一串启动指令</p>
<blockquote>
<p> 又是坑, 按照官网说的输入命令保证就让人痛不欲生了</p>
</blockquote>
<p>我这里最终的指令是如下,项目路径替换成自己的, <code>E:/PSO/</code>是放数据的路径</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">项目路径/NextVR.uproject <span class="attr">-run</span>=ShaderPipelineCacheTools expand E:/PSO/*.rec.upipelinecache E:/PSO/*.shk NextVR_SF_VULKAN_ES31_ANDROID.stablepc.csv</span><br></pre></td></tr></table></figure>

<p>如果是图形是GL, 文件名称应该是<code>项目名称_GLSL_ES3_1_ANDROID.stablepc.csv</code></p>
<p>运行以后生成如下文件</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230303143819832.png" alt="image-20230303143819832"></p>
<p>这里很有可能没有在当前目录生成这个文件,  去引擎的<code>Binaries/Win64</code>下找</p>
<blockquote>
<p> 如果没有生成, 那一定是前面哪一步做错了</p>
</blockquote>
<h2 id="再次打包"><a href="#再次打包" class="headerlink" title="再次打包"></a>再次打包</h2><p>到这里我们已经有了所需要的数据文件了</p>
<p>把这个<code>.stablepc.csv</code>文件放到<code>Build\Android\PipelineCaches</code>中,</p>
<blockquote>
<p>注意: 这个路径只跟发布平台有关,  不管Android-ASTC还是其他都统一是Android</p>
</blockquote>
<p>然后打包, 正常情况, 打包 的时候会出现若干条下面格式的日志</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Loaded %d shader info lines from %.*s.&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果没有报错, 那么打包就是成功了, 确保万无一失, 去设备的游戏路径下查看</p>
<p>在<code>Content</code>下会出现一个新的叫<code>PipelineCaches</code>的文件夹,  里面有一个后缀是<code>.stable.upipelinecache</code>的数据文件, 这就对了</p>
<p>完成!</p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>shader</tag>
        <tag>优化</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>MaxScript学习笔记</title>
    <url>/2021/03/26/MaxScript/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MaxScript学习笔记</p>
<blockquote>
<p>搬运至遥远的2019年</p>
</blockquote>
<span id="more"></span>

<h2 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h2><p><code>\AppData\Local\Autodesk\3dsMax\2018 - 64bit\CHS\scripts\startup</code></p>
<p>把ms文件放到启动文件夹下，启动max就启动脚本</p>
<h2 id="快捷添加"><a href="#快捷添加" class="headerlink" title="快捷添加"></a>快捷添加</h2><ul>
<li>用下面代码包裹一个ms代码，存为类型mcr格式</li>
<li>放到路径<code>\AppData\Local\Autodesk\3dsMax\2018 - 64bit\CHS\usermacros</code>，重新启动max</li>
<li>或者直接在编辑器模式下运行宏命令会直接添加到路径</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">macroScript VextexCacheTool   <span class="comment">--具体类别里的名称             </span></span><br><span class="line">        category:<span class="string">&quot;VJ&quot;</span>    <span class="comment">--显示的类别</span></span><br><span class="line">        toolTip:<span class="string">&quot;&quot;</span>                        </span><br><span class="line">	(</span><br><span class="line">    <span class="comment">-- 把ms脚本粘贴进来</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20200421095311706.png" alt="image-20200421095311706"></p>
<h2 id="语法记录"><a href="#语法记录" class="headerlink" title="语法记录"></a>语法记录</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mybox=box()</span><br><span class="line">$Box:Box001 @ [<span class="number">0.000000</span>,<span class="number">0.000000</span>,<span class="number">0.000000</span>]</span><br><span class="line">mybox.lengthsegs=<span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">mybox.heightsegs=<span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">addModifier mybox (twist angle:<span class="number">30</span>)</span><br><span class="line">OK</span><br><span class="line">mybox.twist.angle=<span class="number">99</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line">mybox.twist.offset=<span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">addModifier mybox (spherify percent:<span class="number">50</span>)</span><br><span class="line">OK</span><br><span class="line">mybox.spherify.percent=<span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><ul>
<li>独立单一窗口</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">try destroyDialog ::TestRoll catch() <span class="comment">--关闭已有窗口</span></span><br><span class="line">rollout TestRoll <span class="string">&quot;TestRoll&quot;</span> </span><br><span class="line">(</span><br><span class="line">    button myBtn <span class="string">&quot;MyButton&quot;</span> width:<span class="number">200</span> height:<span class="number">100</span></span><br><span class="line">  </span><br><span class="line">)</span><br><span class="line">CreateDialog TestRoll width:<span class="number">250</span> height:<span class="number">300</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>效果</p>
<p><img src="https://img.supervj.top//img/image-20200423175159452.png" alt="image-20200423175159452"></p>
</blockquote>
<ul>
<li>多个rollout</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">  global Morph_Floater = newRolloutFloater <span class="string">&quot;&quot;</span> <span class="number">200</span> <span class="number">230</span> </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">rollout tt <span class="string">&quot;Test Tool&quot;</span> </span><br><span class="line">(</span><br><span class="line">	button bt2 <span class="string">&quot;test&quot;</span> height:<span class="number">30</span> width:<span class="number">200</span> </span><br><span class="line">	</span><br><span class="line">)</span><br><span class="line">addRollout tt Morph_Floater</span><br><span class="line"></span><br><span class="line">rollout tt2 <span class="string">&quot;Test Tool2&quot;</span> </span><br><span class="line">(</span><br><span class="line">	button bt2 <span class="string">&quot;test2&quot;</span> height:<span class="number">30</span> width:<span class="number">200</span> </span><br><span class="line">	</span><br><span class="line">)</span><br><span class="line">addRollout tt2 Morph_Floater</span><br></pre></td></tr></table></figure>

<blockquote>
<p>效果</p>
<p><img src="https://img.supervj.top//img/image-20200423175135064.png" alt="image-20200423175135064"></p>
</blockquote>
<h4 id="button"><a href="#button" class="headerlink" title="button"></a>button</h4><ul>
<li>设置图片 </li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">button BakeBtn <span class="string">&quot;开始烘培&quot;</span> height:<span class="number">80</span> width:<span class="number">250</span> images:#(GetDir #maxSysIcons+<span class="string">&quot;\CAT_CATMode_a.bmp&quot;</span>, undefined, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span> ) iconSize:[<span class="number">200</span>,<span class="number">80</span>]</span><br></pre></td></tr></table></figure>







<h3 id=""><a href="#" class="headerlink" title="$"></a>$</h3><ul>
<li>一般用法是指选中的物体，比如</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">$.name <span class="comment">--选中物体的名字</span></span><br><span class="line">#.height	<span class="comment">--选中物体的高度</span></span><br></pre></td></tr></table></figure>

<ul>
<li>特定物体</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">$box01.height=<span class="number">10</span> <span class="comment">--把名称为box01的物体的高度设置为10</span></span><br></pre></td></tr></table></figure>



<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mybox =box()</span><br><span class="line">animate on</span><br><span class="line">(</span><br><span class="line">  at <span class="built_in">time</span> <span class="number">0</span> (mybox.pos = [<span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>]; mybox.scale = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0.25</span>])</span><br><span class="line">  at <span class="built_in">time</span> <span class="number">100</span> (mybox.pos = [<span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>]; mybox.scale = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">)<span class="comment">--设置动画</span></span><br><span class="line">playanimation()<span class="comment">--播放</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> mybox.height == <span class="number">10</span></span><br><span class="line"><span class="keyword">then</span> mybox.width = <span class="number">20</span></span><br><span class="line"><span class="keyword">else</span> mybox.width = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">mybox.width = <span class="keyword">if</span> mybox.height == <span class="number">10</span> <span class="keyword">then</span> <span class="number">20</span> <span class="keyword">else</span> <span class="number">10</span>   <span class="comment">--类似C++ 的 ?:</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title="=="></a>==</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">== <span class="comment">--equal to</span></span><br><span class="line"></span><br><span class="line">!= <span class="comment">--not equal to</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">--greater than</span></span><br><span class="line"></span><br><span class="line">&gt;= <span class="comment">--greater than or equal to</span></span><br><span class="line"></span><br><span class="line">&lt; <span class="comment">--less than</span></span><br><span class="line"></span><br><span class="line">&lt;= <span class="comment">--less than or equal to</span></span><br></pre></td></tr></table></figure>



<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> var = value to array.count by <span class="number">-1</span> where (condition) <span class="keyword">do</span> (</span><br><span class="line">    </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一堆box</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mybox =box()</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to <span class="number">10</span> <span class="keyword">do</span> (</span><br><span class="line">    copy_box=copy mybox</span><br><span class="line">    copy_box.pos=[i*<span class="number">30</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    copy_box.wirecolor=[i*<span class="number">25</span>,i*<span class="number">50</span>,<span class="number">50</span>]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20200421163756826.png" alt="image-20200421163756826"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">arr = <span class="keyword">for</span> i =<span class="number">1</span> to <span class="number">5</span> collect i</span><br><span class="line"><span class="comment">--#(1, 2, 3, 4, 5)</span></span><br><span class="line">arr2=#(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">555</span>,<span class="number">44</span>)</span><br><span class="line"><span class="comment">--#(1, 2, 3, 555, 44)</span></span><br><span class="line">a = #()<span class="comment">--空数组</span></span><br><span class="line">a = #(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">joint a #(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)<span class="comment">-- a数组加入4,5,6</span></span><br><span class="line">a.count <span class="comment">--数量</span></span><br><span class="line">c=($box* as Array)+($Sphere* as Array) <span class="comment">--把所有box和spehre名称的作为数组并且相加</span></span><br><span class="line">append c ($Cone* as Array) <span class="comment">--把所有Cone作为数组成员添加到c</span></span><br></pre></td></tr></table></figure>

<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">x=<span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="built_in">print</span>(x-=<span class="number">1</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">fn fun1 v:<span class="number">0</span>=(</span><br><span class="line"><span class="keyword">if</span> v==<span class="number">0</span> <span class="keyword">then</span> <span class="built_in">print</span> <span class="string">&quot;good&quot;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> v&gt;<span class="number">0</span> <span class="keyword">then</span> messagebox (<span class="string">&quot;greater than 0&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> messagebox (<span class="string">&quot;too low&quot;</span>)</span><br><span class="line">)</span><br><span class="line">        </span><br><span class="line">fun1 v:<span class="number">-9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Struct person (name,sex,age)</span><br><span class="line">joe=person name:<span class="string">&quot;helo&quot;</span> sex:#male age:<span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(joe.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="max命令"><a href="#max命令" class="headerlink" title="max命令"></a>max命令</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span> file ? <span class="comment">--显示file下面的命令 </span></span><br><span class="line"><span class="built_in">max</span> file <span class="built_in">open</span> <span class="comment">-- 打开文件</span></span><br></pre></td></tr></table></figure>

<h3 id="脚本：批量重命名"><a href="#脚本：批量重命名" class="headerlink" title="脚本：批量重命名"></a>脚本：批量重命名</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">macroScript RenameThem   <span class="comment">--运行以后生成宏，可以放到快捷方式上</span></span><br><span class="line">    category:<span class="string">&quot;HowTo&quot;</span></span><br><span class="line">    ButtonText:<span class="string">&quot;RenameThem&quot;</span></span><br><span class="line">    toolTip:<span class="string">&quot;Rename&quot;</span></span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    </span><br><span class="line">    rollout rename_rollout <span class="string">&quot;Enter New Base Name&quot;</span></span><br><span class="line">    (</span><br><span class="line">        edittext base_name <span class="string">&quot;&quot;</span></span><br><span class="line">        button rename_them <span class="string">&quot;RENAME&quot;</span></span><br><span class="line">        On rename_them pressed <span class="keyword">do</span> </span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">if</span> base_name.text!=<span class="string">&quot;&quot;</span> <span class="keyword">do</span> (</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> selection <span class="keyword">do</span> i.name=uniquename base_name.text  <span class="comment">--uniquename保证不重名</span></span><br><span class="line">            ) </span><br><span class="line">        ) </span><br><span class="line">    )</span><br><span class="line">    CreateDialog rename_rollout <span class="number">250</span> <span class="number">50</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="脚本：批量选择偶数面"><a href="#脚本：批量选择偶数面" class="headerlink" title="脚本：批量选择偶数面"></a>脚本：批量选择偶数面</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">rollout TestRoll <span class="string">&quot;TestRoll&quot;</span> </span><br><span class="line">(</span><br><span class="line">    button myBtn <span class="string">&quot;MyButton&quot;</span> width:<span class="number">200</span> height:<span class="number">100</span></span><br><span class="line">  </span><br><span class="line">    on myBtn Pressed <span class="keyword">do</span> (</span><br><span class="line">        <span class="keyword">if</span> selection.count==<span class="number">1</span> <span class="keyword">and</span> classOf selection[<span class="number">1</span>].baseobject==Editable_Poly <span class="keyword">then</span></span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">local</span> face_selection=#&#123;&#125;   <span class="comment">--选择的面，值为bool</span></span><br><span class="line">                <span class="keyword">local</span> base_obj = $.baseobject   <span class="comment">--选择的物体转换为baseobject</span></span><br><span class="line">                <span class="keyword">local</span> num_faces=polyop.getNumFaces (base_obj) <span class="comment">--得到所有面</span></span><br><span class="line">                <span class="built_in">print</span>(num_faces)  </span><br><span class="line">                <span class="keyword">for</span> f=<span class="number">1</span> to num_faces <span class="keyword">do</span> </span><br><span class="line">                (</span><br><span class="line">                    <span class="keyword">local</span> isSelect=((<span class="built_in">mod</span> f <span class="number">2</span>)==<span class="number">0</span>)  <span class="comment">--选择偶数面</span></span><br><span class="line">                   face_selection[f]=isSelect </span><br><span class="line">                ) </span><br><span class="line">                polyop.setFaceSelection base_obj face_selection <span class="comment">--设置选择的面</span></span><br><span class="line">                <span class="built_in">max</span> modify mode	<span class="comment">--改成修改模式</span></span><br><span class="line">                modPanel.setCurrentObject base_obj	<span class="comment">--把物体添加到修改面板里（后续会细讲）</span></span><br><span class="line">                subobjectlevel = <span class="number">4</span>  <span class="comment">--[[一个3ds Max的系统全局变量，让您获取和设置子对象层级在修改面板，如果它是开放的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">该值是一个零或更大的Integer，直到当前打开的修饰符支持的子对象级别数为止，通常按照“子对象”下拉列表中显示的顺序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一种 subObjectLevel 为0表示关闭子对象模式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果“修改”面板未打开或当前修改器中不允许子对象级别设置，则全局变量包含该值 未定义 </span></span><br><span class="line"><span class="comment">                        </span></span><br><span class="line"><span class="comment">                        测试发现&gt;=4才可以实现代码效果</span></span><br><span class="line"><span class="comment">                        ]]</span> <span class="comment">--</span></span><br><span class="line"></span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">      <span class="keyword">else</span> messageBox (<span class="string">&quot;error&quot;</span>)</span><br><span class="line">           </span><br><span class="line">    ) </span><br><span class="line">)</span><br><span class="line">CreateDialog TestRoll width:<span class="number">250</span> height:<span class="number">300</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="控制菜单是否可以点击"><a href="#控制菜单是否可以点击" class="headerlink" title="控制菜单是否可以点击"></a>控制菜单是否可以点击</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">on isEnabled <span class="keyword">return</span></span><br><span class="line">(</span><br><span class="line"> selection.count == <span class="number">1</span> <span class="keyword">and</span> classOf selection[<span class="number">1</span>].baseobject == Editable_Poly</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="菜单开启-关闭"><a href="#菜单开启-关闭" class="headerlink" title="菜单开启/关闭"></a>菜单开启/关闭</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">macroScript AutoMat category: <span class="string">&quot;HowTo&quot;</span></span><br><span class="line">(</span><br><span class="line"> <span class="keyword">local</span> AutoMat_Enabled</span><br><span class="line"> on isChecked <span class="keyword">return</span> AutoMat_Enabled   <span class="comment">--关键这一行</span></span><br><span class="line"> on Execute <span class="keyword">do</span></span><br><span class="line"> (</span><br><span class="line">  <span class="keyword">if</span> AutoMat_Enabled == undefined <span class="keyword">then</span></span><br><span class="line">   AutoMat_Enabled = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   AutoMat_Enabled = <span class="keyword">not</span> AutoMat_Enabled</span><br><span class="line">  <span class="keyword">if</span> AutoMat_Enabled <span class="keyword">then</span></span><br><span class="line">  (</span><br><span class="line">   txt =<span class="string">&quot;if superclassof meditmaterials[4] != texturemap do \n&quot;</span></span><br><span class="line">   txt +=<span class="string">&quot;selection.material = meditmaterials[10]&quot;</span></span><br><span class="line">   callbacks.addscript #selectionSetChanged txt id:#AssignMaterial persistent:<span class="literal">false</span></span><br><span class="line">    Print <span class="string">&quot;set mat&quot;</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   callbacks.removescripts id:#AssignMaterial</span><br><span class="line">  updateToolbarButtons()</span><br><span class="line"> )<span class="comment">--end Execute</span></span><br><span class="line">)<span class="comment">--end macroScript</span></span><br></pre></td></tr></table></figure>

<h5 id="脚本：物体移动到自己的表面"><a href="#脚本：物体移动到自己的表面" class="headerlink" title="脚本：物体移动到自己的表面"></a>脚本：物体移动到自己的表面</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">macroscript MoveToSurface category: <span class="string">&quot;HowTo&quot;</span></span><br><span class="line">(</span><br><span class="line">fn g_filter o = superclassof o == Geometryclass</span><br><span class="line">fn find_intersection z_node node_to_z =</span><br><span class="line">(</span><br><span class="line"> <span class="keyword">local</span> testRay = ray node_to_z.pos [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>]  <span class="comment">--参见下级目录ray</span></span><br><span class="line"> <span class="keyword">local</span> nodeMaxZ = z_node.<span class="built_in">max</span>.z	<span class="comment">--得到物体的max坐标系的z</span></span><br><span class="line"> testRay.pos.z = nodeMaxZ + <span class="number">0.0001</span> * <span class="built_in">abs</span> nodeMaxZ  <span class="comment">--修改ray的起始点坐标为物体z加上一点点</span></span><br><span class="line"> intersectRay z_node testRay</span><br><span class="line">)</span><br><span class="line">on isEnabled <span class="keyword">return</span> selection.count &gt; <span class="number">0</span></span><br><span class="line">on Execute <span class="keyword">do</span></span><br><span class="line">(</span><br><span class="line"> target_mesh = pickObject message:<span class="string">&quot;Pick Target Surface:&quot;</span> filter:g_filter </span><br><span class="line"> <span class="keyword">if</span> isValidNode target_mesh <span class="keyword">then</span></span><br><span class="line"> (</span><br><span class="line">  undo <span class="string">&quot;MoveToSurface&quot;</span> on   <span class="comment">--注册撤销操作，否则无法撤销</span></span><br><span class="line">  (</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> selection <span class="keyword">do</span></span><br><span class="line">   (</span><br><span class="line">    int_point = find_intersection target_mesh i</span><br><span class="line">    <span class="built_in">print</span>(int_point)</span><br><span class="line">    <span class="keyword">if</span> int_point != undefined <span class="keyword">then</span> i.pos = int_point.pos</span><br><span class="line">   )<span class="comment">--end i loop</span></span><br><span class="line">  )<span class="comment">--end undo</span></span><br><span class="line"> )<span class="comment">--end if</span></span><br><span class="line">)<span class="comment">--end execute</span></span><br><span class="line">)<span class="comment">--end script</span></span><br></pre></td></tr></table></figure>

<h4 id="射线变量-ray"><a href="#射线变量-ray" class="headerlink" title="射线变量 ray"></a>射线变量 ray</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> testRay = ray node_to_z.pos [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>]  <span class="comment">--射线变量，第一个变量是起点，第二个变量是方向</span></span><br></pre></td></tr></table></figure>

<p><a href="http://help.autodesk.com/view/MAXDEV/2021/ENU/?guid=GUID-5A117E26-3BA4-4C4C-A0C7-0F4190F9D50D#GUID-5A117E26-3BA4-4C4C-A0C7-0F4190F9D50D">ray文档</a></p>
<h4 id="射线方法-intersectRay"><a href="#射线方法-intersectRay" class="headerlink" title="射线方法 intersectRay"></a>射线方法 intersectRay</h4><p><a href="http://help.autodesk.com/view/MAXDEV/2021/ENU/?guid=GUID-84E24969-C175-4389-B9A6-3B2699B66785">文档</a></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">intersectRay z_node testRay </span><br></pre></td></tr></table></figure>

<blockquote>
<p>该内置的intersectRay函数被赋予一个节点和一条光线（具有起点和方向的空间矢量），并返回空间中光线照射到节点表面的点；如果没有相交，则返回未定义的点。相交的结果也将是函数的返回值，因为它是最后计算的值。</p>
</blockquote>
<h4 id="pickObject"><a href="#pickObject" class="headerlink" title="pickObject"></a>pickObject</h4><ul>
<li>原型</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">pickObject [	message:&lt;<span class="built_in">string</span>&gt; ] [	prompt:&lt;<span class="built_in">string</span>&gt; ] \ </span><br><span class="line">[	count:n|#multiple ] [	filter:fn ] \ </span><br><span class="line">[	<span class="built_in">select</span>:&lt;boolean&gt; ] [	pickFrozen:&lt;boolean&gt; ] \ </span><br><span class="line">[	rubberBand:&lt;point3&gt;] [	rubberBandColor:&lt;color&gt; ] \ </span><br><span class="line">[	forceListenerFocus:&lt;boolean&gt; ] </span><br></pre></td></tr></table></figure>

<ul>
<li>案例</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">target_mesh = pickObject message:<span class="string">&quot;Pick Target Surface:&quot;</span> filter:g_filter </span><br></pre></td></tr></table></figure>

<p>第一个参数用于显示在信息窗口的提示</p>
<p><img src="https://img.supervj.top//img/image-20200422141811636.png" alt="image-20200422141811636"></p>
<p>filter参数传入一个条件函数，案例里用来判断是否是几何体</p>
<h2 id="扩展脚本：移动所有物体的Z坐标与选定物体对齐"><a href="#扩展脚本：移动所有物体的Z坐标与选定物体对齐" class="headerlink" title="扩展脚本：移动所有物体的Z坐标与选定物体对齐"></a>扩展脚本：移动所有物体的Z坐标与选定物体对齐</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">macroscript MoveAllGeometryToLand category: <span class="string">&quot;HowTo&quot;</span></span><br><span class="line">(</span><br><span class="line">fn g_filter o = superclassof o == Geometryclass</span><br><span class="line">fn getZ node_land=</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">local</span> testray=ray [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1000</span>] [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(intersectRay node_land testray) </span><br><span class="line">   </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">on isEnabled <span class="keyword">return</span> selection.count == <span class="number">1</span></span><br><span class="line">on Execute <span class="keyword">do</span></span><br><span class="line">(</span><br><span class="line">    target_mesh = pickObject message:<span class="string">&quot;Pick Target LandMesh:&quot;</span> filter:g_filter</span><br><span class="line">    <span class="keyword">if</span> isValidNode target_mesh <span class="keyword">then</span></span><br><span class="line">        (</span><br><span class="line">            undo <span class="string">&quot;MoveAllGeometryToLand&quot;</span> on</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> geometry where((g_filter i)<span class="keyword">and</span> i!=target_mesh) <span class="keyword">do</span></span><br><span class="line">                    (</span><br><span class="line">                        <span class="keyword">local</span> point=getZ selection[<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> point!=undefined <span class="keyword">then</span> i.pos.z=point.pos.z</span><br><span class="line"></span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">)<span class="comment">--end script</span></span><br></pre></td></tr></table></figure>

<h3 id="路径定义"><a href="#路径定义" class="headerlink" title="路径定义"></a>路径定义</h3><p><a href="http://help.autodesk.com/view/MAXDEV/2021/ENU/?guid=GUID-F7577416-051E-478C-BB5D-81243BAAC8EC#GUID-F7577416-051E-478C-BB5D-81243BAAC8EC">路径说明文档</a></p>
<h3 id="脚本：录制并播放动画"><a href="#脚本：录制并播放动画" class="headerlink" title="脚本：录制并播放动画"></a>脚本：录制并播放动画</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">macroScript QuickPreview category: <span class="string">&quot;HowTo&quot;</span></span><br><span class="line">(</span><br><span class="line"> preview_name = (getDir #preview)+<span class="string">&quot;/quickpreview.avi&quot;</span>  <span class="comment">--保存的文件路径</span></span><br><span class="line"> view_size = getViewSize()  <span class="comment">--得到视口大小，2位向量</span></span><br><span class="line"> anim_bmp = bitmap view_size.x view_size.y filename:preview_name  <span class="comment">--创建位图</span></span><br><span class="line"> <span class="keyword">for</span> t = animationrange.start to animationrange.<span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"> (</span><br><span class="line">  sliderTime = t</span><br><span class="line">  dib = gw.getViewportDib()  <span class="comment">--得到dib</span></span><br><span class="line">  copy dib anim_bmp <span class="comment">--把dib信息拷贝到bmp位图里</span></span><br><span class="line">  save anim_bmp <span class="comment">--保存位图</span></span><br><span class="line"> )</span><br><span class="line"> <span class="built_in">close</span> anim_bmp</span><br><span class="line"> gc()</span><br><span class="line"> ramplayer preview_name <span class="string">&quot;&quot;</span>  <span class="comment">--调用raw播放器预览</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="脚本：创建自定义模型"><a href="#脚本：创建自定义模型" class="headerlink" title="脚本：创建自定义模型"></a>脚本：创建自定义模型</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">radius1 = <span class="number">100</span></span><br><span class="line">radius2 = <span class="number">10</span></span><br><span class="line">width = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">vert_array = #()</span><br><span class="line">face_array = #()</span><br><span class="line"> </span><br><span class="line">vert_count = <span class="number">0</span></span><br><span class="line">num_faces = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> a = <span class="number">0</span> to (<span class="number">360</span>-(<span class="number">360</span>/num_faces)) by <span class="number">360</span>/num_faces <span class="keyword">do</span></span><br><span class="line">(</span><br><span class="line">v1 = [radius1*<span class="built_in">cos</span>(a+width),radius1*<span class="built_in">sin</span>(a+width),<span class="number">0</span>]</span><br><span class="line">v2 = [radius1*<span class="built_in">cos</span>(a-width),radius1*<span class="built_in">sin</span>(a-width),<span class="number">0</span>]</span><br><span class="line">v3 = [radius2*<span class="built_in">cos</span>(a),radius2*<span class="built_in">sin</span>(a),<span class="number">0</span>]</span><br><span class="line">append vert_array v1   <span class="comment">--添加点到数组</span></span><br><span class="line">append vert_array v2</span><br><span class="line">append vert_array v3</span><br><span class="line"> </span><br><span class="line">append face_array [vert_count+<span class="number">1</span>,vert_count+<span class="number">3</span>,vert_count+<span class="number">2</span>]</span><br><span class="line">vert_count += <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">m = mesh vertices:vert_array faces:face_array</span><br></pre></td></tr></table></figure>

<h4 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">vert_array=#()</span><br><span class="line">faces_array=#()</span><br><span class="line">h=<span class="number">20</span></span><br><span class="line">iv=<span class="number">0</span></span><br><span class="line">num=<span class="number">10</span></span><br><span class="line">l=<span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span> to num <span class="keyword">do</span></span><br><span class="line">(</span><br><span class="line">     </span><br><span class="line">             v1=[l/num*(i<span class="number">-1</span>),<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">			 v2=[l/num*i,-h,<span class="number">0</span>]</span><br><span class="line">             v3=[l/num*i,h,<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">            append vert_array v1</span><br><span class="line">            append vert_array v2</span><br><span class="line">			append vert_array v3</span><br><span class="line">            append faces_array [iv+<span class="number">1</span>,iv+<span class="number">2</span>,iv+<span class="number">3</span>]</span><br><span class="line">            </span><br><span class="line">            iv+=<span class="number">3</span></span><br><span class="line">            <span class="built_in">print</span> iv</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">m = mesh vertices:vert_array faces:faces_array</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20200423140625851.png" alt="image-20200423140625851"></p>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><ul>
<li>原型     <a href="http://help.autodesk.com/view/3DSMAX/2018/ENU/?guid=__files_GUID_9F6ABEE1_0728_4B39_8903_D909634C1304_htm">文档</a></li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">bitmap &lt;width &lt;height&gt; [filename:&lt;filename_string&gt;] \ </span><br><span class="line">[numframes:&lt;integer&gt;] \</span><br><span class="line">[color:&lt;color&gt;] \ </span><br><span class="line">[gamma:&lt;float&gt;] \ </span><br><span class="line">[pixelAspect:&lt;float&gt;] \ </span><br><span class="line">[channels:&lt;channel_name array&gt;]\ </span><br><span class="line">[hdr:&lt;bool&gt;] \</span><br><span class="line">[iconName:&lt;filename&gt;]\</span><br><span class="line">[iconSize:&lt;point2&gt;]</span><br></pre></td></tr></table></figure>



<ul>
<li>示例</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">b=bitmap <span class="number">100</span> <span class="number">100</span> color:white</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span> to <span class="number">100</span> <span class="keyword">do</span></span><br><span class="line">	(</span><br><span class="line">		setPixels b [i,i] #(red)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">display b</span><br><span class="line"></span><br><span class="line">b.filename=@<span class="string">&quot;d:t.bmp&quot;</span></span><br><span class="line">save b</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20200424113002291.png" alt="image-20200424113002291"></p>
<p><img src="%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98/image-20200424113018711.png" alt="image-20200424113018711"></p>
<h3 id="EXR格式输出"><a href="#EXR格式输出" class="headerlink" title="EXR格式输出"></a>EXR格式输出</h3><p><a href="http://help.autodesk.com/view/3DSMAX/2018/ENU/?guid=__files_GUID_FDECDBDE_C741_4CD8_9DE4_F3355490C796_htm">文档</a></p>
<h2 id="Epic顶点动画插件代码分析"><a href="#Epic顶点动画插件代码分析" class="headerlink" title="Epic顶点动画插件代码分析"></a>Epic顶点动画插件代码分析</h2><h3 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h3><h4 id="得到法线"><a href="#得到法线" class="headerlink" title="得到法线"></a>得到法线</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">fn getTheVertexNormal processObject vertexIndex = ( </span><br><span class="line">    normal = [<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>] </span><br><span class="line">    <span class="keyword">if</span> classof processObject.baseobject == Editable_Poly <span class="keyword">then</span> (</span><br><span class="line">            vertexPolygons = polyOp.getFacesUsingVert processObject vertexIndex</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> vertexPolygons <span class="keyword">do</span> (</span><br><span class="line">                    normal+=<span class="keyword">in</span> coordsys world polyOp.getFaceNormal processObject i</span><br><span class="line">                )</span><br><span class="line">            ) <span class="keyword">else</span> (</span><br><span class="line">                normal= getNormal processObject vertexIndex</span><br><span class="line">            )</span><br><span class="line">            normal=normalize normal </span><br><span class="line">            normal </span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<ul>
<li> 如果是可编辑多边形，得到一个顶点序号所有法线之和</li>
<li>否则就根据<code>getNormal</code>方法直接去要</li>
</ul>
<h4 id="法线颜色"><a href="#法线颜色" class="headerlink" title="法线颜色"></a>法线颜色</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">oldnormal=((((normalize (getTheVertexNormal currentMorphTarget j))*[<span class="number">1.0</span>,<span class="number">-1.0</span>,<span class="number">1.0</span>])+<span class="number">1.0</span>)*<span class="number">0.5</span>)*<span class="number">255.0</span>   <span class="comment">--法线顶点色数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>[-1,1]转换成[0,1]再乘以255得到颜色</li>
</ul>
<h3 id="顶点偏移"><a href="#顶点偏移" class="headerlink" title="顶点偏移"></a>顶点偏移</h3><h4 id="位置和颜色"><a href="#位置和颜色" class="headerlink" title="位置和颜色"></a>位置和颜色</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--遍历模型所有顶点</span></span><br><span class="line"><span class="keyword">for</span> j=<span class="number">1</span> to numberofVerts <span class="keyword">do</span> (</span><br><span class="line">        oldnormal=((((normalize (getTheVertexNormal currentMorphTarget j))*[<span class="number">1.0</span>,<span class="number">-1.0</span>,<span class="number">1.0</span>])+<span class="number">1.0</span>)*<span class="number">0.5</span>)*<span class="number">255.0</span></span><br><span class="line">        append CurrentMorphTargetNormalArray oldnormal</span><br><span class="line">        originalVertPos=originalMeshVertPositions[j]</span><br><span class="line">        currentModelVertPos=getVertPos currentMorphTarget j  <span class="comment">--得到顶点位置</span></span><br><span class="line">        <span class="keyword">if</span> (captureAbsolutePositions.checked) </span><br><span class="line">            <span class="keyword">then</span> (</span><br><span class="line">                currentOffset=currentModelVertPos</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span> (</span><br><span class="line">                currentOffset=(currentModelVertPos-originalVertPos)<span class="comment">--如果不是绝对位置就要减去本地坐标来得到世界坐标</span></span><br><span class="line">            )</span><br><span class="line">            <span class="comment">--反转Y轴</span></span><br><span class="line">            currentOffset=[currentOffset[<span class="number">1</span>],<span class="number">-1.0</span>*currentOffset[<span class="number">2</span>],currentOffset[<span class="number">3</span>]]</span><br><span class="line">            currentOffset*=<span class="number">255.0</span>            <span class="comment">--转成颜色</span></span><br><span class="line">            append currentMorphVertexOffsetArray currentOffset</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--从系统方法得到顶点位置</span></span><br><span class="line">fn getVertPos model index= (</span><br><span class="line">    pos=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> classof model.baseobject == editable_poly <span class="keyword">then</span> (</span><br><span class="line">            pos=<span class="keyword">in</span> coordsys world polyop.getVert model index</span><br><span class="line">        ) <span class="keyword">else</span> (</span><br><span class="line">            pos=<span class="keyword">in</span> coordsys world getVert model index</span><br><span class="line">        )</span><br><span class="line">        pos</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="输出贴图"><a href="#输出贴图" class="headerlink" title="输出贴图"></a>输出贴图</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">fn renderOutTheTextures = (	</span><br><span class="line">    fopenexr.SetCompression <span class="number">0</span></span><br><span class="line">    fopenexr.setLayerOutputType <span class="number">0</span> <span class="number">1</span> <span class="comment">-- set layer 0  main layer to RGBA, RGB = 1</span></span><br><span class="line">    fopenexr.setLayerOutputFormat <span class="number">0</span> <span class="number">1</span> <span class="comment">--0 32 sets main layer to float 16 via 1. other options are 0 float 32, 2 int 32 </span></span><br><span class="line">    global TextureName = getSaveFileName types:<span class="string">&quot;EXR (*.EXR)|*.EXR&quot;</span></span><br><span class="line">    <span class="keyword">if</span> TextureName == undefined <span class="keyword">then</span> (</span><br><span class="line">            messagebox <span class="string">&quot;please select a file location&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>(</span><br><span class="line">            uvString=<span class="string">&quot;_UV&quot;</span>+((targetMorphUV<span class="number">-1</span>) as <span class="built_in">string</span>)</span><br><span class="line">            TextureNameNormal= replace TextureName (findString TextureName <span class="string">&quot;.EXR&quot;</span>) <span class="number">4</span> (uvString+<span class="string">&quot;_Normals.BMP&quot;</span>)</span><br><span class="line">            TextureNameOffset= replace TextureName (findString TextureName <span class="string">&quot;.EXR&quot;</span>) <span class="number">4</span> (uvString+<span class="string">&quot;.EXR&quot;</span>)</span><br><span class="line">            global FinalTexture = bitmap numberofVerts (MorphVertOffsetArray.count) filename:TextureNameOffset hdr:<span class="literal">true</span>; <span class="comment">--创建EXR贴图</span></span><br><span class="line">            global FinalMorphTexture = bitmap numberofVerts (MorphVertOffsetArray.count) filename:TextureNameNormal hdr:<span class="literal">true</span>  gamma:<span class="number">1.0</span> ;<span class="comment">--创建法线贴图</span></span><br><span class="line">            <span class="comment">--遍历所有顶点数，设置像素颜色</span></span><br><span class="line">            <span class="comment">--2个颜色数组用UE4的语法表示是个数组  TArray&lt;TArray&lt;FVector&gt;&gt;</span></span><br><span class="line">            <span class="comment">--所以一个成员代表一行的所有颜色</span></span><br><span class="line">            <span class="keyword">for</span> i=<span class="number">0</span> to (MorphVertOffsetArray.count<span class="number">-1</span>) <span class="keyword">do</span> (</span><br><span class="line">                    setPixels FinalTexture [<span class="number">0</span>, i] MorphVertOffsetArray[(i+<span class="number">1</span>)]</span><br><span class="line">                    setPixels FinalMorphTexture [<span class="number">0</span>, i] MorphNormalArray[(i+<span class="number">1</span>)]</span><br><span class="line">                )</span><br><span class="line">                save FinalTexture gamma:<span class="number">1.0</span></span><br><span class="line">                <span class="built_in">close</span> FinalTexture</span><br><span class="line"></span><br><span class="line">                save FinalMorphTexture gamma:<span class="number">1.0</span></span><br><span class="line">                <span class="built_in">close</span> FinalMorphTexture</span><br><span class="line">            )</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>dcc</category>
      </categories>
      <tags>
        <tag>3DMAX</tag>
        <tag>MaxScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper2D第三方工具TexturerPacker</title>
    <url>/2021/01/08/Paper2D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7TexturerPacker/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于Paper2D使用第三方工具<code>TexturerPacker</code>的简单使用方法记录</p>
<blockquote>
<p>从遥远的2019年搬运而来</p>
</blockquote>
<span id="more"></span>

<h2 id="第三方工具：TexturerPacker"><a href="#第三方工具：TexturerPacker" class="headerlink" title="第三方工具：TexturerPacker"></a>第三方工具：TexturerPacker</h2><ul>
<li><a href="https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-with-unreal-paper2d">下载地址</a></li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>TexturePacker流程</p>
<p><img src="https://img.supervj.top//img/thumbnail.png" alt="thumbnail"></p>
<ul>
<li><p>将序列帧图片直接拖入软件中，也可以只能选择外部文件夹，一个文件夹内的图片会被全部导入</p>
</li>
<li><p>设置框架为<strong>UnrealEngine-Paper-2d</strong>,需要用Pro版本,免费使用7天😓</p>
</li>
<li><p>设置右上角的<strong>数据文件</strong>（导出数据），主要目的是设置路劲和文件名</p>
</li>
<li><p><strong>多文件打包</strong>一般不用设置，除非同一个动作序列帧非常多</p>
</li>
<li><p>发布为<strong>paper2dsprites</strong> 文件,可导入UE4</p>
<hr>
</li>
</ul>
<h2 id="UE4的Paper2D导入流程"><a href="#UE4的Paper2D导入流程" class="headerlink" title="UE4的Paper2D导入流程"></a>UE4的Paper2D导入流程</h2><ul>
<li>导入paper2dsprites数据（亦可以直接导入PNG或者其他图片格式），以下按照paper2dsprites流程</li>
<li>导入以后生成3个文件，如下</li>
</ul>
<p><img src="https://img.supervj.top//img/thumbnail%20(1).png" alt="thumbnail (1)"></p>
<ul>
<li>Texutres文件内包含一张x*y小图的PNG图片，格式自动设置为2D格式图片，如下图<br><img src="https://img.supervj.top//img/image-20191213134651199.png" alt="image-20191213134651199"></li>
<li>Frames文件内自动生成UE4的**sprite-20191213134528934.png)<img src="https://img.supervj.top//img/image-20191213134528934.png" alt="image-20191213134528934"></li>
<li><strong>FlipBook</strong>就是完整的一个序列动画文件，包含了对应的所有<strong>sprite</strong><br><img src="https://img.supervj.top//img/image-20191213135749674.png" alt="image-20191213135749674"></li>
<li>**paper2dsprites **文件记录数据，以及用于重导入的操作</li>
</ul>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>Paper2D</tag>
        <tag>TexturerPacker</tag>
      </tags>
  </entry>
  <entry>
    <title>Picgo+GitHub搭建免费图床</title>
    <url>/2020/05/13/Picgo+GitHub%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍如何用Picgo+GitHub搭建免费的图床</p>
<p>可用于个人Markdown文档的图片外链</p>
<p>Github图床优点：免费，安全；缺点：网络不稳定，偶尔上传失败</p>
</blockquote>
<h3 id="关于Picgo"><a href="#关于Picgo" class="headerlink" title="关于Picgo"></a>关于Picgo</h3><p>这是一款图片上传的工具，目前支持<code>七牛图床</code>，<code>腾讯云</code>，<code>阿里oss</code>，<code>GitHub</code>等图床，未来将支持更多图床。</p>
<p>所以解决问题的思路就是，将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以随时随地使用图片外链了</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li><p>git和github使用请参考本人另一篇文章<a href="%5Bhttps://supervj.top/2020/05/12/%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8Git/%5D(https://supervj.top/2020/05/12/%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8Git/)">《Git使用指北》</a></p>
</li>
<li><p><a href="https://github.com/Molunerfinn/PicGo/releases">下载picgo软件</a></p>
</li>
</ul>
<h3 id="GitHub流程"><a href="#GitHub流程" class="headerlink" title="GitHub流程"></a>GitHub流程</h3><ol>
<li><p>新建一个<code>Repository</code>，建议命名成<code>img</code>之类的方便记忆</p>
</li>
<li><p>生成一个Token用于操作GitHub repository，流程如下</p>
<blockquote>
<p>Settings-&gt;Developer settings-&gt;Personnal access tokens-&gt;Generate new token</p>
</blockquote>
<p> 注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存</p>
</li>
</ol>
<h3 id="配置Picgo"><a href="#配置Picgo" class="headerlink" title="配置Picgo"></a>配置Picgo</h3><p><img src="https://img.supervj.top/imgpicgo_github_3.jpg"></p>
<ul>
<li>仓库名：即你<code>github</code>仓库的名称</li>
<li>设定分支：对应仓库的分支，默认是<code>master</code></li>
<li>设定Token：之前保存的<code>Token</code></li>
<li>指定存储路径：保存到仓库的路径</li>
<li>设定自定义域名：见如下</li>
</ul>
<h5 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h5><p>默认不指定域名，这样生成的是<code>github</code>地址，部分情况会被墙掉，对于图片访问不是特别友善</p>
<p>有自己域名的同学强烈建议使用自定义域名</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>博客</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>Picgo+阿里oss搭建图床</title>
    <url>/2020/05/14/Picgo+%E9%98%BF%E9%87%8Coss%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍如何用Picgo+阿里oss搭建图床</p>
<p>可用于个人Markdown文档的图片外链</p>
<p>oss图床优点：速度快，安全；缺点：流量大的情况下收费很夸张</p>
</blockquote>
<h3 id="阿里oss"><a href="#阿里oss" class="headerlink" title="阿里oss"></a>阿里oss</h3><ol>
<li>登录注册阿里云账户，选择<code>对象存储oss</code>服务</li>
</ol>
<p><img src="https://img.supervj.top/imgoss1.jpg"></p>
<ol start="2">
<li>右侧创建新的<code>创建Bucket</code>，这个就是存储的仓库</li>
</ol>
<p><img src="https://img.supervj.top/imgoss2.jpg"></p>
<ol start="3">
<li>各种参数根据需求设置，需要注意的是读写权限必须选择<code>公共读</code>,不然无法访问;地区选择离自己最近的地区</li>
</ol>
<p><img src="https://img.supervj.top/imgoss3.jpg"></p>
<ol start="4">
<li>选择右上角自己头像，选择<code>AccessKey</code>管理</li>
</ol>
<p><img src="https://img.supervj.top/imgoss4.jpg"></p>
<ol start="5">
<li>创建用户</li>
</ol>
<p><img src="https://img.supervj.top/imgoss5.jpg"></p>
<ol start="6">
<li>选择<code>权限管理</code>-&gt; <code>添加权限</code>-&gt;选择并添加<code>AliyunOSSFullAccess</code></li>
</ol>
<p><img src="https://img.supervj.top/imgoss6.jpg"></p>
<ol start="7">
<li>创建<code>AccessKey</code>,记得保存<code>AccessKeySecret</code>,下次登录就看不到了，不过即使忘记了还可以继续创建新的<code>AccessKey</code></li>
</ol>
<p><img src="https://img.supervj.top/imgoss7.jpg"></p>
<p><img src="https://img.supervj.top/imgoss8.jpg"></p>
<blockquote>
<p>到此oss端的操作已经完成</p>
</blockquote>
<h3 id="Picgo设置"><a href="#Picgo设置" class="headerlink" title="Picgo设置"></a>Picgo设置</h3><ul>
<li>KeyId：AccessKey</li>
<li>KeySecret：AccessKeySecret</li>
<li>设定存储空间名：Bucket名称</li>
<li>存储地区：Bucket的地区名称</li>
<li>存储路径：Bucket内的文件夹路径</li>
</ul>
<p><img src="https://img.supervj.top/imgoss9.jpg"></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>博客</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>PureMVC框架</title>
    <url>/2020/11/30/PureMVC/</url>
    <content><![CDATA[<blockquote>
<p>Pure MVC是在基于模型、视图和控制器的MVC模式建立的一个轻量级的应用框架.</p>
<p>目前已经广泛应用于各类平台,常见用的语言如C#,Java等</p>
<p>本文尝试根据标准的C++PureMVC框架魔改成UE4版本方便使用的UnrealPureMVC(UPM)框架插件</p>
</blockquote>
<p><a href="git@github.com:VJien/UnrealPureMVC.git">github:UnrealPureMVC </a></p>
<span id="more"></span>

<ul>
<li>参考文献</li>
</ul>
<p><a href="https://baike.baidu.com/item/pureMVC/8328354?fr=aladdin">PureMVC百度百科</a></p>
<p><a href="https://github.com/PureMVC/puremvc-cpp-multicore-framework">GitHub:puremvc-cpp-multicore-framework</a></p>
<p><a href="http://puremvc.org/docs/PureMVC_IIBP_Chinese.pdf">PureMVC官方中文文档</a></p>
<p><img src="https://img.supervj.top//img/image-20201128123312313.png" alt="image-20201128123312313"></p>
<!-- more -->

<h3 id="PureMVC简单介绍"><a href="#PureMVC简单介绍" class="headerlink" title="PureMVC简单介绍"></a>PureMVC简单介绍</h3><p>PureMVC框架把程序分为低耦合的三层：Model、View和 Controller。</p>
<p>在PureMVC首先实现了设计模式中的<strong>单例模式</strong>,其中以上3部分都是单例模式来管理,然后通过单例**<code>Facade</code>作为对外的唯一接口访问**</p>
<ul>
<li><strong>Model</strong></li>
</ul>
<p>Model 保存对 Proxy 对象的引用，Proxy 负责操作数据模型，与远程服务通 信存取数据。</p>
<ul>
<li> <strong>Proxy</strong></li>
</ul>
<p>Proxy 负责操作数据模型，与远程服务通信存取数据；</p>
<ul>
<li><strong>View</strong></li>
</ul>
<p>View 保存对 Mediator 对象的引用;</p>
<p>Mediator 对象来操作具体的视图组件,如UE4中的UMG组件</p>
<p>这样做是把视图的逻辑层和表现层剥离开</p>
<ul>
<li><strong>Mediator:</strong></li>
</ul>
<p>Mediator操作具体的视图组件UI，包括：添加事件监听器，发送或接收 Notification ，直接改变视图组件的状态；</p>
<ul>
<li><strong>Controller</strong></li>
</ul>
<p>Controller 保存所有 Command 的映射。</p>
<p>Command 类是无状态的，只在需 要时才被创建。</p>
<ul>
<li><strong>Command</strong></li>
</ul>
<p>Command 可以获取 Proxy 对象并与之交互，发送 Notification，执行其他的 Command。</p>
<p><img src="https://img.supervj.top//img/image-20201128134718774.png" alt="image-20201128134718774"></p>
<hr>
<p>还有几点需要注意</p>
<ul>
<li>新建我们自己的Facade类</li>
<li>用该类初始化各种需要初始化的Command/Proxy/Mediator</li>
<li>M/V/C三个单例是内部类,尽量不要给外部访问,这里我们把3个单例的方法的<code>UFUNCTION</code>宏都注释掉了</li>
</ul>
<h3 id="PureMVC通信机制和接口"><a href="#PureMVC通信机制和接口" class="headerlink" title="PureMVC通信机制和接口"></a>PureMVC通信机制和接口</h3><p>先说明两个核心的事件**[发送消息/<code>SendNotification</code>]<strong>和</strong>[处理消息/<code>HandleNotification</code>]**,我们做的事件多数围绕着这两件事情而展开</p>
<h5 id="Notifier"><a href="#Notifier" class="headerlink" title="Notifier"></a>Notifier</h5><p>最为基类存在,实现了发送消息的方法<code>SendNotification</code>,同时提供如下方法,在初始化的时候设置必要参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetFacade</span><span class="params">(UMVC_Facade* facade)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetWorldContext</span><span class="params">(UObject* worldContext)</span></span>;</span><br></pre></td></tr></table></figure>

<p>后面的<code>Proxy</code>,<code>Command</code>,<code>Mediator</code>均是继承自<code>Notifier</code>类</p>
<h5 id="Modle-Proxy"><a href="#Modle-Proxy" class="headerlink" title="Modle/Proxy"></a>Modle/Proxy</h5><p>M层使用了设计模式中的<strong>代理模式</strong>,即外部与数据的通信都通过<code>Proxy</code>类来交互而非直接对数据进行处理</p>
<p>M层提供了注册/获取/移除/判断 <code>Proxy</code>的接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterProxy</span><span class="params">(UMVC_Proxy* Proxy)</span></span>;</span><br><span class="line"><span class="function">UMVC_Proxy* <span class="title">RetrieveProxy</span><span class="params">(<span class="keyword">const</span> FString&amp; ProxyName)</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RemoveProxy</span><span class="params">(<span class="keyword">const</span> FString&amp; ProxyName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasProxy</span><span class="params">(<span class="keyword">const</span> FString&amp; ProxyName)</span><span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>一般情况我们在代码中需要实现一个<code>Modle</code>类和一个<code>IModel</code>接口,在这里我对此进行了简化,传统的<code>IModel</code>,甚至包括后面的<code>IFacade</code>,<code>IView</code>,<code>IProxy</code>等等接口都统统简化掉,把所有接口方法都放到对应的基类内</p>
<blockquote>
<p>虽然有悖于依赖倒置原则,但是为了简化代码量,如有必要后面添加相应接口并把方法移动至接口内</p>
</blockquote>
<p><code>Proxy</code>类的主要则是存储数据,以及跟服务端通信</p>
<p><code>Proxy</code>可以发送消息, 但是<strong>不能接收消息</strong>, 在官方文档中有解释,原因是如果<code>Proxy</code>能接受消息的话那么M层与VC两层的耦合就太高了</p>
<p><strong>VC层可以接受来自<code>Proxy</code>的消息而对视图作为一定处理;反过来,VC层的改变不应该影响M层</strong></p>
<p>我们在<code>Proxy</code>类内实现一些基础方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetInfo</span><span class="params">(<span class="keyword">const</span> FString&amp; Name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRegister</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRemove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">FString <span class="title">GetProxyName</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetData</span><span class="params">(UObject* Data)</span></span>;</span><br><span class="line"><span class="function">UObject* <span class="title">GetProxyData</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中这些方法都不是必须实现的, 在蓝图层面, 我们可以在<code>OnRegister</code>和<code>OnRemove</code>两个方法最为启动和结束的入口函数对数据做一定的处理</p>
<h5 id="View-Mediator"><a href="#View-Mediator" class="headerlink" title="View/Mediator"></a>View/Mediator</h5><p><code>View</code>类相比<code>Model</code>类会复杂一点,这里我们会用到几个新的类</p>
<p><code>Observer</code>类应用了<strong>观察者模式</strong>,在注册每一个<code>Mediator</code>类的时候都会创建一个临时<code>Observer</code>类来作为观察者,在接受到特定消息以后将消息通知给<code>Mediator</code>类</p>
<p>如下代码简单解释了这一操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册mediator时</span></span><br><span class="line">UMVC_Observer* obs = NewObject&lt;UMVC_Observer&gt;();</span><br><span class="line">		obs-&gt;<span class="built_in">SetInfo</span>(mediator, [mediator](UMVC_Notification* notification) &#123;</span><br><span class="line">			mediator-&gt;<span class="built_in">HandleNotification</span>(notification);</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sendNotification后调用到的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMVC_View::NotifyObservers_Implementation</span><span class="params">(UMVC_Notification* noitifyCation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FString name = noitifyCation-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">	<span class="keyword">if</span> (ObserverMap.<span class="built_in">Contains</span>(name))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> cur : ObserverMap[name].Observers)</span><br><span class="line">		&#123;</span><br><span class="line">			cur-&gt;<span class="built_in">NotifyObserver</span>(noitifyCation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>UMVC_Notification</li>
</ul>
<p>此类作为一个封装类存在,在这里其实就是简单封装了一个字符串和UObject类,对应的就是<code>SendNotification</code>方法的2个参数;</p>
<p>当然, 我们后面可以自定义我们所需要的<code>Notification</code>类来添加更多的参数</p>
<hr>
<p>在<code>View</code>类中,保存了2个字典以便于随时获取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">		TMap&lt;FString, UMVC_Mediator*&gt; MediatorMap;</span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">		TMap&lt;FString, FObserverArray&gt; ObserverMap;</span><br></pre></td></tr></table></figure>

<p>这里补充一点,一个消息字符串对应的是一个观察者数组, 因为观察同一个消息的可能有很多对象,而一个对象就对应一个<code>Observer</code>类</p>
<p><code>View</code>主要代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterObserver</span><span class="params">(<span class="keyword">const</span> FString&amp; NotificationName, UMVC_Observer* observer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveObserver</span><span class="params">(<span class="keyword">const</span> FString&amp; NotificationName, UObject* notifyObject)</span></span>;<span class="string">&quot;)</span></span><br><span class="line"><span class="string">void NotifyObservers(UMVC_Notification* noitifyCation);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void RegisterMeditor(UMVC_Mediator* mediator);</span></span><br><span class="line"><span class="string">UMVC_Mediator* RetrieveMediator(const FString&amp; mediatorName)const;</span></span><br><span class="line"><span class="string">bool RemoveMediator(const FString&amp; mediatorName);</span></span><br><span class="line"><span class="string">bool HasMediator(const FString&amp; mediatorName) ;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><code>Mediator</code>类作为非常核心的一个类而存在, 多数情况, 大多数的交互逻辑都放在此类中, 如发送消息打开某某界面等等</p>
<p><strong><code>Mediator</code>发送、声明、接收消息</strong></p>
<p><code>Mediator</code>类在创建后需要调用一个初始化方法,目的是让<code>Mediator</code>绑定一个具体对象, 如我们UE中的UMG类, 但其实<code>MVC</code>框架不仅仅只适合用与UI的管理, 我们同样可以<code>Mediator</code>来绑定其他对象比如我们玩家甚至我们的<code>GameMode</code>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMVC_Mediator::Init_Implementation</span><span class="params">(<span class="keyword">const</span> FString&amp; mediatorName, UObject* viewInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MediatorName = mediatorName;</span><br><span class="line">	ViewInstance = viewInstance;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(UPM, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Meditor [%s, %s] Init &quot;</span>), *mediatorName,viewInstance?*(UKismetSystemLibrary::<span class="built_in">GetDisplayName</span>(viewInstance)):<span class="built_in">TEXT</span>(<span class="string">&quot; NONE &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们同样封装了一个蓝图函数库来用于创建<code>Mediator</code>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UMVC_Mediator* <span class="title">UFlib_UPM::CreateMediator</span><span class="params">(UObject* worldContext, TSubclassOf&lt;UMVC_Mediator&gt; mediatorClass, UObject* Instance, <span class="keyword">const</span> FString&amp; specialName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mediatorClass &amp;&amp; Instance)</span><br><span class="line">	&#123;</span><br><span class="line">		UMVC_Mediator* m = NewObject&lt;UMVC_Mediator&gt;(worldContext, mediatorClass);</span><br><span class="line">		m-&gt;<span class="built_in">Init</span>(specialName.<span class="built_in">IsEmpty</span>() ? mediatorClass-&gt;<span class="built_in">GetName</span>() : specialName, Instance);</span><br><span class="line">		m-&gt;<span class="built_in">SetWorldContext</span>(worldContext);</span><br><span class="line">		<span class="keyword">return</span> m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们后面派生的<code>Mediator</code>子类需要重写的函数是<code>ListNotificationInterests</code>和<code>HandleNotification</code>,也就是我们最前面说的两个事件,前者返回的数组是我们观察的消息,后者处理收到的消息后的逻辑</p>
<p>同样,在<code>OnRegister</code>和<code>OnRemove</code>事件中可以在启动和销毁时做处理, 如绑定我们<code>GetViewInstance</code>得到的对象的代理事件 或者 获取数据类<code>Proxy</code></p>
<p><img src="https://img.supervj.top//img/image-20201128151312264.png" alt="image-20201128151312264"></p>
<h5 id="Controller-Command"><a href="#Controller-Command" class="headerlink" title="Controller/Command"></a>Controller/Command</h5><p>MVC中的C,其实就是作为设计模式中的<strong>中介者模式</strong>存在,同时<code>Command</code>类又应用了<strong>命令模式</strong></p>
<p>在<code>PureMVC</code>中的<code>Command</code>只作为一个无状态的类存在,在需要的时候被创建,执行逻辑以后就销毁</p>
<p>目的是方便了我们封装一些常用功能的逻辑,如显示某个UI,移除某个UI</p>
<p><code>Controller</code>类的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(UMVC_View* view)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterCommand</span><span class="params">(<span class="keyword">const</span> FString&amp; notificationName, UMVC_Command* command)</span></span>;</span><br><span class="line"><span class="function">UMVC_Command* <span class="title">RetrieveCommand</span><span class="params">(<span class="keyword">const</span> FString&amp; notificationName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteCommand</span><span class="params">(UMVC_Notification* notification)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RemoveCommand</span><span class="params">(<span class="keyword">const</span> FString&amp; noitificationName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasCommand</span><span class="params">(<span class="keyword">const</span> FString&amp; notificationName)</span><span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>



<p>我们会注意到有一个<code>Init</code>方法来获取一个<code>View</code>类对象,意味着其实我们VC两层是耦合的,</p>
<p>同样我们注册<code>Command</code>类的时候会创建一个观察者类<code>Observer</code>,注册的变量<code>notificationName</code>即<code>Command</code>对应的消息名称,参考我们<code>Mediator</code>对象的<code>ListNotificationInterests</code>方法,</p>
<p>观察者的对象是我们<code>Controller</code>本身,在接受到消息的时候直接调用<code>ExecuteCommand</code>命令</p>
<blockquote>
<p>即Notification可以直接触发Comand执行</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMVC_Controller::RegisterCommand</span><span class="params">(<span class="keyword">const</span> FString&amp; notificationName, UMVC_Command* command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (CommandMap.<span class="built_in">Contains</span>(notificationName))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	CommandMap.<span class="built_in">Add</span>(notificationName, command);</span><br><span class="line">	UMVC_Observer* obs = NewObject&lt;UMVC_Observer&gt;();</span><br><span class="line">	obs-&gt;<span class="built_in">SetInfo</span>(<span class="keyword">this</span>, [<span class="keyword">this</span>](UMVC_Notification* notification)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ExecuteCommand</span>(notification);</span><br><span class="line">	&#125;);</span><br><span class="line">	View-&gt;<span class="built_in">RegisterObserver</span>(notificationName, obs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><code>Command</code>类可以获取<code>Proxy</code>和<code>Mediator</code>类,如下是我们后面的案例实现的一个<code>PushUI</code>的<code>Command</code></p>
<p><img src="https://img.supervj.top//img/image-20201128152841398.png" alt="image-20201128152841398"></p>
<p>我们会注意到有一个名称带<code>Body</code>的类,也就是我们上面提到的<code>SendNotification</code>方法中的<code>UObject</code>扩展类</p>
<p>我们显示/隐藏UI的时候提供的参数都使用的是<code>MediatorName</code>,因为围绕MVC的中心思想, 对视图的控制我们会集中在我们自己的框架中,每个UMG都是由一个<code>Mediator</code>管理,那么我们对视图的显示隐藏就直接用<code>MediatorName</code>类作为唯一参数是比较直观的</p>
<h3 id="蓝图案例"><a href="#蓝图案例" class="headerlink" title="蓝图案例"></a>蓝图案例</h3><p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_11_28_16_03_35_455.gif" alt="录制_2020_11_28_16_03_35_455"></p>
<p>我们简单实现了一个小游戏</p>
<p>包含功能</p>
<ul>
<li>设置子弹数量</li>
<li>子弹自动回复</li>
<li>鼠标点击击杀怪物(盒子)</li>
<li>获取击杀数量数据和得分</li>
<li>右下角测试UI</li>
<li>测试UI切换</li>
</ul>
<hr>
<p>以上大致分为两部分内容,一部分是关于UMG的内容,另外是其他类</p>
<p><img src="https://img.supervj.top//img/image-20201130090855726.png" alt="image-20201130090855726"></p>
<p>我们从<code>Mediator</code>类就可以发现,我们把<code>GameMode</code>以及如<code>Enemy</code>类也加入了我们的<code>PureMVC</code>框架</p>
<p><img src="https://img.supervj.top//img/image-20201130091014189.png" alt="image-20201130091014189"></p>
<p>上图是<code>GameMode</code>中的内容,在运行初期就创建<code>Facade</code>以及把<code>GameMode</code>本身注册到框架内</p>
<p><img src="https://img.supervj.top//img/image-20201130091148445.png" alt="image-20201130091148445"></p>
<p><code>Facade</code>中的3个提供给蓝图重写的方法分别创建了初始的<code>Mediator</code>,<code>Command</code>以及<code>Proxy</code></p>
<p>这里的<code>Mediator</code>对应的对象都是<code>UMG</code>类,因为也只有<code>UMG</code>类可以在最初的时候就先实例化出来(不显示到屏幕)</p>
<p>这里因为蓝图不方便用构造obj的方式来创建<code>UMG</code>,所以我们简单封装了一个构造<code>UMG</code>的方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UUserWidget* <span class="title">UFlib_UPM::CreateWidgetObject</span><span class="params">(UObject* worldContext, TSubclassOf&lt;UUserWidget&gt; umgClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (umgClass)</span><br><span class="line">	&#123;</span><br><span class="line">		UUserWidget* m = NewObject&lt;UUserWidget&gt;(worldContext, umgClass);</span><br><span class="line">		<span class="keyword">return</span> m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>我们创建了2个蓝图<code>Command</code>类,用来显示/隐藏UI</p>
<p><img src="https://img.supervj.top//img/image-20201130091556643.png" alt="image-20201130091556643"></p>
<p><img src="https://img.supervj.top//img/image-20201130091607660.png" alt="image-20201130091607660"></p>
<p>如上图,两个<code>Command</code>类对UI进行处理,主要修改了对应的<code>Proxy</code>类的数据, 以及从<code>Mediator</code>信息得到的具体<code>UMG</code>对象进行处理</p>
<p><img src="https://img.supervj.top//img/image-20201130092810959.png" alt="image-20201130092810959"></p>
<p>我们封装了2个显示/隐藏UI的宏,传入调用的<code>mediator</code>对象以及UI对应的<code>MediatorClass</code>类型</p>
<blockquote>
<p>从这里我们就已经可以看到, UI与UI, UI与数据,UI与其他类之间已经完全解耦,逻辑部分都集中在<code>Mediator</code>/<code>Command</code>中</p>
</blockquote>
<p>同样的,我们也可以用<code>Mediator</code>来管理其他场景类的交互</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>思考:如果我们主要想使用的就是<code>PureMVC</code>中的收发消息功能, 我们已经有很多蓝图类而不想创建同样数量的<code>Mediator</code>类,那有没有办法让蓝图类本身就替代或者模拟<code>Mediator</code>类在框架中的角色呢</p>
<hr>
<p>这里我们打算对UE一般的类都当作<code>Mediator</code>来处理,那么我们先声明一个接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendNotification</span><span class="params">(<span class="keyword">const</span> FString&amp; notification,UObject* body)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleNotification</span><span class="params">(UMVC_Notification* notification)</span></span>;</span><br><span class="line"><span class="function">FString <span class="title">GetOwnMeditorName</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">UMVC_Proxy* <span class="title">RetrieveProxy</span><span class="params">(<span class="keyword">const</span> FString&amp; ProxyName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRegister</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRemove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TArray&lt;FString&gt; <span class="title">ListNotificationInterests</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">UMVC_Facade* <span class="title">GetOwnFacade</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">UUPM_Mediator* <span class="title">GetOwnMediator</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUPMObject</span><span class="params">(UMVC_Facade* facade)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后我们创建一个继承自<code>UMVC_Mediator</code>类 <code>UPM_Mediator</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE</span>(FUPMMulDlg);</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FUPMMulDlgOneParam, UMVC_Notification*, notification);</span><br><span class="line"><span class="comment">/****/</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintCallable,BlueprintAssignable)</span><br><span class="line">		FUPMMulDlg OnRegistered;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintCallable, BlueprintAssignable)</span><br><span class="line">		FUPMMulDlg OnRemoved;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintCallable, BlueprintAssignable)</span><br><span class="line">		FUPMMulDlgOneParam OnHandleNotification;</span><br></pre></td></tr></table></figure>

<p>主要目的是作为一个中介连接UE类和PureMVC</p>
<p>拿<code>OnRegister</code>为例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UUPM_Mediator::OnRegister_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">OnRegister_Implementation</span>();</span><br><span class="line">	OnRegistered.<span class="built_in">Broadcast</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们创建继承自<code>UserWidget</code>的UMG类<code>UPM_Widget</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendNotification_Implementation</span><span class="params">(<span class="keyword">const</span> FString&amp; notification, UObject* body)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HandleNotification_Implementation</span><span class="params">(UMVC_Notification* notification)</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FString <span class="title">GetOwnMeditorName_Implementation</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UMVC_Proxy* <span class="title">RetrieveProxy_Implementation</span><span class="params">(<span class="keyword">const</span> FString&amp; ProxyName)</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRegister_Implementation</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRemove_Implementation</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TArray&lt;FString&gt; <span class="title">ListNotificationInterests_Implementation</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UMVC_Facade* <span class="title">GetOwnFacade_Implementation</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RegisterUPMObject_Implementation</span><span class="params">(UMVC_Facade* facade)</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UUPM_Mediator* <span class="title">GetOwnMediator_Implementation</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="comment">/*UPM END*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">		FString CustomName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Instanced)</span><br><span class="line">		UUPM_Mediator* ownMediator;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UUPM_Widget::RegisterUPMObject_Implementation</span><span class="params">(UMVC_Facade* facade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (facade )</span><br><span class="line">	&#123;</span><br><span class="line">		ownMediator = NewObject&lt;UUPM_Mediator&gt;();</span><br><span class="line">			<span class="comment">// CreateDefaultSubobject&lt;UUPM_Mediator&gt;(TEXT(&quot;UPM_Mediator&quot;));</span></span><br><span class="line">		ownMediator-&gt;<span class="built_in">Init</span>(CustomName.<span class="built_in">IsEmpty</span>()?<span class="keyword">this</span>-&gt;<span class="built_in">GetName</span>():CustomName, <span class="keyword">this</span>);</span><br><span class="line">		ownMediator-&gt;<span class="built_in">SetWorldContext</span>(<span class="keyword">this</span>);</span><br><span class="line">		ownMediator-&gt;OnRemoved.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UUPM_Widget::OnRemove);</span><br><span class="line">		ownMediator-&gt;OnRegistered.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UUPM_Widget::OnRegister);</span><br><span class="line">		ownMediator-&gt;OnHandleNotification.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UUPM_Widget::HandleNotification);</span><br><span class="line">		ownMediator-&gt;NotificationInterests = <span class="built_in">Execute_ListNotificationInterests</span>(<span class="keyword">this</span>);</span><br><span class="line">		facade-&gt;<span class="built_in">RegisterMediator</span>(ownMediator);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(UPM, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;UPM Object Register Failed!! &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部用来注册此类的方法来创建这个中介<code>UUPM_Mediator</code>,然后绑定代理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UUPM_Widget* <span class="title">UFlib_UPMEx::CreateUPMWidget</span><span class="params">(UMVC_Facade* facade, TSubclassOf&lt;UUPM_Widget&gt; umgClass, <span class="keyword">const</span> FString&amp; specialName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (umgClass &amp;&amp; facade)</span><br><span class="line">	&#123;</span><br><span class="line">		UUPM_Widget* w = NewObject&lt;UUPM_Widget&gt;(facade-&gt;WorldContext, umgClass);</span><br><span class="line">		w-&gt;CustomName = specialName;</span><br><span class="line">		w-&gt;<span class="built_in">Execute_RegisterUPMObject</span>(w, facade);</span><br><span class="line">		<span class="keyword">return</span> w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个蓝图库函数创建和注册此UMG类</p>
<p><img src="https://img.supervj.top//img/image-20201130162447580.png" alt="image-20201130162447580"></p>
<p>封装一个蓝图宏库,直接把自己Push到屏幕;对于其他地方如果想Push/Pop该UMG,那么需要得到对应的<code>MediatorName</code>,这个可以自行扩展</p>
<hr>
<blockquote>
<p> 同样的方法, 我们也可以申明同样的类,如<code>UPM_Actor</code>,<code>UPM_Pawn</code></p>
<p>或者我们可以创建一个ActorComponent来实现这个同样的功能</p>
</blockquote>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>PureMVC</tag>
        <tag>框架</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm For Maya</title>
    <url>/2021/11/18/PyCharm%20For%20Maya/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>maya本身的脚本编辑器比较简陋, 推荐使用 JetBrains旗下的 PyCharm来作为脚本编辑器</p>
<span id="more"></span>



<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>安装目前最新的Maya2022</li>
<li>安装<a href="https://www.jetbrains.com/pycharm/">PyCharm</a></li>
<li>下载<a href="https://www.autodesk.com/developer-network/platform-technologies/maya?us_oa=dotcom-us&us_si=579f0098-8b2d-4e48-9fee-e1fa1874a191&us_st=maya%202022%20devkit">Maya 2022 Update 2 win64 DevKit</a>, 这个页面一直往下拉才看得到, 第一次找了老半天</li>
</ol>
<h2 id="配置Pycharm"><a href="#配置Pycharm" class="headerlink" title="配置Pycharm"></a>配置Pycharm</h2><p>打开一个新的py项目</p>
<p><img src="https://img.supervj.top/imgimage-20211117174653673.png" alt="image-20211117174653673"></p>
<p><img src="https://img.supervj.top/imgimage-20211117174714509.png" alt="image-20211117174714509"></p>
<p>按照上图设置环境</p>
<p>进入项目以后测试下代码</p>
<p><img src="https://img.supervj.top/imgimage-20211117174916344.png" alt="image-20211117174916344"></p>
<hr>
<p>如果是刚开始创建项目没有配置环境, 那么需要稍微麻烦一点用下图方式配置</p>
<p><img src="https://img.supervj.top/imgimage-20211117175132322.png" alt="image-20211117175132322"></p>
<h2 id="链接maya"><a href="#链接maya" class="headerlink" title="链接maya"></a>链接maya</h2><p>先打开settings中的plugin , 安装插件 <code>MayaCharm</code></p>
<p><img src="https://img.supervj.top/imgimage-20211117185831769.png" alt="image-20211117185831769"></p>
<p>重启PyCharm</p>
<p>在setting中会多出一个选项</p>
<p><img src="https://img.supervj.top/imgimage-20211117185905934.png" alt="image-20211117185905934"></p>
<p>复制红色框框内的脚本, 这个就是让maya与pycharm通信的脚本</p>
<p>可以手动在maya中运行, 但是这样每次启动都需要运行一次, 比较麻烦, 所以还是建议创建一个脚本, 让maya每次启动自动运行</p>
<p><img src="https://img.supervj.top/imgimage-20211117190027153.png" alt="image-20211117190027153"></p>
<p>记住是文档中的maya目录, 不是安装程序中的maya目录</p>
<p>这样就完成了两边的通信, 试一下</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_11_17_19_02_43_170.gif" alt="录制_2021_11_17_19_02_43_170"></p>
<p>成功!!</p>
<h2 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h2><p>现在可以通信了, 但是代码补全功能还没有, 这个非常的麻烦, 所以我们刚开始下载了一个maya的开发者插件现在就用到了</p>
<p><img src="https://img.supervj.top/imgimage-20211117190605502.png" alt="image-20211117190605502"></p>
<p>藏得很深, 根据图片上的顺序依次点开, 添加了一个路劲, 同时移除一个路径, 这样输入maya相关的 指令的时候就会有提示和补全功能了</p>
<p><img src="https://img.supervj.top/imgimage-20211117190725970.png" alt="image-20211117190725970"></p>
]]></content>
      <categories>
        <category>dcc</category>
      </categories>
      <tags>
        <tag>maya</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>RootMotionSource原理分析和插件封装</title>
    <url>/2022/03/24/RootMotionSource/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到Root Motion, 通常会想到的是Root Motion Animation,  将位移量嵌在Animation中, 角色Tick Pose时会计算frame之间的root bone的偏移量, 換算成velocity与acceleration, 然后PerformMovement, 如此可以表现到角色位移上, 但是在多人游戏中, Root Motion Animation是个不安定因素, 在网络延迟不稳定时, 玩家就会发生被Server拉回矫正的情况</p>
<p>Paragon中使用了RootMotionSource(下面<strong>简称RMS</strong>)这个技术, 策略是动画单独播放, 程序控制位移</p>
<p>RMS是一个非常规性的RootMotion技术, 本质上已经脱离了动画, 通过程序模拟来实现每一帧的根骨骼位移. 相比较手动SetActorLocation等等的暴力方式, 好处是这套流程是在角色移动组件里的(下面会细讲), 不仅使用方便也满足于角色移动同步流程.</p>
<span id="more"></span>

<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_05_07_17_43_17_140.gif" alt="录制_2022_05_07_17_43_17_140"></p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用RMS最简单的方法是配合GAS使用, 见下图</p>
<p><img src="https://img.supervj.top/imgimage-20220120164653916.png" alt="image-20220120164653916"></p>
<p>因为GAS本身可以满足同步, 所以我们可以简单的在GA里就直接调用这类API(K2Node), 但是如何在脱离GAS的环境下使用呢? 这个就需要模仿GAS的Task类封装一套函数库, 例如下面这样</p>
<p><img src="https://img.supervj.top/imgimage-20220120170355260.png" alt="image-20220120170355260"></p>
<p>但是这样使用就需要自己手动同步两边的逻辑了</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_01_20_17_15_23_534~1.gif" alt="录制_2022_01_20_17_15_23_534~1"></p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>RootMotion主要的代码都在角色的移动组件内, 即<code>UCharacterMovementComponent</code>中的<code>PerformMovement()</code>里</p>
<p>我们按照阶段分类, <strong>重点是看一些RMS相关的内容</strong></p>
<h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>准备阶段, 先会清理/重置一些过期数据</p>
<p>然后会判断是否需要执行RootMotion相关的逻辑, 这里的判断依据有几个, 看下面代码即可</p>
<p><img src="https://img.supervj.top/imgimage-20220120172642888.png" alt="image-20220120172642888"></p>
<p>这个判定过了以后会先清理一波过期的RMS数据</p>
<p>然后再次进行一个一样的判定, 在两次之间其实就是做了一些数据的初始化, 然后这次判定过了以后就先判断是否是动画驱动的RootMotoin, 如果是那么就会执行<code>TickCharacterPose()</code>,这个逻辑会从动画中提取RootMotion数据设置到关键数据<code>RootMotionParams</code>上, 当中的过程本文省略</p>
<p><img src="https://img.supervj.top/imgimage-20220120193555533.png" alt="image-20220120193555533"></p>
<p>然后如果是网络的情况, 那么处理本地和网络的<code>RootMotionParams</code>数据</p>
<p><img src="https://img.supervj.top/imgimage-20220120173424329.png" alt="image-20220120173424329"></p>
<p>接下来就到了我们的RMS的处理, 这里会执行<code>FRootMotionSourceGroup::PrepareRootMotion()</code>的操作</p>
<p>这个过程以后我们的<code>RootMotionParams</code>已经是有数据了, 这个函数重点就是通过调用RMS具体对象的<code>PrepareRootMotion()</code>方法(后面我们通过具体案例讲解)来获取到这一帧应该得到的速度值</p>
<blockquote>
<p>核心部分就是这里,  这里不通过动画, 而是通过一个RMS对象封装了一套位移的算法</p>
<p>这一步是最关键的, 我们RMS的数据就是这一步被提取出来的</p>
</blockquote>
<h4 id="FRootMotionSourceGroup-PrepareRootMotion"><a href="#FRootMotionSourceGroup-PrepareRootMotion" class="headerlink" title="FRootMotionSourceGroup::PrepareRootMotion"></a>FRootMotionSourceGroup::PrepareRootMotion</h4><p>我们看重点, 首先根据优先级排序, 因为同一时间可能会有多个RootMotionSource, 在应用的时候会设置Prioty</p>
<p>然后根据不同的配置和服务端/客户端情况 计算得到当前期望的模拟时间, 作为参数传递给具体RMS对象的<code>PrepareRootMotion()</code>函数</p>
<p>我们这里使用的是<code>RootMotionSource_JumpForce()</code>那就会执行这个类的<code>PrepareRootMotion()</code></p>
<blockquote>
<p>实际上每个RMS类虽然数据有所差异, 但是大致逻辑没有差太多, 核心点就是计算得到RootMotionParams中所需要的偏移量</p>
</blockquote>
<p><img src="https://img.supervj.top/imgimage-20220120174205955.png" alt="image-20220120174205955"></p>
<p>这当中有几个讨巧的地方</p>
<p>默认位移就是按照线性的方式执行的, 但是RMS提供了几个曲线, 如</p>
<ul>
<li>PathOffsetCurve: Vector曲线, 3个轴向随着时间做的偏移量</li>
<li>Time Mapping Curve: 时间的曲线, 因为动画中的位移肯定不是线性的, 所以就是把linear的time再做一层转换, mapping curve的結果值会直接当作lerp function的alpha, 也就是说0=起点, 1=终点</li>
</ul>
<h3 id="应用阶段"><a href="#应用阶段" class="headerlink" title="应用阶段"></a>应用阶段</h3><p>这里会区分动画驱动还是RMS的方式</p>
<p>如果是动画驱动, 那么首先就是通过<code>ConvertLocalRootMotionToWorld()</code>做root motion数据的空间转换, <strong>这里就是MotionWarping的入口, 所以意味着我们用RMS的方式, 目前是无法实现MotionWarping的</strong>. 转换后就进行计算velocity的delta值</p>
<p>如果是RMS模式, 那么就从RMS对象中提取得到velocity(这里就是提取, 计算在Prepare阶段就完成了)</p>
<p>然后就把velocity反馈到移动计算当中了</p>
<p>当中有一部分代码是一些Debug和网络时间戳相关的代码, 这里先忽略了</p>
<h3 id="多个RMS同时作用"><a href="#多个RMS同时作用" class="headerlink" title="多个RMS同时作用"></a>多个RMS同时作用</h3><p>在移动组件中的<code>CurrentRootMotion</code>成员一直是一个数组的存在, 也就是同时一直保存着所有的有效的RMS, 那么如何执行多个RMS呢?</p>
<p>首先需要RMS的覆盖类型, 即<code>AccumulateMode</code>是Override还是Additive, 如果是Additive,那么不论多少都是一起作用</p>
<p>如果是Override, 那么会根据优先级排序, 在Prepare阶段执行排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (RootMotionSources.<span class="built_in">Num</span>() &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		RootMotionSources.<span class="built_in">StableSort</span>([](<span class="keyword">const</span> TSharedPtr&lt;FRootMotionSource&gt;&amp; SourceL, <span class="keyword">const</span> TSharedPtr&lt;FRootMotionSource&gt;&amp; SourceR)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (SourceL.<span class="built_in">IsValid</span>() &amp;&amp; SourceR.<span class="built_in">IsValid</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> SourceL-&gt;Priority &gt; SourceR-&gt;Priority;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">checkf</span>(<span class="literal">false</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;RootMotionSources being sorted are invalid pointers&quot;</span>));</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后看到移动组件通过RMS设置速度的代码和RMS中提取速度的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FVector NewVelocity = Velocity;</span><br><span class="line">CurrentRootMotion.<span class="built_in">AccumulateOverrideRootMotionVelocity</span>(DeltaSeconds, *CharacterOwner, *<span class="keyword">this</span>, NewVelocity);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsFalling</span>())</span><br><span class="line">&#123;</span><br><span class="line">    NewVelocity += CurrentRootMotion.<span class="built_in">HasOverrideVelocityWithIgnoreZAccumulate</span>() ? <span class="built_in">FVector</span>(DecayingFormerBaseVelocity.X, DecayingFormerBaseVelocity.Y, <span class="number">0.f</span>) : DecayingFormerBaseVelocity;</span><br><span class="line">&#125;</span><br><span class="line">Velocity = NewVelocity;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FRootMotionSourceGroup::AccumulateRootMotionVelocity</span></span></span><br><span class="line"><span class="function">	<span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		ERootMotionAccumulateMode RootMotionType,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">float</span> DeltaTime, </span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> ACharacter&amp; Character, </span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> UCharacterMovementComponent&amp; MoveComponent, </span></span></span><br><span class="line"><span class="params"><span class="function">		FVector&amp; InOutVelocity</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(RootMotionType == ERootMotionAccumulateMode::Additive || RootMotionType == ERootMotionAccumulateMode::Override);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Go through all sources, accumulate their contribution to root motion</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; RootMotionSource : RootMotionSources)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (RootMotionSource.<span class="built_in">IsValid</span>() &amp;&amp; RootMotionSource-&gt;AccumulateMode == RootMotionType)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">AccumulateRootMotionVelocityFromSource</span>(*RootMotionSource, DeltaTime, Character, MoveComponent, InOutVelocity);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// For Override root motion, we apply the highest priority override and ignore the rest</span></span><br><span class="line">			<span class="keyword">if</span> (RootMotionSource-&gt;AccumulateMode == ERootMotionAccumulateMode::Override)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以找到最高优先级的Overide的RMS以后就break了;</p>
<p>同样的,如果应用了2个同名的RMS,  通过<code>GetRootMotionSource</code>获取的RMS对象, 只会获取当前最高优先级的同名RMS对象</p>
<h2 id="RMS分析"><a href="#RMS分析" class="headerlink" title="RMS分析"></a>RMS分析</h2><p>RMS基类是<code>FRootMotionSource</code>, UE自己继承了好几个类, 如</p>
<ul>
<li>FRootMotionSource_MoveToForce: 最基础的线性移动</li>
<li>FRootMotionSource_MoveToDynamicForce: 动态目标的移动, 举例如果上面的是MoveToLocation, 那么这个就是MoveToActor</li>
<li>FRootMotionSource_JumpForce: 其实就是抛物线运动</li>
</ul>
<p>另外, RMS其实还有2个比较特殊的继承类, 因为RMS实际上是可以来用RootMotion来模拟类似物理中的AddImpulse/AddForce效果的, 相比于物理的力, RMS更可控, 下面就是2个已经封装好的力相关的RMS类</p>
<ul>
<li>FRootMotionSource_RadialForce: 顾名思义, 范围力,类似AddRadialForce</li>
<li>FRootMotionSource_ConstantForce: 常量的力, 类似AddForce</li>
</ul>
<p>先解释几个重要的基类变量的用途</p>
<ul>
<li>Priority: 优先级,  结合<code>AccumulateMode</code>是覆盖还是叠加使用, 如果是覆盖那么同一时间只会使用优先级最高的RMS</li>
<li>AccumulateMode: 叠加/覆盖</li>
<li>InstanceName: 当前RMS对象的Key, 可以用来查找或者移除</li>
<li>Settings: 特殊标签, 一般使用默认即可, 如果要忽略Z方向可以用<code>IgnoreZAccumulate</code></li>
<li>FinishVelocityParams: 完成 以后的速度模式, 默认就是维持RootMotion的速度, 也有设置速度和Clamp速度的选项</li>
</ul>
<h3 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h3><p>Parepare时的计算的是前后两帧的delta速度值, 如果有相应的曲线, 就对时间或速度做一定偏移, 最后填充为为RootMotionParames的Velocity, 下图是Jump模式的主要计算代码</p>
<p><img src="https://img.supervj.top/imgimage-20220124191424403.png" alt="image-20220124191424403"></p>
<h2 id="扩展-插件封装"><a href="#扩展-插件封装" class="headerlink" title="扩展: 插件封装"></a>扩展: 插件封装</h2><p>虽然引擎已经自带了一些基础的API, 但是我们的目标是把他扩展成能适配多种场合的一项功能, 如果能类似MotionWarping的机制就更棒了</p>
<p><a href="https://github.com/VJien/RootMotionSource">RootMotionSource开源插件GitHub地址</a></p>
<blockquote>
<p>强调一点, UE自己的RMS实现没有旋转, 只有位移.</p>
<p>不过我们可以想办法加入旋转</p>
</blockquote>
<h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><h4 id="ApplyRootMotionSource-MoveToForce"><a href="#ApplyRootMotionSource-MoveToForce" class="headerlink" title="ApplyRootMotionSource_MoveToForce"></a>ApplyRootMotionSource_MoveToForce</h4><p><img src="https://img.supervj.top/imgimage-20220507172637196.png" alt="image-20220507172637196"></p>
<p>点对点的移动, Start和Target都需要用角色中心作为参考点</p>
<p>拥有一个扩展Vector曲线做特定空间内的偏移(起点到终点为X轴, 此方向的右侧为Y轴, 下成RMS空间), </p>
<p>所有API都有一个ApplyMode, 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">ERMSApplyMode</span> :</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//不做处理</span></span><br><span class="line">	None = <span class="number">0</span>,</span><br><span class="line">	<span class="comment">//取代同名RMS, 会先把同名RMS移除掉</span></span><br><span class="line">	Replace,</span><br><span class="line">	<span class="comment">//用同名的RMS优先级+1应用</span></span><br><span class="line">	ApplyHigherPriority,</span><br><span class="line">	<span class="comment">//如果有同名的RMS,那就取消应用	</span></span><br><span class="line">	Block,</span><br><span class="line">	<span class="comment">//排队</span></span><br><span class="line">	Queue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为有时候会有重复的同名RMS调用, 这个是为了解决冲突和优先级问题</p>
</blockquote>
<p>另外所有不是必须的选项都统一放到一个结构体<code>ExtraSetting</code>中</p>
<p>同时相比较GAS的用法多了StartTime, 即可以选择该路径中的某个时刻点开始位移</p>
<ul>
<li><strong>2022.5.9更新: 添加了RotationSetting, Mode如果是Custom, 那么目标Rotator就是下面的TargetRotation, 如果是FaceToTarget就是Start指向Target的向量朝向</strong></li>
</ul>
<blockquote>
<p>注意: 曲线偏移是局部空间的绝对值</p>
</blockquote>
<h4 id="ApplyRootMotionSource-JumpForce"><a href="#ApplyRootMotionSource-JumpForce" class="headerlink" title="ApplyRootMotionSource_JumpForce"></a>ApplyRootMotionSource_JumpForce</h4><p><img src="https://img.supervj.top/imgimage-20220507173040960.png" alt="image-20220507173040960"></p>
<p>需要提供Height和Distance, 如下图,  角色跳跃的运行轨迹就是这样一个缺省的抛物线</p>
<p><img src="https://img.supervj.top/imgimage-20220124191018367.png" alt="image-20220124191018367"></p>
<blockquote>
<p>曲线的偏移比较遗憾, 并不是跟MoveToForce一样的绝对偏移值,而是接近于跳跃的抛物线, 就是你得自己算一个抛物线出来,  比较难以掌控, 测试发现使用缺省值还比较理想</p>
</blockquote>
<p><img src="https://img.supervj.top/imgimage-20220124191658039.png" alt="image-20220124191658039"></p>
<p>如果是按照下图的方式的曲线, 那么结果就是下面第二张图(左右反了)</p>
<p><img src="https://img.supervj.top/imgimage-20220124192511176.png" alt="image-20220124192511176"></p>
<p><img src="https://img.supervj.top/imgimage-20220124192459992.png" alt="image-20220124192459992"></p>
<h4 id="ApplyRootMotionSource-DynamicMoveToForce"><a href="#ApplyRootMotionSource-DynamicMoveToForce" class="headerlink" title="ApplyRootMotionSource_DynamicMoveToForce"></a>ApplyRootMotionSource_DynamicMoveToForce</h4><p><img src="https://img.supervj.top/imgimage-20220507173024559.png" alt="image-20220507173024559"></p>
<p>动态目标的MoveTo, 需要<code>UpdateDynamicMoveToTarget</code>配合来修改目标点, 可以用来做类似AIMoveTo,目标点是Actor的操作, 但是如果目标变化过大, 会导致瞬切.另外由于设定了Duration, 所以到了时间就不会再继续跟着目标走了</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_04_13_20_50_15_326.gif" alt="录制_2022_04_13_20_50_15_326"></p>
<h4 id="ApplyRootMotionSource-ConstantForece-ApplyRootMotionSource-RadialForece"><a href="#ApplyRootMotionSource-ConstantForece-ApplyRootMotionSource-RadialForece" class="headerlink" title="ApplyRootMotionSource_ConstantForece/ApplyRootMotionSource_RadialForece"></a>ApplyRootMotionSource_ConstantForece/ApplyRootMotionSource_RadialForece</h4><p>比较简单, 类似AddForce的效果, 暂略</p>
<h3 id="移动扩展"><a href="#移动扩展" class="headerlink" title="移动扩展"></a>移动扩展</h3><h4 id="ApplyRootMotionSource-MoveToForce-Parabola"><a href="#ApplyRootMotionSource-MoveToForce-Parabola" class="headerlink" title="ApplyRootMotionSource_MoveToForce_Parabola"></a>ApplyRootMotionSource_MoveToForce_Parabola</h4><p><img src="https://img.supervj.top/imgimage-20220413205509772.png" alt="image-20220413205509772"></p>
<p>抛物线的移动, 提供了2个曲线, 一个定义抛物线形态, 一个定义时间缩放</p>
<p><img src="https://img.supervj.top/imgimage-20220413205544715.png" alt="image-20220413205544715"></p>
<p>如果我们用上面的形态曲线,那么最终的结果如下</p>
<p>案例的分段数是8, 所以最终表现会有一些段落感, 分段越高越平滑</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_04_13_20_57_33_118.gif" alt="录制_2022_04_13_20_57_33_118"></p>
<h4 id="ApplyRootMotionSource-PathMoveToForce"><a href="#ApplyRootMotionSource-PathMoveToForce" class="headerlink" title="ApplyRootMotionSource_PathMoveToForce"></a>ApplyRootMotionSource_PathMoveToForce</h4><p><img src="https://img.supervj.top/imgimage-20220507173228177.png" alt="image-20220507173228177"></p>
<p>多路径点的MoveTo, 每个分段时间独立, 结果如下</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_05_07_17_33_47_406.gif" alt="录制_2022_05_07_17_33_47_406"></p>
<h3 id="适配动画的扩展"><a href="#适配动画的扩展" class="headerlink" title="适配动画的扩展"></a>适配动画的扩展</h3><p>如果只是上面单纯的移动, 那么RMS没有办法代替稍微复杂一点的RootMotion, 比如攀爬/翻越这种, 那么这里我就思考了如何将RMS扩展成<strong>支持动画数据</strong>的移动</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://img.supervj.top/imgimage-20220507173708734.png" alt="image-20220507173708734"></h4><p>基本上所有变量都有注释, 都不需要特殊解释, 不过有两种方式, 如果是bForwardCalculation的话原理是把动画数据提取出来生成动态的VectorCurve, 作为PathOffset传给MoveTo, <strong>优点是大部分计算都在初始应用阶段, 之后移动组件每一帧提取数据时本质上跟MoveToForce没有任何区别.</strong> 反之那么所有数据都是通过Rumtime计算, 结果更为准确但是开销会大一点</p>
<p>按用途分大致分为了3类</p>
<ul>
<li>ApplyRootMotionSource_SimpleAnimation</li>
</ul>
<p>就是单纯的跟播放RootMotion动画是一样的, 使用原始的动画根骨位移信息</p>
<ul>
<li>ApplyRootMotionSource_AnimationAdjustment</li>
</ul>
<p>这个需要设定一个目标点,通过缩放从动画中提取的RootMotion数据来适配移动到目标点</p>
<p><img src="https://img.supervj.top/imgimage-20220124201957454.png" alt="image-20220124201957454"></p>
<p><del>这里有几个参数需要注意</del></p>
<ol>
<li><del>AnimWarpingScale: 动画信息缩放的比例</del></li>
<li><del>WarpingType: 因为写这个BM类型的时候没有参考MotionWarping的做法(实际上也不一定合适, 后续尝试修改)动画偏移的缩放是按照这个枚举的设置来决定缩放参考的</del></li>
<li><del>WarpingAxis: 动画信息适配的是哪些轴, 比如攀爬很可能就是XZ平面就足够了, Y方向不需要有偏移,  因为动画本身实际上Y反向是有略微浮动的, 如果把这个信息加进去会稍微有点奇怪</del></li>
</ol>
<blockquote>
<p>4.19更新删除</p>
</blockquote>
<ul>
<li>ApplyRootMotionSource_AnimationWarping</li>
</ul>
<p>这个就是多目标的前者, 这个目标通过动画通知来配置, 跟MotionWarping基本一致, 区别就是这种方式只需要在应用的第一时间传入对应的目标和目标的Key(FName)就行了</p>
<p><img src="https://img.supervj.top/imgimage-20220507174104994.png" alt="image-20220507174104994"></p>
<blockquote>
<p>这里的动画通知只需要配置一个FName, 是否使用旋转在API传参的时候确定</p>
</blockquote>
<p>这个算法参考了MotionWarping, 实时计算每一帧对应的速度值和旋转</p>
<p>看最终表现</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_05_07_17_43_17_140.gif" alt="录制_2022_05_07_17_43_17_140"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>同样的实现了几个预测位置的API, 分RMS正在Runtime运行的和离线的, 只看API应该能从字面上理解含义</p>
<p><img src="https://img.supervj.top/imgimage-20220414101634855.png" alt="image-20220414101634855"></p>
<h3 id="实验性功能"><a href="#实验性功能" class="headerlink" title="实验性功能"></a>实验性功能</h3><p>尝试写了常见的异步K2Node, 用于监听某个RMS结束以后的回调事件, 但是比较坑爹的是移动组件本身对RMS的移除没有进行广播, 所以这个就蛋疼了, 方法有2个, 要么改引擎, 要么就只有自己每一帧去查询RMS有没有存在</p>
<p>因为是插件, 所以只能是后者</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>首先需要给角色加一个RMS组件, 确保组件的 ListenTaskEnd选项勾选</p>
<p>然后初始化</p>
<p><img src="https://img.supervj.top/imgimage-20220414101147636.png" alt="image-20220414101147636"></p>
<p>接下里执行异步节点就可以收到回调事件了</p>
<p><img src="https://img.supervj.top/imgimage-20220414101224315.png" alt="image-20220414101224315"></p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_04_14_10_12_35_791.gif" alt="录制_2022_04_14_10_12_35_791"></p>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><ul>
<li>4.19:   优化SimpleAnimation和Adjustment的BM模式的计算, 删除了3个输入配置</li>
<li>5.7:     <ul>
<li>添加了RMS旋转</li>
<li>整合了部分节点的2种算法, 用bForwardCalculation区别</li>
<li>优化Dynamic算法, 目前修改位置和时间不会导致跳帧</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>RootMotion源码简单解析</title>
    <url>/2021/08/02/RootMotion%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于平时经常使用<code>RootMotion</code>动画, 经常遇到一些问题, 所以还是凑空看了一下源码, 大概整理了一下<code>RootMotion</code>动画的运行机制和关键问题</p>
<span id="more"></span>



<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>先用伪代码简单的描述一下<code>RootMotion</code>的大概运行逻辑, 以单机蒙太奇动画示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 移动组件::PerformMovement</span><br><span class="line">cd1=&gt;condition: 是否有RootMotion?</span><br><span class="line">c1=&gt;operation: TickCharacterPose获取RootMotionParam</span><br><span class="line">c2=&gt;operation: 通过RootMotionParam计算速度</span><br><span class="line">e=&gt;end: 刷新位置</span><br><span class="line"></span><br><span class="line">st-&gt;cd1(yes)-&gt;c1-&gt;c2-&gt;e</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>这当中涉及到的内容非常多, 下面慢慢整理</p>
<h2 id="动画实例部分"><a href="#动画实例部分" class="headerlink" title="动画实例部分"></a>动画实例部分</h2><p>上面伪代码中需要的参数<code>RootMotionParams</code>来自于动画资源, 也就是来自动画实例部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>()</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FRootMotionMovementParams</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//..............</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="keyword">bool</span> bHasRootMotion;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="keyword">float</span> BlendWeight;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FTransform RootMotionTransform;</span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数主要就上面3个属性</p>
<hr>
<p>这里先讨论多数情况下的<code>RootMotion</code>, 一般都是由蒙太奇触发, 那么起点就是动画实例(<code>AnimInstance</code>)内的<code>UAnimInstance::Montage_Play()</code></p>
<p>播放蒙太奇的时候, 会创建一个<code>FAnimMontageInstance*</code>对象来真正的播放蒙太奇动画</p>
<p><img src="https://img.supervj.top//img/image-20210802110915641.png" alt="image-20210802110915641"></p>
<p>也就是是说, 播放蒙太奇会创建一个对象来管理这个蒙太奇动画, 同时也会存放在动画实例里面的数组和Map中</p>
<hr>
<p>下面要去看动画实例中的函数<code>UAnimInstance::UpdateAnimation</code></p>
<p><img src="https://img.supervj.top//img/image-20210802111137556.png" alt="image-20210802111137556"></p>
<p>看调用栈, 就是来自<code>PerformMovement()</code>(稍后再看)的调用</p>
<p>然后就调用到<code>UpdateMontage(DeltaSeconds);</code></p>
<p><img src="https://img.supervj.top//img/image-20210802111258219.png" alt="image-20210802111258219"></p>
<p><code>Montage_UpdateWeight();</code>这个刷新混合值</p>
<p>在<code> UAnimInstance::Montage_Advance()</code> 中重点做了这个事</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MontageInstance-&gt;<span class="built_in">Advance</span>(DeltaSeconds, RootMotionParams, bUsingBlendedRootMotion);</span><br></pre></td></tr></table></figure>

<p>然后在<code>FAnimMontageInstance::Advance()</code>中重点做了下面的事情</p>
<p><img src="https://img.supervj.top//img/image-20210802111520573.png" alt="image-20210802111520573"></p>
<p><code>ExtractRootMotionFromTrackRange()</code>函数获取了蒙太奇的位置插值信息, 这个计算内容也比较复杂, 会有片段以及slot等检测, 这里不展开. 得到的信息是本地空间的, 即是一个位移而不是位置, 最后计算的时候会经过转换到世界空间等计算; </p>
<blockquote>
<p>那么动画实例这一部分的任务就是计算出<code>RootMotionParams</code>, 等待着移动组件的使用</p>
</blockquote>
<h2 id="移动组件部分"><a href="#移动组件部分" class="headerlink" title="移动组件部分"></a>移动组件部分</h2><p>从<code>UCharacterMovementComponent::PerformMovement()</code>开始</p>
<p>先判断是否开启了<code>RootMotion</code>,  如果开启那么就<code>TickCharacterPose(DeltaSeconds);</code>,同时清理掉当前的<code>RootMotionParams</code>参数</p>
<blockquote>
<p><code>RootMotionParams</code>参数都是用完就清理, 包括在<code>SkeletalMesh</code>中也有类似操作</p>
</blockquote>
<p>然后是<code>TickCharacterPose()</code></p>
<p><img src="https://img.supervj.top//img/image-20210802113219463.png" alt="image-20210802113219463"></p>
<p>这里对<code>Mesh</code>的Tick会调用到之前动画实例部分的代码</p>
<p>下面通过<code>ConsumeRootMotion()</code>获取参数并清理了<code>Mesh</code>中的参数</p>
<p><code>Mesh</code>中保存里<code>AnimScriptInstance(就是当前的AnimInstance)</code>, <code>AnimScriptInstance::ConsumeExtractedRootMotion()</code>可以获取并清理<code>ExtractedRootMotion</code></p>
<p>然后设置缩放以后设置到当前的<code>RootMotionParams</code></p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">	<span class="keyword">float</span> AnimRootMotionTranslationScale;</span><br></pre></td></tr></table></figure>

<p>这个缩放参数 目前没有扩展出方便蓝图调用的API,  如果有需要可以手动设置此变量来动态的控制蒙太奇的运动,  参考UE5的<code>WarpMotion</code>组件的思路</p>
</blockquote>
<hr>
<p>接下来跳过一大堆代码,转到下面这里</p>
<p><img src="https://img.supervj.top//img/image-20210802113830692.png" alt="image-20210802113830692"></p>
<p><code>Velocity</code>变量直接决定下一次渲染我们角色的偏移位置, 那么实际上这里就可以简单理解为之前计算出来的<code>RootMotionParams</code>参数在这里经过了空间转换, 然后通过若干计算转换成了<code>Velocity</code></p>
<blockquote>
<p>偷懒具体计算就不去看了</p>
</blockquote>
<h2 id="动画序列RootMotion"><a href="#动画序列RootMotion" class="headerlink" title="动画序列RootMotion"></a>动画序列RootMotion</h2><p>用动画序列来执行根骨个运动, 即开启<code>RootMotion From Everything</code></p>
<p>开启此模式以后,  <code>PerformMovement()</code>会一直调用<code>TickCharacterPose()</code></p>
<p>随后会执行如下代码</p>
<p><img src="https://img.supervj.top//img/image-20210802152027895.png" alt="image-20210802152027895"></p>
<p>这里就要提到动画实例里面的一个多线程辅助类<code>FAnimInstanceProxy</code>,如果当前的<code>RootMotionMode</code>为<code>RootMotion From Everything</code>，那么我们在主线程Tick的时候就会立刻去更新<code>FAnimInstanceProxy::TickAssetPlayerInstances()</code>，这样是为了能及时获取到每一帧的<code>Rootmotion</code>信息</p>
<p><img src="https://img.supervj.top//img/image-20210802152320194.png" alt="image-20210802152320194"></p>
<p>随后通过<code>FAnimInstanceProxy</code>类来一直获取<code>RootMotionMovementParams</code>参数</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>其实RootMotion本质上走的还是移动组件的处理流程，只不过其移动数据是从动画里面提取的。</li>
<li>Rootmotion只支持Montage的同步; UE4的状态机太复杂不容易同步</li>
<li>除非是常规的线性运动的Rootmotion，其他的不规则的运动几乎无法预测, 导致同步效果不理想</li>
<li>从性能上说，减少数据的同步和校验可以减少服务器的CPU和内存的压力，所以Rootmotion在网络游戏中的使用要慎重考虑。</li>
</ul>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>animation</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime重定向</title>
    <url>/2021/11/17/Runtime%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然UE4动画蓝图系统不支持跨骨架的动画使用, 但是实际上UE4自己写了一套Runtime的动画重定向机制, 当然这个跟离线重定向是不同的概念, 理论上讲, Runtime的重定向<strong>只满足骨架相同, 但是参考姿势不同</strong>的动画表现</p>
<p><img src="https://img.supervj.top/img%E5%AE%9E%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="实时重定向"></p>
<span id="more"></span>





<a name = "SkeletonRemappings ">

<h2 id="FSkeletonRemapping"><a href="#FSkeletonRemapping" class="headerlink" title="FSkeletonRemapping"></a>FSkeletonRemapping</h2><p>USkeleton即我们的骨架资源里保存着这样一个数据, 他保存了本骨架与资源里所有其他骨架的比对信息, 见下图</p>
<p><img src="https://img.supervj.top/imgimage-20211117102615321.png" alt="image-20211117102615321"></p>
<p><img src="https://img.supervj.top/imgimage-20211117102632491.png" alt="image-20211117102632491"></p>
<p>骨架资源在编辑器启动加载资源完以后会创建此数组, 在编辑器有骨架更新以后也会刷新此数组</p>
<p>考虑线程安全, UE直接使用一个全局数组来保存所有加载的骨架资源</p>
<p>在骨架删除以后自己移除自己, 然后广播所有其他骨架来删除对应的Mapping数据</p>
<p><img src="https://img.supervj.top/imgimage-20211117102748263.png" alt="image-20211117102748263"></p>
<p>当然,  UE的规则是通过名字查找匹配骨架, 与层级无关系, 也不能通过离线重定向的Rig文件来查找</p>
<p><img src="https://img.supervj.top/imgimage-20211117102832520.png" alt="image-20211117102832520"></p>
<p>除了匹配骨骼, 后面还保存了一个类似map格式的数据表, 用于比对source和target骨骼对应的旋转关系, 计算方式非常复杂, 可以看下图参考或者<code>Skeleton.cpp</code>中262行</p>
<p><img src="https://img.supervj.top/imgimage-20211117102849113.png" alt="image-20211117102849113"></p>
<p>重点就是计算得到这个Q0和Q1, 用下图的方式计算</p>
<p><img src="https://img.supervj.top/imgimage-20211115114804975.png" alt="image-20211115114804975"></p>
<p>在重定向的时候会用到这个表格设置新的cs变换信息</p>
<p><img src="https://img.supervj.top/imgimage-20211115113718863.png" alt="image-20211115113718863"></p>
<p>另外, Scale是不做处理的</p>
<p>这个算法完全是推导出来的, 在debug的时候很不直观, 所以导致修改或者测试成本比较高, 目前得出的结论是这一套计算只会正对参考姿势不同的骨架的重定向, 不能完成差别非常大的骨架的重定向, 似乎在runtime中要完成离线的重定向(开销很大)也是不太合理的事情</p>
<h2 id="DecompressPose"><a href="#DecompressPose" class="headerlink" title="DecompressPose"></a>DecompressPose</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DecompressPose</span><span class="params">(FCompactPose&amp; OutPose, <span class="keyword">const</span> FCompressedAnimSequence&amp; CompressedData, <span class="keyword">const</span> FAnimExtractContext&amp; ExtractionContext, USkeleton* SourceSkeleton, <span class="keyword">float</span> SequenceLength, EAnimInterpolationType Interpolation, <span class="keyword">bool</span> bIsBakedAdditive, <span class="keyword">const</span> TArray&lt;FTransform&gt;&amp; RetargetTransforms, FName SourceName, <span class="keyword">const</span> FRootMotionReset&amp; RootMotionReset)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>动画蓝图里面随意播放一个动画序列, 从调用栈可以看到, 动画Node提取Pose数据最终是来自<code>DecompressPose()</code>库函数, 字面意思就是解压缩Pose, 我们重点也是要来看一下这个函数的内容</p>
<p><img src="https://img.supervj.top/imgimage-20211117102426140.png" alt="image-20211117102426140"></p>
<p>下面我们简述一下解压缩的流程</p>
<ol>
<li>首先会从动画资源的骨架与作用目标骨架获取 SkeletonRemapping, 这是每个骨架都会保存的一个匹配字典, 可以看<a href="#SkeletonRemappings">↑SkeletonRemappings </a>, UE自己会去查找骨骼是否匹配, 匹配就能使用其他骨骼的动画, 当然如果是同一套骨架, 就直接跳过这部分匹配逻辑</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211112100429353.png" alt="image-20211112100429353"></p>
<ol start="2">
<li>从全局单例获取5个数据结构对象,并重置, <strong>干啥用??</strong> 看下面</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211112100521687.png" alt="image-20211112100521687"></p>
<ol start="3">
<li>遍历所有Track(从压缩数据获取的骨骼数),  并且如果第一根骨骼是root骨骼(基本都是),那么从序号1开始遍历. 目的是把所有Compact序号作为key, 把所有Track或者Bone序号最为value添加到第2步的各种键值对中;  用于后续Runtime重定向需要用</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211112110356261.png" alt="image-20211112110356261"></p>
<ol start="4">
<li><p>单独解压缩Root骨骼, 同时如果跨骨骼, 那么还会根据Mapping信息校正root骨骼的旋转和位移, 重定向根骨骼</p>
</li>
<li><p>对旋转缩放类型(基本上是全部)的骨骼进行解压缩</p>
</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211117133519560.png" alt="image-20211117133519560"></p>
<ol start="6">
<li><p>根据上面用到的键值对, 对各种类型的骨骼进行重定向,  这之前的pose信息都是原始的(新骨架对应的原始动画数据)</p>
</li>
<li><p>输出pose</p>
</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>通过修改<code>FSkeletonRemapping</code>类, 因为毕竟这个类的创建是一次性的, 我们就在创建或者刷新的时候扩展通过Rig来查找骨架匹配信息, 那么理论上可以做到真正的跨骨架的使用同一套动画</p>
<p><img src="https://img.supervj.top/imgimage-20211117103304663.png" alt="image-20211117103304663"></p>
<p><img src="https://img.supervj.top/imgimage-20211117103432419.png" alt="image-20211117103432419"></p>
<p>上图中的做法比较简单粗暴, 在动画配置里加一个bool和数组, 符合要求的骨架会去Rig查找骨架匹配信息</p>
<hr>
<p>离线重定向是从模型获取的元数据, 通过新旧骨架的比对计算, 最终的目的是把修改后的BoneTrack信息写入新动画资源(保存在Model类中), 而实时重定向是提取或者说是解压缩了动画资源的动画数据来进一步的校正, 实际上两者的数据来源是不一样的, 或者是前后关系</p>
<p>动画资源Node比如SequencePlayer节点, 他获取的基础Pose信息就是参考姿势的局部空间数据,  然后再结合解压缩出来的动画数据进行处理的;</p>
<p>至于不同骨架解压出来的数据是怎么处理的? </p>
<p> UE解压缩动画数据使用的是<code>ispc</code>接口, 这里具体方式就不在讨论范围了, 有兴趣的可以去看 <code>AnimEncoding_PerTrackCompression.ispc</code>的实现</p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title>UHT和UBT分析</title>
    <url>/2021/03/11/UBT%E5%92%8CUHT/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文大致梳理一下UBT和UHT的作用以及涉及到的其他几个概念的使用</p>
<span id="more"></span>

<h2 id="UHT"><a href="#UHT" class="headerlink" title="UHT"></a>UHT</h2><p>UHT是C++代码解析生成工具，我们在C++里面写的<code>UClass</code>和<code>#include</code>和<code>.generate.h</code>都是为UHT提供了对应的信息来生成对应的C++反射代码的</p>
<p>简单说, 由于UE4代码不是标准的C++代码, 而UHT主要作用就是把UE4的C++代码翻译成标准C++代码</p>
<h2 id="UBT"><a href="#UBT" class="headerlink" title="UBT"></a>UBT</h2><p>主要责任是UE4的各个模块的编译并处理各模块之间的依赖关系的。</p>
<p>build.cs和Target.cs都是为这个工具来服务的。</p>
<p>UBT调用标准C++代码的编译器(VS)来将UHT转化后的标准C++代码完全编译成二进制文件</p>
<h2 id="Target-cs"><a href="#Target-cs" class="headerlink" title="Target.cs"></a>Target.cs</h2><p>UBT编译的目标类型,</p>
<p>每个项目都包含一个名称为<code>项目名.target.cs</code>的文件, 这个<code>C#</code>文件主要描述描述生成的目标类型, 默认为<code>Game</code>, 还可以为其他类型</p>
<p><a href="https://docs.unrealengine.com/en-US/ProductionPipelines/BuildTools/UnrealBuildTool/TargetFiles/index.html">官方文档</a></p>
<ul>
<li><strong>Game</strong> - 默认模式, 一般的打包形式</li>
<li><strong>Client</strong> - 类似Game, 但是不包含服务端代码</li>
<li><strong>Server</strong> - 类似Game, 但是不包含客户端代码, 一般作为独立服务器打包</li>
<li><strong>Editor</strong> - 包含编辑器模块</li>
<li><strong>Program</strong> -独立程序</li>
</ul>
<h2 id="Build-cs"><a href="#Build-cs" class="headerlink" title="Build.cs"></a>Build.cs</h2><p>每个模块都包含的一个文件, 每个<code>.build.cs</code>文件都声明一个从<code>ModuleRules</code>基类派生的类，并设置控制应如何从其构造函数构造它的属性。这些<code>.build.cs</code>文件由<code>UBT</code>编译，并构造为确定总体编译环境。</p>
<p>类似的如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using UnrealBuildTool;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">public class MyModule : ModuleRules</span><br><span class="line">&#123;</span><br><span class="line">    public MyModule(ReadOnlyTargetRules Target) : base(Target)</span><br><span class="line">    &#123;</span><br><span class="line">        // Settings go here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Public和Private"><a href="#Public和Private" class="headerlink" title="Public和Private"></a>Public和Private</h3><p>常见的如<code>PublicDependencyModuleNames</code>和<code>PrivateDependencyModuleNames</code>, 或者<code>PublicIncludePaths</code>和<code>PrivateIncludePaths</code></p>
<p>有些文章有误读, 解释与目录有关系, 其实两者主要描述的是三个模块及以上的关系, 如A包含B,B包含C这种情况, 对于两个模块的情况可以随意使用</p>
<p>对于三个模块的情况,无法获得Private中模块的任何信息,可以获得Public中模块的头文件信息.</p>
<p>下图来自知乎大佬, 另外还有国外大佬的<a href="https://docs.google.com/presentation/d/1rSFFQk7RxNAHevROfVvUNviUfIntLkO_HpdvzHLkNEs/edit#slide=id.g6e0e4b3bcf_2_145">PPT</a></p>
<p><img src="https://img.supervj.top//img/chrome_u7pBEW5ju4.png" alt="chrome_u7pBEW5ju4"></p>
<blockquote>
<p>结论: <strong>建议只使用PrivateDependencyModuleNames.</strong></p>
</blockquote>
<h3 id="Include和Dependency"><a href="#Include和Dependency" class="headerlink" title="Include和Dependency"></a>Include和Dependency</h3><p>二者都能使本模块可以包含其它模块Public目录下的头文件,从而调用函数.</p>
<p>但<code>IncludePathModuleNames</code>只能调用<strong>定义全部在头文件里</strong>的函数.</p>
<blockquote>
<p>结论: 使用Dependency</p>
</blockquote>
<h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><p>详情见<a href="https://docs.unrealengine.com/zh-CN/ProductionPipelines/BuildTools/UnrealBuildTool/ModuleFiles/index.html">官方文档</a></p>
<h4 id="PublicIncludePaths"><a href="#PublicIncludePaths" class="headerlink" title="PublicIncludePaths"></a>PublicIncludePaths</h4><p>常用于包含第三方库的头文件如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> string ThirdPartyPath</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; <span class="keyword">return</span> Path.<span class="built_in">GetFullPath</span>(Path.<span class="built_in">Combine</span>(ModulePath, <span class="string">&quot;../../ThirdParty/&quot;</span>)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">PublicIncludePaths.<span class="built_in">Add</span>(Path.<span class="built_in">Combine</span>(ThirdPartyPath, <span class="string">&quot;Include&quot;</span>));</span><br></pre></td></tr></table></figure>





<h4 id="PublicLibraryPaths-PublicAdditionalLibaries"><a href="#PublicLibraryPaths-PublicAdditionalLibaries" class="headerlink" title="PublicLibraryPaths/PublicAdditionalLibaries"></a>PublicLibraryPaths/PublicAdditionalLibaries</h4><p>系统/库路径列表（.lib文件的目录） - 通常用于外部（第三方）模块</p>
<p>如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PublicAdditionalLibraries.<span class="built_in">Add</span>(Path.<span class="built_in">Combine</span>(ThirdPartyPath, <span class="string">&quot;Lib&quot;</span>, <span class="string">&quot;ThirdPartyDLL.lib&quot;</span>));</span><br></pre></td></tr></table></figure>



<h4 id="RuntimeDependencies"><a href="#RuntimeDependencies" class="headerlink" title="RuntimeDependencies"></a>RuntimeDependencies</h4><p>该模块在运行时依赖的文件列表。这些文件将与目标一同暂存.</p>
<p>如果使用动态链接库可以用此添加,  不然打包以后无法正确获取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RuntimeDependencies.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">RuntimeDependency</span>(Path.<span class="built_in">Combine</span>(ThirdPartyPath, <span class="string">&quot;DLL&quot;</span>, <span class="string">&quot;ThirdPartyDLL.dll&quot;</span>)));</span><br></pre></td></tr></table></figure>







<h2 id="BuildConfiguration"><a href="#BuildConfiguration" class="headerlink" title="BuildConfiguration"></a>BuildConfiguration</h2><p><strong>UBT</strong>将从以下位置中的XML配置文件读取设置：</p>
<ul>
<li>Engine/Saved/UnrealBuildTool/BuildConfiguration.xml</li>
<li>User Folder/AppData/Roaming/Unreal Engine/UnrealBuildTool/BuildConfiguration.xml</li>
<li>My Documents/Unreal Engine/UnrealBuildTool/BuildConfiguration.xml</li>
</ul>
<p>具体可以看<a href="https://docs.unrealengine.com/en-US/ProductionPipelines/BuildTools/UnrealBuildTool/BuildConfiguration/index.html">官方文档</a></p>
<h2 id="IWYU"><a href="#IWYU" class="headerlink" title="IWYU"></a><strong>IWYU</strong></h2><p>全称<code>nclude what you use</code>,即<strong>只包含你需要的头文件</strong>。</p>
<p>在旧版本的虚幻引擎4（UE4）中，引擎的大部分功能通过大型、以模块为中心的头文件（如 <code>Engine.h</code> 和 <code>UnrealEd.h</code>）进行包含。通过预编译头文件（PCH）快速编译这些文件即可达成较快的编译时间。但随着引擎的更新，这成为了一个瓶颈。</p>
<p>通过IWYU，每个文件只包括其需要的内容。我们选择使用的所有PCH文件纯粹只是作为基础源文件之上的优化层。可对它们进行修改，将编译时间缩至最短。其独立于源文件本身的修改，不会影响代码是否成功编译。</p>
<p>编写IWYU代码时，我们需要遵循4个特定规则：</p>
<ol>
<li><strong>所有头文件包含其所需的依赖性。</strong></li>
<li><strong>.cpp文件首先包含其匹配的*.h文件。</strong></li>
<li><strong>PCH文件已不再是显式包含。</strong></li>
<li><strong>不再包含单块头文件。</strong></li>
</ol>
<p><a href="https://docs.unrealengine.com/zh-CN/ProductionPipelines/BuildTools/UnrealBuildTool/IWYU/index.html">官方文档</a></p>
<h3 id="验证已启用"><a href="#验证已启用" class="headerlink" title="验证已启用"></a>验证已启用</h3><p>在<code>build,cs</code>文件中的<code>PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;</code></p>
<h2 id="其他描述符"><a href="#其他描述符" class="headerlink" title="其他描述符"></a>其他描述符</h2><h3 id="MinimalAPI"><a href="#MinimalAPI" class="headerlink" title="MinimalAPI"></a>MinimalAPI</h3><p>暴露该类的类型信息让其它模块可以</p>
<ul>
<li>Cast到该类型</li>
<li>继承该类型 (该类型的所有定义在.cpp文件的<strong>虚函数</strong>都需要导出)</li>
<li>使用<strong>内联</strong>函数</li>
</ul>
<h3 id="YourModuleName-API宏"><a href="#YourModuleName-API宏" class="headerlink" title="[YourModuleName]_API宏"></a>[YourModuleName]_API宏</h3><ul>
<li>放函数声明前用于暴露该函数</li>
<li>放类声明前用于暴露该类的<strong>所有内容</strong></li>
</ul>
<blockquote>
<p>结论: 不加这个宏的话其他模块就无法使用该函数/类</p>
</blockquote>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>UBT</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4发布steam游戏流程</title>
    <url>/2020/05/09/UE4%E4%BD%BF%E7%94%A8Steam%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B8%83Steam%E5%8C%85/</url>
    <content><![CDATA[<blockquote>
<p>2019年4月18日在steam发布了个人一款独立动作游戏《EndlessHell》，本文将借此记录发布steam游戏的流程</p>
<p><a href="https://store.steampowered.com/app/1055000/EndlessHell/">游戏链接</a></p>
<p>UE4版本4.21</p>
<p><a href="https://partner.steamgames.com/doc/gettingstarted">SteamWork入门指南</a></p>
<p>文中内容前半部分为提交当时编辑，搬运至博客后更新后续部分</p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="SteamDLL"><a href="#SteamDLL" class="headerlink" title="SteamDLL"></a>SteamDLL</h3><p>复制steam程序中的dll文件至本地引擎文件内<code>*\UE_4.21\Engine\Binaries\ThirdParty\Steamworks\Steamv139</code></p>
<p>如下图所示</p>
<p><img src="https://img.supervj.top/imgsteamapi2.png"></p>
<p><img src="https://img.supervj.top/imgsteamapi3.png"></p>
<p>最终效果如下</p>
<p><img src="https://img.supervj.top/imgapi1.png"></p>
<h3 id="Engine-ini"><a href="#Engine-ini" class="headerlink" title="Engine.ini"></a>Engine.ini</h3><p>添加如下代码</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[/Script/Engine.GameEngine]</span></span><br><span class="line">+<span class="attr">NetDriverDefinitions</span>=(DefName=<span class="string">&quot;GameNetDriver&quot;</span>,DriverClassName=<span class="string">&quot;OnlineSubsystemSteam.SteamNetDriver&quot;</span>,DriverClassNameFallback=<span class="string">&quot;OnlineSubsystemUtils.IpNetDriver&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">[OnlineSubsystem]</span></span><br><span class="line"><span class="attr">DefaultPlatformService</span>=Steam</span><br><span class="line"></span><br><span class="line"><span class="section">[OnlineSubsystemSteam]</span></span><br><span class="line"><span class="attr">bEnabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SteamDevAppId</span>=<span class="number">480</span>//测试ID，正式包用自己的ApplicationID</span><br><span class="line"><span class="attr">Achievement_0_Id</span>=ACH_WIN_ONE_GAME //添加成就，正式包用自己的成就</span><br><span class="line"><span class="section">[/Script/OnlineSubsystemSteam.SteamNetDriver]</span></span><br><span class="line"><span class="attr">NetConnectionClassName</span>=<span class="string">&quot;OnlineSubsystemSteam.SteamNetConnection&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="UE4配置"><a href="#UE4配置" class="headerlink" title="UE4配置"></a>UE4配置</h3><p>开启子系统，如下图 </p>
<p><img src="https://img.supervj.top/imgsteam1.PNG"></p>
<p>至此进入游戏后按<code>shift+tab</code>可以唤出steam窗口,记住需要使用==独立窗口模式运行==</p>
<p><img src="https://img.supervj.top/imgsteam2.png"></p>
<ul>
<li>如需使用steamapi，在target.cs中开启如下选项</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">bUsesSteam = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>同时在<code>build.cs</code>中如下模块</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">PublicDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="built_in">string</span>[] &#123;</span><br><span class="line">            <span class="string">&quot;OnlineSubsystem&quot;</span>,</span><br><span class="line">            <span class="string">&quot;OnlineSubsystemUtils&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Steamworks&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"> DynamicallyLoadedModuleNames.Add(<span class="string">&quot;OnlineSubsystemSteam&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="SteamWork"><a href="#SteamWork" class="headerlink" title="SteamWork"></a>SteamWork</h2><ul>
<li>首先需要注册一个stemawork账号</li>
<li>发布steam游戏需要申请一个ID，本作ID是<em><strong>1055000</strong></em>（此数字+1为depot的ID），以下用的此数字均为游戏ID，另外需要一次性付费<strong>100美刀</strong>（当时价格），当销售额度达到1000美刀后返还</li>
<li>另外需要提供个人银行账户，每月月初当上个月份税后金额达到100刀以上会打款到账户</li>
<li>在进入下面之前需要先下载steamSDK，如steamwork首页右下角位置,如图</li>
</ul>
<img src="https://img.supervj.top/imgsteamSdk.jpg" style="zoom:50%;" />

<h3 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h3><h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><h5 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h5><p>设置正确的游戏名字和平台</p>
<h5 id="steam输入"><a href="#steam输入" class="headerlink" title="steam输入"></a>steam输入</h5><p>提供的输入方式，如手柄，xbox等</p>
<h4 id="SteamPipe"><a href="#SteamPipe" class="headerlink" title="SteamPipe"></a>SteamPipe</h4><h6 id="提交版本"><a href="#提交版本" class="headerlink" title="提交版本"></a>提交版本</h6><p>这个是版本生成器，用于提交版本和选择当前在商店下载的游戏版本</p>
<p>提交版本可以使用SDK包中的工具提交，在开始提交之前需要设置如下内容</p>
<ol>
<li>修改<code> sdk\tools\ContentBuilder\scripts\app_build_*.vdf</code>文件为<code>app_build_1055000.vdf</code>，同时修改内容为</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;appbuild&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;appid&quot;</span>	<span class="attr">&quot;1055000&quot;</span></span><br><span class="line">	<span class="attr">&quot;desc&quot;</span> <span class="attr">&quot;Your build description here&quot;</span> <span class="comment">// description for this build</span></span><br><span class="line">	<span class="attr">&quot;buildoutput&quot;</span> <span class="attr">&quot;..\output\&quot; // build output folder for .log, .csm &amp; .csd files, relative to location of this file</span></span><br><span class="line"><span class="attr">	&quot;</span>contentroot<span class="attr">&quot; &quot;</span>..\content\<span class="attr">&quot; // root content folder, relative to location of this file</span></span><br><span class="line"><span class="attr">	&quot;</span>setlive<span class="attr">&quot;	&quot;</span><span class="attr">&quot; // branch to set live after successful build, non if empty</span></span><br><span class="line"><span class="attr">	&quot;</span>preview<span class="attr">&quot; &quot;</span>0<span class="attr">&quot; // to enable preview builds</span></span><br><span class="line"><span class="attr">	&quot;</span>local<span class="attr">&quot;	&quot;</span><span class="attr">&quot;	// set to flie path of local content server </span></span><br><span class="line"><span class="attr">	</span></span><br><span class="line"><span class="attr">	&quot;</span>depots<span class="attr">&quot;</span></span><br><span class="line"><span class="attr">	&#123;</span></span><br><span class="line"><span class="attr">		&quot;</span>1055001<span class="attr">&quot; &quot;</span>depot_build_1055001.vdf<span class="attr">&quot;</span></span><br><span class="line"><span class="attr">	&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>必须修改的是appid和depots的内容， 对应的ID修改成自己的</p>
</blockquote>
<ol start="2">
<li>depot_build_1055001.vdf文件同样修改内容为</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;DepotBuildConfig&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set your assigned depot ID here</span></span><br><span class="line">	<span class="attr">&quot;DepotID&quot;</span> <span class="attr">&quot;1055001&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set a root for all content.</span></span><br><span class="line">	<span class="comment">// All relative paths specified below (LocalPath in FileMapping entries, and FileExclusion paths)</span></span><br><span class="line">	<span class="comment">// will be resolved relative to this root.</span></span><br><span class="line">	<span class="comment">// If you don&#x27;t define ContentRoot, then it will be assumed to be</span></span><br><span class="line">	<span class="comment">// the location of this script file, which probably isn&#x27;t what you want</span></span><br><span class="line">	<span class="attr">&quot;ContentRoot&quot;</span>	<span class="attr">&quot;E:\Download\steamworks_sdk_144\sdk\tools\ContentBuilder\content&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// include all files recursivley</span></span><br><span class="line">  <span class="attr">&quot;FileMapping&quot;</span></span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">// This can be a full path, or a path relative to ContentRoot</span></span><br><span class="line">    <span class="attr">&quot;LocalPath&quot;</span> <span class="attr">&quot;*&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// This is a path relative to the install folder of your game</span></span><br><span class="line">    <span class="attr">&quot;DepotPath&quot;</span> <span class="attr">&quot;.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If LocalPath contains wildcards, setting this means that all</span></span><br><span class="line">    <span class="comment">// matching files within subdirectories of LocalPath will also</span></span><br><span class="line">    <span class="comment">// be included.</span></span><br><span class="line">    <span class="attr">&quot;recursive&quot;</span> <span class="attr">&quot;1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// but exclude all symbol files  </span></span><br><span class="line">	<span class="comment">// This can be a full path, or a path relative to ContentRoot</span></span><br><span class="line">  <span class="string">&quot;FileExclusion&quot;</span> <span class="string">&quot;*.pdb&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要修改depotsid和content的路径</p>
</blockquote>
<ol start="3">
<li><p>运行<code> \sdk\tools\ContentBuilder\builder\steamcmd.exe</code>准备提交内容</p>
</li>
<li><p>```\sdk\tools\ContentBuilder\content``内是<strong>游戏包的内容</strong>，请确保exe启动名字与==[安装&gt;通用安装&gt;启动选项&gt;可执行文件]==名字一样</p>
</li>
<li><p>更新&gt;登录&gt;运行如下脚本提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run_app_build E:\Download\steamworks_sdk_144\sdk\tools\ContentBuilder\scripts\app_build_1055000.vdf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>路径为app_build文件的路径</p>
</blockquote>
</li>
<li><p>提交后看到如下图的新的分支，修改default为当前展示和下载的分支</p>
</li>
</ol>
<p><img src="https://img.supervj.top/imgdepot.jpg"></p>
<h6 id="depot设置"><a href="#depot设置" class="headerlink" title="depot设置"></a>depot设置</h6><p>此页面比较简单，需要正确设置程序支持的<strong>语言</strong>和<strong>平台</strong></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="通用安装"><a href="#通用安装" class="headerlink" title="通用安装"></a>通用安装</h5><h6 id="安装文件夹"><a href="#安装文件夹" class="headerlink" title="安装文件夹"></a>安装文件夹</h6><p>下载安装以后的文件夹名字</p>
<h6 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h6><ul>
<li>可执行文件：启动程序，一般就是引擎打包以后那个exe文件</li>
<li>其他正确设置就可以</li>
</ul>
<h6 id="可再发行文件"><a href="#可再发行文件" class="headerlink" title="可再发行文件"></a>可再发行文件</h6><p>Steam 可以自动安装您的许多常见可再发行文件</p>
<h6 id="客户端图像"><a href="#客户端图像" class="headerlink" title="客户端图像"></a>客户端图像</h6><p>根据要求规格上传各种icon文件</p>
<h4 id="统计与成就"><a href="#统计与成就" class="headerlink" title="统计与成就"></a>统计与成就</h4><h6 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h6><p>设置统计的类型和名称</p>
<h6 id="成就"><a href="#成就" class="headerlink" title="成就"></a>成就</h6><p>设置名称、描述和icon</p>
<p><img src="https://img.supervj.top/imgchengjiu.jpg"></p>
<h6 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h6><p>成就名称和描述的本地化，可以下载文档再提交更新</p>
<p><img src="https://img.supervj.top/imgbendihua.jpg"></p>
<h4 id="管理序列号"><a href="#管理序列号" class="headerlink" title="管理序列号"></a>管理序列号</h4><p>申请序列号，注意其中不同的序列号的用途</p>
<p><img src="https://img.supervj.top/imgcdkey.jpg"></p>
<p>在首页有下载选项</p>
<p><img src="https://img.supervj.top/imgkey.jpg"></p>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>所有修改完后都需要进入发布选项进行发布到商店，系统会提示差异</p>
<h4 id="成就API"><a href="#成就API" class="headerlink" title="成就API"></a>成就API</h4><ul>
<li>很容易被忘记的一点，ini文件利必须设置与网站成就对应的字符串，如下图</li>
</ul>
<p><img src="https://img.supervj.top/imgsteam%E6%88%90%E5%B0%B11.jpg"></p>
<ul>
<li>蓝图api</li>
</ul>
<p><img src="https://img.supervj.top/imgsteam%E6%88%90%E5%B0%B13.jpg"></p>
<p>读写成就之前必须先缓存成功</p>
<p>目前版本对于成就进度条的读取和设置只有0或者1，所以只要写入的参数大于0成就即完成，不知后续更新能不能完善</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>steam</tag>
      </tags>
  </entry>
  <entry>
    <title>创建异步节点</title>
    <url>/2020/06/01/UE4%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img.supervj.top/img/AIMoveTo/move_4.jpg"></p>
<blockquote>
<p>如图所示，我们经常在UE4内看到如此的异步节点，简单说此类节点的输出并非像函数一样瞬间完成，而是拥有自己的生命周期，此类节点一般在右上角有一个<strong>时钟标志</strong></p>
<p>本文讲解如何制作类似<code>AI_MoveTo</code>的异步节点</p>
<p>另一篇<a href="%5Bhttps://supervj.top/2020/05/27/AI_MoveTo%E7%A0%94%E7%A9%B6/%5D(https://supervj.top/2020/05/27/AI_MoveTo%E7%A0%94%E7%A9%B6/)">AI_MoveTo简单分析和扩展</a>介绍<code>AI_MoveTo</code>的简单运行机制和其他扩展方式</p>
</blockquote>
<hr>
<blockquote>
<ul>
<li>2020.11.24更新:</li>
</ul>
<p>更新各类移动扩展函数库以及K2Node</p>
<p><a href="git@github.com:VJien/MovementEx.git">github</a></p>
<p><img src="https://img.supervj.top//img/image-20201124134801666.png" alt="image-20201124134801666"></p>
<ul>
<li>2021.2.25更新:</li>
</ul>
<p>基于<code>UBlueprintAsyncActionBase</code>的异步节点 <a href="#Asyc">跳转</a></p>
</blockquote>
<span id="more"></span>

<h2 id="UK2Node-AIMoveTo"><a href="#UK2Node-AIMoveTo" class="headerlink" title="UK2Node_AIMoveTo"></a>UK2Node_AIMoveTo</h2><p>我们先看一下这个节点的所有申明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AIGRAPH_API</span> <span class="title">UK2Node_AIMoveTo</span> :</span> <span class="keyword">public</span> UK2Node_BaseAsyncTask<span class="comment">//继承类</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_UCLASS_BODY</span>() <span class="comment">//加入UCLASS生成默认构造函数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetTooltipText</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">//鼠标移动到节点的说明</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetNodeTitle</span><span class="params">(ENodeTitleType::Type TitleType)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;<span class="comment">//节点的名字</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetMenuCategory</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;<span class="comment">//分类</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>短短没几行代码，主要内容在构造函数的定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UK2Node_AIMoveTo::<span class="built_in">UK2Node_AIMoveTo</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">	: <span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">	ProxyFactoryFunctionName = <span class="built_in">GET_FUNCTION_NAME_CHECKED</span>(UAIBlueprintHelperLibrary, CreateMoveToProxyObject);</span><br><span class="line">	ProxyFactoryClass = UAIBlueprintHelperLibrary::<span class="built_in">StaticClass</span>();</span><br><span class="line">	ProxyClass = UAIAsyncTaskBlueprintProxy::<span class="built_in">StaticClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>ProxyFactoryFunctionName = GET_FUNCTION_NAME_CHECKED(UAIBlueprintHelperLibrary, CreateMoveToProxyObject);</code><ol>
<li>参数1：调用函数的类</li>
<li>参数2：调用的函数</li>
</ol>
</li>
<li><code>ProxyFactoryClass</code>:工厂类，一般就是上述参数1的类</li>
<li><code>ProxyClass</code>：代理类，用来执行<code>MoveTo</code>操作并且监听派发的<code>UObject</code></li>
</ol>
<h3 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAIController</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOAISimpleDelegate, EPathFollowingResult::Type, MovementResult);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(MinimalAPI)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UAIAsyncTaskBlueprintProxy</span> :</span> <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_UCLASS_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">	FOAISimpleDelegate	OnSuccess;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">	FOAISimpleDelegate	OnFail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnMoveCompleted</span><span class="params">(FAIRequestID RequestID, EPathFollowingResult::Type MovementResult)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnNoPath</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnAtGoal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//~ Begin UObject Interface</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginDestroy</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="comment">//~ End UObject Interface</span></span><br><span class="line"></span><br><span class="line">	TWeakObjectPtr&lt;AAIController&gt; AIController;</span><br><span class="line">	FAIRequestID MoveRequestId;</span><br><span class="line">	TWeakObjectPtr&lt;UWorld&gt; MyWorld;</span><br><span class="line"></span><br><span class="line">	FTimerHandle TimerHandle_OnInstantFinish;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代理类的代码也不多，实际上最关键的就是几个多播代理，异步节点的扩展节点就是由这几个多播代理决定的，代理类里什么时候广播就决定异步节点的运行了；</p>
<p>大概看明白了以后我们自己来扩展一个高级版的<code>AIMoveTo</code></p>
<h2 id="UK2Node"><a href="#UK2Node" class="headerlink" title="UK2Node"></a>UK2Node</h2><h3 id="代理类-1"><a href="#代理类-1" class="headerlink" title="代理类"></a>代理类</h3><p><img src="https://img.supervj.top/img/AIMoveTo/k2node_1.jpg"></p>
<blockquote>
<p>参考<code>AI_MoveTo</code>,我们制作一个输入一个路径点数组，完成逐步沿着各个点移动的节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FMoveResult, EPathFollowingResult::Type, MovementResult);</span><br></pre></td></tr></table></figure>

<p>先定义一个多播代理，用来申明我们自己的代理变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable,BlueprintCallable)</span><br><span class="line">	FMoveResult OnFail;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, BlueprintCallable)</span><br><span class="line">	FMoveResult OnFinished;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, BlueprintCallable)</span><br><span class="line">	FMoveResult OnOneStep;</span><br></pre></td></tr></table></figure>

<p>直接来3个代理变量，意味着我们这个异步节点会有3个扩展节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveTo</span><span class="params">(APawn* Pawn, <span class="keyword">const</span> TArray&lt;FVector&gt;&amp; Path, <span class="keyword">float</span> AcceptanceRadius = <span class="number">5.0</span>, <span class="keyword">bool</span> StopOnOverlap = <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveEnd</span><span class="params">(EPathFollowingResult::Type result)</span></span>;</span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveSuccess</span><span class="params">(EPathFollowingResult::Type result)</span></span>;</span><br></pre></td></tr></table></figure>

<p>再来3个函数，第一个函数让函数库调用，后两个用来内部控制移动的逻辑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">TArray&lt;FVector&gt; CurPath;</span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">APawn* CurPawn;</span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line"><span class="keyword">float</span> fAcceptanceRadius;</span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line"><span class="keyword">bool</span> bStopOnOverlap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> bIsInit = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>主要用<code>CurPath</code>这个数组，记录实时路径点</p>
<p>直接贴代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAIMoveToByPathProxy::MoveTo</span><span class="params">(APawn* Pawn, <span class="keyword">const</span> TArray&lt;FVector&gt;&amp; Path, <span class="keyword">float</span> AcceptanceRadius <span class="comment">/*= 5.0*/</span>, <span class="keyword">bool</span> StopOnOverlap <span class="comment">/*= false*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Path.<span class="built_in">Num</span>()&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!bIsInit)</span><br><span class="line">	&#123;</span><br><span class="line">		bIsInit = <span class="literal">true</span>;</span><br><span class="line">		CurPath = Path;</span><br><span class="line">		CurPawn = Pawn;</span><br><span class="line">		fAcceptanceRadius = AcceptanceRadius;</span><br><span class="line">		bStopOnOverlap = StopOnOverlap;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	UAIAsyncTaskBlueprintProxy* p=UAIBlueprintHelperLibrary::<span class="built_in">CreateMoveToProxyObject</span>(Pawn, Pawn, Path[<span class="number">0</span>], <span class="literal">nullptr</span>, AcceptanceRadius, StopOnOverlap);</span><br><span class="line">	p-&gt;OnFail.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UAIMoveToByPathProxy::MoveEnd);</span><br><span class="line">	p-&gt;OnSuccess.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UAIMoveToByPathProxy::MoveSuccess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAIMoveToByPathProxy::MoveEnd</span><span class="params">(EPathFollowingResult::Type result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//UKismetSystemLibrary::PrintString(CurPawn, TEXT(&quot;End!&quot;));</span></span><br><span class="line">	OnFail.<span class="built_in">Broadcast</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UAIMoveToByPathProxy::MoveSuccess</span><span class="params">(EPathFollowingResult::Type result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (CurPath.<span class="built_in">Num</span>()&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OnOneStep.<span class="built_in">Broadcast</span>(result);</span><br><span class="line">		OnFinished.<span class="built_in">Broadcast</span>(result);</span><br><span class="line">		<span class="comment">//UKismetSystemLibrary::PrintString(CurPawn, TEXT(&quot;Finish!&quot;));</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		OnOneStep.<span class="built_in">Broadcast</span>(result);</span><br><span class="line">		<span class="keyword">if</span> (CurPath.<span class="built_in">Num</span>() &gt; <span class="number">1</span>)			</span><br><span class="line">		&#123;</span><br><span class="line">			CurPath.<span class="built_in">RemoveAt</span>(<span class="number">0</span>);	</span><br><span class="line">			<span class="built_in">MoveTo</span>(CurPawn, CurPath, fAcceptanceRadius, bStopOnOverlap);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">MoveTo</span>(CurPawn, CurPath, fAcceptanceRadius, bStopOnOverlap);</span><br><span class="line">			CurPath.<span class="built_in">RemoveAt</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//UKismetSystemLibrary::PrintString(CurPawn, TEXT(&quot;OneSTEP!&quot;));</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此类移动一次成功后就会派发<code>OneStep</code>，移动完成和失败分别广播对应事件</p>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UAIMoveToByPathProxy* <span class="title">UBPLib_MoveTo::V_AI_MoveToByPath</span><span class="params">(APawn* Pawn, <span class="keyword">const</span> TArray&lt;FVector&gt;&amp; Path, <span class="keyword">float</span> AcceptanceRadius <span class="comment">/*= 5.0*/</span>, <span class="keyword">bool</span> StopOnOverlap <span class="comment">/*= false*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAIMoveToByPathProxy* p = NewObject&lt;UAIMoveToByPathProxy&gt;(Pawn);</span><br><span class="line">	p-&gt;<span class="built_in">MoveTo</span>(Pawn, Path, AcceptanceRadius, StopOnOverlap);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="K2Node"><a href="#K2Node" class="headerlink" title="K2Node"></a>K2Node</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">UUK2Node_MoveByPath::<span class="built_in">UUK2Node_MoveByPath</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">	: <span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">	ProxyFactoryFunctionName = <span class="built_in">GET_FUNCTION_NAME_CHECKED</span>(UBPLib_MoveTo, V_AI_MoveToByPath);</span><br><span class="line">	ProxyFactoryClass = UBPLib_MoveTo::<span class="built_in">StaticClass</span>();</span><br><span class="line">	ProxyClass = UAIMoveToByPathProxy::<span class="built_in">StaticClass</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FText <span class="title">UUK2Node_MoveByPath::GetTooltipText</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;move by a path&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FText <span class="title">UUK2Node_MoveByPath::GetNodeTitle</span><span class="params">(ENodeTitleType::Type TitleType)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveByPath&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FText <span class="title">UUK2Node_MoveByPath::GetMenuCategory</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveByPath&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://img.supervj.top/img/AIMoveTo/k2node_2.gif"></p>
<a name = "Asyc">

<h2 id="UBlueprintAsyncActionBase"><a href="#UBlueprintAsyncActionBase" class="headerlink" title="UBlueprintAsyncActionBase"></a>UBlueprintAsyncActionBase</h2><p>用法比K2Node的简单一些, 但是一般是建立在能获取多播代理的情况下,如下类是监听<code>tag</code>的改变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams</span>(FOnStatChanged, FGameplayTag, NewStatTag, <span class="keyword">bool</span>, bIsAdd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">INTERACTIONEXTRA_API</span> <span class="title">UListenForStatChanged</span> :</span> <span class="keyword">public</span> UBlueprintAsyncActionBase</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">		FOnStatChanged OnStatChanged;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听状态标签改变</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="function"><span class="keyword">static</span> UListenForStatChanged* <span class="title">ListenForStatChanged</span><span class="params">(AInteractableActorBase* Actor)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">EndTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	AInteractableActorBase* ListenActor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">TagChanged</span><span class="params">(<span class="keyword">const</span> FGameplayTag&amp; Tag, <span class="keyword">bool</span> bIsAdd)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UListenForStatChanged::EndTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ListenActor)</span><br><span class="line">	&#123;</span><br><span class="line">		ListenActor-&gt;<span class="built_in">GetStatChangedDelegate</span>().<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SetReadyToDestroy</span>();</span><br><span class="line">	<span class="built_in">MarkPendingKill</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">UListenForStatChanged* <span class="title">UListenForStatChanged::ListenForStatChanged</span><span class="params">(AInteractableActorBase* Actor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Actor)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	UListenForStatChanged* task = NewObject&lt;UListenForStatChanged&gt;();</span><br><span class="line">	task-&gt;ListenActor = Actor;</span><br><span class="line">	Actor-&gt;<span class="built_in">GetStatChangedDelegate</span>().<span class="built_in">AddUObject</span>(task, &amp;UListenForStatChanged::TagChanged);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UListenForStatChanged::TagChanged</span><span class="params">(<span class="keyword">const</span> FGameplayTag&amp; Tag, <span class="keyword">bool</span> bIsAdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OnStatChanged.<span class="built_in">Broadcast</span>(Tag, bIsAdd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们被监听的类内需要实现如下内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_TwoParams</span>(FOnTagChanged, <span class="keyword">const</span> FGameplayTag&amp;, <span class="keyword">bool</span>);</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> FOnTagChanged&amp; <span class="title">GetStatChangedDelegate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> OnStatChanged;</span><br><span class="line">&#125;;</span><br><span class="line">FOnTagChanged OnStatChanged;</span><br></pre></td></tr></table></figure>

<p>主要是这个代理需要此类在合适的时机去广播, 比如下面方法内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AInteractableActorBase::AddStat_Implementation</span><span class="params">(FGameplayTag StatTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StatTags.<span class="built_in">AddTag</span>(StatTag);</span><br><span class="line">	OnStatChanged.<span class="built_in">Broadcast</span>(StatTag, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>异步节点</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4压缩和解压缩工具</title>
    <url>/2021/03/26/UE4%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UE4编辑器和运行时使用解压缩和压缩功能, 一个简单的蓝图库, 源代码来自GitHub的<a href="https://github.com/getnamo/ZipUtility-ue4">ZipUtility Plugin</a></p>
<p>对其做了稍微修改, 修复了部分因为版本更新的报错信息(大量头文件包含问题)</p>
<p><a href="https://github.com/VJien/ZipUtility-UE4-Extra"> ZipUtility-UE4-Extra</a></p>
<p>本文简单介绍这个插件的使用方式</p>
<p><img src="https://img.supervj.top//img/UE4Editor_Eenx6GKDoT.png" alt="UE4Editor_Eenx6GKDoT"></p>
<span id="more"></span>





<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>下载/克隆</li>
<li>放到目录 <code>项目/Plugins/</code>内</li>
<li>刷新项目</li>
</ul>
<blockquote>
<p>检查VS是否安装了最新的<code>ATL</code>和<code>MFC</code>组件,否则会提示<code>atlbase.h</code>找不到</p>
</blockquote>
<blockquote>
<p> 如果已经安装了还是报错, 检查<code>ZipUtility.Build.cs</code>文件</p>
</blockquote>
<p>检查如下字段,默认是vs2017的, 我这里改成了2019</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> VsDirectory</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Trying to find VS installation directory from registry</span></span><br><span class="line">            <span class="built_in">string</span> regPath = (<span class="built_in">string</span>)Registry.GetValue(<span class="string">@&quot;HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\VisualStudio\SxS\VS7\&quot;</span>, <span class="string">&quot;15.0&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(regPath))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;ZipUtility: Found VS path in registry: &quot;</span> + regPath);</span><br><span class="line">                <span class="keyword">return</span> regPath;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// If failed - using the most common install path</span></span><br><span class="line">                <span class="built_in">string</span> vsDefaultBasePath = <span class="string">@&quot;C:\Program Files (x86)\Microsoft Visual Studio\2019&quot;</span>;</span><br><span class="line">                <span class="built_in">string</span> vsVersion = Directory.GetDirectories(vsDefaultBasePath)[<span class="number">0</span>];</span><br><span class="line">                <span class="built_in">string</span> vsPath = Path.Combine(vsDefaultBasePath, vsVersion);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;ZipUtility Warning: Using default VS path: &quot;</span> + vsPath);</span><br><span class="line">                <span class="keyword">return</span> vsPath;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> ATLPath</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Trying to find ATL path similar to:</span></span><br><span class="line">            <span class="comment">// C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.14.26428/atlmfc</span></span><br><span class="line">            <span class="built_in">string</span> atlPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> vsDir = VsDirectory;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(vsDir))</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">string</span> msvcPath = Path.Combine(vsDir, <span class="string">@&quot;VC\Tools\MSVC\&quot;</span>);</span><br><span class="line">                    <span class="built_in">string</span> msvcVersion = Directory.GetDirectories(msvcPath)[<span class="number">0</span>];</span><br><span class="line">                    atlPath = Path.Combine(msvcPath, msvcVersion, <span class="string">&quot;atlmfc&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;ZipUtility Error: can&#x27;t find VS path: &quot;</span> + ex.ToString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(atlPath))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;ZipUtility Error: Couldn&#x27;t find an ATLPath, fix it in ZipUtility.Build.cs&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> atlPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>比如我这边的路径是<code>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29910\atlmfc</code>,需要与上述csharp指定的atl路径匹配,否则在VS编译会报警告和错误</p>
<blockquote>
<p>尝试在 <code>Property-&gt;VC++ Directories-&gt;Include Directories</code>中加入类似<code>Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29910\atlmfc\include</code>的路径</p>
</blockquote>
<p><img src="https://img.supervj.top//img/UE4Editor_md5TmgDXhY.png" alt="UE4Editor_md5TmgDXhY"></p>
<p><img src="https://img.supervj.top//img/image-20210326134323995.png" alt="image-20210326134323995"></p>
<p>每个方法都需要提供一个<code>UObject</code>类对象, 该对象如果挂上接口就可以获取回调事件</p>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>解压缩</tag>
        <tag>第三方工具</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4使用第三方静态库和动态库</title>
    <url>/2021/01/09/UE4%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文介绍一下UE4使用第三方库的简单用法, 即<code>DLL</code>动态库和<code>Lib</code>静态库的使用</p>
<p>我们用插件的形式封装起来, 便于以后移植到其他项目中去;</p>
<p>所以在开始之前先新建一个空或者蓝图库插件</p>
<span id="more"></span>

<h2 id="导出动态-静态库"><a href="#导出动态-静态库" class="headerlink" title="导出动态/静态库"></a>导出动态/静态库</h2><p>新建控制台应用程序<code>ThirdPartyDLL</code></p>
<p>然后创建一个同名头文件,写入一下内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllexport)	<span class="comment">//shortens __declspec(dllexport) to DLL_EXPORT</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus		<span class="comment">//if C++ is used convert it to C to prevent C++&#x27;s name mangling of method names</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> DLL_EXPORT <span class="title">GetMac</span><span class="params">(<span class="keyword">char</span> * mac)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为要确保函数名称我们用C的方式编译即<code>extern &quot;C&quot;</code></p>
<p>实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ThirdPartyDLL.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wincon.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Nb30.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;netapi32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">GetMac</span><span class="params">(<span class="keyword">char</span> * mac)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NCB ncb;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ASTAT_</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ADAPTER_STATUS   adapt;</span><br><span class="line">		NAME_BUFFER   NameBuff[<span class="number">30</span>];</span><br><span class="line">	&#125;ASTAT, *PASTAT;</span><br><span class="line"></span><br><span class="line">	ASTAT Adapter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LANA_ENUM</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		UCHAR   length;</span><br><span class="line">		UCHAR   lana[MAX_LANA];</span><br><span class="line">	&#125;LANA_ENUM;</span><br><span class="line"></span><br><span class="line">	LANA_ENUM lana_enum;</span><br><span class="line">	UCHAR uRetCode;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;ncb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ncb));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;lana_enum, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(lana_enum));</span><br><span class="line">	ncb.ncb_command = NCBENUM;</span><br><span class="line">	ncb.ncb_buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;lana_enum;</span><br><span class="line">	ncb.ncb_length = <span class="built_in"><span class="keyword">sizeof</span></span>(LANA_ENUM);</span><br><span class="line">	uRetCode = <span class="built_in">Netbios</span>(&amp;ncb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uRetCode != NRC_GOODRET)</span><br><span class="line">		<span class="keyword">return</span> uRetCode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> lana = <span class="number">0</span>; lana &lt; lana_enum.length; lana++)</span><br><span class="line">	&#123;</span><br><span class="line">		ncb.ncb_command = NCBRESET;</span><br><span class="line">		ncb.ncb_lana_num = lana_enum.lana[lana];</span><br><span class="line">		uRetCode = <span class="built_in">Netbios</span>(&amp;ncb);</span><br><span class="line">		<span class="keyword">if</span> (uRetCode == NRC_GOODRET)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uRetCode != NRC_GOODRET)</span><br><span class="line">		<span class="keyword">return</span> uRetCode;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;ncb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ncb));</span><br><span class="line">	ncb.ncb_command = NCBASTAT;</span><br><span class="line">	ncb.ncb_lana_num = lana_enum.lana[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="keyword">char</span>*)ncb.ncb_callname, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">	ncb.ncb_buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;Adapter;</span><br><span class="line">	ncb.ncb_length = <span class="built_in"><span class="keyword">sizeof</span></span>(Adapter);</span><br><span class="line">	uRetCode = <span class="built_in">Netbios</span>(&amp;ncb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uRetCode != NRC_GOODRET)</span><br><span class="line">		<span class="keyword">return</span> uRetCode;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sprintf</span>(mac, <span class="string">&quot;%02X-%02X-%02X-%02X-%02X-%02X&quot;</span>,</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">0</span>],</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">1</span>],</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">2</span>],</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">3</span>],</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">4</span>],</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>   mac[<span class="number">200</span>];</span><br><span class="line">	<span class="built_in">GetMac</span>(mac);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The Mac Address is : %s   \n&quot;</span>, mac);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上述内容目的是获取本地的<code>mac</code>地址, 不用理会具体实现方法, 我们主要是拿来当作第三方库使用, 毕竟UE4现在自己的API没有可以拿到<code>Mac</code>地址的;</p>
<p>设置模式为 <code>Release</code>+<code>x64</code></p>
<p>在vs中简单运行一下得到结果</p>
<p><img src="https://img.supervj.top//img/image-20210111164720144.png" alt="image-20210111164720144"></p>
<p>运行正常, 然后是导出我们所需要的动态库</p>
<p>在项目属性里设置配置类型为DLL,如下</p>
<p><img src="https://img.supervj.top//img/image-20210111164824509.png" alt="image-20210111164824509"></p>
<p>生成以后就得到了我们需要的<code>DLL</code>文件</p>
<hr>
<p>静态库只需要在项目配置里修改成<code>Lib</code>,然后再生成一次即可</p>
<h2 id="UE4封装函数库"><a href="#UE4封装函数库" class="headerlink" title="UE4封装函数库"></a>UE4封装函数库</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>先到插件目录下,在<code>source</code>同级目录下新建文件夹<code>ThirdParty</code>,然后分别创建子文件夹<code>DLL</code>,<code>Include</code>,<code>Lib</code>,如下</p>
<p><img src="https://img.supervj.top//img/image-20210111165251214.png" alt="image-20210111165251214"></p>
<p>分别放入的文件为<code>ThirdPartyDLL.dll</code>,<code>ThirdPartyDLL.h</code>,<code>ThirdPartyDLL.lib</code></p>
<p>然后来到我们的插件模块,找到<code>*.build.cs</code>文件,添加必要路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//using System.IO; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> string ModulePath</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; <span class="keyword">return</span> ModuleDirectory; &#125;<span class="comment">//return </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> string ThirdPartyPath</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; <span class="keyword">return</span> Path.<span class="built_in">GetFullPath</span>(Path.<span class="built_in">Combine</span>(ModulePath, <span class="string">&quot;../../ThirdParty/&quot;</span>)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> PublicIncludePaths.<span class="built_in">Add</span>(Path.<span class="built_in">Combine</span>(ThirdPartyPath, <span class="string">&quot;Include&quot;</span>));</span><br><span class="line">        PublicAdditionalLibraries.<span class="built_in">Add</span>(Path.<span class="built_in">Combine</span>(ThirdPartyPath, <span class="string">&quot;Lib&quot;</span>, <span class="string">&quot;ThirdPartyDLL.lib&quot;</span>));</span><br></pre></td></tr></table></figure>



<p>这样我们就可以在自己的cpp中包含静态库的头文件了</p>
<p>找到/创建蓝图函数库</p>
<p>头文件下声明如下函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure ,Category = <span class="string">&quot;Flib|DllHelper&quot;</span>, meta = (DisplayName = <span class="string">&quot;GetMac&quot;</span>))</span><br><span class="line">		<span class="function"><span class="keyword">static</span> FString <span class="title">GetMacFromLib</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ThirdPartyDLL.h&quot;</span></span></span><br><span class="line"><span class="function">FString <span class="title">UFlib_DllHelper::GetMacFromLib</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>   mac[<span class="number">200</span>];</span><br><span class="line">	<span class="built_in">GetMac</span>(mac);</span><br><span class="line">	FString out = <span class="built_in">FString</span>(mac);</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行测试</p>
<p><img src="https://img.supervj.top//img/image-20210111165817017.png" alt="image-20210111165817017"></p>
<p><img src="https://img.supervj.top//img/image-20210111165829392.png" alt="image-20210111165829392"></p>
<p>运行正常,打包以后也正常</p>
<h3 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h3><p>动态获取<code>DLL</code>, 我们可以直接在函数库中使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;Flib|DllHelper&quot;</span>, meta = (DisplayName = <span class="string">&quot;GetMacDLL&quot;</span>))</span><br><span class="line">		<span class="function"><span class="keyword">static</span> FString <span class="title">GetMacFromDLL</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*_getMac)</span><span class="params">(<span class="keyword">char</span> * mac)</span></span>;</span><br><span class="line">_getMac funcGetMac; <span class="comment">//函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *v_dllHandle; <span class="comment">//DLL句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">UFlib_DllHelper::GetMacFromDLL</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//我们基于插件目录找到DLL文件</span></span><br><span class="line">	FString folder =<span class="string">&quot;DllImporter//ThirdParty//DLL&quot;</span>;</span><br><span class="line">	FString file = <span class="string">&quot;ThirdPartyDLL.dll&quot;</span>;</span><br><span class="line">	FString filePath = *FPaths::<span class="built_in">ProjectPluginsDir</span>() + folder + <span class="string">&quot;/&quot;</span> + file;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FPaths::<span class="built_in">FileExists</span>(filePath))</span><br><span class="line">	&#123;</span><br><span class="line">		v_dllHandle = FPlatformProcess::<span class="built_in">GetDllHandle</span>(*filePath);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (v_dllHandle != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			funcGetMac = <span class="literal">nullptr</span>;</span><br><span class="line">			FString procName = <span class="string">&quot;GetMac&quot;</span>;</span><br><span class="line">			funcGetMac = (_getMac)FPlatformProcess::<span class="built_in">GetDllExport</span>(v_dllHandle, *procName);</span><br><span class="line">			<span class="keyword">if</span> (funcGetMac != <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">char</span>   mac[<span class="number">200</span>];</span><br><span class="line">				idx = <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">funcGetMac</span>(mac));</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">FString</span>(mac);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210111171736080.png" alt="image-20210111171736080"></p>
<blockquote>
<p>但是如果只是这样的话, 编辑器模式下没有问题, 打包以后会找不到DLL文件</p>
</blockquote>
<p>解决方法是在<code>*.build.cs</code>内对动态库添加包含</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PublicLibraryPaths.<span class="built_in">Add</span>(Path.<span class="built_in">Combine</span>(ThirdPartyPath, <span class="string">&quot;DLL&quot;</span>));</span><br><span class="line">RuntimeDependencies.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">RuntimeDependency</span>(Path.<span class="built_in">Combine</span>(ThirdPartyPath, <span class="string">&quot;DLL&quot;</span>,<span class="string">&quot;ThirdPartyDLL.dll&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>成功</p>
<blockquote>
<p>另外还有一种情况, DLL导出库是Lib的链接, 在编辑器下没有问题, 但是打包以后会提示招不到DLL</p>
<p>但是DLL是在你所在模块插件的目录里, 你需要手动复制到项目Binaries里去,或者用如下的方式自动拷贝并添加动态依赖</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string BinariesDirectory = Path.<span class="built_in">Combine</span>(ProjectDirectory, <span class="string">&quot;Binaries&quot;</span>, PlatformString);</span><br><span class="line">			string SourceFile = Path.<span class="built_in">Combine</span>(ThirdPartyPath, <span class="string">&quot;assimp/bin&quot;</span>, PlatformString, <span class="string">&quot;assimp-vc140-mt.dll&quot;</span>);</span><br><span class="line">			string TargetFile = Path.<span class="built_in">Combine</span>(BinariesDirectory, <span class="string">&quot;assimp-vc140-mt.dll&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (!Directory.<span class="built_in">Exists</span>(BinariesDirectory))</span><br><span class="line">            &#123;</span><br><span class="line">				Directory.<span class="built_in">CreateDirectory</span>(BinariesDirectory);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">if</span>(File.<span class="built_in">Exists</span>(SourceFile) &amp;&amp; !File.<span class="built_in">Exists</span>(TargetFile))</span><br><span class="line">            &#123;</span><br><span class="line">				File.<span class="built_in">Copy</span>(SourceFile, TargetFile, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">			RuntimeDependencies.<span class="built_in">Add</span>(Path.<span class="built_in">Combine</span>(BinariesDirectory, <span class="string">&quot;assimp-vc140-mt.dll&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210324113946789.png" alt="image-20210324113946789"></p>
<p>如上图打包以后就放到了正确的目录</p>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>第三方库</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4子系统</title>
    <url>/2020/08/03/UE4%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>UE4在4.22版本后加入了子系统即Subsystem，子系统是生命周期受控的自动实例化类，非常易用。</p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>目前在4.24版本中，子系统主要分为4大类</p>
<ul>
<li>引擎<code>UEngineSubsystem</code></li>
</ul>
<p>当引擎子系统的模块加载时，子系统将在模块的 <code>Startup()</code> 函数返回后执行 <code>Initialize()</code>，子系统将在模块的 <code>Shutdown()</code> 函数返回后执行 <code>Deinitialize()</code>。</p>
<p>通过<code>GEngine</code>访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UMyEngineSubsystem MySubsystem = GEngine-&gt;GetEngineSubsystem&lt;UMyEngineSubsystem&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑器<code>UEditorSubsystem</code></li>
</ul>
<p>当编辑器子系统的模块加载时，子系统将在模块的 <code>Startup()</code> 函数返回后执行 <code>Initialize()</code>，子系统将在模块的 <code>Shutdown()</code> 函数返回后执行 <code>Deinitialize()</code>。</p>
<p>这些子系统可通过<code>GEditor</code>访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UMyEditorSubsystem MySubsystem = GEditor-&gt;GetEditorSubsystem&lt;UMyEditorSubsystem&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>游戏实例<code>UGameInstanceSubsystem</code></li>
</ul>
<p>生命周期跟随游戏实例的初始化和卸载</p>
<p>可通过<code>UGameInstance</code>访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UGameInstance* GameInstance = ...;</span><br><span class="line">UMyGameSubsystem* MySubsystem = GameInstance-&gt;GetSubsystem&lt;UMyGameSubsystem&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>本地玩家<code>ULocalPlayerSubsystem</code></li>
</ul>
<p>随着本地玩家创建而创建</p>
<p>通过<code>ULocalPlayer</code>访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ULocalPlayer* LocalPlayer = ...;</span><br><span class="line">UMyPlayerSubsystem * MySubsystem = LocalPlayer-&gt;<span class="built_in">GetSubsystem</span>();</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>创建<code>UMyGameInstanceSubsystem</code>继承自<code>UGameInstanceSubsystem</code></p>
<p>重写基类方法,如下图所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回false就不会自动创建</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ShouldCreateSubsystem</span><span class="params">(UObject* Outer)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(FSubsystemCollectionBase&amp; Collection)</span><span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//卸载</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Deinitialize</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstanceSubsystem::Initialize</span><span class="params">(FSubsystemCollectionBase&amp; Collection)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(LogTemp,Log,<span class="built_in">TEXT</span>(<span class="string">&quot;MySubsystem Initialize!!!!&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstanceSubsystem::Deinitialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;MySubsystem Deinitialize!!!!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外我们手动创建一个继承自<code>UGameInstance</code>的蓝图类</p>
<p><img src="https://img.supervj.top/img/other/image-20200803100004102.png" alt="image-20200803100004102"></p>
<p>然后我们在子系统里实现一个测试方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">TestPrint</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadWrite,EditAnywhere)</span><br><span class="line">		int32 Number=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstanceSubsystem::TestPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(LogTemp,Log,<span class="built_in">TEXT</span>(<span class="string">&quot;Number= %d !!&quot;</span>),Number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在蓝图里默认直接可以得到子系统如下图</p>
<p><img src="https://img.supervj.top/img/other/image-20200803100155123.png" alt="image-20200803100155123"></p>
<p>在关卡蓝图里测试</p>
<p><img src="https://img.supervj.top/img/other/image-20200803100224677.png" alt="image-20200803100224677"></p>
<p>得到结果</p>
<p><img src="https://img.supervj.top/img/other/image-20200803100258176.png" alt="image-20200803100258176"></p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>子系统</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4对windows文件的操作</title>
    <url>/2021/01/07/UE4%E6%93%8D%E4%BD%9Cwindows%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此文简单记录UE4对windows文件的处理</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_01_08_13_50_01_590.gif" alt="录制_2021_01_08_13_50_01_590"></p>
<span id="more"></span>

<h2 id="打开窗口读取文件"><a href="#打开窗口读取文件" class="headerlink" title="打开窗口读取文件"></a>打开窗口读取文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TArray&lt;FString&gt; <span class="title">UFlib_IO::OpenWindowsFilesDialog</span><span class="params">(<span class="keyword">const</span> FString&amp; Path, <span class="keyword">const</span> FString&amp; fileName, <span class="keyword">const</span> FString&amp; SufStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TArray&lt;FString&gt; OpenFileNames;<span class="comment">//获取的文件绝对路径</span></span><br><span class="line"></span><br><span class="line">	FString ExtensionStr = SufStr.<span class="built_in">IsEmpty</span>()?<span class="built_in">TEXT</span>(<span class="string">&quot;*.*&quot;</span>):SufStr;<span class="comment">//文件类型</span></span><br><span class="line">	IDesktopPlatform* DesktopPlatform = FDesktopPlatformModule::<span class="built_in">Get</span>();</span><br><span class="line">	DesktopPlatform-&gt;<span class="built_in">OpenFileDialog</span>(<span class="literal">nullptr</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;打开文件&quot;</span>), Path, fileName,*SufStr, EFileDialogFlags::None,OpenFileNames);</span><br><span class="line">	<span class="keyword">return</span> OpenFileNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法最后返回的是文件的绝对路径,而非打开文件</p>
<h2 id="打开窗口读取文件夹路径"><a href="#打开窗口读取文件夹路径" class="headerlink" title="打开窗口读取文件夹路径"></a>打开窗口读取文件夹路径</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FString <span class="title">UFlib_IO::OpenWindowsDirection</span><span class="params">(<span class="keyword">const</span> FString&amp; Path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FString oldPath;</span><br><span class="line">	IDesktopPlatform* DesktopPlatform = FDesktopPlatformModule::<span class="built_in">Get</span>();</span><br><span class="line">	DesktopPlatform-&gt;<span class="built_in">OpenDirectoryDialog</span>(<span class="literal">nullptr</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;打开路径&quot;</span>), Path, oldPath);</span><br><span class="line">	<span class="keyword">return</span> oldPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同上, 不一样的是返回的是文件夹的路径</p>
<h2 id="打开exe程序"><a href="#打开exe程序" class="headerlink" title="打开exe程序"></a>打开exe程序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFlib_IO::OpenWindowsExe</span><span class="params">(<span class="keyword">const</span> FString&amp; AbsolutePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FWindowsPlatformProcess::<span class="built_in">CreateProc</span>(*AbsolutePath, <span class="literal">nullptr</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nullptr</span>, <span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较简单, 但是需要注意的是只能运行<code>exe</code>, 其他比如<code>txt</code>等不能用此方式运行</p>
<h2 id="打开文件夹"><a href="#打开文件夹" class="headerlink" title="打开文件夹"></a>打开文件夹</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFlib_IO::OpenWindowsFolder</span><span class="params">(<span class="keyword">const</span> FString&amp; AbsolutePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FWindowsPlatformProcess::<span class="built_in">ExploreFolder</span>(*AbsolutePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此为<code>windows</code>版本,类似的也有其他比如安卓版本的打开</p>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>文件</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 4.25离线文档</title>
    <url>/2020/08/28/UE4%E7%A6%BB%E7%BA%BF%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<blockquote>
<p>UE4 4.25离线文档，基于Dash文档源，使用Zeal查阅</p>
</blockquote>
<p><img src="https://img.supervj.top/img/advVR/image-20200828133618221.png" alt="image-20200828133618221"></p>
<p><img src="https://img.supervj.top/img/advVR/image-20200828133843396.png" alt="image-20200828133843396"></p>
<p><a href="https://shueducn-my.sharepoint.com/:u:/g/personal/rugbyuu_shu_edu_cn/EfJIQPZ_l-NOvi8yxHQvGkcBNDLnHBVcuhz2i7SMigJ9kQ?e=ZZFCmq">Zeal下载</a></p>
<p><a href="https://shueducn-my.sharepoint.com/:u:/g/personal/rugbyuu_shu_edu_cn/Eeis5FkxAVRFjqvj7LBf0vEBJJ2pKpMaKPFsP47PxKl5XA?e=YiQl5e">4.25文档下载</a></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>直接将压缩版解压到<code>Zeal\docsets\</code>路径内，没有文件夹请自行新建</p>
<p>然后按照下图设置docsets路径</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200828134552604.png" alt="image-20200828134552604"></p>
<h3 id="下载其他文档"><a href="#下载其他文档" class="headerlink" title="下载其他文档"></a>下载其他文档</h3><p>参考如下图方式下载，因为都是国外链接，所以请酌情使用交通工具✈</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200828155324943.png" alt="image-20200828155324943"></p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>Zeal</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4顶点动画开发流程</title>
    <url>/2020/04/30/UE4%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>本文介绍从max到UE4顶点动画实现流程</p>
<p>使用的方式是贴图记录顶点位置和法线信息通过材质球使静态模型模拟动画的播放</p>
</blockquote>
<p><img src="https://img.supervj.top/imgd1.gif" alt="Alt text"></p>
<p><a href="https://github.com/VJien/VextexAnimationTool.git">脚本下载</a></p>
<span id="more"></span>

<h3 id="顶点缓存脚本"><a href="#顶点缓存脚本" class="headerlink" title="顶点缓存脚本"></a>顶点缓存脚本</h3><ul>
<li><strong>如果是非骨骼动画，可以直接跳过此步骤</strong></li>
</ul>
<p>用顶点缓存脚本把骨骼动画信息保存到==pointCache修改器==内，脚本界面如下</p>
<p><img src="https://img.supervj.top/imgd2.jpg" alt="Alt text"></p>
<ul>
<li>缓存文件可以选择自定义路径</li>
<li>烘培范围默认是时间轴的时间，一般不需要自定义</li>
</ul>
<p>完成后如下图所示</p>
<p><img src="https://img.supervj.top/imgvertexAnim_pointCache.jpg" alt="Alt text"></p>
<p>skin修改器会被自动禁用，然后就可以进入下一步骤</p>
<h3 id="用顶点动画导出工具"><a href="#用顶点动画导出工具" class="headerlink" title="用顶点动画导出工具"></a>用顶点动画导出工具</h3><p>脚本界面如下 </p>
<p><img src="https://img.supervj.top/imgd4.jpg" alt="Alt text"></p>
<ul>
<li>动画设置的的开始和结束一般不用修改，<strong>间隔</strong>参数后有详细数据测试</li>
<li>压缩格式和渲染通道不建议修改</li>
<li>输出格式可以用FLOAT16减少体积，测试影响不大</li>
</ul>
<p>点击【开始烘培】后选择目录保存2张贴图，然后模型窗口自动生成后缀为<strong>MorpohExport</strong>的模型，选择导出【<strong>非动画模型</strong>】，得到如下图</p>
<p><img src="https://img.supervj.top/imgd5.jpg" alt="Alt text"></p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol>
<li>每个动作都需要一个FBX和2个贴图</li>
</ol>
<h5 id="测试间隔参数"><a href="#测试间隔参数" class="headerlink" title="测试间隔参数"></a>测试间隔参数</h5><p><strong>模型顶点数为：1729</strong></p>
<ol>
<li>以Run动作为测试，模型资源大小：189kb<ol>
<li>原始数据：25帧，2张贴图大小合计（非cook数据，以下简称贴图)：273kb</li>
<li>间隔1帧：13帧，贴图：143kb</li>
<li>间隔2帧：9帧数，贴图：99kb</li>
<li>间隔3帧：7帧，贴图：76kb</li>
<li>间隔4帧：5帧，贴图：60kb</li>
<li>间隔5帧：5帧，贴图：53kb</li>
</ol>
</li>
<li>以attack动作测试，模型资源大小：189kb<ol>
<li>原始数据：91帧，贴图：962kb</li>
<li>间隔1帧：46帧，贴图：501kb</li>
<li>间隔2帧：31帧数，贴图：343kb</li>
<li>间隔3帧：23帧，贴图：262kb</li>
<li>间隔4帧：19帧，贴图：214kb</li>
<li>间隔5帧：16帧，贴图：180kb</li>
</ol>
</li>
</ol>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ol>
<li>原始动画的帧数直接决定贴图<strong>y</strong>轴尺寸（像素数量），意味着帧数越少贴图越小（线性）</li>
<li>原始动画的顶点数决定贴图<strong>x</strong>轴，所以尽可能的降低顶点数，同样意味着顶点数越少贴图越小</li>
<li>由于顶点材质球（具体见下面材质球部分）计算有过度效果，所以去掉中间帧数（设置间隔参数）带来的影响并不大，损失部分细节，但不会出现跳跃现象，但是资源大小是线性变化的</li>
<li>从max中对动画进行帧数手动减半，效果等同于用脚本设置间隔参数1，而且效果更直接，方便观察和调整</li>
</ol>
<h3 id="UE4部分"><a href="#UE4部分" class="headerlink" title="UE4部分"></a>UE4部分</h3><h5 id="导入模型"><a href="#导入模型" class="headerlink" title="导入模型"></a>导入模型</h5><p><img src="https://img.supervj.top/imgvertexAnim_ImportMesh.jpg"></p>
<p><img src="https://img.supervj.top/img/vertexAnim_1.jpg"></p>
<ul>
<li>如图所示选项需要设置</li>
</ul>
<h5 id="EXR贴图"><a href="#EXR贴图" class="headerlink" title="EXR贴图"></a>EXR贴图</h5><p><img src="https://img.supervj.top/imgvertexAnim_EXR.jpg"></p>
<ul>
<li>参数设置如图<ul>
<li>sRGB需要去掉</li>
<li>压缩格式设置成HDR</li>
</ul>
</li>
</ul>
<h5 id="Normal贴图"><a href="#Normal贴图" class="headerlink" title="Normal贴图"></a>Normal贴图</h5><p><img src="https://img.supervj.top/imgvertexAnim_nor.jpg"></p>
<ul>
<li>参数设置<ul>
<li>sRGB去掉</li>
<li>压缩格式设置为VectorDisplacementMap</li>
<li>其他不是很关键</li>
</ul>
</li>
</ul>
<h5 id="材质球"><a href="#材质球" class="headerlink" title="材质球"></a>材质球</h5><p><img src="https://img.supervj.top/imgvertexAnim_mat.jpg"></p>
<ul>
<li>使用UE自带的材质函数<ul>
<li>设置材质球的TangentSpaceNormal选项为false</li>
<li>NumCustomizedUVs设置为4</li>
<li>图中sp节点为动画速度</li>
<li>Mor参数为动画帧数<ul>
<li>测试发现参数不能小于帧数，也就是贴图的Y轴像素大小</li>
<li>当帧数过小，比如5帧的时候，设置这个Mor参数为5的较大整数倍，比如100，可以去掉原本有的跳帧显现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="脚本核心功能解释"><a href="#脚本核心功能解释" class="headerlink" title="脚本核心功能解释"></a>脚本核心功能解释</h3><h5 id="顶点缓存脚本-1"><a href="#顶点缓存脚本-1" class="headerlink" title="顶点缓存脚本"></a>顶点缓存脚本</h5><ul>
<li>max自带顶点缓存插件，本脚本工作原理是调用了插件的功能</li>
<li>核心代码如下</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">createDialog test_dialog</span><br><span class="line">	</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">--Label RangeSelect &quot;选择导出范围&quot;</span></span><br><span class="line">	checkbox cbCustomRange <span class="string">&quot;自定义范围&quot;</span> checked:<span class="literal">false</span> tooltip:<span class="string">&quot;默认使用时间轴范围&quot;</span></span><br><span class="line">	spinner Start <span class="string">&quot;开始帧:&quot;</span> range:[<span class="number">-10000</span>,<span class="number">10000</span>,<span class="number">0</span>] <span class="built_in">type</span>:#integer enabled:<span class="literal">false</span></span><br><span class="line">	Spinner End <span class="string">&quot;结束帧:&quot;</span> range:[<span class="number">-10000</span>,<span class="number">10000</span>,<span class="number">100</span>] <span class="built_in">type</span>:#integer enabled:<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	on cbCustomRange changed stat <span class="keyword">do</span></span><br><span class="line">	(</span><br><span class="line">		<span class="keyword">if</span> cbCustomRange.checked==<span class="literal">true</span> <span class="keyword">then</span> </span><br><span class="line">		(</span><br><span class="line">			Start.enabled=<span class="literal">true</span> </span><br><span class="line">			End.enabled=<span class="literal">true</span></span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		(</span><br><span class="line">			Start.enabled=<span class="literal">false</span> </span><br><span class="line">			End.enabled=<span class="literal">false</span></span><br><span class="line">		)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	Button _BakePC <span class="string">&quot;开始缓存&quot;</span> width:<span class="number">130</span> height:<span class="number">64</span></span><br><span class="line">	progressbar Bake_prog color:green </span><br><span class="line">	on _BakePC pressed <span class="keyword">do</span> </span><br><span class="line">	(</span><br><span class="line">		<span class="keyword">if</span> PCpath.text==<span class="string">&quot;&quot;</span> <span class="keyword">then</span> </span><br><span class="line">			messagebox <span class="string">&quot;请选择输出文件夹以保存顶点缓存文件&quot;</span></span><br><span class="line">		<span class="keyword">else</span> 		</span><br><span class="line">		<span class="keyword">if</span> $==undefined <span class="keyword">then</span></span><br><span class="line">		messagebox<span class="string">&quot;选择烘培物体&quot;</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		(</span><br><span class="line">			 <span class="keyword">for</span> i = <span class="number">1</span> to selection.count <span class="keyword">do</span>    <span class="comment">--遍历所有选择的物体，一般只会选择1个</span></span><br><span class="line">			(</span><br><span class="line">				A= selection as array</span><br><span class="line">				OBJname = A[i].name + <span class="string">&quot;.xml&quot;</span></span><br><span class="line">				FilePathName= PCpath.text</span><br><span class="line">				PointCacheName= FilePathName +@<span class="string">&quot;\&quot;+ OBJname</span></span><br><span class="line"><span class="string">				addmodifier A[i] (Point_Cache ())   --添加点缓存修改器</span></span><br><span class="line"><span class="string">				A[i].modifiers[#Point_Cache].filename=PointCacheName  </span></span><br><span class="line"><span class="string">				if cbCustomRange.checked then  --如果开启了自定义，就设置插件内如下参数</span></span><br><span class="line"><span class="string">				(</span></span><br><span class="line"><span class="string">					A[i].modifiers[#Point_Cache].playbackType=2</span></span><br><span class="line"><span class="string">					A[i].modifiers[#Point_Cache].playbackStart=Start.value</span></span><br><span class="line"><span class="string">					A[i].modifiers[#Point_Cache].playbackEnd=End.value</span></span><br><span class="line"><span class="string">				)</span></span><br><span class="line"><span class="string">				else</span></span><br><span class="line"><span class="string">				(</span></span><br><span class="line"><span class="string">					A[i].modifiers[#Point_Cache].playbackType=0</span></span><br><span class="line"><span class="string">				)</span></span><br><span class="line"><span class="string">				</span></span><br><span class="line"><span class="string">				cacheOps.recordcache A[i].modifiers[#point_cache] --记录点信息</span></span><br><span class="line"><span class="string">				cacheOps.DisableBelow A[i].modifiers[#point_cache] --关闭下面的修改器，一般就是skin</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			Bake_prog.value = 100.*i/A.count</span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			)</span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string">					Messagebox &quot;</span>生成完毕<span class="string">&quot;</span></span><br><span class="line"><span class="string">					</span></span><br><span class="line"><span class="string">				</span></span><br><span class="line"><span class="string">		)</span></span><br><span class="line"><span class="string">	)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">createdialog PointCacheTool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>



<h5 id="顶点动画导出工具"><a href="#顶点动画导出工具" class="headerlink" title="顶点动画导出工具"></a>顶点动画导出工具</h5><ul>
<li>修改自Epic的顶点动画脚本，原版插件多数功能无用而且无导出选项</li>
<li>核心代码如下</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">fn renderOutTheTextures = (	</span><br><span class="line">				  </span><br><span class="line">				fopenexr.SetCompression CompressionType  <span class="comment">--压缩格式，一般不压缩</span></span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;输出压缩格式:&quot;</span>+(CompressionType as <span class="built_in">string</span>))</span><br><span class="line">				fopenexr.setLayerOutputType <span class="number">0</span> OutputType <span class="comment">-- 输出通道，一般就是RPG</span></span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;输出通道:&quot;</span>+(OutputType as <span class="built_in">string</span>))</span><br><span class="line">				fopenexr.setLayerOutputFormat <span class="number">0</span> OutputFormat <span class="comment">--输出格式，一般FLOAT16够用</span></span><br><span class="line">				global TextureName = getSaveFileName types:<span class="string">&quot;EXR (*.EXR)|*.EXR&quot;</span></span><br><span class="line">				<span class="keyword">if</span> TextureName == undefined <span class="keyword">then</span> (</span><br><span class="line">					messagebox <span class="string">&quot;需要选择一个路径&quot;</span></span><br><span class="line">				)</span><br><span class="line">				<span class="keyword">else</span>(</span><br><span class="line">					uvString=<span class="string">&quot;_UV&quot;</span>+((targetMorphUV<span class="number">-1</span>) as <span class="built_in">string</span>)</span><br><span class="line">					TextureNameNormal= replace TextureName (findString TextureName <span class="string">&quot;.EXR&quot;</span>) <span class="number">4</span> (uvString+<span class="string">&quot;_Normals.BMP&quot;</span>)</span><br><span class="line">					TextureNameOffset= replace TextureName (findString TextureName <span class="string">&quot;.EXR&quot;</span>) <span class="number">4</span> (uvString+<span class="string">&quot;.EXR&quot;</span>)</span><br><span class="line">					global FinalTexture = bitmap numberofVerts (MorphVertOffsetArray.count) filename:TextureNameOffset hdr:<span class="literal">true</span>;</span><br><span class="line">					global FinalMorphTexture = bitmap numberofVerts (MorphVertOffsetArray.count) filename:TextureNameNormal hdr:<span class="literal">true</span>  gamma:<span class="number">1.0</span> ;</span><br><span class="line">					<span class="keyword">for</span> i=<span class="number">0</span> to (MorphVertOffsetArray.count<span class="number">-1</span>) <span class="keyword">do</span> (</span><br><span class="line">						setPixels FinalTexture [<span class="number">0</span>, i] MorphVertOffsetArray[(i+<span class="number">1</span>)]</span><br><span class="line">						setPixels FinalMorphTexture [<span class="number">0</span>, i] MorphNormalArray[(i+<span class="number">1</span>)]   <span class="comment">--设置图片对应坐标的像素颜色  2d坐标X分量是列，Y分量是行</span></span><br><span class="line"><span class="comment">--设置图片对应坐标的像素颜色  2d坐标X分量是列，Y分量是行</span></span><br><span class="line">					)</span><br><span class="line">					save FinalTexture gamma:<span class="number">1.0</span></span><br><span class="line">					<span class="built_in">close</span> FinalTexture</span><br><span class="line">					</span><br><span class="line">					save FinalMorphTexture gamma:<span class="number">1.0</span></span><br><span class="line">					<span class="built_in">close</span> FinalMorphTexture</span><br><span class="line">				)</span><br><span class="line">			)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>顶点动画</tag>
        <tag>3DMax</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5动画重定向</title>
    <url>/2023/08/21/UE5%E5%8A%A8%E7%94%BB%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UE5的动画重定向已经使用了全新的方式,  在经历了EA版的重重bug后, 在5.1和5.2上基本已经成熟, 官方文档有大致使用方式的说明, 但是对一些细节方面还是缺乏说明, 导致刚开始使用时会走不少弯路; 本文对官方文档流程进行一些补充</p>
<p>5.2文档参考 </p>
<p><a href="https://docs.unrealengine.com/5.2/zh-CN/ik-rig-in-unreal-engine/">IK Rig编辑器</a></p>
<p><a href="https://docs.unrealengine.com/5.2/zh-CN/ik-rig-animation-retargeting-in-unreal-engine/">IK Rig重定向</a></p>
<span id="more"></span>



<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>创建ik rig资源</li>
<li>创建fullbody ik解算器</li>
<li>添加goal, 一般为2个hand以及2个ball(也可以是foot)共4个goal; 偶尔情况会对pelvis和head加goal</li>
<li>添加chain</li>
</ul>
<p>这一步是比较耗时的, 为了防治遗漏, 第一步先对着pelvis(基本人形态都是这个骨骼)设置为 解算器的root bone以及retarget root</p>
<p>后面就是设置各个骨骼链</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//%E5%BD%95%E5%88%B6_2023_08_21_10_15_49_254.gif" alt="录制_2023_08_21_10_15_49_254"></p>
<p>最后是这样的</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821102232402.png" alt="image-20230821102232402"></p>
<ul>
<li>fullbody setting</li>
</ul>
<p>编辑好骨骼链还不够, 如果这个时候你尝试拖动ik控制器就会发现很多动作会很诡异, 如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821102442846.png" alt="image-20230821102442846"></p>
<p>因为部分骨骼需要设置一下fullbody的配置属性</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821102543857.png" alt="image-20230821102543857"></p>
<p>具体不知道怎么设置的, 可以去参考UE自己的小白人的属性设置, </p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821103732030.png" alt="image-20230821103732030"></p>
<p>往上提脚上的控制器, 发现整条腿的旋转很诡异, 这是因为没有设置legik的旋转角度, 通过设置calf的setting中的自定义角度可以实现</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821103852596.png" alt="image-20230821103852596"></p>
<p>这个角度如何设置, 网上资料也不多, 实际上可以这样思考</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821104450936.png" alt="image-20230821104450936"></p>
<p>这个calf骨骼是绕Z轴转的, 按顺时针转90度应该是合适的范围</p>
<ul>
<li>创建重定向文件 IK Retargetor, 选择动作源的IK Rig为source</li>
<li>编辑姿势</li>
</ul>
<p>先通过偏移和缩放把人大致对上</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821105613739.png" alt="image-20230821105613739"></p>
<p>后面就是一点点的调整pose对齐, 没有什么捷径, 只能花时间慢慢调整</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821110029458.png" alt="image-20230821110029458"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821110648834.png" alt="image-20230821110648834"></p>
<p>尽量保证一致性就好了, 而且要尽量一步到位, 因为重定向动画以后, 再调整姿势已经不会对已经生成的资源产生影响了</p>
<ul>
<li>确认骨骼链对应关系</li>
</ul>
<p>检查2套ik rig的骨骼链对应关系</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821110931817.png" alt="image-20230821110931817"></p>
<ul>
<li>设置rootmotion</li>
</ul>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230821110830772.png" alt="image-20230821110830772"></p>
<p>默认不会把rootmotion重定向过去, 需要选中root骨骼如上图设置</p>
<p>测试一下root骨骼有么有正确重定向</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//%E5%BD%95%E5%88%B6_2023_08_21_11_34_55_625.gif" alt="录制_2023_08_21_11_34_55_625"></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5新特性:Data Registry</title>
    <url>/2022/06/14/UE5%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ADataRegistry/</url>
    <content><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>UE5多了一个叫做DataRegistry(下称DR)的东西, 目前处于实验性功能, 看着名字像是类似DataAsset类似的东西, 研究了一番发现这个是一个还不错的与DataTable配合使用的东西</p>
<p>UE文档有一个聊胜于无的文档, 看了比没看…..也没好多少(还有点误导作用)  <a href="https://docs.unrealengine.com/5.0/en-US/data-registries-in-unreal-engine/">文档链接</a></p>
<span id="more"></span>

<p>补充: 知乎大佬有一篇更详细的文档, 后来才发现的 <a href="https://zhuanlan.zhihu.com/p/471631747">链接</a></p>
<p><a href="https://www.bilibili.com/video/BV1dk4y1r752?share_source=copy_web">Epic讲座</a></p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用DataRegistry需要开启插件</p>
<p><img src="https://img.supervj.top/imgimage-20220614105015868.png" alt="image-20220614105015868"></p>
<p>然后到项目设置相关的标签下找到DataRegistry, 添加若干个扫描的路径</p>
<p>这样项目在启动的时候<code>UDataRegistrySubsystem</code>就会自动扫面路径下的所有DR文件并加载保存</p>
<p>当然我们需要创建DR资源</p>
<p><img src="https://img.supervj.top/imgimage-20220614105732827.png" alt="image-20220614105732827"></p>
<p>然后界面是这样色的</p>
<p><img src="https://img.supervj.top/imgimage-20220614105856769.png" alt="image-20220614105856769"></p>
<ul>
<li>RegistryType : 这个可以理解为这个DR的Key</li>
<li>BaseGameplayTag: 如果你填写了, 那么这个就是RowName/否则通过真正的RowName, Epic真是对Tag这个技术无所不尽其极啊</li>
<li>ItemStruct: 一般就是DataTable对应的数据结构体, 如果是CurveTable那么这里是RealCurve; 别听文档说的用DataTableHandle啥的</li>
<li>DataSources: 可以选4个类型<ul>
<li>CurveTableSource/DataTableSource: 直接选择一个table资源</li>
<li>CurveTableMetaSource/DataTableMetaSource: 通过元数据构造一个表格/数据, 感觉一般不会常用,暂略</li>
</ul>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="DataTable"><a href="#DataTable" class="headerlink" title="DataTable"></a>DataTable</h3><p>创建一个蓝图结构体如下图</p>
<p><img src="https://img.supervj.top/imgimage-20220614112705301.png" alt="image-20220614112705301"></p>
<p>创建一个表格,数据乱填, 如下图</p>
<p><img src="https://img.supervj.top/imgimage-20220614112733964.png" alt="image-20220614112733964"></p>
<p>然后是到DR里面选择如下</p>
<p><img src="https://img.supervj.top/imgimage-20220614113121595.png" alt="image-20220614113121595"></p>
<p>红色框框中的东西错一不可,然后点刷新, 如果一切正常那么右侧就会出来正确是数据</p>
<p><img src="https://img.supervj.top/imgimage-20220614113216901.png" alt="image-20220614113216901"></p>
<p>然后就可以使用了, 看下图</p>
<p><img src="https://img.supervj.top/imgimage-20220614113337841.png" alt="image-20220614113337841"></p>
<p><img src="https://img.supervj.top/imgimage-20220614113405266.png" alt="image-20220614113405266"></p>
<p>Type中罗列了所有注册的DR, 同样的Item对应的是所有Row</p>
<hr>
<p>那么如果用Tag会怎么样?</p>
<p><img src="https://img.supervj.top/imgimage-20220614113445370.png" alt="image-20220614113445370"></p>
<p>先添加上图的一堆Tag</p>
<p><img src="https://img.supervj.top/imgimage-20220614113513048.png" alt="image-20220614113513048"></p>
<p>然后选择Item的时候发现所有的选项直接变成了Tag</p>
<p>意味着我们的RowName需要跟这个Tag对应起来</p>
<p><img src="https://img.supervj.top/imgimage-20220614113755703.png" alt="image-20220614113755703"></p>
<p>如上图, 这俩是对应的, 需要注意Tag的命名规范</p>
<h3 id="CurveTable"><a href="#CurveTable" class="headerlink" title="CurveTable"></a>CurveTable</h3><p>CurveTable如果是外部导入和UE自己有点区别, 自己创建的打开界面就是一堆的曲线, 外部导入是一个纯数据的表格, 见下面俩图</p>
<p><img src="https://img.supervj.top/imgimage-20220614114113360.png" alt="image-20220614114113360"></p>
<p><img src="https://img.supervj.top/imgimage-20220614114124453.png" alt="image-20220614114124453"></p>
<p>不过在DR中使用没啥区别</p>
<p>同样的 创建一个DR, 配置好如下图</p>
<p><img src="https://img.supervj.top/imgimage-20220614114201844.png" alt="image-20220614114201844"></p>
<p>通过EvaluateDataRegistryCurve()使用</p>
<p><img src="https://img.supervj.top/imgimage-20220614114307563.png" alt="image-20220614114307563"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>相比于传统的DataTable用DR的方式可以统一注册和加载, 统一调用, 相对于Cpp, 蓝图的优势更加明显;</p>
<p>不过, 目前目前还处于实验性阶段, 功能还不是特别稳定, 比如DR中添加了一个DataSource后再删除就会导致编辑器崩溃, 必须手动先把类型改成None以后在删除才可以.</p>
<p>所以还是坐等正式版发布</p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5顶点动画方案</title>
    <url>/2024/12/17/UE5%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UE5为了黑客帝国的样片增加了内置顶点动画插件，另外第三方也有相对比较成熟的顶点动画工具</p>
<p>本文分析并记录一下</p>
<span id="more"></span>

<h2 id="Anim-To-Texture"><a href="#Anim-To-Texture" class="headerlink" title="Anim To Texture"></a>Anim To Texture</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage.png" alt="img"></p>
<p>UE从5.0开始跟随者Mass更新了这个插件，不过一直到5.4也一直处于实验性功能</p>
<p>并且没有文档</p>
<p>开启插件以后，并没有什么特殊的提示和菜单</p>
<hr>
<h3 id="DataAsset"><a href="#DataAsset" class="headerlink" title="DataAsset"></a>DataAsset</h3><p>创建类型为AnimToTextureDataAsset的DA资产</p>
<p>界面如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217114454271.png" alt="image-20241217114454271"></p>
<p>需要重点关注的几个地方</p>
<ul>
<li>SkeletalMesh：原始骨骼模型</li>
<li>StaticMesh：用于播放顶点动画的静态模型，可由骨骼模型一键生成</li>
<li>Mode:两种计算方式<ul>
<li>Vertex：从顶点采样</li>
<li>Bone：通过骨骼和蒙皮采样</li>
</ul>
</li>
<li>Texture：对应上面2个模式的数据贴图</li>
<li>AnimSequences：动画片段，可以设置多个一起烘焙到同一张贴图上，通过材质参数改动画</li>
</ul>
<p>其他参数一般可以不修改或者视情况调整</p>
<h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p>两种模式创建的材质不一样，这里以顶点方式举例</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217114511937.png" alt="image-20241217114511937"></p>
<p>函数库都是提供好的，也不展开讨论</p>
<h3 id="设置材质数据"><a href="#设置材质数据" class="headerlink" title="设置材质数据"></a>设置材质数据</h3><p>这一步不需要通过手动设置，那会非常麻烦，通过一些现有的编辑器方法将DA的数据烘焙到贴图中，然后在设置一下材质参数即可</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217114527223.png" alt="image-20241217114527223"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217114537741.png" alt="image-20241217114537741"></p>
<p>上面的材质即该角色用到的所有材质实例</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_13_11_11_11_738.gif" alt="录制_2024_12_13_11_11_11_738"></p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>必须自己再写一套工具自动识别模型和材质，自动创建贴图，否则流程过于冗长</p>
<p>另外没有办法混合/过渡动画</p>
<p>所以只适合简单的顶点动画机制</p>
<h2 id="VertexAnimationManager"><a href="#VertexAnimationManager" class="headerlink" title="VertexAnimationManager"></a>VertexAnimationManager</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217114650433.png" alt="image-20241217114650433"></p>
<p>一个评分挺高的第三方插件</p>
<p><a href="https://drive.google.com/file/d/15kLk25k9TEwvUiW-d6kW4Ei4lmDlOQQE/view">文档</a></p>
<p><strong>文档比较旧，很多设置已经不一样了，仅供参考</strong></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_12_17_11_39_37_140.gif" alt="录制_2024_12_17_11_39_37_140"></p>
<p>这个插件按照介绍，解决了官方版本的很多短处，如下</p>
<ul>
<li>更简单的配置方式</li>
<li>支持动画过渡</li>
<li>更好的动画切换方式</li>
<li>支持获取Socket位置</li>
<li>支持动画通知（一种平替）</li>
<li>支持同步组</li>
<li>支持RootMotion</li>
<li>支持Ragdoll</li>
<li>支持ABP</li>
</ul>
<p>具体每个功能效果怎么样，下面分析</p>
<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>创建一个DA，类型是UVertexAnimationProfile</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133304726.png" alt="image-20241217133304726"></p>
<p>一般只需要修改上图种的内容</p>
<ul>
<li>Mode: 同官方，分骨骼和顶点，一般建议骨骼；以下以骨骼模式距离</li>
<li>InfluencesMaxBones: 最大影响的骨骼数，一般建议4个</li>
<li>InfluencesStorage: 建议选择Texture用贴图来存储顶点信息，否则会用模型的定点色来存储，会影响模型本身的顶点色的使用</li>
<li>Animation: 可以选择多条动画</li>
</ul>
<h3 id="材质-1"><a href="#材质-1" class="headerlink" title="材质"></a>材质</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133325820.png" alt="image-20241217133325820"></p>
<p>材质非常简单，使用一个函数库，如图连上即可</p>
<h3 id="Bake"><a href="#Bake" class="headerlink" title="Bake"></a>Bake</h3><p>然后打开骨骼模型资源，在AssetUserData里添加插件的一个，对象如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133343985.png" alt="image-20241217133343985"></p>
<p>然后点击骨骼模型编辑页面左上角插件提供的一个按钮</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133355619.png" alt="image-20241217133355619"></p>
<p>点以后会自动的生产贴图和静态模型，并且会设置到DA中</p>
<p>完整的DA应该是如下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133405135.png" alt="image-20241217133405135"></p>
<h3 id="创建BP"><a href="#创建BP" class="headerlink" title="创建BP"></a>创建BP</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage(11).png" alt="img"></p>
<p>添加上图两个组件，一个静态模型，一个播放动画</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133441586.png" alt="image-20241217133441586"></p>
<p>静态模型如上图设置好</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage(13).png" alt="img"></p>
<p>runtime组件如上图，一般功能都可以勾上</p>
<p>然后就可以通过播放动画的API播放特定的动画了</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage(14).png" alt="img"></p>
<h3 id="动画通知"><a href="#动画通知" class="headerlink" title="动画通知"></a>动画通知</h3><p>动画通知算是比较重要的功能了，看他如何实现的</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage(15).png" alt="img"></p>
<p>看一下他如何实现</p>
<p>核心的代码在 <strong>UVARuntimeComponent::RegisterNotifications</strong>中</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133525141.png" alt="image-20241217133525141"></p>
<p>遍历搜集到的所有通知，对几种类型的通知分别处理</p>
<p>核心围绕TimerManager，本质上就是倒计时到点了就发出通知事件</p>
<ul>
<li>ANS<ul>
<li>Begin/End 2个计时器，到点了触发</li>
<li>注册world的tick回调，一直触发，end以后销毁</li>
</ul>
</li>
<li>AN：到点了触发</li>
<li>自定义通知<ul>
<li>判断是否有Handle对象</li>
<li>查询同名函数并执行</li>
<li>最多支持一个参数</li>
</ul>
</li>
</ul>
<h4 id="蓝图-cpp通知"><a href="#蓝图-cpp通知" class="headerlink" title="蓝图/cpp通知"></a>蓝图/cpp通知</h4><p>蓝图或者cpp写的动画通知都需要继承对应的接口</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage(17).png" alt="img"></p>
<p>然后实现里面的接口就以触发通知，比如</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage(18).png" alt="img"></p>
<p>但是蓝图的ANS通知有一个bug</p>
<p>看实现的地方</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage(19).png" alt="img"></p>
<p>蓝图的ANS类即使继承了接口也会cast失败，这个是UE自身的问题，所以无法正常触发动画通知</p>
<p>可以通过修改代码实现，但是不建议，直接用cpp吧</p>
<h4 id="自定义通知"><a href="#自定义通知" class="headerlink" title="自定义通知"></a>自定义通知</h4><p>这个要分2类，一般就是我们右键直接创建出来的通知</p>
<p>对应关系如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage(20).png" alt="img"></p>
<p>这里不得不提到还有一种自定义通知的方法</p>
<p>就是创建一个蓝图AN，但是不继承自上述说到的接口</p>
<p>那么也是通过函数名去查询，但是名称有点奇怪，反正不建议就是了，如下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage(21).png" alt="img"></p>
<h3 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h3><p>ABP也能用是没想到的，这样就非常方便了</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgImage(22).png" alt="img"></p>
<p>ABP里专门写了一个播放动画的节点</p>
<img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133722459.png" alt="image-20241217133722459" style="zoom:80%;" />

<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133740881.png" alt="image-20241217133740881"></p>
<p>看代码发现核心逻辑是拷贝pose</p>
<p>那么既然有ABP，后面肯定有个在跑的SkeletalMeshComponent</p>
<p>所以理解一下就是， 后面其实是有一个看不见的骨骼模型在跑，然后将ABP的pose拷贝到静态模型上</p>
<p>所以意义在哪里？</p>
<p>用顶点动画其中一点原因难道不就是为了节约ABP和骨骼模型的那些性能开销吗？</p>
<p>实际使用下来发现也有一些问题和bug</p>
<ul>
<li>在编辑器模拟运行是可以的，运行时状态机无法根据条件正确跳转</li>
<li>节点无法自动过渡</li>
<li>无法使用蒙太奇</li>
</ul>
<h3 id="Ragdoll"><a href="#Ragdoll" class="headerlink" title="Ragdoll"></a>Ragdoll</h3><p>这个也是同ABP，必修后面有个SkeletalMeshComponent，原理也类似</p>
<p>那这个功能也就鸡肋了</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133800368.png" alt="image-20241217133800368"></p>
<h3 id="同步组"><a href="#同步组" class="headerlink" title="同步组"></a>同步组</h3><p>本以为同步组也是跟上面两者一样偷梁换柱，结果这个反而是正儿八经的做了的</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20241217133814111.png" alt="image-20241217133814111"></p>
<p>考虑到本身这个动画只有一种情况会用到同步组，就是2个动画过渡的时候，那么也能理解这个同步组的实现并不需要骨骼动画那么麻烦了</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>24年12月作者只更新到支持5.4，还未支持5.5</li>
<li>使用过程中会出现动画丢失或者严重变形，需要重新Bake或者重新设置2个组件，应该是个bug</li>
<li>编辑或者运行过程中偶尔会crash，也是bug</li>
</ul>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5搭建Pico开发环境</title>
    <url>/2023/09/26/UE5%E9%80%82%E9%85%8DPico/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UE本身不支持Pico开发, 需要手动搭建开发环境,本文简单记录</p>
<span id="more"></span>

<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>Pico的SDK是已UE插件的形式安装的, 直接到官网<a href="https://developer-cn.pico-interactive.com/resources/#sdk">下砸</a></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230926111231394.png" alt="image-20230926111231394"></p>
<p>文档提示有4个插件, 实际下到3个插件, 没看到<code>PicoSpatialAudio</code></p>
<p>另外,  开发时肯定需要在编辑器预览, 这个默认也不支持, 需要下载两个东西</p>
<ul>
<li><a href="https://developer-cn.pico-interactive.com/resources/#pdc">Pico Developer Center</a></li>
<li><a href="https://developer-cn.pico-interactive.com/resources/#sdk"><strong>PICO Unreal Live Preview Plugin (Experiment)</strong></a></li>
</ul>
<h2 id="输入适配"><a href="#输入适配" class="headerlink" title="输入适配"></a>输入适配</h2><p>Pico加入了自己的输入映射, 跟oculus几乎一致</p>
<p>原原本本的抄一遍就可以了</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230926112853575.png" alt="image-20230926112853575"></p>
<p>但是截止UE5.1, PicoSdk 2.3.0 , Pico的手柄坐标系并未像Oculus或者steam那样, 对OpenXR进行了适配, 如果你什么都不处理, 那么手柄朝向在Pitch角度是比较歪的, 需要程序化的判定并矫正一下,(笔者在pitch上减去了45度)</p>
<h2 id="编辑器预览"><a href="#编辑器预览" class="headerlink" title="编辑器预览"></a>编辑器预览</h2><p>编辑器预览Pico也有单独一篇文档 :<a href="https://developer-cn.pico-interactive.com/document/unreal/preview-app-scenes/">实时预览应用场景</a></p>
<p>简单来讲需要以下几点</p>
<ul>
<li>Pico开启开发者模式并开启USB调试</li>
<li>下载了上面提到的PICO Unreal Live Preview Plugin (Experiment)插件并放到项目中</li>
<li>开启插件</li>
<li>RHI设置成DX11</li>
<li>去掉InstancedStereo</li>
</ul>
<p>每次预览都需要在眼镜里点击确认才能进入游戏场景, 比较麻烦</p>
<p>还有就是RHI和InstancedStereo 的要求不太适配项目本身, 因为多数项目还是会使用DX12和开启InstancedStereo来优化性能的, 意味着这两个选项只能是临时的为编辑器预览而修改一下的</p>
<h2 id="手柄反馈"><a href="#手柄反馈" class="headerlink" title="手柄反馈"></a>手柄反馈</h2><p>UE原生的<code>PlayHapticEffect</code>即手柄震动对Pico无效, Pico需要使用他自己的<code>Set Controller Vibration Event</code></p>
<p>但是这玩意儿只在安卓生效, 那么pc串流是不是就暂时放弃了?</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230926113817789.png" alt="image-20230926113817789"></p>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p><code>PICOLivePreview</code>插件是用于编辑器实时预览的, 但是如果你不做额外处理, 那么打包也会打进去, 这个会导致打包失败, 解决打包时候的代码以后也会导致运行初就crash</p>
<p>把插件下的所有模块都改成uncookonly或者editor即可</p>
<h2 id="串流"><a href="#串流" class="headerlink" title="串流"></a>串流</h2><p>对于打出来的包, pico并不能直接像quest一样, 开个meta link就直接跑</p>
<p>需要下载一个<a href="https://www.picoxr.com/cn/software/pico-link">pc串流工具</a> </p>
<p>然后运行这个工具以后在头显也运行串流工具, 连上pc</p>
<blockquote>
<p>这里一开始找不到PC设备, 解决办法就是…..反复插拔usb</p>
</blockquote>
<p>连上pc以后, 笔者又遇到了一个坑</p>
<p>一直显示等待steamVR启动,  手动启动steamVR以后也没用, steamVR也显示异常 </p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230927115043111.png" alt="image-20230927115043111"></p>
<p>包括PDC上显示也是异常, 反复尝试都无果, 最后的解决方法是</p>
<p><strong>重启电脑</strong></p>
<p>重启以后在steamVR上就可以正确显示设备了, 如下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230927115147095.png" alt="image-20230927115147095"></p>
<p>尝试启动Alyx试一下, 第一遍steamVR报错, 第2,3…N边, 最好的情况是PC有画面, 头显内有声音没画面</p>
<p>然后反复开关steamVR, 启动游戏, 然后………..成功了……..</p>
<p>然后直接启动打出来的包, 也可以了……</p>
<p>Pico威武!!!</p>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>vr</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4各种代理(委托)使用方法</title>
    <url>/2021/02/25/UE%E4%BB%A3%E7%90%86%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img.supervj.top//img/chrome_FGGFGHQnkb.png"></p>
<p>UE4中有茫茫多的代理类型, 对于初学者刚开始都是一头雾水, 本篇文章逐步分析每一种代理的使用方法</p>
<span id="more"></span>





<p>我们先用一个输入整形输入参数的形式,声明所有类型的代理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单播代理</span></span><br><span class="line"><span class="built_in">DECLARE_DELEGATE_OneParam</span>(FDlg_1P,int32);</span><br><span class="line"><span class="comment">//多播代理</span></span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FDlgMul_1P, int32);</span><br><span class="line"><span class="comment">//事件</span></span><br><span class="line"><span class="built_in">DECLARE_EVENT_OneParam</span>(AActor,FDlgEvent_1P,int32);</span><br><span class="line"><span class="comment">//动态代理</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_DELEGATE_OneParam</span>(FDlgDy_1P, int32, number);</span><br><span class="line"><span class="comment">//动态多播代理</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FDlgDyMul_1P, int32, number);</span><br><span class="line"><span class="comment">//带返回的单播</span></span><br><span class="line"><span class="built_in">DECLARE_DELEGATE_RetVal_OneParam</span>(<span class="keyword">bool</span>,FDlgRet_1P,int32);</span><br><span class="line"><span class="comment">//带返回值的动态单播</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_DELEGATE_RetVal_OneParam</span>(<span class="keyword">bool</span>, FDlgDyRet_1P, int32, number);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">		FDlg_1P Dlg_1P;</span><br><span class="line">		FDlgMul_1P DlgMul_1P;</span><br><span class="line">		FDlgEvent_1P DlgEvent_1P;</span><br><span class="line">		FDlgDy_1P DlgDy_1P;</span><br><span class="line"><span class="comment">//唯一可以声明为蓝图变量的类型</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, BlueprintCallable)</span><br><span class="line">		FDlgDyMul_1P DlgDyMul_1P;</span><br><span class="line"></span><br><span class="line">		FDlgRet_1P DlgRet_1P;</span><br><span class="line">		FDlgDyRet_1P DlgDyRet_1P;</span><br></pre></td></tr></table></figure>



<p>按使用方式, 一般就是普通的单播代理, 动态代理, 多播代理以及动态多播代理, 每种类型都有无参数很若干参数的版本以及带返回值的版本(多播无返回值);</p>
<p>后续我们也按照蓝图可否使用来区分各个代理</p>
<h2 id="单播代理"><a href="#单播代理" class="headerlink" title="单播代理"></a>单播代理</h2><ul>
<li>声明</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DELEGATE_OneParam</span>(FDlg_1P,int32);</span><br><span class="line"><span class="built_in">DECLARE_DELEGATE_RetVal_OneParam</span>(<span class="keyword">bool</span>,FDlgRet_1P,int32);<span class="comment">//带返回值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FDlg_1P Dlg_1P;</span><br><span class="line">FDlgRet_1P DlgRet_1P;</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定/解绑</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Event_FDlg_1P</span><span class="params">(int32 number)</span></span>;</span><br><span class="line">Dlg_1P.<span class="built_in">BindUObject</span>(<span class="keyword">this</span>, &amp;ATestActor::Event_FDlg_1P);</span><br><span class="line">Dlg_1P.<span class="built_in">Unbind</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Event_DlgRet_1P</span><span class="params">(int32 number)</span></span>;</span><br><span class="line"><span class="built_in">GetFDlgRet_1P</span>().<span class="built_in">BindUObject</span>(<span class="keyword">this</span>, &amp;ATestActor::Event_DlgRet_1P);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Static函数 // BindStatic</span></span><br><span class="line"><span class="comment">//普通C++对象的成员函数 // BindRaw</span></span><br><span class="line"><span class="comment">//Lambda表达式 // BindLambda // BindWeakLambda</span></span><br><span class="line"><span class="comment">//与某个UObject对象关联的Lambda表达式</span></span><br><span class="line"><span class="comment">//共享引用包裹的普通C++对象的成员函数 // BindSP // BindThreadSafeSP</span></span><br><span class="line"><span class="comment">//线程安全的共享引用包裹的普通C++对象的成员函数</span></span><br><span class="line"><span class="comment">//UObject对象的成员函数 // BindUObject</span></span><br><span class="line"><span class="comment">//UObject对象的UFunction成员函数 // BindUFunction</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用/触发</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Dlg_1P.<span class="built_in">ExecuteIfBound</span>(number);</span><br><span class="line"><span class="keyword">if</span> (DlgRet_1P.<span class="built_in">IsBound</span>())<span class="comment">//有返回值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> DlgRet_1P.<span class="built_in">Execute</span>(number);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>不支持反射以及序列化，可以有返回值，支持Playload参数，可以绑定一个</p>
<p>另外定义的变量无法定义为蓝图变量, 也无法作为参数传递给蓝图;</p>
<p>绑定以后会顶替掉其他绑定的类,即<strong>绑定唯一</strong></p>
<h2 id="多播代理-事件"><a href="#多播代理-事件" class="headerlink" title="多播代理/事件"></a>多播代理/事件</h2><ul>
<li>声明/定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FDlgMul_1P, int32);</span><br><span class="line"><span class="built_in">DECLARE_EVENT_OneParam</span>(AActor,FDlgEvent_1P,int32);</span><br><span class="line">FDlgMul_1P DlgMul_1P;</span><br><span class="line">FDlgEvent_1P DlgEvent_1P;</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定/解绑</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetFDlgMul_1P</span>().<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;ATestActor::Event_FDlgMul_1P);</span><br><span class="line"><span class="built_in">GetFDlgMul_1P</span>().<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Static函数 // AddStddatic</span></span><br><span class="line"><span class="comment">//普通C++对象的成员函数 // AddRaw</span></span><br><span class="line"><span class="comment">//Lambda表达式 // AddLambda // AddWeakLambda</span></span><br><span class="line"><span class="comment">//与某个UObject对象关联的Lambda表达式</span></span><br><span class="line"><span class="comment">//共享引用包裹的普通C++对象的成员函数 // AddSP // AddThreadSafeSP</span></span><br><span class="line"><span class="comment">//线程安全的共享引用包裹的普通C++对象的成员函数</span></span><br><span class="line"><span class="comment">//UObject对象的成员函数 // AddUObject</span></span><br><span class="line"><span class="comment">//UObject对象的UFunction成员函数 // AddUFunction</span></span><br><span class="line"><span class="comment">//也可以创建FDelegate对象，然后调用Add函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>触发/调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DlgMul_1P.<span class="built_in">Broadcast</span>(number);</span><br></pre></td></tr></table></figure>



<p>不支持反射以及序列化，<strong>无返回值</strong>，支持Playload参数，可以绑定多个</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul>
<li>声明/定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_DELEGATE_OneParam</span>(FDlgDy_1P, int32, number);</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_DELEGATE_RetVal_OneParam</span>(<span class="keyword">bool</span>, FDlgDyRet_1P, int32, number);</span><br><span class="line">FDlgDy_1P DlgDy_1P;</span><br><span class="line">FDlgDyRet_1P DlgDyRet_1P;</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定/解绑</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Event_FDlgDy_1P</span><span class="params">(int32 number)</span></span>;</span><br><span class="line"><span class="built_in">GetFDlgDy_1P</span>().<span class="built_in">BindUFunction</span>(<span class="keyword">this</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Event_FDlgDy_1P&quot;</span>));</span><br><span class="line"><span class="comment">//GetFDlgDy_1P().BindDynamic(this, &amp;ATestActor::Event_FDlgDy_1P);//宏绑定</span></span><br><span class="line"><span class="built_in">GetFDlgDy_1P</span>().<span class="built_in">Unbind</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//带返回值的类同</span></span><br></pre></td></tr></table></figure>

<ul>
<li>触发/调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetFDlgDy_1P</span>().<span class="built_in">Broadcast</span>(number);</span><br><span class="line"><span class="keyword">if</span> (DlgDyRet_1P.<span class="built_in">IsBound</span>())<span class="comment">//带返回值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> DlgDyRet_1P.<span class="built_in">Execute</span>(number);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>支持反射以及序列化，可以有返回值，不支持Playload参数，<strong>绑定唯一</strong></p>
<p>另外动态代理支持作为蓝图函数的参数, 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintNativeEvent)</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">TestFunction</span><span class="params">(<span class="keyword">const</span> FDlgDy_1P&amp; callback_Dy, <span class="keyword">const</span> FDlgDyRet_1P&amp; callback_DyRet)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/UE4Editor_lvL7XrynEG.png" alt="UE4Editor_lvL7XrynEG"></p>
<blockquote>
<p>调用此函数以后也作为唯一绑定而顶替掉原有绑定.</p>
</blockquote>
<h2 id="动态多播代理"><a href="#动态多播代理" class="headerlink" title="动态多播代理"></a>动态多播代理</h2><ul>
<li>声明/定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FDlgDyMul_1P, int32, number);</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, BlueprintCallable)<span class="comment">//唯一可以声明为蓝图变量的</span></span><br><span class="line">		FDlgDyMul_1P DlgDyMul_1P;</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定/解绑</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetFDlgDyMul_1P</span>().<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ATestActor::Event_FDlgDyMul_1P);</span><br><span class="line"><span class="built_in">GetFDlgDyMul_1P</span>().<span class="built_in">RemoveDynamic</span>(<span class="keyword">this</span>, &amp;ATestActor::Event_FDlgDyMul_1P);</span><br><span class="line"><span class="comment">//也同样支持Add和AddUnique函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用/触发</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DlgDyMul_1P.<span class="built_in">Broadcast</span>(number);</span><br></pre></td></tr></table></figure>

<p>如果定义的时候加入了<code>BlueprintAssignable, BlueprintCallable</code>即可以作为蓝图变量, 类似蓝图的<code>Dispatcher</code>的使用</p>
<p><img src="https://img.supervj.top//img/UE4Editor_o15wfc0YJ4.png" alt="UE4Editor_o15wfc0YJ4"></p>
<h2 id="关于Payload"><a href="#关于Payload" class="headerlink" title="关于Payload"></a>关于Payload</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DELEGATE_OneParam</span>(FTestDlg, <span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestPayload</span><span class="params">(<span class="keyword">int</span> number, FString txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;TestPayload : %d  %s&quot;</span>), number,  *txt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FTestDlg TestDlg;</span><br><span class="line">TestDlg.<span class="built_in">BindStatic</span>(TestPayload, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello&quot;</span>)); </span><br><span class="line">TestDlg.<span class="built_in">ExecuteIfBound</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>初探UE4反射系统</title>
    <url>/2020/07/08/Unreal4Refraction/</url>
    <content><![CDATA[<blockquote>
<p>参考文献</p>
<p>《<a href="https://zhuanlan.zhihu.com/p/25098685">InsideUE4》UObject（四）类型系统代码生成</a>》</p>
</blockquote>
<blockquote>
<p> 创建项目 <code>AdvanceFunc</code></p>
<p> 创建2个Actor类，<code>HelloWolrd</code>,<code>ByeWorld</code></p>
</blockquote>
<p><code>ByeWorld</code>的<code>GENERATED_BODY</code>替换成<code>GENERATED_UCLASS_BODY</code></p>
<h3 id="GENERATED-BODY-GENERATED-UCLASS-BODY"><a href="#GENERATED-BODY-GENERATED-UCLASS-BODY" class="headerlink" title="GENERATED_BODY/GENERATED_UCLASS_BODY"></a>GENERATED_BODY/GENERATED_UCLASS_BODY</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERATED_BODY_LEGACY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY_LEGACY);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>CURRENT_FILE_ID </li>
</ul>
<p>定义在<code> *.generated.h</code>的底部,如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CURRENT_FILE_ID</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURRENT_FILE_ID AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__LINE__</code></li>
</ul>
<p>改标准宏指向了该宏使用时候的的函数。加了一个__LINE__宏的目的是为了支持在同一个文件内声明多个类，比如在MyClass.h里接着再声明UMyClass2，就可以支持生成不同的宏名称</p>
<p>对比2个版本的，在<code>generated.h</code>中发现在<code>UCLASS</code>版本的52行多出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NO_API <span class="title">AByeWorld</span><span class="params">(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get())</span> : Super(ObjectInitializer) &#123;</span> &#125;; \</span><br></pre></td></tr></table></figure>

<p>所以<code>UCLASS</code>版本自动申明带<code>FObjectInitializer</code> 参数的构造函数</p>
<h3 id="generated-h"><a href="#generated-h" class="headerlink" title=".generated.h"></a>.generated.h</h3><p>先看<code>HelloWorld.generated.h</code>的全貌</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UObject/ObjectMacros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UObject/ScriptMacros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">PRAGMA_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ADVANCEFUNC_HelloWorld_generated_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;HelloWorld.generated.h already included, missing &#x27;#pragma once&#x27; in HelloWorld.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADVANCEFUNC_HelloWorld_generated_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_SPARSE_DATA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_RPC_WRAPPERS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_RPC_WRAPPERS_NO_PURE_DECLS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_INCLASS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">	static void StaticRegisterNativesAHelloWorld(); \</span></span><br><span class="line"><span class="meta">	friend struct Z_Construct_UClass_AHelloWorld_Statics; \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">	DECLARE_CLASS(AHelloWorld, AActor, COMPILED_IN_FLAGS(0 | CLASS_Config), CASTCLASS_None, TEXT(<span class="meta-string">&quot;/Script/AdvanceFunc&quot;</span>), NO_API) \</span></span><br><span class="line"><span class="meta">	DECLARE_SERIALIZER(AHelloWorld)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_INCLASS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">	static void StaticRegisterNativesAHelloWorld(); \</span></span><br><span class="line"><span class="meta">	friend struct Z_Construct_UClass_AHelloWorld_Statics; \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">	DECLARE_CLASS(AHelloWorld, AActor, COMPILED_IN_FLAGS(0 | CLASS_Config), CASTCLASS_None, TEXT(<span class="meta-string">&quot;/Script/AdvanceFunc&quot;</span>), NO_API) \</span></span><br><span class="line"><span class="meta">	DECLARE_SERIALIZER(AHelloWorld)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_STANDARD_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** Standard constructor, called after all reflected properties have been initialized */</span> \</span></span><br><span class="line"><span class="meta">	NO_API AHelloWorld(const FObjectInitializer&amp; ObjectInitializer); \</span></span><br><span class="line"><span class="meta">	DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(AHelloWorld) \</span></span><br><span class="line"><span class="meta">	DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, AHelloWorld); \</span></span><br><span class="line"><span class="meta">DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(AHelloWorld); \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** Private move- and copy-constructors, should never be used */</span> \</span></span><br><span class="line"><span class="meta">	NO_API AHelloWorld(AHelloWorld&amp;&amp;); \</span></span><br><span class="line"><span class="meta">	NO_API AHelloWorld(const AHelloWorld&amp;); \</span></span><br><span class="line"><span class="meta">public:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_ENHANCED_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** Private move- and copy-constructors, should never be used */</span> \</span></span><br><span class="line"><span class="meta">	NO_API AHelloWorld(AHelloWorld&amp;&amp;); \</span></span><br><span class="line"><span class="meta">	NO_API AHelloWorld(const AHelloWorld&amp;); \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">	DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, AHelloWorld); \</span></span><br><span class="line"><span class="meta">DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(AHelloWorld); \</span></span><br><span class="line"><span class="meta">	DEFINE_DEFAULT_CONSTRUCTOR_CALL(AHelloWorld)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_PRIVATE_PROPERTY_OFFSET</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_9_PROLOG</span></span><br><span class="line"> <span class="comment">//GENERATED_UCLASS_BODY定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_GENERATED_BODY_LEGACY \</span></span><br><span class="line"><span class="meta">PRAGMA_DISABLE_DEPRECATION_WARNINGS \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">	AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_PRIVATE_PROPERTY_OFFSET \</span></span><br><span class="line"><span class="meta">	AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_SPARSE_DATA \</span></span><br><span class="line"><span class="meta">	AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_RPC_WRAPPERS \</span></span><br><span class="line"><span class="meta">	AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_INCLASS \</span></span><br><span class="line"><span class="meta">	AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_STANDARD_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GENERATED_BODY定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_GENERATED_BODY \</span></span><br><span class="line"><span class="meta">PRAGMA_DISABLE_DEPRECATION_WARNINGS \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">	AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_PRIVATE_PROPERTY_OFFSET \</span></span><br><span class="line"><span class="meta">	AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_SPARSE_DATA \</span></span><br><span class="line"><span class="meta">	AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_RPC_WRAPPERS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">	AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_INCLASS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">	AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_ENHANCED_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; ADVANCEFUNC_API UClass* StaticClass&lt;<span class="class"><span class="keyword">class</span> <span class="title">AHelloWorld</span>&gt;</span>();</span><br><span class="line"><span class="comment">//GENERATED_BODY定义用到的ID</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CURRENT_FILE_ID</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURRENT_FILE_ID AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>关于<code>GENERATED_BODY</code>的宏定义</li>
</ul>
<p>带<code>PRIVATE_PROPERTY_OFFSET和PROLOG</code>的先跳过，后面再补充</p>
<p><code>AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_INCLASS</code>和<code>AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_INCLASS_NO_PURE_DECLS</code>的定义一样，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_INCLASS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">	static void StaticRegisterNativesAHelloWorld(); \</span></span><br><span class="line"><span class="meta">	friend struct Z_Construct_UClass_AHelloWorld_Statics; \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">	DECLARE_CLASS(AHelloWorld, AActor, COMPILED_IN_FLAGS(0 | CLASS_Config), CASTCLASS_None, TEXT(<span class="meta-string">&quot;/Script/AdvanceFunc&quot;</span>), NO_API) \</span></span><br><span class="line"><span class="meta">	DECLARE_SERIALIZER(AHelloWorld)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_INCLASS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">	static void StaticRegisterNativesAHelloWorld(); \</span></span><br><span class="line"><span class="meta">	friend struct Z_Construct_UClass_AHelloWorld_Statics; \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">	DECLARE_CLASS(AHelloWorld, AActor, COMPILED_IN_FLAGS(0 | CLASS_Config), CASTCLASS_None, TEXT(<span class="meta-string">&quot;/Script/AdvanceFunc&quot;</span>), NO_API) \</span></span><br><span class="line"><span class="meta">	DECLARE_SERIALIZER(AHelloWorld)</span></span><br></pre></td></tr></table></figure>

<p>然后是<code>AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_ENHANCED_CONSTRUCTORS</code>和<code>AdvanceFunc_Source_AdvanceFunc_Public_HelloWorld_h_12_STANDARD_CONSTRUCTORS</code>,对比代码发现</p>
<p>后者多了<code>NO_API AHelloWorld(const FObjectInitializer&amp; ObjectInitializer); </code>,转身去看一看<code>ByeWorld</code>发现此版本的2个宏几乎完全一样，只是后者多了<code>Super(ObjectInitializer) &#123; &#125;;</code></p>
<p>这里重点要说的是不管上述宏都将<strong>C++11的拷贝构造和移动构造</strong>私有化了，目的是防止误操作</p>
<ul>
<li><code>DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(TClass) \</span></span><br><span class="line"><span class="meta">	static void __DefaultConstructor(const FObjectInitializer&amp; X) &#123; new((EInternal*)X.GetObj())TClass(X); &#125;</span></span><br></pre></td></tr></table></figure>

<p> 该声明定义了一个构造函数包装器。需要这么做的原因是，在根据名字反射创建对象的时候，需要调用该类的构造函数。可是类的构造函数并不能用函数指针指向，因此这里就用一个static函数包装一下，变成一个”平凡”的函数指针，而且所有类的签名一致，就可以在UClass里用一个函数指针里保存起来</p>
<ul>
<li><code>DECLARE_CLASS</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_CLASS( TClass, TSuperClass, TStaticFlags, TStaticCastFlags, TPackage, TRequiredAPI  ) \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">    TClass&amp; operator=(TClass&amp;&amp;);   \</span></span><br><span class="line"><span class="meta">    TClass&amp; operator=(const TClass&amp;);   \</span></span><br><span class="line"><span class="meta">	TRequiredAPI static UClass* GetPrivateStaticClass(); \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** Bitwise union of #EClassFlags pertaining to this class.*/</span> \</span></span><br><span class="line"><span class="meta">	enum &#123;StaticClassFlags=TStaticFlags&#125;; \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** Typedef for the base class (&#123;&#123; typedef-type &#125;&#125;) */</span> \</span></span><br><span class="line"><span class="meta">	typedef TSuperClass Super;\</span></span><br><span class="line"><span class="meta">	<span class="comment">/** Typedef for &#123;&#123; typedef-type &#125;&#125;. */</span> \</span></span><br><span class="line"><span class="meta">	typedef TClass ThisClass;\</span></span><br><span class="line"><span class="meta">	<span class="comment">/** Returns a UClass object representing this class at runtime */</span> \</span></span><br><span class="line"><span class="meta">	inline static UClass* StaticClass() \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		return GetPrivateStaticClass(); \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** Returns the package this class belongs in */</span> \</span></span><br><span class="line"><span class="meta">	inline static const TCHAR* StaticPackage() \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		return TPackage; \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** Returns the static cast flags for this class */</span> \</span></span><br><span class="line"><span class="meta">	inline static EClassCastFlags StaticClassCastFlags() \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		return TStaticCastFlags; \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** For internal use only; use StaticConstructObject() to create new objects. */</span> \</span></span><br><span class="line"><span class="meta">	inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags) \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags); \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** For internal use only; use StaticConstructObject() to create new objects. */</span> \</span></span><br><span class="line"><span class="meta">	inline void* operator new( const size_t InSize, EInternal* InMem ) \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		return (void*)InMem; \</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>TClass</code>：类名 </li>
<li><code>TSuperClass</code>：基类名字</li>
<li><code>TStaticFlags</code>：类的属性标记，这里是0，表示最默认，不带任何其他属性。读者可以查看<code>EClassFlags</code>枚举来查看其他定义。</li>
<li><code>TStaticCastFlags</code>：指定了该类可以转换为哪些类，这里为0表示不能转为那些默认的类，读者可以自己查看<code>EClassCastFlags</code>声明来查看具体有哪些默认类转换。</li>
<li><code>TPackage</code>：类所处于的包名，所有的对象都必须处于一个包中，而每个包都具有一个名字，可以通过该名字来查找。这里是”/Script/Hello”，指定是Script下的Hello，Script可以理解为用户自己的实现，不管是C++还是蓝图，都可以看作是引擎外的一种脚本，当然用这个名字也肯定有UE3时代<code>UnrealScript</code>的影子。Hello就是项目名字，该项目下定义的对象处于该包中。Package的概念涉及到后续Object的组织方式，目前可以简单理解为一个大的Object包含了其他子Object。</li>
<li><code>TRequiredAPI</code>：就是用来Dll导入导出的标记，这里是NO_API，因为是最终exe，不需要导出。</li>
</ul>
<h3 id="generated-cpp"><a href="#generated-cpp" class="headerlink" title=".generated.cpp"></a>.generated.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UObject/GeneratedCppIncludes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AdvanceFunc/Public/HelloWorld.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span> (push)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span> (disable : 4883)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function">PRAGMA_DISABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmptyLinkFunctionForGeneratedCodeHelloWorld</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//忽略</span></span><br><span class="line"><span class="comment">// Cross Module References</span></span><br><span class="line">	<span class="function">ADVANCEFUNC_API UClass* <span class="title">Z_Construct_UClass_AHelloWorld_NoRegister</span><span class="params">()</span></span>;<span class="comment">//构造对应的没有后续的注册过程UClass对象</span></span><br><span class="line">	<span class="function">ADVANCEFUNC_API UClass* <span class="title">Z_Construct_UClass_AHelloWorld</span><span class="params">()</span></span>;<span class="comment">//在下面L61，构造AHelloWorld对应的UClass对象</span></span><br><span class="line">	<span class="function">ENGINE_API UClass* <span class="title">Z_Construct_UClass_AActor</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">UPackage* <span class="title">Z_Construct_UPackage__Script_AdvanceFunc</span><span class="params">()</span></span>;<span class="comment">//构造本身的UPackage对象</span></span><br><span class="line"><span class="comment">// End Cross Module References</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AHelloWorld::StaticRegisterNativesAHelloWorld</span><span class="params">()</span><span class="comment">//静态注册，目前是空的</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">UClass* <span class="title">Z_Construct_UClass_AHelloWorld_NoRegister</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> AHelloWorld::<span class="built_in">StaticClass</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Z_Construct_UClass_AHelloWorld_Statics</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">static</span> UObject* (*<span class="keyword">const</span> DependentSingletons[])();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_METADATA</span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> FCppClassTypeInfoStatic StaticCppClassTypeInfo;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> UE4CodeGen_Private::FClassParams ClassParams;</span><br><span class="line">	&#125;;</span><br><span class="line">	UObject* (*<span class="keyword">const</span> Z_Construct_UClass_AHelloWorld_Statics::DependentSingletons[])() = &#123;</span><br><span class="line">		(UObject* (*)())Z_Construct_UClass_AActor,</span><br><span class="line">		(UObject* (*)())Z_Construct_UPackage__Script_AdvanceFunc,</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_METADATA</span></span><br><span class="line">	<span class="keyword">const</span> UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AHelloWorld_Statics::Class_MetaDataParams[] = &#123;</span><br><span class="line">		&#123; <span class="string">&quot;IncludePath&quot;</span>, <span class="string">&quot;HelloWorld.h&quot;</span> &#125;,</span><br><span class="line">		&#123; <span class="string">&quot;ModuleRelativePath&quot;</span>, <span class="string">&quot;Public/HelloWorld.h&quot;</span> &#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">const</span> FCppClassTypeInfoStatic Z_Construct_UClass_AHelloWorld_Statics::StaticCppClassTypeInfo = &#123;</span><br><span class="line">		TCppClassTypeTraits&lt;AHelloWorld&gt;::IsAbstract,</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//构造HelloWorld的UPackage</span></span><br><span class="line">	<span class="keyword">const</span> UE4CodeGen_Private::FClassParams Z_Construct_UClass_AHelloWorld_Statics::ClassParams = &#123;</span><br><span class="line">		&amp;AHelloWorld::StaticClass,</span><br><span class="line">		<span class="string">&quot;Engine&quot;</span>,</span><br><span class="line">		&amp;StaticCppClassTypeInfo,</span><br><span class="line">		DependentSingletons,</span><br><span class="line">		<span class="literal">nullptr</span>,</span><br><span class="line">		<span class="literal">nullptr</span>,</span><br><span class="line">		<span class="literal">nullptr</span>,</span><br><span class="line">		<span class="built_in">UE_ARRAY_COUNT</span>(DependentSingletons),</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="number">0x009000A4</span>u,</span><br><span class="line">		<span class="built_in">METADATA_PARAMS</span>(Z_Construct_UClass_AHelloWorld_Statics::Class_MetaDataParams, <span class="built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_AHelloWorld_Statics::Class_MetaDataParams))</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function">UClass* <span class="title">Z_Construct_UClass_AHelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">static</span> UClass* OuterClass = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">if</span> (!OuterClass)</span><br><span class="line">		&#123;</span><br><span class="line">			UE4CodeGen_Private::<span class="built_in">ConstructUClass</span>(OuterClass, Z_Construct_UClass_AHelloWorld_Statics::ClassParams);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> OuterClass;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">IMPLEMENT_CLASS</span>(AHelloWorld, <span class="number">1028549712</span>); <span class="comment">//这个比较重要,见下文</span></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt; ADVANCEFUNC_API UClass* StaticClass&lt;AHelloWorld&gt;()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> AHelloWorld::<span class="built_in">StaticClass</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">////延迟注册，注入信息，在启动的时候调用</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> FCompiledInDefer <span class="title">Z_CompiledInDefer_UClass_AHelloWorld</span><span class="params">(Z_Construct_UClass_AHelloWorld, &amp;AHelloWorld::StaticClass, TEXT(<span class="string">&quot;/Script/AdvanceFunc&quot;</span>), TEXT(<span class="string">&quot;AHelloWorld&quot;</span>), <span class="literal">false</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">	<span class="built_in">DEFINE_VTABLE_PTR_HELPER_CTOR</span>(AHelloWorld);<span class="comment">//热更新相关</span></span><br><span class="line">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span> (pop)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><code>IMPLEMENT_CLASS</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_CLASS(TClass, TClassCrc) \</span></span><br><span class="line"><span class="meta">	static TClassCompiledInDefer<span class="meta-string">&lt;TClass&gt;</span> AutoInitialize##TClass(TEXT(#TClass), sizeof(TClass), TClassCrc); \</span></span><br><span class="line"><span class="meta">	UClass* TClass::GetPrivateStaticClass() \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		static UClass* PrivateStaticClass = NULL; \</span></span><br><span class="line"><span class="meta">		<span class="meta-keyword">if</span> (!PrivateStaticClass) \</span></span><br><span class="line"><span class="meta">		&#123; \</span></span><br><span class="line"><span class="meta">			<span class="comment">/* this could be handled with templates, but we want it external to avoid code bloat */</span> \</span></span><br><span class="line"><span class="meta">			GetPrivateStaticClassBody( \</span></span><br><span class="line"><span class="meta">				StaticPackage(), \ <span class="comment">//Package名字</span></span></span><br><span class="line">				(TCHAR*)<span class="built_in">TEXT</span>(#TClass) + <span class="number">1</span> + ((StaticClassFlags &amp; CLASS_Deprecated) ? <span class="number">11</span> : <span class="number">0</span>), \</span><br><span class="line">				PrivateStaticClass, \<span class="comment">//输出引用</span></span><br><span class="line">				StaticRegisterNatives##TClass, \</span><br><span class="line">				<span class="built_in"><span class="keyword">sizeof</span></span>(TClass), \</span><br><span class="line">				<span class="built_in"><span class="keyword">alignof</span></span>(TClass), \</span><br><span class="line">				(EClassFlags)TClass::StaticClassFlags, \</span><br><span class="line">				TClass::<span class="built_in">StaticClassCastFlags</span>(), \</span><br><span class="line">				TClass::<span class="built_in">StaticConfigName</span>(), \</span><br><span class="line">				(UClass::ClassConstructorType)InternalConstructor&lt;TClass&gt;, \</span><br><span class="line">				(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller&lt;TClass&gt;, \</span><br><span class="line">				&amp;TClass::AddReferencedObjects, \</span><br><span class="line">				&amp;TClass::Super::StaticClass, \</span><br><span class="line">				&amp;TClass::WithinClass::StaticClass \</span><br><span class="line">			); \</span><br><span class="line">		&#125; \</span><br><span class="line">		<span class="keyword">return</span> PrivateStaticClass; \</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>目的是把该类的信息传进去给<code>GetPrivateStaticClassBody</code>函数，该函数真正创建<code>UClass*</code></p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="UPROPERTY-UFUNCTION"><a href="#UPROPERTY-UFUNCTION" class="headerlink" title="UPROPERTY,UFUNCTION"></a>UPROPERTY,UFUNCTION</h3><blockquote>
<p>在<code>ByeWorld</code>里加入属性和函数</p>
</blockquote>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">int32 number=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BP_Callable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BP_Native</span><span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BP_Implemetable</span><span class="params">(<span class="keyword">const</span> FString&amp; str,int32 id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对比两文件以后，发生改变的地方如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_ByeWorld_h_12_RPC_WRAPPERS \</span></span><br><span class="line"><span class="meta">	virtual void BP_Native_Implementation(float value); \</span></span><br><span class="line"><span class="meta"> \</span></span><br><span class="line"><span class="meta">	DECLARE_FUNCTION(execBP_Native) \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		P_GET_PROPERTY(UFloatProperty,Z_Param_value); \</span></span><br><span class="line"><span class="meta">		P_FINISH; \</span></span><br><span class="line"><span class="meta">		P_NATIVE_BEGIN; \</span></span><br><span class="line"><span class="meta">		P_THIS-&gt;BP_Native_Implementation(Z_Param_value); \</span></span><br><span class="line"><span class="meta">		P_NATIVE_END; \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta"> \</span></span><br><span class="line"><span class="meta">	DECLARE_FUNCTION(execBP_Callable) \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		P_FINISH; \</span></span><br><span class="line"><span class="meta">		P_NATIVE_BEGIN; \</span></span><br><span class="line"><span class="meta">		P_THIS-&gt;BP_Callable(); \</span></span><br><span class="line"><span class="meta">		P_NATIVE_END; \</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_ByeWorld_h_12_RPC_WRAPPERS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">	virtual void BP_Native_Implementation(float value); \</span></span><br><span class="line"><span class="meta"> \</span></span><br><span class="line"><span class="meta">	DECLARE_FUNCTION(execBP_Native) \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		P_GET_PROPERTY(UFloatProperty,Z_Param_value); \</span></span><br><span class="line"><span class="meta">		P_FINISH; \</span></span><br><span class="line"><span class="meta">		P_NATIVE_BEGIN; \</span></span><br><span class="line"><span class="meta">		P_THIS-&gt;BP_Native_Implementation(Z_Param_value); \</span></span><br><span class="line"><span class="meta">		P_NATIVE_END; \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta"> \</span></span><br><span class="line"><span class="meta">	DECLARE_FUNCTION(execBP_Callable) \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		P_FINISH; \</span></span><br><span class="line"><span class="meta">		P_NATIVE_BEGIN; \</span></span><br><span class="line"><span class="meta">		P_THIS-&gt;BP_Callable(); \</span></span><br><span class="line"><span class="meta">		P_NATIVE_END; \</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AdvanceFunc_Source_AdvanceFunc_Public_ByeWorld_h_12_EVENT_PARMS \</span></span><br><span class="line"><span class="meta">	struct ByeWorld_eventBP_Implemetable_Parms \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		FString str; \</span></span><br><span class="line"><span class="meta">		int32 id; \</span></span><br><span class="line"><span class="meta">		bool ReturnValue; \</span></span><br><span class="line"><span class="meta"> \</span></span><br><span class="line"><span class="meta">		<span class="comment">/** Constructor, initializes return property only **/</span> \</span></span><br><span class="line"><span class="meta">		ByeWorld_eventBP_Implemetable_Parms() \</span></span><br><span class="line"><span class="meta">			: ReturnValue(false) \</span></span><br><span class="line"><span class="meta">		&#123; \</span></span><br><span class="line"><span class="meta">		&#125; \</span></span><br><span class="line"><span class="meta">	&#125;; \</span></span><br><span class="line"><span class="meta">	struct ByeWorld_eventBP_Native_Parms \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		float value; \</span></span><br><span class="line"><span class="meta">	&#125;;</span></span><br></pre></td></tr></table></figure>

<p>源于蓝图虚拟机的约定，蓝图调用的函数前面会加上<code>exec</code></p>
<ul>
<li>.generated.cpp</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="function">ADVANCEFUNC_API UFunction* <span class="title">Z_Construct_UFunction_AByeWorld_BP_Callable</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">ADVANCEFUNC_API UFunction* <span class="title">Z_Construct_UFunction_AByeWorld_BP_Implemetable</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">ADVANCEFUNC_API UFunction* <span class="title">Z_Construct_UFunction_AByeWorld_BP_Native</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//............</span></span><br><span class="line"><span class="comment">//函数名字定义</span></span><br><span class="line">	<span class="keyword">static</span> FName NAME_AByeWorld_BP_Implemetable = <span class="built_in">FName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;BP_Implemetable&quot;</span>));</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">AByeWorld::BP_Implemetable</span><span class="params">(<span class="keyword">const</span> FString&amp; str, int32 id)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ByeWorld_eventBP_Implemetable_Parms Parms;</span><br><span class="line">		Parms.str=str;</span><br><span class="line">		Parms.id=id;</span><br><span class="line">		<span class="built_in">ProcessEvent</span>(<span class="built_in">FindFunctionChecked</span>(NAME_AByeWorld_BP_Implemetable),&amp;Parms);</span><br><span class="line">		<span class="keyword">return</span> !!Parms.ReturnValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> FName NAME_AByeWorld_BP_Native = <span class="built_in">FName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;BP_Native&quot;</span>));</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AByeWorld::BP_Native</span><span class="params">(<span class="keyword">float</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ByeWorld_eventBP_Native_Parms Parms;</span><br><span class="line">		Parms.value=value;</span><br><span class="line">		<span class="built_in">ProcessEvent</span>(<span class="built_in">FindFunctionChecked</span>(NAME_AByeWorld_BP_Native),&amp;Parms);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//注册函数名字和函数指针映射，其他2个函数类同</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AByeWorld::StaticRegisterNativesAByeWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		UClass* Class = AByeWorld::<span class="built_in">StaticClass</span>();</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> FNameNativePtrPair Funcs[] = &#123;</span><br><span class="line">			&#123; <span class="string">&quot;BP_Callable&quot;</span>, &amp;AByeWorld::execBP_Callable &#125;,</span><br><span class="line">			&#123; <span class="string">&quot;BP_Native&quot;</span>, &amp;AByeWorld::execBP_Native &#125;,</span><br><span class="line">		&#125;;</span><br><span class="line">		FNativeFunctionRegistrar::<span class="built_in">RegisterFunctions</span>(Class, Funcs, <span class="built_in">UE_ARRAY_COUNT</span>(Funcs));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//对应函数所有反射信息，其他类同</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Z_Construct_UFunction_AByeWorld_BP_Callable_Statics</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_METADATA</span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> UE4CodeGen_Private::FFunctionParams FuncParams;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_METADATA</span></span><br><span class="line">	<span class="keyword">const</span> UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AByeWorld_BP_Callable_Statics::Function_MetaDataParams[] = &#123;</span><br><span class="line">		&#123; <span class="string">&quot;ModuleRelativePath&quot;</span>, <span class="string">&quot;Public/ByeWorld.h&quot;</span> &#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">const</span> UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AByeWorld_BP_Callable_Statics::FuncParams = &#123; (UObject*(*)())Z_Construct_UClass_AByeWorld, <span class="literal">nullptr</span>, <span class="string">&quot;BP_Callable&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, RF_Public|RF_Transient|RF_MarkAsNative, (EFunctionFlags)<span class="number">0x04020401</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">METADATA_PARAMS</span>(Z_Construct_UFunction_AByeWorld_BP_Callable_Statics::Function_MetaDataParams, <span class="built_in">UE_ARRAY_COUNT</span>(Z_Construct_UFunction_AByeWorld_BP_Callable_Statics::Function_MetaDataParams)) &#125;;</span><br><span class="line">	<span class="function">UFunction* <span class="title">Z_Construct_UFunction_AByeWorld_BP_Callable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">static</span> UFunction* ReturnFunction = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">if</span> (!ReturnFunction)</span><br><span class="line">		&#123;</span><br><span class="line">			UE4CodeGen_Private::<span class="built_in">ConstructUFunction</span>(ReturnFunction, Z_Construct_UFunction_AByeWorld_BP_Callable_Statics::FuncParams);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ReturnFunction;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//......................</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Z_Construct_UClass_AByeWorld_Statics</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">static</span> UObject* (*<span class="keyword">const</span> DependentSingletons[])();</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> FClassFunctionLinkInfo FuncInfo[];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_METADATA</span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_METADATA</span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> UE4CodeGen_Private::FMetaDataPairParam NewProp_number_MetaData[];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> UE4CodeGen_Private::FIntPropertyParams NewProp_number;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> UE4CodeGen_Private::FPropertyParamsBase* <span class="keyword">const</span> PropPointers[];</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> FCppClassTypeInfoStatic StaticCppClassTypeInfo;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> UE4CodeGen_Private::FClassParams ClassParams;</span><br><span class="line">	&#125;;</span><br><span class="line">	UObject* (*<span class="keyword">const</span> Z_Construct_UClass_AByeWorld_Statics::DependentSingletons[])() = &#123;</span><br><span class="line">		(UObject* (*)())Z_Construct_UClass_AActor,</span><br><span class="line">		(UObject* (*)())Z_Construct_UPackage__Script_AdvanceFunc,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">const</span> FClassFunctionLinkInfo Z_Construct_UClass_AByeWorld_Statics::FuncInfo[] = &#123;</span><br><span class="line">		&#123; &amp;Z_Construct_UFunction_AByeWorld_BP_Callable, <span class="string">&quot;BP_Callable&quot;</span> &#125;, <span class="comment">// 2843195228</span></span><br><span class="line">		&#123; &amp;Z_Construct_UFunction_AByeWorld_BP_Implemetable, <span class="string">&quot;BP_Implemetable&quot;</span> &#125;, <span class="comment">// 3962882496</span></span><br><span class="line">		&#123; &amp;Z_Construct_UFunction_AByeWorld_BP_Native, <span class="string">&quot;BP_Native&quot;</span> &#125;, <span class="comment">// 1595191378</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//定义UPROPERTY反射数据，（如果是TMap会有3条，本身，键，值）</span></span><br><span class="line">	<span class="keyword">const</span> UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_AByeWorld_Statics::NewProp_number = &#123; <span class="string">&quot;number&quot;</span>, <span class="literal">nullptr</span>, (EPropertyFlags)<span class="number">0x0010000000000004</span>, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, <span class="number">1</span>, <span class="built_in">STRUCT_OFFSET</span>(AByeWorld, number), <span class="built_in">METADATA_PARAMS</span>(Z_Construct_UClass_AByeWorld_Statics::NewProp_number_MetaData, <span class="built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_AByeWorld_Statics::NewProp_number_MetaData)) &#125;;</span><br><span class="line"><span class="comment">//把所有属性加入这个数组，然后放入类的反射数据</span></span><br><span class="line">	<span class="keyword">const</span> UE4CodeGen_Private::FPropertyParamsBase* <span class="keyword">const</span> Z_Construct_UClass_AByeWorld_Statics::PropPointers[] = &#123;</span><br><span class="line">		(<span class="keyword">const</span> UE4CodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UClass_AByeWorld_Statics::NewProp_number,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">const</span> FCppClassTypeInfoStatic Z_Construct_UClass_AByeWorld_Statics::StaticCppClassTypeInfo = &#123;</span><br><span class="line">		TCppClassTypeTraits&lt;AByeWorld&gt;::IsAbstract,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">const</span> UE4CodeGen_Private::FClassParams Z_Construct_UClass_AByeWorld_Statics::ClassParams = &#123;</span><br><span class="line">		&amp;AByeWorld::StaticClass,</span><br><span class="line">		<span class="string">&quot;Engine&quot;</span>,</span><br><span class="line">		&amp;StaticCppClassTypeInfo,</span><br><span class="line">		DependentSingletons,</span><br><span class="line">		FuncInfo,</span><br><span class="line">		Z_Construct_UClass_AByeWorld_Statics::PropPointers,</span><br><span class="line">		<span class="literal">nullptr</span>,</span><br><span class="line">		<span class="built_in">UE_ARRAY_COUNT</span>(DependentSingletons),</span><br><span class="line">		<span class="built_in">UE_ARRAY_COUNT</span>(FuncInfo),</span><br><span class="line">		<span class="built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_AByeWorld_Statics::PropPointers),</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="number">0x009000A4</span>u,</span><br><span class="line">		<span class="built_in">METADATA_PARAMS</span>(Z_Construct_UClass_AByeWorld_Statics::Class_MetaDataParams, <span class="built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_AByeWorld_Statics::Class_MetaDataParams))</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//....................</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 总结一下</p>
<p>通过<code>ConstructUFunction</code>把对应的函数反射数据加入到反射系统</p>
<p>然后包括函数和属性等反射数据也加入到UCLASS一起通过<code>ConstructUClass</code>加入到反射系统</p>
<p>即通过类的反射数据可以找到类的所有成员，通过函数的反射数据找到函数的成员</p>
</blockquote>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>反射系统</tag>
      </tags>
  </entry>
  <entry>
    <title>VR框架AdvancedVRFrameworkV3_1分析</title>
    <url>/2020/08/21/VR%E6%A1%86%E6%9E%B6AdvancedVRFrameworkV3_1%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>虚幻商城有一个非常成熟而且有诚意的VR框架，涵盖了基本上VR可以用到的所有主流功能，同时也有PC和移动端的支持。</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/advanced-vr-framework">商城链接</a></p>
<p>趁着项目需求借机分析一下这个框架，后续打算基于此扩展适用于项目的框架</p>
</blockquote>
<h3 id="分析记录"><a href="#分析记录" class="headerlink" title="分析记录"></a>分析记录</h3><blockquote>
<p>2020.8.21:</p>
<p>1.纯蓝图+组件的思路搭建，使用起来不算麻烦也不能算太方便，学习成本还是有的</p>
<p>2.解耦做的不是特别的好，很多类之间有强依赖，少一个就报错</p>
<p>3.功能做的非常完善，该有的基本的有了</p>
<p>4.性能无实测，但是各类组件无脑Tick初步看有性能压力</p>
<p>5.部分内容比如地图、边缘发光、武器/弓箭交互等单独拎出来都是非常实用的功能</p>
</blockquote>
<h3 id="关卡管理"><a href="#关卡管理" class="headerlink" title="关卡管理"></a>关卡管理</h3><h5 id="必要元素"><a href="#必要元素" class="headerlink" title="必要元素"></a>必要元素</h5><ul>
<li>GameMode</li>
<li>BP_Info_Map</li>
<li>BP_Info_Level</li>
<li>BP_PostProcess</li>
<li>BP_PlayerPostion</li>
</ul>
<p>以上的这些都可以用<code>EU_Widget</code>来生成</p>
<p><img src="https://img.supervj.top/img/gitlab/image-20200820111916928.png" alt="image-20200820111916928"></p>
<h5 id="BP-MapInfo"><a href="#BP-MapInfo" class="headerlink" title="BP_MapInfo"></a>BP_MapInfo</h5><p>放置在场景中的具体对象，主要就是为了配置<code>Info_Level</code>，在<code>BP_GameInstance_Main</code>类中直接通过方法<code>GetCurrentLevelClass</code>从此对象去要到<code>Info_Level</code></p>
<h5 id="Info-Level"><a href="#Info-Level" class="headerlink" title="Info_Level"></a>Info_Level</h5><h6 id="Streaming-Level"><a href="#Streaming-Level" class="headerlink" title="Streaming Level"></a>Streaming Level</h6><p>用于加载子关卡，比如当前关卡是TestMainMap,LevelsToLoad设置为TestMap01，那么在进入TestMainMap后会自动加载TestMap01</p>
<h6 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h6><p>切换关卡的选项，首先设置时间变量，如果是0就是瞬间加载，可以设置天空球贴图和背景色</p>
<h6 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a>Panel</h6><p>关卡面板的UI布局信息，可以参考demo演示的布局，见下图</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200820135730829.png" alt="image-20200820135730829"></p>
<h6 id="key"><a href="#key" class="headerlink" title="key"></a>key</h6><p>本地化文字有关的一个变量，此框架是用表格的方式设置本地化。</p>
<p>此变量作为DataTable的RowName读取表格</p>
<h6 id="pawn"><a href="#pawn" class="headerlink" title="pawn"></a>pawn</h6><p>对应平台的pawn设置</p>
<h6 id="Pallet"><a href="#Pallet" class="headerlink" title="Pallet"></a>Pallet</h6><p>LevelImage变量决定关卡在Map面板下的显示图片，如下图</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200820140512683.png" alt="image-20200820140512683"></p>
<h5 id="BP-PostProcess"><a href="#BP-PostProcess" class="headerlink" title="BP_PostProcess"></a>BP_PostProcess</h5><p>维护后期效果的类，主要目的是用于高光显示，当然高光显示还有其他几个方式，只是后期方式效果比较好</p>
<h5 id="BP-PlayerPostion"><a href="#BP-PlayerPostion" class="headerlink" title="BP_PlayerPostion"></a>BP_PlayerPostion</h5><p>玩家起始位置，内部主要实现了一个传送玩家并校准位置的方法</p>
<h3 id="VR玩家配置"><a href="#VR玩家配置" class="headerlink" title="VR玩家配置"></a>VR玩家配置</h3><p>VR玩家需要继承自<code>BP_Pawn_VR</code>或者<code>BP_Pawn_VR_Char</code>,区别在于后者提供了一个半身小白人模型</p>
<h5 id="Comp-Controller-VR"><a href="#Comp-Controller-VR" class="headerlink" title="Comp_Controller_VR"></a>Comp_Controller_VR</h5><ul>
<li>Controller Set</li>
</ul>
<p>自定义对应<code>MotionController</code>的类，框架给的<code>BP_MotionController_Hands</code>内通过4个<code>ChildrenActor</code>分别实现模型、传送、菜单、移动功能，具体功能类如下</p>
<ul>
<li>BP_MComp_Teleport：传送功能，以及传送效果的一些参数配置</li>
<li>BP_MComp_Hand：手模型以及动画，提供一些抓取等参数的设置</li>
<li>BP_MComp_Controller：控制器模型，代替手</li>
<li>BP_MComp_RadialMenu：菜单功能</li>
<li>BP_MComp_Movement：移动功能</li>
<li>BP_MComp_Trigger：单纯用于监听按键事件的组件，可以用来扩展输入事件</li>
<li>BP_MComp_Laser：射线功能组件，提供一些射线相关参数配置</li>
<li>BP_MComp_Smartwatch：手表菜单组件，需要配置相应UMG</li>
</ul>
<p>如果设置了<code>Controller Mesh Override</code>，就会用相应的模型覆盖上面设置的模型</p>
<ul>
<li>ControlsPresets</li>
</ul>
<p>对应平台的按键映射</p>
<ul>
<li>Haptics<ul>
<li>HapticsForSelect:在点开Select选单时手柄震动</li>
<li>HapticsForDevices:在与工具类型的道具交互时手柄震动</li>
<li>HapticsForGrab:在触发Grab时手柄震动</li>
<li>HapticsForTrigger:在各种操作触发触发器需要修改set值时手柄震动</li>
</ul>
</li>
</ul>
<h6 id="Teleport-传送"><a href="#Teleport-传送" class="headerlink" title="Teleport/传送"></a>Teleport/传送</h6><ul>
<li><img src="https://img.supervj.top/img/advVR/image-20200820142920984.png" alt="image-20200820142920984"></li>
<li>Teleport Mode:配置不同的传送交互类型<ul>
<li>TeleportFree:传送到射线所指定的位置,但是在Z轴normal值小于30度的情况下不允许传送</li>
<li>TeleportAreaSelect：激活Teleport出现网格,触发手柄上的select操作进行传送,传送后网格消失</li>
<li>TeleportAreaActive：手柄指向地面时出现网格,激活Teleport即传送</li>
<li>Nav Mesh:在寻路网格可达的范围内进行传送,交互与TeleportFree类似,但是取消了30度的角度判断</li>
</ul>
</li>
<li>Teleport Search Type:用于传送的射线类型<ul>
<li>Straight:直线射线指向</li>
<li>Projectile:抛物线射线指向</li>
</ul>
</li>
<li>Teleport Time:传送所花费的总时间</li>
<li>Use Teleport Motion:设定传送的过渡类型<ul>
<li>None:没有过渡态,直接传送到目标点</li>
<li>Indication:location具有过渡态,逐步过渡到目标点</li>
<li>FullMotion:location与rotation都具有过渡态,位置过渡到目标点且角色的rotation过渡到目标rotation</li>
</ul>
</li>
</ul>
<p>在配置按键映射的DataAssets内相关的teleport选项</p>
<ul>
<li>Teleport Execute:传送触发的条件<ul>
<li>OnTrigger:trigger按键按到底触发</li>
<li>OnThumbstickRelease:thumbstick按下并松开时(通过thumbstick来转向时比较好用)</li>
<li>OnTeleportButtonRelease:上面注册的Teleport按钮被按下并松开时</li>
</ul>
</li>
<li>Teleport Deactivate:传送取消的条件<ul>
<li>OnlyExecute:只允许被触发不允许取消</li>
<li>NeutralThumbstick:trackpad中键取消传送</li>
</ul>
</li>
<li>TeleportRotationType:传送时的面向操控<ul>
<li>None:无法转向</li>
<li>RotateByThumbstick:通过trackpad来操作传送时的方向</li>
<li>RotateByHand:通过手的转向来操作传送时的方向</li>
</ul>
</li>
</ul>
<h6 id="Movement-移动"><a href="#Movement-移动" class="headerlink" title="Movement/移动"></a>Movement/移动</h6><p><img src="https://img.supervj.top/img/advVR/image-20200820143452130.png" alt="image-20200820143452130"></p>
<ul>
<li>Movement Style:移动的方式<ul>
<li>Fluent:在地面上以固定速度移动</li>
<li>StopMotion:当walk的按钮按下后产生一个ghost,然后移动固定秒后瞬移到ghost的位置,若提前松开则取消移动,最多两秒</li>
<li>Ghost:当walk的按钮按下后产生一个ghost,松开则瞬移到ghost的位置</li>
</ul>
</li>
<li>Ghost Behaviour:Ghost的位移操作形式配置<ul>
<li>Direction:通过手柄的方向来操作ghost移动的方向与速度</li>
<li>MovementRelativeToOrigin:通过按下walk按钮时的初始位置来计算后续的相对偏移量来操作ghost的移动,非常难用</li>
<li>PositionRelativeToOrigin:按下按钮后通过手柄的移动距离来移动ghost的位置,通过手柄的方向来改变ghost的朝向</li>
</ul>
</li>
<li>Stop Motion Interval:用于配置StopMotion的固定秒数时间,大于2秒也会被设置成2秒</li>
<li>Movement Speed:ghost移动的速度</li>
<li>Move with Fade:瞬移时是否允许黑屏过渡</li>
</ul>
<h6 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h6><p><code>RotateDerees</code>:对应按键映射中的<code>TurnLeft</code>和<code>TurnRight</code>的转向角度</p>
<h6 id="按键映射补充"><a href="#按键映射补充" class="headerlink" title="按键映射补充"></a>按键映射补充</h6><ul>
<li>Trigger Grip:是否允许长按select的按钮来触发grip(默认是0.4秒,可以通过BP_MCmop_Laser中的Handle Trigger来修改长按间隔)</li>
<li>Holding Grip:是否允许按下按钮抓取,松开按钮放开,或者为单次按下抓取,抓取状态下再次按下松开</li>
</ul>
<h6 id="关于按键的自定义"><a href="#关于按键的自定义" class="headerlink" title="关于按键的自定义"></a>关于按键的自定义</h6><p>按键的起始点在Pawn内，如下截图</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200820145557962.png" alt="image-20200820145557962"></p>
<p>调用到<code>BP_MotionController</code>内的方法<code>KeyInput</code>，然后遍历调用所有<code>BP_MComp</code>组件的方法<code>FunctionInput</code>,然后继承自<code>BP_MComp</code>的组件各自实现/重写按键对应的逻辑，一般可以用一个Switch来做</p>
<p>如需要添加自定义按键事件，修改枚举<code>Enum_Control_Function</code>即可</p>
<h5 id="Comp-RadialMenu"><a href="#Comp-RadialMenu" class="headerlink" title="Comp_RadialMenu"></a>Comp_RadialMenu</h5><p><img src="https://img.supervj.top/img/advVR/image-20200820150244981.png" alt="image-20200820150244981"></p>
<p>如图所示，框架默认给予2个RadialMenu事件，分别可以设置2个面板，</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200820150349447.png" alt="image-20200820150349447"></p>
<h5 id="Comp-UI-Display"><a href="#Comp-UI-Display" class="headerlink" title="Comp_UI_Display"></a>Comp_UI_Display</h5><p><img src="https://img.supervj.top/img/advVR/image-20200820150423064.png" alt="image-20200820150423064"></p>
<p><img src="https://img.supervj.top/img/advVR/image-20200820150455057.png" alt="image-20200820150455057"></p>
<p>如图所示，手部内测的面板，通过设置该组件配置</p>
<h5 id="Comp-UI-Pallet"><a href="#Comp-UI-Pallet" class="headerlink" title="Comp_UI_Pallet"></a>Comp_UI_Pallet</h5><p>一个次级面板，在RadiaMenu面板中如果指定了对应的类就可以触发此面板，比如指定了<code>BP_Radial_Button_Pallet_Bookmarks</code>，在此组件内就可以配置相应的Bookmarks内容</p>
<p>此组件又非常多的功能，之后逐步细讲</p>
<h3 id="DataAssets"><a href="#DataAssets" class="headerlink" title="DataAssets"></a>DataAssets</h3><p>首先要回顾一下<code>Info_Level</code>类中有一个<code>ActorInfos</code>列表，需要在里面添加所有需要用到的表</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200820164521985.png" alt="image-20200820164521985"></p>
<p>如上图所示，我们需要的DA_Test资源需要从<code>PDA_ActorList</code>创建，此类是继承自<code>PrimaryDataAsset</code>的蓝图类，内部就是创建了一系列变量；然后把这个资源放入<code>Info_Level</code>内</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200820165040854.png" alt="image-20200820165040854"></p>
<p>然后我们右键自建蓝图类,<code>CreateDatatableEntry</code>，主要选择标签和<code>ActorList</code>,创建后自动生成基础的DataAsset，即可添加到之前创建的<code>DA_Test</code>    内</p>
<p>然后我们以<code>Map_Demo_UI</code>关卡做测试，找到类<code>BP_Pallet_ObjectDropper</code>的<code>Comp_UI_Pallet</code>组件，配置如下</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200820165341595.png" alt="image-20200820165341595"></p>
<p>运行以后就得到如下结果</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200820165410975.png" alt="image-20200820165410975"></p>
<h3 id="Comp-Select"><a href="#Comp-Select" class="headerlink" title="Comp_Select"></a>Comp_Select</h3><p>关于选择的组件，比较基础也比较有用</p>
<p>对于VR玩家，默认使用<code>Trigger</code>按键类出发select功能</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200820172012396.png" alt="image-20200820172012396"></p>
<ul>
<li>SelectMenu</li>
</ul>
<p>对应上面的变量<code>SelctionTypes</code>，点击以后就自动生成按钮</p>
<ul>
<li>Custom</li>
</ul>
<p>自定义<code>PressSelect</code>事件就可以</p>
<ul>
<li>Trigger</li>
</ul>
<p>需要配合组件<code>Comp_ListenToTrigger</code> 使用，点击以后<code>Comp_ListenToTrigger::TriggerSingle</code>能执行 </p>
<p>可以设置<code>ActorsToTrigger</code>变量来让其他类收到Listen消息</p>
<p>设置<code>ComponentTagToSearch</code>可以对类内的不同模型进行筛选</p>
<ul>
<li>window</li>
</ul>
<p>详情请看后面的<code>Comp_WindowObject</code></p>
<ul>
<li>visual</li>
</ul>
<p>配置请看后面的<code>Comp_Visual</code>，区别于<code>SelectMenu+VisualChange</code>的组合，如果直接指定<code>Visual</code>则是直接切换，无菜单提示</p>
<ul>
<li>light</li>
</ul>
<p>配合光源和Light组件一起使用</p>
<ul>
<li>open</li>
</ul>
<p>详情请看后面的<code>Comp_Open</code></p>
<ul>
<li>active</li>
</ul>
<p>详情请看后面的<code>Comp_Active</code></p>
<h3 id="Comp-Drag"><a href="#Comp-Drag" class="headerlink" title="Comp_Drag"></a>Comp_Drag</h3><p>拖拽组件，可以平移和旋转拖拽，一般需要配合<code>Latch</code>组件来使用</p>
<h5 id="变量解释"><a href="#变量解释" class="headerlink" title="变量解释"></a>变量解释</h5><ul>
<li>identifier:组件之间交互的名称，如果类内有多个Drag组件就需要区分不同的名称<h6 id="DragType-拖动规则"><a href="#DragType-拖动规则" class="headerlink" title="DragType:拖动规则"></a>DragType:拖动规则</h6><ul>
<li>key:具体规则，如变量名称描述的含义</li>
<li>value<ul>
<li>SnapType:吸附规则<ul>
<li>FreeMovement:自由移动</li>
<li>SnapToSegment:吸附到最近的分段，即下面的sectionSet分段</li>
<li>Reset:重置为初始状态</li>
</ul>
</li>
<li>StartPositon:初始位置</li>
<li>SnappingSpeed:吸附速度</li>
<li>FollowSpeed:跟随速度</li>
<li>SelectRule:取值方式，3个选项以此为四舍五入，ceil，floor</li>
<li>Toggle:强制设定每次到达极值时的set变量为上次的反向值</li>
</ul>
</li>
</ul>
</li>
<li>SectionSet:分段极值设定</li>
<li>TriggerAlsoOwner:通知owner</li>
<li>ComponentTagToSearch:需要拖动的mesh需要加上该标签</li>
</ul>
<h5 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h5><ul>
<li><p>在被拖动的模型中加入插槽<code>AttachPoint</code>来指定交互点</p>
</li>
<li><p>确保交互模型可以被射线检测到</p>
</li>
<li><p>挂上<code>Comp_Drag</code>,然后需要配合<code>Comp_Latch</code>使用，该组件可以使用默认值</p>
</li>
<li><p>在交互模型中加入以上2个组件所需要的tag,默认为<code>Drag,Latch</code></p>
</li>
<li><p>可以配合<code>Comp_ListenToServer</code>使用，可以监听每次到达极值的时间，或者Tick的Drag事件</p>
</li>
<li><p>同一个类下可以挂载多个Drag组件来拖动不同的模型组件，记得修改<code>identifier</code>和<code>ComponentTagToSearch</code>,也需要修改Latch组件的<code>ComponentTagToSearch</code>变量，也不要忘记区分不同模型的Tag</p>
</li>
<li><p>如果是spline模式，在类内创建一个spline组件</p>
</li>
</ul>
<hr>
<h3 id="Comp-Grab"><a href="#Comp-Grab" class="headerlink" title="Comp_Grab"></a>Comp_Grab</h3><p>抓取组件，对于VR玩家可以有射线和接触抓取两种方式，不过具体的功能会有区别，见下图</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821095808183.png" alt="image-20200821095808183"></p>
<h5 id="变量解释-1"><a href="#变量解释-1" class="headerlink" title="变量解释"></a>变量解释</h5><ul>
<li>GrabType:是否在抓取后模拟物理，利用的是<code>PhysicsHandle</code>的抓取机制，一般的需要把模型放到root位置</li>
<li>SnappingType:取消抓取后吸附的过程是否开启物理模拟</li>
<li>ShouldKeepUpright:在抓取后是否保持世界坐标正前方</li>
<li>ShouldAutoPickup:VR模式下手部接触以后直接抓取</li>
<li>CanBePickedUp:是否可以被抓取</li>
<li>SnapAndReplaceControlls:抓取之后替换手柄预设的所有操作，直到release为止，之后手柄的操作可以映射到组件的<code>KeyInput</code>和<code>Thumbsticks</code>方法中</li>
<li>RelativeControllerPostion:抓取以后的相对位置校准</li>
<li>MaxDistanceToSocket:最大抓取距离(距离socket)</li>
<li>SpawnTinyDisplay:抓取以后生成小提示面板，需要用DA去配置，同样的只支持VR射线模式</li>
<li>GrabAttachedActorInstead:决定是否抓取此物体时替换掉之前抓取的物体</li>
<li>GrabTag:默认抓取类中的所有物体，可以用此标签区分</li>
</ul>
<h3 id="Comp-Connector-Surface"><a href="#Comp-Connector-Surface" class="headerlink" title="Comp_Connector_Surface"></a>Comp_Connector_Surface</h3><p>配合Grab组件一起使用，目的是</p>
<ul>
<li>RotateOnSurface:决定如何旋转，是否垂直墙面等</li>
<li>ShouldBeActiveEvenIfPhysics:如果开启物理模拟，就需要开启此选项，防止过多碰撞挤压</li>
<li>AllowPhysicsAfterSnap：此物体吸附到平面后是否启用物理模拟</li>
<li>RequiresTag:对吸附的平面做tag判断</li>
<li>SearchDistance：吸附距离</li>
</ul>
<blockquote>
<p> 需要特别注意的是，需要设置此组件的朝向问题，默认是X轴检测</p>
</blockquote>
<h3 id="Comp-Anchor-Comp-Connect-Anchor"><a href="#Comp-Anchor-Comp-Connect-Anchor" class="headerlink" title="Comp_Anchor/Comp_Connect_Anchor"></a>Comp_Anchor/Comp_Connect_Anchor</h3><p>特殊的吸附配套组件，后者吸附到前者</p>
<h5 id="Comp-Anchor"><a href="#Comp-Anchor" class="headerlink" title="Comp_Anchor"></a>Comp_Anchor</h5><p><img src="https://img.supervj.top/img/advVR/image-20200821170439723.png" alt="image-20200821170439723"></p>
<ul>
<li>Anchor_Deactived:关闭吸附效果</li>
<li>Allow_Physics:吸附后启用物理</li>
<li>Connect_IDs_To_Allow:需要与配套组件对应的ID</li>
<li>Connect_Should_Attach:子物体吸附到此物体后是否attach</li>
<li>Sphere_Radius:查找半径</li>
<li>Attached_Lock:吸附以后锁定，即不能再交互</li>
</ul>
<h5 id="Comp-Connect-Anchor"><a href="#Comp-Connect-Anchor" class="headerlink" title="Comp_Connect_Anchor"></a>Comp_Connect_Anchor</h5><p><img src="https://img.supervj.top/img/advVR/image-20200821170830375.png" alt="image-20200821170830375"></p>
<ul>
<li>Tag Of Component to Attach:初始时此Actor attach到Attached to Actor下的带有此tag的component中</li>
<li>Attached to Socket:当Attached to Actor不为None,且Tag Of Component to Attach也不为None时,该actor会attach到Tag Of Component to Attach所提到的component中的名为Attached to Socket的socket中,若Attached to Actor不为None,但是Tag Of Component to Attach为None时,此Actor会attach根组件下名为Attached to Socket的socket上,若没有则会attach到Attached to Actor的根组件下</li>
<li>ConnectorID：与配套组件对应的ID</li>
<li>SearchRadius: 查找半径</li>
<li>SearchDistance:判断连接时的球形射线距离组件原点的距离</li>
</ul>
<p>最终效果</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821171243617.png" alt="image-20200821171243617"></p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821171309985.png" alt="image-20200821171309985"></p>
<h3 id="Comp-Latch"><a href="#Comp-Latch" class="headerlink" title="Comp_Latch"></a>Comp_Latch</h3><p>在之前Grab组件中已经有用到，主要作用是用来锁定位置</p>
<p>主要设置就是<code>LatchType</code></p>
<ul>
<li>Drag:对应的是就是抓取</li>
<li>SimpleLatch:简单的吸附，不需要配合Grab组件，手靠近以后就自动吸附，针对VR玩家</li>
<li>Climb:攀爬模式，可以用于攀岩类操作，针对VR玩家</li>
</ul>
<h3 id="Comp-ListenToServer"><a href="#Comp-ListenToServer" class="headerlink" title="Comp_ListenToServer"></a>Comp_ListenToServer</h3><p>除了上面的Grab用到的功能，该组件还有其他作用</p>
<h5 id="Light"><a href="#Light" class="headerlink" title="Light"></a>Light</h5><p>设置为<code>Light</code>模式，需要配合组件<code>Comp_Light</code>使用，在类内需要至少给一个光源，对于多个光源可以一起被作用</p>
<p>测试类如下图</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821105432348.png" alt="image-20200821105432348"></p>
<blockquote>
<p>如果使用<code>ListenToSingle</code>模式那么对于Drag过来的事件按50%作为临界点开关</p>
</blockquote>
<h5 id="Active"><a href="#Active" class="headerlink" title="Active"></a>Active</h5><p>详情请看后面的<code>Comp_Active</code></p>
<h5 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h5><p>详情请看后面的<code>Comp_Open</code></p>
<h5 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h5><p>详情请看后面的<code>Comp_WindowObject</code></p>
<h3 id="Comp-Active"><a href="#Comp-Active" class="headerlink" title="Comp_Active"></a>Comp_Active</h3><p>配合其他可以发送active事件的组件使用，如select.</p>
<p>该组件可以收到事件<code>ActiveStateChanged</code>和<code>ConstActiveStateChanged</code>，自行实现后续的逻辑</p>
<h3 id="Comp-Open"><a href="#Comp-Open" class="headerlink" title="Comp_Open"></a>Comp_Open</h3><p>配合其他可以发送Open事件的组件，比如Select或者Drag组件，来实现移动、旋转或者缩放的操作</p>
<p>需要将key的值对应到交互模型的tag</p>
<p>可以通过Listen组件来监听其他类的事件发送</p>
<h3 id="Comp-Overlap"><a href="#Comp-Overlap" class="headerlink" title="Comp_Overlap"></a>Comp_Overlap</h3><p>一般搭配Drag组件来模拟按钮效果</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821152007053.png" alt="image-20200821152007053"></p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821152143566.png" alt="image-20200821152143566"></p>
<p>如上图所示，绿色模型开启overlap效果，增加tag成员<code>overlap</code>,<code>drag</code></p>
<p>抓取其他物件对绿色部分overlap以后就能模拟按钮效果</p>
<h3 id="Comp-WindowObject"><a href="#Comp-WindowObject" class="headerlink" title="Comp_WindowObject"></a>Comp_WindowObject</h3><p>主要是文字和图片说明的窗口，可以配合Select组件展示</p>
<p>需要注意的是挂载此组件的类必须注册到<code>PDA_Actor_List</code>里面,否则框架没有判空直接报错，具体请看之前<code>Info_level</code>以及<code>Data_Assets</code>内容</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821172837931.png" alt="image-20200821172837931"></p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821172859847.png" alt="image-20200821172859847"></p>
<h3 id="Comp-Visual"><a href="#Comp-Visual" class="headerlink" title="Comp_Visual"></a>Comp_Visual</h3><p>改变外观的组件，一般配合select组件的<code>selectionMenu</code>模式，然后在<code>SelectionTypes</code>内添加<code>VisualChange</code>成员来实现</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821154014085.png" alt="image-20200821154014085"></p>
<ul>
<li>CurrentMaterials:当前的材质类型，对应下面的配置</li>
<li>PossibleMaterials:材质配置表<ul>
<li>Key:材质效果的键</li>
<li>ButtonMaterial/ButtonTexture:按钮的材质和图片</li>
<li>MeshInfo:替换模型的效果<ul>
<li>Key:需要把这个值填写到模型的Tag中去</li>
<li>Value:替换模型的模型和材质效果</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://img.supervj.top/img/advVR/image-20200821154329493.png" alt="image-20200821154329493"></p>
<h3 id="Comp-Widget"><a href="#Comp-Widget" class="headerlink" title="Comp_Widget"></a>Comp_Widget</h3><p>封装了UMG的组件，同时方便于交互</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821160827586.png" alt="image-20200821160827586"></p>
<ul>
<li>UsesRecursiveWidgetSelection:使用框架自定义的UMG交互，如<code>Widget_Button</code></li>
<li>‘UsesWidgetInteractionComponent：使用默认UMG空间交互，如<code>Button</code></li>
</ul>
<h5 id="UsesRecursiveWidgetSelection"><a href="#UsesRecursiveWidgetSelection" class="headerlink" title="UsesRecursiveWidgetSelection"></a>UsesRecursiveWidgetSelection</h5><p>我们创建一个继承自<code>Widget_Pallet_Button_Normal</code>的UMG，直接放入测试UMG中，监听<code>Pressed</code>事件即可得到点击事件</p>
<h5 id="UsesWidgetInteractionComponent"><a href="#UsesWidgetInteractionComponent" class="headerlink" title="UsesWidgetInteractionComponent"></a>UsesWidgetInteractionComponent</h5><p>创建一个Button，点击交互后就可以走到<code>Pressed</code>事件</p>
<blockquote>
<p> 要注意<code>Clicked</code>事件无效</p>
</blockquote>
<h3 id="框架UMG类"><a href="#框架UMG类" class="headerlink" title="框架UMG类"></a>框架UMG类</h3><blockquote>
<p>待补充….</p>
</blockquote>
<hr>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>小地图的使用，分为2D和3D两种模式</p>
<p>在需要显示在地图上的类中需要挂载组件<code>Comp_MapLocation</code></p>
<p>设置Icon及尺寸，以及是否支持旋转缩放等选项</p>
<p>SubstitueMaterial可以用来覆盖原有材质，让物体在小地图里显示特殊材质</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200821112246681.png" alt="image-20200821112246681"></p>
<p>然后需要若干个地面，用框架中的类<code>BP_Floorplanmeasurement</code></p>
<p>指定贴图，该贴图最好跟场景的样貌匹配，给定FloorName,用于显示在面板上的名称</p>
<h5 id="2DMap"><a href="#2DMap" class="headerlink" title="2DMap"></a>2DMap</h5><p>使用类<code>BP_2DMap</code>，直接拖入场景中即可，记得设置<code>InitTab</code></p>
<h5 id="3DMap"><a href="#3DMap" class="headerlink" title="3DMap"></a>3DMap</h5><p>使用类<code>BP_3DMap</code>,拖入场景中以后需要给与变量<code>Measurement</code>一个地面单位即可显示3D地形；</p>
<p>或者直接使用<code>Comp_Child_3DMap</code>也是一样的，记得把地形的缩放拷贝到这个类的缩放中，不然会导致变形</p>
]]></content>
      <categories>
        <category>VR</category>
      </categories>
      <tags>
        <tag>VR</tag>
      </tags>
  </entry>
  <entry>
    <title>VR:MotionController与插件</title>
    <url>/2022/11/23/VR%EF%BC%9AMotionController%E4%B8%8E%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>VR设备种类繁多, 而且因为OpenXR的推出, 各种设备都有自家版本和OpenXR版本的插件, 当中也有很多差异, 所以本文记录一下开发VR时, MotionController与插件之间的关系</p>
<span id="more"></span>

<p>我们以4.27Plus版本引擎测试, 创建默认的VR模板项目</p>
<p>看到插件页面, 模板统一使用了OpenXR的环境, 像SteamVR和OculusVR都没有开启</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221123161825982.png" alt="image-20221123161825982"></p>
<p>下面具体对比一下当中的差别</p>
<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>设备自家的插件形态各异</p>
<p>OpenXR的设备信息统一成了一直的3个, 即下图中的几个</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221123191715534.png" alt="image-20221123191715534"></p>
<p>从代码中也可以看到</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221123191743054.png" alt="image-20221123191743054"></p>
<p>先看steam家的指虎手柄, 也就是ValveIndex头显配套的手柄的位置信息</p>
<h3 id="Valve-Index"><a href="#Valve-Index" class="headerlink" title="Valve Index"></a>Valve Index</h3><p>先看OpenXR</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221123191627014.png" alt="image-20221123191627014"></p>
<p>Aim的位置在手柄外, 朝向接近于顶部面板的切线方向,</p>
<p> 另外两者都是手柄抓握的地方, 接近于质心的位置</p>
<p>在蓝图里的预览视图内, 如果把OpenXR插件内的预览模型直接拖进去, 那么位置就是我们运行时的位置</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221123192126598.png" alt="image-20221123192126598"></p>
<p>然后是SteamVR的</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//%E5%B1%8F%E5%B9%95%E6%8D%95%E8%8E%B7_2022_11_24_14_55_03_30.png" alt="屏幕捕获_2022_11_24_14_55_03_30"></p>
<p>看一下SteamVR的代码可以看到</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221123203418593.png" alt="image-20221123203418593"></p>
<p>一般, 有用的只有Left和Right</p>
<p>Tracker应该是Vive自己的追踪器设备, 没有条件测试就先略过</p>
<p>按上图中显示, 只有一个位置, 这个质心是在手柄顶部, 这个就不太友善了, 需要做额外的位置匹配</p>
<blockquote>
<p>目前版本的SteamVR控制器位置信息会覆盖掉OpenXR的信息</p>
</blockquote>
<p>不知道V社这么想的……这个位置是干啥的…</p>
<h3 id="HTC-Vive"><a href="#HTC-Vive" class="headerlink" title="HTC Vive"></a>HTC Vive</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//%E5%B1%8F%E5%B9%95%E6%8D%95%E8%8E%B7_2022_11_23_19_36_32_187.png" alt="屏幕捕获_2022_11_23_19_36_32_187"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//%E5%B1%8F%E5%B9%95%E6%8D%95%E8%8E%B7_2022_11_23_20_31_52_682.png" alt="屏幕捕获_2022_11_23_20_31_52_682"></p>
<p>前者是OpenXR的, 后者是SteamVR</p>
<h3 id="Oculus"><a href="#Oculus" class="headerlink" title="Oculus"></a>Oculus</h3><p>Oculus的插件有OculusVR和OculusOpenVR, 目前是2选1的情况, 先看OculusOpenXR</p>
<p>Oculus只有Quest2做测试, Quest比较特别, 如果开启的是OculusOpenXR的话没有办法直接通过引擎编辑器进入VR预览(开OculusVR就可以), 那么只有打包出来看</p>
<p>然后如下图</p>
<p> <img src="https://raw.githubusercontent.com/VJien/img/master//%E5%B1%8F%E5%B9%95%E6%8D%95%E8%8E%B7_2022_11_23_20_12_21_457.png" alt="屏幕捕获_2022_11_23_20_12_21_457"></p>
<p>实际效果与Index很接近, 但是遇到了一个可能是渲染Bug, 左眼一切正常, 右眼的Trigger的位置(上图中的球)是有偏差的, 导致上图中的球看上去不正常, 实际测试了一下逻辑是对的, 包括箭头也是正确的</p>
<p>用蓝图预览试图中模拟一下,  效果大概就是打包以后的效果</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221123201930770.png" alt="image-20221123201930770"></p>
<p>然后是Oculus自家的VR,  OculusVR</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//%E5%B1%8F%E5%B9%95%E6%8D%95%E8%8E%B7_2022_11_24_14_29_20_308.png" alt="屏幕捕获_2022_11_24_14_29_20_308"></p>
<p>位置和朝向都跟前者不一样</p>
<p>而且只有一个Left和Right的位置信息, 其他的都没有</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221124144553907.png" alt="image-20221124144553907"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>OpenXR和SteamVR下的HTC Vive和Index按键基本上都能获取到</p>
<p>但是2种环境下, Index的触摸板Trackpad只能检测到Axis的X和Y, 以及Action中的Touch事件, 上下左右4个反向的按下都无法接收(虽然这么小的一个触摸板确实很难保证不误触)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前版本而言,  但从MotionController的角度看(其实还有一些渲染选项问题, 暂略),  似乎SteamVR可以被OpenXR完全取代</p>
<p>但是Oculus这一分支还只能用OculusVR, 毕竟不能每次调试都打包一次. 而且Meta官方建议也是开启OculusVR, 估计是OculusOpenXR还不够完善吧</p>
]]></content>
      <categories>
        <category>VR</category>
      </categories>
      <tags>
        <tag>VR</tag>
      </tags>
  </entry>
  <entry>
    <title>VS中使用UE代码片段</title>
    <url>/2020/12/03/VS%E4%B8%AD%E4%BD%BF%E7%94%A8UE%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
    <content><![CDATA[<p><img src="https://img.supervj.top//img/image-20201203141501722.png" alt="image-20201203141501722"></p>
<p><img src="https://img.supervj.top//img/image-20201203141518954.png" alt="image-20201203141518954"></p>
<p><img src="https://img.supervj.top//img/image-20201203141549721.png" alt="image-20201203141549721"></p>
<p>需要打开源码版引擎,找到目录<code>Engine\Extras\VisualStudioSnippets</code>,里面有很多后缀是<code>snippet</code>的文件. 或者点击<a href="https://shueducn-my.sharepoint.com/:f:/g/personal/rugbyuu_shu_edu_cn/Eotc_eWLFhRPl9Sx2HwJ5fQBCV9EJb-WJk-cjbzxGT_n3A?e=XJc3Ek">这里下载</a></p>
<blockquote>
<p>如果是非源码版需要使用代码片段可以把这个文件夹复制对应的目录</p>
</blockquote>
<ul>
<li>VS导入UE代码片段</li>
</ul>
<p>在VS中打开<code>Tools(工具)</code>-<code>Code Snippets Manager(代码片段管理器)</code></p>
<p><img src="https://img.supervj.top//img/image-20201203141902771.png" alt="image-20201203141902771"></p>
<p>点击上图中的导入,找到之前所有<code>snippet</code>文件选择导入</p>
<p>然后在VS中按下组合键<code>Ctrl+K</code>然后<code>Ctrl+X</code>就可以选择所有代码片段了</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>VS</tag>
      </tags>
  </entry>
  <entry>
    <title>Valve Index按键与事件</title>
    <url>/2022/11/30/Valve%20Index%E6%8C%89%E9%94%AE%E4%B8%8E%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221130112739041.png" alt="image-20221130112739041"></p>
<span id="more"></span>



<h2 id="Grip-抓握"><a href="#Grip-抓握" class="headerlink" title="Grip(抓握)"></a>Grip(抓握)</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221130112803862.png" alt="image-20221130112803862"></p>
<p>Index 的Grip有3个分类</p>
<ul>
<li>Axis: 根据抓握的力度得到0-1的值, 比较敏感, 如果用到Action的话, 非常容易触发</li>
<li>Force: 需要用力抓握才能得到反馈, 手柄默认会有一个轻微的震动</li>
<li>Grab: 敏感度介于前面两者之间的抓握</li>
</ul>
<p>如果用于抓握道具的话, 建议可以用Force, 不容易误触</p>
<blockquote>
<p> VR模板用的是Axis, 坑…..</p>
</blockquote>
<h2 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221130112922160.png" alt="image-20221130112922160"></p>
<ul>
<li>Trigger: 完全按下Trigger才能触发(Axis等于1的时候还需要再继续按下)</li>
<li>TriggerAxis: 根据按下力度得到0-1的值</li>
<li>TriggerTouch: 触摸到就触发Press事件, 松开就得到Release事件</li>
</ul>
<h2 id="Thumbstick"><a href="#Thumbstick" class="headerlink" title="Thumbstick"></a>Thumbstick</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221130112943787.png" alt="image-20221130112943787"></p>
<ul>
<li>X/Y: 这俩可以直接理解坐标, 范围[-1 , 1]</li>
<li>Touch: 触摸到就触发, 类似Trigger</li>
<li>Up/Down/Left/Right:  比如Left, <strong>当X值大约小于 -0.25</strong> 的时候触发</li>
<li>Thumbstick: 没有啥后缀的这个, 需要整个按键按下, 操作有点麻烦</li>
<li>Touch: 触摸, 类似上面的</li>
</ul>
<h2 id="Trackpad"><a href="#Trackpad" class="headerlink" title="Trackpad"></a>Trackpad</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221130112956715.png" alt="image-20221130112956715"></p>
<p>Trackpad有更多的按键, 但是这个只是小小的一块触摸板, 实测4方向的事件都无法接收到</p>
<ul>
<li>X/Y: 坐标值, 范围[-1 , 1]</li>
<li>Touch: 触摸触发</li>
<li>Force:按下触发, 有震动反馈, 与Touch的区别类似Grip中的Touch和Force</li>
<li>Up/Down/Left/Right: 无法触发</li>
<li>UpTouch等4个方向: 无法触发</li>
</ul>
<h2 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221130113011072.png" alt="image-20221130113011072"></p>
<p>Index的按键左右手都有A和B两个按键, 事件有两种</p>
<ul>
<li>Press: 按下触发</li>
<li>Touch: 触摸触发</li>
</ul>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20221130113023848.png" alt="image-20221130113023848"></p>
<p>类似其他按键</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Pinch Grab: 一个奇怪的按键组合, 需要同时按住Trackpad 和Tirgger才能触发</p>
]]></content>
      <categories>
        <category>VR</category>
      </categories>
      <tags>
        <tag>VR</tag>
      </tags>
  </entry>
  <entry>
    <title>随机数</title>
    <url>/2021/07/21/c++%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用c++时经常要用到随机数, 本文对c++的随机数api做个简单的总结</p>
<span id="more"></span>



<h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>c++11之前一般会用<code>srand()</code>配合<code>rand()</code>来实现随机数的使用</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">rand</span>() % <span class="number">10</span> &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//返回0-9的随机数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210721144150064.png" alt="image-20210721144150064"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">rand</span>() % <span class="number">10</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210721144237834.png" alt="image-20210721144237834"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">srand</span>(i%<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">rand</span>() % <span class="number">10</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210721144316345.png" alt="image-20210721144316345"></p>
<h2 id="c-11随机数算法"><a href="#c-11随机数算法" class="headerlink" title="c++11随机数算法"></a>c++11随机数算法</h2><p>c++11提供了3个新的随机算法</p>
<ul>
<li>linear_congruential_engine线性同余法</li>
<li>mersenne_twister_engine梅森旋转法</li>
<li>substract_with_carry_engine滞后Fibonacci</li>
</ul>
<p>借用网络图用一下</p>
<p><img src="https://img.supervj.top//img/image-20210721144503338.png" alt="image-20210721144503338"></p>
<p>如果我们要使用这三个模板类的话，就必须自己实例化之。但这些实例化参数都是这些算法里面使用到的参数，如果不懂算法的原理的话，真的不知道需要用什么参数才能得到比较好的随机序列。所以我们这些卑微的码农是用不了这些模板类的。C++11标准也想到了这点，所以就帮我们预定义了一些随机数类，这些随机数类都是用比较好的参数实例化上面那三个模板类。注意：在C++11里面，把这些随机数生成器叫做引擎(engines)。</p>
<p>直接开撸</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::default_random_engine  random;	</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">random</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果就不显示了, 一堆随机数</p>
<p>同样的, 也可以设置随机种子(seed),方法是往构造函数传入参数或者使用 <code>random.seed()</code>来设置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::default_random_engine  <span class="title">random</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//等价于 random.seed(1);</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::default_random_engine  random;</span><br><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">dis1</span><span class="params">(<span class="number">0</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">dis2</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dis1</span>(random) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dis2</span>(random) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210721144827258.png" alt="image-20210721144827258"></p>
<p>用上述两个模板类来生成的均是<strong>均匀分布的随机数</strong>, 基本已经能满足一般的项目需求了</p>
<blockquote>
<p>需要注意的是</p>
<p>uniform_int_distribution的随机数的范围是 <code>[ ]</code></p>
<p>uniform_real_distribution却是半开范围 <code> [ )</code></p>
<p>如果需要浮点数随机范围是<code>[]</code>,那么按照如下使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">dis2</span><span class="params">(<span class="number">0</span>, std::nextafter(<span class="number">1</span>,DBL_MAX))</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h2><p>C++11提供的概率分布类型有下面这些：</p>
<p>均匀分布：</p>
<pre><code>uniform_int_distribution          整数均匀分布
uniform_real_distribution        浮点数均匀分布
</code></pre>
<p>伯努利类型分布：（仅有yes/no两种结果，概率一个p，一个1-p）</p>
<pre><code>bernoulli_distribution    伯努利分布
binomial_distribution     二项分布
geometry_distribution    几何分布
negative_biomial_distribution  负二项分布
</code></pre>
<p>Rate-based distributions: </p>
<pre><code>poisson_distribution 泊松分布
exponential_distribution指数分布
gamma_distribution 伽马分布
weibull_distribution 威布尔分布
extreme_value_distribution 极值分布
</code></pre>
<p>正态分布相关：</p>
<pre><code>normal_distribution        正态分布
chi_squared_distribution卡方分布
cauchy_distribution       柯西分布
fisher_f_distribution      费歇尔F分布
student_t_distribution t分布
</code></pre>
<p>分段分布相关：</p>
<pre><code>discrete_distribution离散分布
piecewise_constant_distribution分段常数分布
piecewise_linear_distribution分段线性分布
</code></pre>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::default_random_engine  random;</span><br><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">dis1</span><span class="params">(<span class="number">0</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">dis2</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function">std::poisson_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">dis3</span><span class="params">(<span class="number">2.5</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">dis3</span>(random);	</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p[n]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; i &lt;&lt; <span class="string">&quot; : &quot;</span>&lt;&lt; <span class="built_in">string</span>(p[i]*<span class="number">0.01</span>, <span class="string">&#x27;*&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210721151336229.png" alt="image-20210721151336229"></p>
<p>上图显示的就是如下图的情况</p>
<p><img src="https://img.supervj.top//img/image-20210721151404832.png" alt="image-20210721151404832"></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>obj及mtl文件数据</title>
    <url>/2021/06/18/obj%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>obj文件是Alias|Wavefront公司开发的一种标准3D模型文件格式，适合用于3D软件模型之间的互导。</p>
<p>obj和信息文件mtl都是文本文件, 都可以用记事本打开, 本文主要对两种文件内数据格式简单的解释一下</p>
<span id="more"></span>



<h2 id="obj"><a href="#obj" class="headerlink" title="obj"></a>obj</h2><p><img src="https://img.supervj.top//img/image-20210618171800597.png" alt="image-20210618171800597"></p>
<p>OBJ3.0文件格式支持直线(Line)、多边形(Polygon)、表面(Surface)和自由形态曲线(Free-form Curve)。直线和多边形通过它们的点来描述，曲线和表面则根据它们的控制点和依附于曲线类型的额外信息来定义，这些信息支持规则和不规则的曲线，包括那些基于贝塞尔曲线(Bezier)、B样条(B-spline)、基数(Cardinal/Catmull-Rom)和泰勒方程(Taylor equations)的曲线。其他特点如下：</p>
<ol>
<li><p>OBJ文件是一种3D模型文件。不包含动画、材质特性、贴图路径、动力学、粒子等信息。</p>
</li>
<li><p>OBJ文件主要支持多边形(Polygons)模型。虽然也支持曲线(Curves)、表面(Surfaces)、点组材质(Point Group Materials)，但Maya导出的OBJ文件并不包括这些信息。</p>
</li>
<li><p>OBJ文件支持三个点以上的面，这一点很有用。很多其它的模型文件格式只支持三个点的面，所以导入Maya的模型经常被三角化了，这对于我们对模型进行再加工甚为不利。</p>
</li>
<li><p>OBJ文件支持法线和贴图坐标。在其它软件中调整好贴图后，贴图坐标信息可以存入OBJ文件中，这样文件导入Maya后只需指定一下贴图文件路径就行了，不需要再调整贴图坐标。</p>
</li>
</ol>
<ul>
<li>常见关键字</li>
</ul>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>注释</td>
<td># <a href="http://www.blender.org/">www.blender.org</a></td>
</tr>
<tr>
<td>usemtl</td>
<td>材质名称</td>
<td>usemtl Glass</td>
</tr>
<tr>
<td>v</td>
<td>顶点坐标</td>
<td>v -0.101738 14.455023 0.659757</td>
</tr>
<tr>
<td>vt</td>
<td>贴图坐标点/UV坐标</td>
<td>vt 0.439941 0.453613</td>
</tr>
<tr>
<td>vn</td>
<td>顶点法线</td>
<td>vn 0.496902 -0.240822 0.833674</td>
</tr>
<tr>
<td>o</td>
<td>对象名称</td>
<td>o Legs</td>
</tr>
<tr>
<td>f</td>
<td>面</td>
<td>f 654/611/647 652/609/645 657/614/650</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="mtl"><a href="#mtl" class="headerlink" title="mtl"></a>mtl</h2><p>当你导出Obj模型的时候会发现除了.obj文件还会有个同名.mtl文件，这个文件用来干什么的？其实这个文件是用来记录模型的材质库参数的，包括贴图、环境光参数、模型反射等参数。</p>
<p><img src="https://img.supervj.top//img/image-20210618171740238.png" alt="image-20210618171740238"></p>
<ul>
<li>常见关键字</li>
</ul>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>注释</td>
<td># <a href="http://www.blender.org/">www.blender.org</a></td>
</tr>
<tr>
<td>newmtl</td>
<td>材质名称</td>
<td>usemtl Glass</td>
</tr>
<tr>
<td>Ks</td>
<td>镜面反射颜色</td>
<td>Ks 0.500000 0.500000 0.500000</td>
</tr>
<tr>
<td>Ka</td>
<td>环境颜色</td>
<td>Ka 1.000000 0.000000 0.000000</td>
</tr>
<tr>
<td>Kd</td>
<td>漫反射颜色</td>
<td>Kd 0.640000 0.640000 0.640000</td>
</tr>
<tr>
<td>Ke</td>
<td>自发光/放射光</td>
<td>Ke 0.640000 0.640000 0.640000</td>
</tr>
<tr>
<td>Ni</td>
<td>材质的光密度/折射率</td>
<td>Ni 2.73</td>
</tr>
<tr>
<td>Tf</td>
<td>透明度</td>
<td>Tf 0.00 0.37 0.37</td>
</tr>
<tr>
<td>map_Bump/Bump</td>
<td>凹凸贴图</td>
<td>bump T_Ground_Grass_D.png -bm 1</td>
</tr>
<tr>
<td>map_Kd/Kd</td>
<td>漫反射贴图</td>
<td>map_Kd T_UE4_LOGO_CARD.TGA</td>
</tr>
</tbody></table>
<p>下面放一张maya中的编辑器下的参数与mtl文件的对应关系</p>
<blockquote>
<p>Tf参数与编辑器中的参数是<code> 1-</code>的关系即 <code>Tf = 1 - 编辑器中的参数</code></p>
</blockquote>
<p><img src="https://img.supervj.top//img/image-20210618173920449.png" alt="image-20210618173920449"></p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>模型</tag>
        <tag>obj</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu修改静态IP</title>
    <url>/2020/08/20/ubuntu%E4%BF%AE%E6%94%B9IP/</url>
    <content><![CDATA[<p>第一步我们需要将虚拟机的网络模式修改为<code>桥接模式</code>,并且勾选<code>复制物理网络连接状态</code>选项</p>
<p>ubuntu在20.4版本以后修改IP的方法与之前的有了比较大的区别，在之前的版本是通过编辑<code>/etc/network/interfaces</code>文件去修改IP，在新版本以后修改的配置文件是</p>
<p><code>/etc/netplan/01-cloud-init.yaml</code>,这个<code>01</code>可能每个人不相同，网上有些人是00，我这边是01</p>
<p>所以，我们用用<code>sudo vim /etc/netplan/01-network-manager-all.yaml</code>打开，输入以下指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Let NetworkManager manage all devices on this system</span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">    ens33:</span><br><span class="line">      dhcp4: false</span><br><span class="line">      addresses: [192.168.1.222/24]//ip地址，后面的24不需要改，更掩码有关系</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses: [8.8.8.8,192.168.0.1]</span><br><span class="line">~                                        </span><br></pre></td></tr></table></figure>

<p>上面的222是你自己设定的IP地址，前面需要参考你真是物理IP的情况</p>
<p>然后输入<code>sudo netplan --debug apply</code>应用</p>
<p>然后通过<code>ifconfig</code>查看IP</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode配置MaxScript开发环境</title>
    <url>/2020/04/30/vscode%E9%85%8D%E7%BD%AEmax/</url>
    <content><![CDATA[<h3 id="开发环境配置流程"><a href="#开发环境配置流程" class="headerlink" title="开发环境配置流程"></a>开发环境配置流程</h3><h5 id="MXSPyCom"><a href="#MXSPyCom" class="headerlink" title="MXSPyCom"></a>MXSPyCom</h5><ol>
<li>下载GitHub的MXSPyComRelease包,<a href="https://github.com/techartorg/MXSPyCOM/releases">链接</a></li>
<li>解压，并将安装包内的<code>MXSPyCOM.exe</code>文件复制到自定义目录</li>
<li><code>initialize_COM_server.ms</code>脚本放到max对应版本的startup目录中，默认路径是<code>%localappdata%\autodesk\3dsmax\scripts\startup</code></li>
</ol>
<h5 id="VsCode"><a href="#VsCode" class="headerlink" title="VsCode"></a>VsCode</h5><ol>
<li><p>下载LanguageMaxScript插件<img src="https://img.supervj.top/img1.png"></p>
</li>
<li><p>设置工作区</p>
</li>
<li><p>创建/配置<em><strong>task.json</strong></em>,可以<em><strong>ctrl+e</strong></em>搜索框中输入<code>&gt;task</code>搜索到<code>Configure Default Build Task</code>,在文件内设置如下代码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Execute in Max&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;process&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;C:/MXSPyCOM.exe&quot;</span>,  <span class="comment">//MXSPyCom.exe的路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;$&#123;file&#125;&quot;</span>],</span><br><span class="line">            <span class="attr">&quot;presentation&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;reveal&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;panel&quot;</span>: <span class="string">&quot;new&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>更改快捷键配置,方便调试</p>
<p><img src="https://img.supervj.top/imgmax2.png"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;ctrl+e&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;workbench.action.tasks.runTask&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;args&quot;</span>: <span class="string">&quot;Execute in Max&quot;</span>      <span class="comment">//对应任务的名称   </span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;shift+e&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;workbench.action.quickOpen&quot;</span>  <span class="comment">//原来的ctrl+e功能</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;shift+e&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;workbench.action.quickOpenNavigateNextInFilePicker&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;when&quot;</span>: <span class="string">&quot;inFilesPicker &amp;&amp; inQuickOpen&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h5><ol>
<li>在工作目录创建后缀为 ms格式的脚本文件</li>
<li>启动max</li>
<li>复制如下代码到脚本文件内，按 ctrl+e  调试</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">rollout rename_rollout <span class="string">&quot;Enter New Base Name&quot;</span></span><br><span class="line">    (</span><br><span class="line">        edittext base_name <span class="string">&quot;&quot;</span></span><br><span class="line">        button rename_them <span class="string">&quot;RENAME&quot;</span></span><br><span class="line">        On rename_them pressed <span class="keyword">do</span> </span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">if</span> base_name.text!=<span class="string">&quot;&quot;</span> <span class="keyword">do</span> (</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> selection <span class="keyword">do</span> i.name=uniqueName base_name.text</span><br><span class="line">            ) </span><br><span class="line">        ) </span><br><span class="line">    )</span><br><span class="line">    CreateDialog rename_rollout <span class="number">250</span> <span class="number">50</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>max生成如下窗口</li>
</ol>
<p><img src="https://img.supervj.top/img2.png"></p>
]]></content>
      <categories>
        <category>dcc</category>
      </categories>
      <tags>
        <tag>3dMax</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ApexPhysXLab制作UE4的破损物体(DestructibleMesh)</title>
    <url>/2020/05/21/%E4%BD%BF%E7%94%A8ApexPhysXLab%E5%88%B6%E4%BD%9CUE4%E7%9A%84%E7%A0%B4%E6%8D%9F%E7%89%A9%E4%BD%93%EF%BC%88%20DestructibleMesh%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>UE4自带的DestructibleMesh系统的破碎方式比较单一，可以用英伟达的ApexPhysXLab工具制作自定义破碎文件，然后导入UE4</p>
<p>本文介绍通过使用这一工具制作UE4破碎物体的流程</p>
<p>工具下载地址<a href="**https://developer.nvidia.com/gameworksdownload#?dn=physx-lab-1-3-0**">点击下载</a></p>
</blockquote>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_1.png"></p>
<h3 id="PhysXLab流程"><a href="#PhysXLab流程" class="headerlink" title="PhysXLab流程"></a>PhysXLab流程</h3><p>如下图所示，导入3D模型</p>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_2.png"></p>
<h5 id="三种破碎方式"><a href="#三种破碎方式" class="headerlink" title="三种破碎方式"></a>三种破碎方式</h5><p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_3.png"></p>
<h6 id="Slice模式"><a href="#Slice模式" class="headerlink" title="Slice模式"></a>Slice模式</h6><p>如下图所示，红色框内为主要设置的参数</p>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_4.png"></p>
<p>效果如下</p>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_5.png"></p>
<h6 id="Cutout模式"><a href="#Cutout模式" class="headerlink" title="Cutout模式"></a>Cutout模式</h6><p>主要用黑白通道图来切割，<strong>注意黑白通道只是平面投射，跟UV无关，所以纹理如果要配合切割需要单独制作配合好的纹理及黑白图</strong></p>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_6.png"></p>
<p>效果如下</p>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_7.png"></p>
<h6 id="Voronoi模式"><a href="#Voronoi模式" class="headerlink" title="Voronoi模式"></a>Voronoi模式</h6><p>类似UE4内的破碎</p>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_8.png"></p>
<p> 效果如下</p>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_9.png"></p>
<h5 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h5><p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_10.png"></p>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_11.png"></p>
<h3 id="UE4流程"><a href="#UE4流程" class="headerlink" title="UE4流程"></a>UE4流程</h3><p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_12.png"></p>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_13.png"></p>
<p>用一个模拟子弹来制造破碎效果</p>
<p><img src="https://img.supervj.top/img/PhyXLab/PhyXLab_14.png"></p>
]]></content>
      <categories>
        <category>physics</category>
      </categories>
      <tags>
        <tag>破碎物体</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>使用自定义Slate笔刷</title>
    <url>/2021/04/12/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Slate%E7%AC%94%E5%88%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用slate制作界面的时候往往需要使用到笔刷, 本文简单介绍如何使用自定义的笔刷以及使用系统的笔刷</p>
<span id="more"></span>



<h2 id="自定义笔刷"><a href="#自定义笔刷" class="headerlink" title="自定义笔刷"></a>自定义笔刷</h2><h3 id="纯C"><a href="#纯C" class="headerlink" title="纯C++"></a>纯C++</h3><p>参考引擎其他地方用到的获取笔刷的方式</p>
<p>主要思路是创建一个指针<code>TSharedPtr&lt; class FSlateStyleSet &gt; StyleSet</code>然后通过方法<code>FSlateStyleRegistry::RegisterSlateStyle(*StyleSet.Get())</code>注册笔刷</p>
<hr>
<p>国际惯例(照着引擎代码), 定义几个宏</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_BRUSH(RelativePath, ... ) FSlateImageBrush( FVSM_Style::InResources( RelativePath, <span class="meta-string">&quot;.png&quot;</span> ), __VA_ARGS__ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOX_BRUSH(RelativePath, ... ) FSlateBoxBrush( FVSM_Style::InResources( RelativePath, <span class="meta-string">&quot;.png&quot;</span> ), __VA_ARGS__ )</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StyleSet = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FSlateStyleSet</span>(<span class="built_in">GetStyleSetName</span>()));</span><br><span class="line">	StyleSet-&gt;<span class="built_in">SetContentRoot</span>(IPluginManager::<span class="built_in">Get</span>().<span class="built_in">FindPlugin</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;VSM&quot;</span>))-&gt;<span class="built_in">GetContentDir</span>());</span><br></pre></td></tr></table></figure>





<p>然后从具体目录获取图片</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachineSmall&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="string">&quot;Icons/StateMachine-ToolbarStateMachine-20&quot;</span>, Icon20x20));	</span><br><span class="line">StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.NodeBody&quot;</span>, <span class="keyword">new</span> <span class="built_in">BOX_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Graph/NodeBody&quot;</span>), <span class="built_in">FMargin</span>(<span class="number">4.f</span> / <span class="number">64.f</span>, <span class="number">4.f</span> / <span class="number">64.f</span>, <span class="number">4.f</span> / <span class="number">64.f</span>, <span class="number">4.f</span> / <span class="number">64.f</span>)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个字符串就是获取笔刷的名称</p>
</blockquote>
<p>获取方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SNew</span>(SBorder)			.<span class="built_in">BorderImage</span>(FVSM_Style::<span class="built_in">GetBrush</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;FrameworkGraph.NodeBody&quot;</span>)))</span><br></pre></td></tr></table></figure>



<h4 id="自定义资源缩略图"><a href="#自定义资源缩略图" class="headerlink" title="自定义资源缩略图"></a>自定义资源缩略图</h4><p>缩略图的自定义困扰了我很久, 第一时间想到的就是<code>Factory</code>类里面的虚函数<code>GetNewAssetThumbnailOverride()</code>, 重写以后返回一个之前注册过的笔刷名称,比如上面的 <code>&quot;VSM.StateMachineSmall&quot;</code></p>
<p>那么在右键菜单准备创建的时候确实是正确的图标, 但是创建资源以后就是默认<code>UObject</code>的原型图案了, 这个问题也查不到资料, 我甚至把蓝图资源创建的流程代码整个翻了个遍, 还是得不到有效信息</p>
<p>最后意外的发现, 原来问题出在了注册笔刷的地方</p>
<p>比如我们这个资源的蓝图类叫做<code>VSM_Blueprint</code>(去掉了前缀U), 那么于此对应的缩略图和Icon就这样注册</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;ClassIcon.VSM_Blueprint&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Icons/StateMachine&quot;</span>), Icon16x16));</span><br><span class="line">StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;ClassThumbnail.VSM_Blueprint&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Icons/StateMachine&quot;</span>), Icon128x128));</span><br></pre></td></tr></table></figure>

<p>同时, 我们也不需要重写<code>Factory</code>类里面的相关缩略图方法了;</p>
<p>还要注意一个问题, 蓝图类与它的<code>ParentClass</code>类都需要注册笔刷</p>
<p><img src="https://img.supervj.top//img/UE4Editor_3gT4XKdY99.png" alt="UE4Editor_3gT4XKdY99"></p>
<p><img src="https://img.supervj.top//img/PYM5GUua6f.png" alt="PYM5GUua6f"></p>
<h3 id="WidgetSlateStyle"><a href="#WidgetSlateStyle" class="headerlink" title="WidgetSlateStyle"></a>WidgetSlateStyle</h3><p>此方式方便在蓝图里配置笔刷，不用编译即可修改slate样式</p>
<p>我们创建此类的c++类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VSMEDITOR_API</span> <span class="title">FVSM_SlateStyle</span> :</span> <span class="keyword">public</span> FSlateWidgetStyle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.................</span></span><br><span class="line">  	<span class="comment">//输入框的样式</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, Category = Appearance)</span><br><span class="line">		FInlineEditableTextBlockStyle EditTextBlockStyle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其余均保持默认即可</p>
</blockquote>
<p>为了区别c++的style， 我们在<code>FVSM_Style</code>中的变量命名成 <code>static TSharedPtr&lt;FSlateStyleSet&gt; BlueprintStyleSet;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FVSM_Style::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!BlueprintStyleSet)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		FString styleDir = <span class="built_in">TEXT</span>(<span class="string">&quot;/VSM/Style/&quot;</span>);</span><br><span class="line">		BlueprintStyleSet = FSlateGameResources::<span class="built_in">New</span>(FVSM_Style::<span class="built_in">GetBPStyleSetName</span>(),*styleDir, *styleDir);</span><br><span class="line">		<span class="keyword">if</span> (BlueprintStyleSet)</span><br><span class="line">		&#123;</span><br><span class="line">			FSlateStyleRegistry::<span class="built_in">RegisterSlateStyle</span>(*BlueprintStyleSet);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里需要注意的是, 这里指定的目录是相对目录, 一开始我指定了绝对目录以后一路排查发现在<code>EngineUtils::FindOrLoadAssetsByPath()</code>函数里找不到对应的文件</p>
</blockquote>
<p>然后在的slate里面使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="keyword">const</span>  FVSM_SlateStyle* Style;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="comment">//VSMStyle对应的是蓝图的名称,如果错误可能会导致崩溃问题</span></span><br><span class="line">Style = &amp;FVSM_Style::<span class="built_in">GetBPStyle</span>().GetWidgetStyle&lt;FVSM_SlateStyle&gt;(<span class="string">&quot;VSMStyle&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//.................</span></span><br><span class="line"><span class="built_in">SAssignNew</span>(InlineEditableText, SInlineEditableTextBlock)</span><br><span class="line">								.<span class="built_in">Style</span>(&amp;Style-&gt;EditTextBlockStyle)</span><br></pre></td></tr></table></figure>

<p>然后创建蓝图style</p>
<p><img src="https://img.supervj.top//img/image-20210412183656909.png" alt="image-20210412183656909"></p>
<p>效果</p>
<p><img src="https://img.supervj.top//img/UE4Editor_txLE2n7qwp.png" alt="UE4Editor_txLE2n7qwp"></p>
<p>每次修改以后需要重新打开对应的slate资源才能刷新</p>
<blockquote>
<p>编译以后如果蓝图的style还没有创建, 那么创建以后如果提示找不到笔刷, 则需要再重新启动一次编辑器</p>
</blockquote>
<h2 id="系统笔刷"><a href="#系统笔刷" class="headerlink" title="系统笔刷"></a>系统笔刷</h2><p>系统的笔刷文件多数在 <code>*\Engine\Content\Editor\Slate</code>中</p>
<p>通过文件<code>SlateEditorStyle.cpp</code>中定义和获取</p>
<p>如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FEditorStyle::<span class="built_in">GetBrush</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Graph.StateNode.Pin.Background&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>当然引擎还有很多其他类也定义了自己的笔刷, 如<code>VREditorStyle.cpp</code>, <code>GameMenuBuilderStyle.cpp</code>,具体笔刷名称是啥就直接去看cpp</p>
<h2 id="Style类完整代码"><a href="#Style类完整代码" class="headerlink" title="Style类完整代码"></a>Style类完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;VSM_SlateWidgetStyle.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VSMEDITOR_API</span> <span class="title">FVSM_Style</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************************************************************/</span></span><br><span class="line">    <span class="comment">/* FUNCTION                                                           */</span></span><br><span class="line">    <span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> FLinearColor TransitionNodeHorverColor;</span><br><span class="line">    <span class="keyword">static</span> FLinearColor TransitionNodeBaseColor;</span><br><span class="line">    <span class="keyword">static</span> FLinearColor NodeBodyBaseColor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> TSharedPtr&lt; class ISlateStyle &gt; <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> FName <span class="title">GetStyleSetName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FName <span class="title">GetBPStyleSetName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> FSlateBrush* <span class="title">GetBrush</span><span class="params">(FName PropertyName, <span class="keyword">const</span> ANSICHAR* Specifier = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ISlateStyle&amp; <span class="title">GetBPStyle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> FString <span class="title">InResources</span><span class="params">(<span class="keyword">const</span> FString&amp; RelativePath, <span class="keyword">const</span> ANSICHAR* Extension)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************************************************************/</span></span><br><span class="line">    <span class="comment">/* PROPERTIES                                                           */</span></span><br><span class="line">    <span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> TSharedPtr&lt; <span class="class"><span class="keyword">class</span> <span class="title">FSlateStyleSet</span> &gt;</span> StyleSet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> TSharedPtr&lt;FSlateStyleSet&gt; BlueprintStyleSet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Style/VSM_Style.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Styling/ISlateStyle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Styling/SlateStyle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Interfaces/IPluginManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Styling/SlateStyleRegistry.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SlateOptMacros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Slate/SlateGameResources.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_BRUSH(RelativePath, ... ) FSlateImageBrush( FVSM_Style::InResources( RelativePath, <span class="meta-string">&quot;.png&quot;</span> ), __VA_ARGS__ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOX_BRUSH(RelativePath, ... ) FSlateBoxBrush( FVSM_Style::InResources( RelativePath, <span class="meta-string">&quot;.png&quot;</span> ), __VA_ARGS__ )</span></span><br><span class="line"></span><br><span class="line">TSharedPtr&lt; FSlateStyleSet &gt; FVSM_Style::StyleSet = <span class="literal">nullptr</span>;</span><br><span class="line">TSharedPtr&lt; FSlateStyleSet &gt; FVSM_Style::BlueprintStyleSet = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATION</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FVSM_Style::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Const icon sizes</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> FVector2D <span class="title">Icon8x8</span><span class="params">(<span class="number">8.0f</span>, <span class="number">8.0f</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> FVector2D <span class="title">Icon16x16</span><span class="params">(<span class="number">16.0f</span>, <span class="number">16.0f</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> FVector2D <span class="title">Icon20x20</span><span class="params">(<span class="number">20.0f</span>, <span class="number">20.0f</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> FVector2D <span class="title">Icon40x40</span><span class="params">(<span class="number">40.0f</span>, <span class="number">40.0f</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> FVector2D <span class="title">Generic10x10</span><span class="params">(<span class="number">10.0f</span>, <span class="number">10.0f</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> FVector2D <span class="title">NodeBody64x64</span><span class="params">(<span class="number">64.0f</span>, <span class="number">64.0f</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> FVector2D <span class="title">Icon128x128</span><span class="params">(<span class="number">64.0f</span>, <span class="number">64.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!BlueprintStyleSet)</span><br><span class="line">	&#123;</span><br><span class="line">		FString styleDir = <span class="built_in">TEXT</span>(<span class="string">&quot;/VSM/Style/&quot;</span>);</span><br><span class="line"></span><br><span class="line">		BlueprintStyleSet = FSlateGameResources::<span class="built_in">New</span>(FVSM_Style::<span class="built_in">GetBPStyleSetName</span>(),*styleDir, *styleDir);</span><br><span class="line">		<span class="keyword">if</span> (BlueprintStyleSet)</span><br><span class="line">		&#123;</span><br><span class="line">			FSlateStyleRegistry::<span class="built_in">RegisterSlateStyle</span>(*BlueprintStyleSet);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Only register once</span></span><br><span class="line">	<span class="keyword">if</span> (StyleSet.<span class="built_in">IsValid</span>())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	StyleSet = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FSlateStyleSet</span>(<span class="built_in">GetStyleSetName</span>()));</span><br><span class="line">	<span class="comment">//StyleSet-&gt;SetContentRoot(IPluginManager::Get().FindPlugin(TEXT(&quot;VSM&quot;))-&gt;GetBaseDir() / TEXT(&quot;Resources&quot;));</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">SetContentRoot</span>(FPaths::<span class="built_in">EngineContentDir</span>() / <span class="built_in">TEXT</span>(<span class="string">&quot;Editor/Slate&quot;</span>));</span><br><span class="line">	StyleSet-&gt;<span class="built_in">SetCoreContentRoot</span>(FPaths::<span class="built_in">EngineContentDir</span>() / <span class="built_in">TEXT</span>(<span class="string">&quot;Slate&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Icons </span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;ClassIcon.VSM_Blueprint&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Icons/StateMachine_16&quot;</span>), Icon16x16));</span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;ClassThumbnail.VSM_Blueprint&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Icons/StateMachine_128&quot;</span>), Icon128x128));</span><br><span class="line"></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;ClassIcon.VSM_StateMachine&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Icons/StateMachine_16&quot;</span>), Icon16x16));</span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;ClassThumbnail.VSM_StateMachine&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Icons/StateMachine_128&quot;</span>), Icon128x128));</span><br><span class="line"></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;ClassIcon.VSM_Blueprint_Task&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Icons/Task_16&quot;</span>), Icon16x16));</span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;ClassThumbnail.VSM_Blueprint_Task&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Icons/Task_128&quot;</span>), Icon128x128));</span><br><span class="line"></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;ClassIcon.VSM_Task_Base&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Icons/Task_16&quot;</span>), Icon16x16));</span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;ClassThumbnail.VSM_Task_Base&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Icons/Task_128&quot;</span>), Icon128x128));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Toolbar</span></span><br><span class="line"></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachine&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="string">&quot;Icons/StateMachine&quot;</span>, Icon40x40));</span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachineSmall&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="string">&quot;Icons/StateMachine&quot;</span>, Icon20x20));</span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachineGraphSmall&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="string">&quot;Icons/GraphIconSmall&quot;</span>, Icon20x20));</span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.Task&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="string">&quot;Icons/Task&quot;</span>, Icon40x40));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Graph</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.NodeBody&quot;</span>, <span class="keyword">new</span> <span class="built_in">BOX_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Graph/NodeBody&quot;</span>), <span class="built_in">FMargin</span>(<span class="number">4.f</span> / <span class="number">64.f</span>, <span class="number">4.f</span> / <span class="number">64.f</span>, <span class="number">4.f</span> / <span class="number">64.f</span>, <span class="number">4.f</span> / <span class="number">64.f</span>)));</span><br><span class="line">	<span class="comment">//StyleSet-&gt;Set(&quot;FrameworkGraph.NodeBodySelected&quot;, new BOX_BRUSH(TEXT(&quot;Graph/NodeBodySelected&quot;), FMargin(18.0f / 64.0f)));</span></span><br><span class="line">	<span class="comment">//StyleSet-&gt;Set(&quot;FrameworkGraph.NodePin&quot;, new IMAGE_BRUSH(TEXT(&quot;Graph/NodePin&quot;), Generic10x10));</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.NodePinHoverCue&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Graph/NodePinHoverCue&quot;</span>), Generic10x10));</span><br><span class="line">	<span class="comment">//默认阴影</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.RegularNodeShadow&quot;</span>, <span class="keyword">new</span> <span class="built_in">BOX_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Graph/RegularNodeShadow&quot;</span>), <span class="built_in">FMargin</span>(<span class="number">18.0f</span> / <span class="number">64.0f</span>)));</span><br><span class="line">	<span class="comment">/*StyleSet-&gt;Set(&quot;FrameworkGraph.RegularNodeTitleNormal&quot;, new BOX_BRUSH(TEXT(&quot;Graph/RegularNodeTitleNormal&quot;), FMargin(12.0f / 64.0f)));</span></span><br><span class="line"><span class="comment">	StyleSet-&gt;Set(&quot;FrameworkGraph.RegularNodeTitleHighlight&quot;, new BOX_BRUSH(TEXT(&quot;Graph/RegularNodeTitleHighlight&quot;), FMargin(16.0f / 64.0f, 1.0f, 16.0f / 64.0f, 0.0f)));*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// State Machine </span></span><br><span class="line">	<span class="comment">//默认边框部分</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachine.NodeBody&quot;</span>, <span class="keyword">new</span> <span class="built_in">BOX_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Graph/StateMachine/NodeBody&quot;</span>), <span class="built_in">FMargin</span>(<span class="number">16.f</span> / <span class="number">64.f</span>, <span class="number">25.f</span> / <span class="number">64.f</span>, <span class="number">16.f</span> / <span class="number">64.f</span>, <span class="number">16.f</span> / <span class="number">64.f</span>)));</span><br><span class="line">	<span class="comment">//节点选中阴影</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachine.NodeBodySelected&quot;</span>, <span class="keyword">new</span> <span class="built_in">BOX_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Graph/StateMachine/NodeBodySelected&quot;</span>), <span class="built_in">FMargin</span>(<span class="number">18.0f</span> / <span class="number">64.0f</span>)));</span><br><span class="line">	<span class="comment">//节点主体内部</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachine.NodeBodyColorSpill&quot;</span>, <span class="keyword">new</span> <span class="built_in">BOX_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Graph/StateMachine/NodeBodyColorSpill&quot;</span>), <span class="built_in">FMargin</span>(<span class="number">4.0f</span> / <span class="number">64.0f</span>, <span class="number">4.0f</span> / <span class="number">32.0f</span>)));</span><br><span class="line">	<span class="comment">//鼠标移动到Node上的背景颜色</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachine.NodePinHoverCue&quot;</span>, <span class="keyword">new</span> <span class="built_in">BOX_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Graph/StateMachine/NodePinHoverCue&quot;</span>), <span class="built_in">FMargin</span>(<span class="number">12.0f</span> / <span class="number">64.0f</span>, <span class="number">12.0f</span> / <span class="number">64.0f</span>, <span class="number">12.0f</span> / <span class="number">64.0f</span>, <span class="number">12.0f</span> / <span class="number">64.0f</span>)));</span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachine.Icon&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="string">&quot;Graph/StateMachine/NodeIcon&quot;</span>, Icon16x16));</span><br><span class="line">	<span class="comment">//过渡节点主体，已废弃</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;vsm.StateMachine.TransitionNodeBody&quot;</span>, <span class="keyword">new</span> <span class="built_in">BOX_BRUSH</span>(<span class="string">&quot;Graph/StateMachine/TransNodeBody&quot;</span>, <span class="built_in">FMargin</span>(<span class="number">16.f</span> / <span class="number">64.f</span>, <span class="number">12.f</span> / <span class="number">28.f</span>)));</span><br><span class="line">	<span class="comment">//过渡节点的底色</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachine.TransitionNodeColorSpill&quot;</span>, <span class="keyword">new</span> <span class="built_in">BOX_BRUSH</span>(<span class="string">&quot;Graph/StateMachine/TransNodeColorSpill&quot;</span>, <span class="built_in">FMargin</span>(<span class="number">0.25f</span>, <span class="number">0.25f</span>, <span class="number">0.25f</span>, <span class="number">0.25f</span>))); <span class="comment">//16.f / 64.f, 16.f / 28.f, 16.f / 64.f, 4.f / 28.f)</span></span><br><span class="line">	<span class="comment">//过渡节点的图标</span></span><br><span class="line">	StyleSet-&gt;<span class="built_in">Set</span>(<span class="string">&quot;VSM.StateMachine.TransitionNodeIcon&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="string">&quot;Graph/StateMachine/TransNodeIcon&quot;</span>, <span class="built_in">FVector2D</span>(<span class="number">25</span>, <span class="number">25</span>)));</span><br><span class="line"></span><br><span class="line">	FSlateStyleRegistry::<span class="built_in">RegisterSlateStyle</span>(*StyleSet.<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> FSlateBrush* <span class="title">FVSM_Style::GetBrush</span><span class="params">(FName PropertyName, <span class="keyword">const</span> ANSICHAR* Specifier <span class="comment">/*= NULL*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> FVSM_Style::<span class="built_in">Get</span>()-&gt;<span class="built_in">GetBrush</span>(PropertyName, Specifier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ISlateStyle&amp; <span class="title">FVSM_Style::GetBPStyle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *BlueprintStyleSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">END_SLATE_FUNCTION_BUILD_OPTIMIZATION</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">FLinearColor <span class="title">FVSM_Style::TransitionNodeHorverColor</span><span class="params">(<span class="number">0.22f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">FLinearColor <span class="title">FVSM_Style::TransitionNodeBaseColor</span><span class="params">(<span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>)</span></span>;</span><br><span class="line"><span class="function">FLinearColor <span class="title">FVSM_Style::NodeBodyBaseColor</span><span class="params">(<span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> IMAGE_BRUSH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BOX_BRUSH</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FVSM_Style::Shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (StyleSet.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		FSlateStyleRegistry::<span class="built_in">UnRegisterSlateStyle</span>(*StyleSet.<span class="built_in">Get</span>());</span><br><span class="line">		<span class="built_in">ensure</span>(StyleSet.<span class="built_in">IsUnique</span>());</span><br><span class="line">		StyleSet.<span class="built_in">Reset</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (BlueprintStyleSet.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		FSlateStyleRegistry::<span class="built_in">UnRegisterSlateStyle</span>(*BlueprintStyleSet.<span class="built_in">Get</span>());</span><br><span class="line">		<span class="built_in">ensure</span>(BlueprintStyleSet.<span class="built_in">IsUnique</span>());</span><br><span class="line">		BlueprintStyleSet.<span class="built_in">Reset</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TSharedPtr&lt; class ISlateStyle &gt; <span class="title">FVSM_Style::Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> StyleSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FName <span class="title">FVSM_Style::GetStyleSetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> FName <span class="title">StyleName</span><span class="params">(TEXT(<span class="string">&quot;FVSM_Style&quot;</span>))</span></span>;</span><br><span class="line">	<span class="keyword">return</span> StyleName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FName <span class="title">FVSM_Style::GetBPStyleSetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">FName <span class="title">BPStyleName</span><span class="params">(TEXT(<span class="string">&quot;FVSM_BlueprintStyle&quot;</span>))</span></span>;</span><br><span class="line">	<span class="keyword">return</span> BPStyleName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">FVSM_Style::InResources</span><span class="params">(<span class="keyword">const</span> FString&amp; RelativePath, <span class="keyword">const</span> ANSICHAR* Extension)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> FString ContentDir = IPluginManager::<span class="built_in">Get</span>().<span class="built_in">FindPlugin</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;VSM&quot;</span>))-&gt;<span class="built_in">GetBaseDir</span>() / <span class="built_in">TEXT</span>(<span class="string">&quot;Resources&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (ContentDir / RelativePath) + Extension;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>Slate</tag>
      </tags>
  </entry>
  <entry>
    <title>关于EditorUtilityWiget用cpp来运行</title>
    <url>/2021/01/09/%E5%85%B3%E4%BA%8EEditorUtilityWiget%E7%94%A8cpp%E6%9D%A5%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>奇葩需求,  EditorUtilityWiget用cpp来运行</p>
<span id="more"></span>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SelectObject = 任意编辑器UMG资源</span></span><br><span class="line"></span><br><span class="line">UWidgetBlueprint* Blueprint = Cast&lt;UWidgetBlueprint&gt;(SelectObject);</span><br><span class="line">		<span class="keyword">if</span> (Blueprint &amp;&amp; Blueprint-&gt;GeneratedClass-&gt;<span class="built_in">IsChildOf</span>(UEditorUtilityWidget::<span class="built_in">StaticClass</span>())) &#123;</span><br><span class="line">			<span class="keyword">const</span> UEditorUtilityWidget* CDO = Blueprint-&gt;GeneratedClass-&gt;GetDefaultObject&lt;UEditorUtilityWidget&gt;();</span><br><span class="line">			<span class="keyword">if</span> (CDO-&gt;<span class="built_in">ShouldAutoRunDefaultAction</span>()) &#123;</span><br><span class="line">				UEditorUtilityWidget* Instance = NewObject&lt;UEditorUtilityWidget&gt;(<span class="built_in">GetTransientPackage</span>(), Blueprint-&gt;GeneratedClass);</span><br><span class="line">				Instance-&gt;<span class="built_in">ExecuteDefaultAction</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				FName RegistrationName = <span class="built_in">FName</span>(*(Blueprint-&gt;<span class="built_in">GetPathName</span>() + <span class="built_in">TEXT</span>(<span class="string">&quot;_ActiveTab&quot;</span>)));</span><br><span class="line">				FText DisplayName = FText::<span class="built_in">FromString</span>(Blueprint-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">				FLevelEditorModule&amp; LevelEditorModule = FModuleManager::GetModuleChecked&lt;FLevelEditorModule&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;LevelEditor&quot;</span>));</span><br><span class="line">				TSharedPtr&lt;FTabManager&gt; LevelEditorTabManager = LevelEditorModule.<span class="built_in">GetLevelEditorTabManager</span>();</span><br><span class="line">				TSharedRef&lt;SDockTab&gt; NewDockTab = LevelEditorTabManager-&gt;<span class="built_in">InvokeTab</span>(RegistrationName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案有缺陷, 就是第一次还是需要在编辑器下右键运行一次才能用cpp来运行, 因为右键运行会调用到<code> UEditorUtilitySubsystem::SpawnAndRegisterTab()</code>, 在这个函数中会对<code>UMG</code>进行初始化, 而用上述方法是没法初始化的</p>
<blockquote>
<p>恶心的问题是, 此模块基本上都没有导出符号(即没法在自己的cpp中使用任何有关<code>UEditorUtilityWidget</code>的类),  没法自己初始化, 解决方法二选一</p>
<ol>
<li>手动右键先运行一次(不推荐)</li>
<li>使用<code>AutoRunDefaultAction</code>, 然后在蓝图中自己运行自己的资源(这个资源还没法cast, 否则还能写个通用方法)</li>
</ol>
<p><img src="https://img.supervj.top//img/image-20210106162756815.png" alt="image-20210106162756815"></p>
</blockquote>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>Slate</tag>
        <tag>编辑器扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>提交蓝图工程到虚幻商城</title>
    <url>/2020/05/18/%E5%85%B3%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%95%86%E5%9F%8E%E4%B8%8A%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p> 笔者之前制作了一个<a href="https://www.unrealengine.com/marketplace/zh-CN/product/multiplayer-rpg-template">游戏Demo</a>蓝图工程上架了虚幻商城，本文记录虚幻商城上传蓝图工程的注意事项</p>
</blockquote>
<p><img src="https://img.supervj.top/imgmarket1.jpg"></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>当然是制作一份自己的工程，不要轻易白嫖别人的工程/资源，很容易被逮到，当然也有例外，下文会提到</li>
<li>注册并登录Epic账号，到<a href="https://publish.unrealengine.com/v2/welcome">商城卖家页面</a>准备提交内容<ol>
<li>需要一个公开邮箱，用于跟官方以及买家的交流，包括退款或者错误问题交流</li>
<li>需要提供一个Paypal账户（目前不支持支付宝）来接受汇款</li>
<li>Epic在每月月底统计销售额，需要大于100美元才会在45日之内汇款，略慢</li>
</ol>
</li>
<li>准备一套图片，分辨率为<code>1920x1080</code>，这些贴图会提交为商品预览图片<ol>
<li>这里其中一个图片需要设置为商城浏览时的预览图片，分辨率为<code>284*284</code></li>
<li>还有一张图片会设置为主页上上的图片，分辨率为<code>894x488</code></li>
</ol>
</li>
</ol>
<h3 id="产品信息"><a href="#产品信息" class="headerlink" title="产品信息"></a>产品信息</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">信息</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">发布者名称，产品标题和标签不包含任何版权或商标名称</td>
<td align="center">我上架的时候因为是一个MMORPG的案例，加了标签**”WOW”**,结果违反了这一条规定</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">发布者名称，产品标题和标签不包含Epic的任何商标或属性</td>
<td align="center">不要添加跟Epic有关系的内容</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">发布者名称，产品标题和标签不包含令人反感或不适当的语言</td>
<td align="center">显而易见</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">产品标题不包含主观语言</td>
<td align="center">这个不太清楚意思</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">产品标题，说明文字和标签可准确反映产品内容</td>
<td align="center">字面意思</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">类别与产品的内容和功能有关</td>
<td align="center">这个也容易犯错，可能为了更容易被搜索到添加了无关的分类</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">产品标题，说明文字和标签为英文，包含正确的拼写和正确的语法</td>
<td align="center">不要写中文</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">所有技术信息模板字段均填充有适当的信息</td>
<td align="center">把信息写满就可以</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">提交处于“待批准”状态</td>
<td align="center">这个是废话，正常走流程就可以</td>
</tr>
</tbody></table>
<h3 id="媒体资源"><a href="#媒体资源" class="headerlink" title="媒体资源"></a>媒体资源</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">信息</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">图片不包含任何令人反感的图片</td>
<td align="center">*</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">图像清晰且与产品的内容和功能相关</td>
<td align="center">*</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">图片不会显示任何未经许可的第三方版权材料</td>
<td align="center">推荐自己引擎里截图就可以，不要加有些明显版权的图片什么的</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">显示产品视觉内容的图像在虚幻引擎4中渲染</td>
<td align="center">推荐引擎里截图</td>
</tr>
</tbody></table>
<h3 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h3><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">信息</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">每个项目文件链接仅承载一个具有适当文件夹结构的UE4项目或插件文件夹</td>
<td align="center">你发给官方的链接也就是买家会下载的工程链接是只包含一个工程，这个一般也不会犯错</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">提供的项目与列出的支持的引擎版本匹配</td>
<td align="center">版本不要搞错</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">分发方法适合产品的内容和功能</td>
<td align="center">*</td>
</tr>
</tbody></table>
<h5 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h5><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">信息</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><strong>Content文件夹包含一个以项目命名的Pack文件夹</strong></td>
<td align="center">这个比较容易犯错，文件目录需要严格按照类似以下这种结构<br />MyProject<br/>├── Config<br/>├── Content<br/>│   └── MyProject<br/>├── MyProject.uproject |</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Pack文件夹中的第一层文件夹是根据资产类型或特定资产命名的</td>
<td align="center">你自己的文件夹里的第一个文件夹是资产类文件夹，推荐命名成<code>Assets</code></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">所有资产类型都在各自的文件夹内</td>
<td align="center">比如动画放到Animation文件夹，贴图放到Texture文件夹里,但是笔者并没有严格按照这个分类也没有被打道回府</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><strong>项目不包含未使用的文件夹或资产</strong></td>
<td align="center">这个非常头大，你做项目的时候要谨慎添加资源比如帕拉共的资源，提交之前要删除所有未使用的资源，鉴于虚幻引擎清理资源的速度，可能这会花你几个晚上的时间；ps：笔者因为几张未使用的贴图被打回一次</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">所有重定向器均已清理</td>
<td align="center">制作的时候注意清理/修复路径就可以了</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">命名约定为英语，字母数字，在整个项目中保持一致，并描述资产的含义</td>
<td align="center">不要用中文，所有地方都别用就没事了</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">如果需要，发布者可以提供链接的或编辑者的文档/教程</td>
<td align="center">笔者提供了一个油管<a href="https://www.youtube.com/watch?v=yLLzBsEtyiQ&feature=youtu.be">简介视频</a>,没有提供文档也通过了，不过还是推荐做一个文档</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">.uproject已禁用未使用的插件</td>
<td align="center">关闭不适用的插件，系统默认开启的不用理会</td>
</tr>
</tbody></table>
<h5 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h5><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">信息</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">内容主要不包括易于复制的资产</td>
<td align="center">不清楚，笔者没有被打回</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">资产不包含视觉缺陷</td>
<td align="center">字面意思</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">资产运作不影响绩效</td>
<td align="center">这个翻译的不太对，应该是不影响性能之类的意思</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><strong>所有资产均已完成且功能正常</strong></td>
<td align="center">这个笔者被打回了若干次，项目不能有明显的错误，不仅仅是编译运行错误，你游戏逻辑有错误也不行，笔者的demo里释放一个技能的时候有弹道错误也被打回来了，测试员还是蛮仔细的</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">产品包含总体良好的设计和概念</td>
<td align="center">屁话</td>
</tr>
</tbody></table>
<h5 id="法律"><a href="#法律" class="headerlink" title="法律"></a>法律</h5><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">信息</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><strong>发布者拥有分发包含在产品中或由产品依赖的所有内容的合法权利</strong></td>
<td align="center">重头戏，资源的版权问题，如果你的美术资源都是自己做的就忽略本条，否则见下<br />1.Epic免费资源可以随意使用<br />2.其他第三方免费资源包括月限免的都不能使用<br />3.音效比较难定义，除非太过明显；BGM之类的不行，音乐是容易界定版权的<br />4.动画其实不容易界定版权，但是商城痕迹太明显的肯定不行<br />5.图片和模型资源版权容易界定，不要使用商城禁止的资源<br /></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">不包含版权或商标内容</td>
<td align="center">参考第一条，第一条过了这里基本也过了</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Epic Games的示例内容或源代码的大部分内容仅用于显示/示例</td>
<td align="center">意思应该就是字面意思，不要用示例工程的资源就没事了</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">未经修改的公共领域内容仅限于帮助演示，并且在描述中引用了来源</td>
<td align="center">遵循第一条</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">产品不包含可能令人反感的资产</td>
<td align="center">*</td>
</tr>
</tbody></table>
<h5 id="依赖问题"><a href="#依赖问题" class="headerlink" title="依赖问题"></a>依赖问题</h5><ul>
<li>这个工程不要依赖于其他工程</li>
</ul>
<h5 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h5><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">信息</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">必须要有地图来展示内容</td>
<td align="center">要有正式地图，建议启动地图就是正式地图</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><strong>所有地图均已建立照明</strong></td>
<td align="center">容易被忽略的一条，记得提交之前构造光照</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">地图不会产生任何错误或相应的警告</td>
<td align="center">提交之前修复所有报错信息，容易犯错的是资源引用错误</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">地图没有Z形战斗或重叠的多边形</td>
<td align="center">啥翻译！！不要有重面就可以</td>
</tr>
</tbody></table>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ol>
<li>提交的版本需要支持当前最新版本，笔者在第一次提交的时候还是4.24版本，后面被打回后UE很不合时宜的升级到了4.25，结果工程必须升级到4.25进行重新测试，当中还遇到了很多崩溃问题，这个比较头痛</li>
</ol>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>虚幻商城</tag>
      </tags>
  </entry>
  <entry>
    <title>关卡切换</title>
    <url>/2021/05/19/%E5%85%B3%E5%8D%A1%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UE4 中主要有两种转移方式：无缝和非无缝方式</p>
<p>我们平时用的最多的<code>OpenLevel</code>节点就是非无缝的, 本文主要对这些方式记录一番</p>
<span id="more"></span>





<h2 id="OpenLevel"><a href="#OpenLevel" class="headerlink" title="OpenLevel"></a>OpenLevel</h2><p><img src="https://img.supervj.top//img/image-20210519170513578.png" alt="image-20210519170513578"></p>
<p>这是我们最常用的关卡切换的方法, 本质上都是从客户端调用了<code>GEngine-&gt;SetClientTravel()</code>函数, 然后到下一帧的时候调用 <code>UEngine::Browse()</code></p>
<h2 id="UEngine-Browse"><a href="#UEngine-Browse" class="headerlink" title="UEngine::Browse"></a>UEngine::Browse</h2><blockquote>
<ul>
<li>就像是加载新地图时的硬重置。</li>
<li>将始终导致非无缝切换。</li>
<li>将导致服务器在切换到目标地图前与当前客户端断开连接。</li>
<li>客户端将与当前服务器断开连接。</li>
<li>专用服务器无法切换至其他服务器，因此地图必须存储在本地（不能是 URL）。</li>
</ul>
</blockquote>
<p>引用官网的一段话来解释这个方法</p>
<h2 id="UWorld-ServerTravel"><a href="#UWorld-ServerTravel" class="headerlink" title="UWorld::ServerTravel"></a>UWorld::ServerTravel</h2><p>此方式为<strong>无缝切换</strong></p>
<p>先引用一个端官网的话</p>
<blockquote>
<ul>
<li>仅适用于服务器。</li>
<li>会将服务器跳转到新的世界/场景。</li>
<li>所有连接的客户端都会跟随。</li>
<li>这就是多人游戏在地图之间转移时所用的方法，而服务器将负责调用此函数。</li>
<li>服务器将为所有已连接的客户端玩家调用 <code>APlayerController::ClientTravel</code>。</li>
</ul>
</blockquote>
<p>比如多个玩家在完成连接了以后一起下副本就需要使用此方法讲所有人一起传送到指定关卡中, 不然就断开了</p>
<p>此方法需要cpp的支持, 纯蓝图无法完成这个操作;</p>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>蓝图无法调用这个方法, 我们先封装一个函数库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UFlib_Utilities::ServerTravel</span><span class="params">(<span class="keyword">const</span> UObject* WorldContextObject, <span class="keyword">const</span> FString&amp; InURL, <span class="keyword">bool</span> bAbsolute, <span class="keyword">bool</span> bShouldSkipGameNotify)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (WorldContextObject)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (UWorld* wd = WorldContextObject-&gt;<span class="built_in">GetWorld</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> wd-&gt;<span class="built_in">ServerTravel</span>(InURL, bAbsolute, bShouldSkipGameNotify);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210520102036305.png" alt="image-20210520102036305"></p>
<h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><p>首先要开启传送选项</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bUseSeamlessTravel = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>然后需要重写如下方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetSeamlessTravelActorList</span><span class="params">(<span class="keyword">bool</span> bToTransition, TArray&lt;AActor*&gt;&amp; ActorList)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p>为了方便蓝图扩展, 我们声明一个蓝图方法来添加额外的传送对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line">		<span class="function">TArray&lt;AActor*&gt;  <span class="title">BP_GetSeamlessTravelActorList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>最终形态</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AUtilityGameModeBase::<span class="built_in">AUtilityGameModeBase</span>()</span><br><span class="line">&#123;</span><br><span class="line">	bUseSeamlessTravel = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AUtilityGameModeBase::GetSeamlessTravelActorList</span><span class="params">(<span class="keyword">bool</span> bToTransition, TArray&lt;AActor*&gt;&amp; ActorList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//父类方法添加了PlayerController等, 必须得调用</span></span><br><span class="line">	Super::<span class="built_in">GetSeamlessTravelActorList</span>(bToTransition, ActorList);</span><br><span class="line">	ActorList.<span class="built_in">Append</span>(<span class="built_in">BP_GetSeamlessTravelActorList</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210519172551789.png" alt="image-20210519172551789"></p>
<h3 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h3><blockquote>
<p> 服务器将为所有已连接的客户端玩家调用 <code>APlayerController::ClientTravel</code>。</p>
</blockquote>
<p>所以在玩家控制器里, 同样有方法支持传送目标</p>
<ul>
<li>最终形态</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPlayerController::GetSeamlessTravelActorList</span><span class="params">(<span class="keyword">bool</span> bToEntry, TArray&lt;class AActor*&gt;&amp; ActorList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">GetSeamlessTravelActorList</span>(bToEntry, ActorList);</span><br><span class="line">	ActorList.<span class="built_in">Append</span>(<span class="built_in">BP_GetSeamlessTravelActorList</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="过渡地图"><a href="#过渡地图" class="headerlink" title="过渡地图"></a>过渡地图</h3><p><img src="https://img.supervj.top//img/image-20210519171342531.png" alt="image-20210519171342531"></p>
<p>我们可以在项目设置里设置一个过渡地图,  不过因为这个地图就一瞬间就完成了, 个人觉得意义不大</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>只有服务端可以发起传送</li>
<li>玩家和玩家控制器会默认传送</li>
<li>多数状态(变量)不会传送, <code>BeginPlay()</code>等会重新执行一遍</li>
<li>测试发现对新创建的对象的静态模型修改材质/Scale3D等会传送到新关卡</li>
<li>玩家模型修改材质\Scale或者修改动画状态都无法传送到新关卡(问号脸)</li>
<li>如果是放置/Spawn在世界空间的对象, 传送以后会出现在相同位置</li>
<li>Attach等操作无法传送, 如果一把武器在0点创建后Attach到玩家手上并添加到传送列表,传送以后还是出现在0点并不会Attach到玩家手上</li>
<li>对于GameMode的传送对象, 如果未开启同步, 那么只会在服务端传送</li>
<li>对于PlayerController的传送对象, 如果未开启同步, 只会在本地传送</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_05_19_18_27_22_113.gif" alt="录制_2021_05_19_18_27_22_113"></p>
<ol>
<li>服务端创建cube</li>
<li>客户端创建sphere</li>
<li>创建5秒以后修改scale和材质为红色</li>
<li>传送以后颜色和scale传递了过去</li>
</ol>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_05_19_18_32_04_186.gif" alt="录制_2021_05_19_18_32_04_186"></p>
<ol>
<li>修改玩家模型的材质和缩放</li>
<li>无法传送这些状态</li>
</ol>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>关卡</tag>
      </tags>
  </entry>
  <entry>
    <title>RootMotion控制</title>
    <url>/2021/05/28/%E5%8A%A8%E6%80%81RootMotion/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>根骨骼运动（RootMotion）的位移都是固定的， 但是我们在实际运用中经常想动态的控制角色的位置和旋转，比如挥砍动作在怪物跟前了就应该停止位移，翻墙动作与障碍物的距离适配等</p>
<p>本文实现了2个方案， 其中之一就包括基于最近上线的UE5新插件RootMotionWarping的方案</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_05_28_12_24_19_375.gif"></p>
<span id="more"></span>

<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_05_28_11_19_36_434.gif" alt="录制_2021_05_28_11_19_36_434"></p>
<p>如上图我们有一个翻越障碍物的动作， 此动作的起始到手撑地的前方向位移大约是120-140之间， Z方向位移大约100出头，翻越后半段前方向位移大约200不到</p>
<blockquote>
<p>不需要太精确</p>
</blockquote>
<h2 id="方案一：手动计算位移"><a href="#方案一：手动计算位移" class="headerlink" title="方案一：手动计算位移"></a>方案一：手动计算位移</h2><p>此方案我们关闭<code>RootMotion</code>, 提取所有位移信息，然后我们手动来刷新位置，同时根据障碍物的情况来动态控制位移信息</p>
<p>首先我们需要生成根骨骼运动的位移信息，可以通过一个动画修改器<code>AnimationModifier</code>来得到</p>
<p>主要内容如下截图</p>
<p><img src="https://img.supervj.top//img/image-20210528113152287.png" alt="image-20210528113152287"></p>
<p>然后得到曲线</p>
<p><img src="https://img.supervj.top//img/image-20210528113248295.png" alt="image-20210528113248295"></p>
<p>然后用一个辅助宏来处理位移</p>
<p><img src="https://img.supervj.top//img/image-20210528113332996.png" alt="image-20210528113332996"></p>
<p><img src="https://img.supervj.top//img/image-20210528113410020.png" alt="image-20210528113410020"></p>
<p><code>XYPlaneDistance</code>是开始播放动画与距离障碍物的距离，通过射线检测得到</p>
<p>实测效果感觉手部位置用<code>100-XYPlaneDistance</code>比较合适，因为手的位移跟<code>root</code>骨骼有区别</p>
<p>而<code>ZScale</code>我们通过射线检测得到障碍物顶部的点到地面的距离与我们动画Z位移的百分比</p>
<ul>
<li>简单的测试效果</li>
</ul>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_05_28_11_45_18_258.gif" alt="录制_2021_05_28_11_45_18_258"></p>
<blockquote>
<p>这里有个小问题，如果障碍物太宽， 那么我们需要对后半段的位移进行额外处理，不然就直接站上去了</p>
</blockquote>
<h2 id="方案二：MotionWarping"><a href="#方案二：MotionWarping" class="headerlink" title="方案二：MotionWarping"></a>方案二：MotionWarping</h2><p>UE5新出现在动画模块内的一个插件，专门来控制<code>RootMotion</code>的位移</p>
<p><img src="https://img.supervj.top//img/image-20210528114755745.png" alt="image-20210528114755745"></p>
<p>主要通过一个动画通知来实现， 然后就在合适的时机（播放蒙太奇之前）设置对应的数据即可</p>
<p><img src="https://img.supervj.top//img/image-20210528114937614.png" alt="image-20210528114937614"></p>
<p><img src="https://img.supervj.top//img/image-20210528114950721.png" alt="image-20210528114950721"></p>
<p>通过很多射线组合得到障碍物合适的顶部点以及翻越后的着地点，直接通过上图的方法设置即可</p>
<p>然后我们通过判断障碍物大小来决定播放哪个动画（另外一个动画为UE5实例项目的翻越动画）</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_05_28_12_24_19_375.gif"></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>RootMotion</tag>
      </tags>
  </entry>
  <entry>
    <title>动态创建Texture2D</title>
    <url>/2022/05/22/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BATexture2D/</url>
    <content><![CDATA[<p>直接贴代码</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">UTexture2D* <span class="title">ULibNextBridge::CreateTexture2dAsset_ByPixels</span><span class="params">(FString TextureName, FString Path, <span class="keyword">const</span> TArray&lt;FColor&gt;&amp; FillPixels,</span></span></span><br><span class="line"><span class="params"><span class="function">	int32 Width, int32 Height, EPixelFormat PixelFormat, <span class="keyword">bool</span> sRGB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TArray&lt;FColor&gt; Pixels = FillPixels;</span><br><span class="line">	<span class="comment">//创建非重复的名字</span></span><br><span class="line">	FString UniquePackageName;</span><br><span class="line">	FString UniqueAssetName;</span><br><span class="line">	FAssetToolsModule&amp; AssetToolsModule = FModuleManager::<span class="built_in">Get</span>().LoadModuleChecked&lt;FAssetToolsModule&gt;(<span class="string">&quot;AssetTools&quot;</span>);</span><br><span class="line">	AssetToolsModule.<span class="built_in">Get</span>().<span class="built_in">CreateUniqueAssetName</span>(Path + TextureName, <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>), UniquePackageName, UniqueAssetName);</span><br><span class="line">	<span class="comment">//创建包</span></span><br><span class="line">	UPackage* Package = <span class="built_in">CreatePackage</span>( *UniquePackageName);</span><br><span class="line">	Package-&gt;<span class="built_in">FullyLoad</span>();</span><br><span class="line">	<span class="comment">//创建贴图资源</span></span><br><span class="line">	UTexture2D* res = NewObject&lt;UTexture2D&gt;(Package, *UniqueAssetName, RF_Public | RF_Standalone | RF_MarkAsRootSet);</span><br><span class="line">	res-&gt;<span class="built_in">AddToRoot</span>();</span><br><span class="line">	res-&gt;SRGB = sRGB;</span><br><span class="line">	res-&gt;MipGenSettings = TMGS_NoMipmaps;</span><br><span class="line">	<span class="comment">//创建PlatformData数据</span></span><br><span class="line">	FTexturePlatformData* PlatformData = <span class="keyword">new</span> <span class="built_in">FTexturePlatformData</span>();</span><br><span class="line">	PlatformData-&gt;SizeX = Width;</span><br><span class="line">	PlatformData-&gt;SizeY = Height;</span><br><span class="line">	PlatformData-&gt;PixelFormat = PixelFormat;</span><br><span class="line">	res-&gt;<span class="built_in">SetPlatformData</span>(PlatformData);</span><br><span class="line">	res-&gt;<span class="built_in">UpdateResource</span>();</span><br><span class="line">	FTexture2DMipMap* Mip = <span class="keyword">new</span> <span class="built_in">FTexture2DMipMap</span>();</span><br><span class="line">	res-&gt;<span class="built_in">GetPlatformData</span>()-&gt;Mips.<span class="built_in">Add</span>(Mip);</span><br><span class="line">	Mip-&gt;SizeX = Width;</span><br><span class="line">	Mip-&gt;SizeY = Height;</span><br><span class="line"> 	<span class="comment">//写入像素数据</span></span><br><span class="line">	Mip-&gt;BulkData.<span class="built_in">Lock</span>(LOCK_READ_WRITE);</span><br><span class="line">	uint8* TextureData = <span class="keyword">static_cast</span>&lt;uint8*&gt;(Mip-&gt;BulkData.<span class="built_in">Realloc</span>(Width * Height * <span class="built_in"><span class="keyword">sizeof</span></span>(FColor)));</span><br><span class="line">	FMemory::<span class="built_in">Memcpy</span>(TextureData, Pixels.<span class="built_in">GetData</span>(), Width * Height * <span class="built_in"><span class="keyword">sizeof</span></span>(FColor));</span><br><span class="line">	Mip-&gt;BulkData.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">	res-&gt;<span class="built_in">UpdateResource</span>();</span><br><span class="line"> 	<span class="comment">//初始化source数据</span></span><br><span class="line">	res-&gt;Source.<span class="built_in">Init</span>(Width,Height,<span class="number">1</span>, <span class="number">1</span>, ETextureSourceFormat::TSF_BGRA8, <span class="keyword">reinterpret_cast</span>&lt;uint8*&gt;(Pixels.<span class="built_in">GetData</span>()));</span><br><span class="line">	res-&gt;<span class="built_in">UpdateResource</span>();</span><br><span class="line">	Package-&gt;<span class="built_in">MarkPackageDirty</span>();</span><br><span class="line">    <span class="comment">//注册资源</span></span><br><span class="line">	FAssetRegistryModule::<span class="built_in">AssetCreated</span>(res);</span><br><span class="line">	<span class="comment">//创建LongPackageName, 并保存包</span></span><br><span class="line">	FString PackageFileName = FPackageName::<span class="built_in">LongPackageNameToFilename</span>(UniquePackageName, FPackageName::<span class="built_in">GetAssetPackageExtension</span>());</span><br><span class="line">	FSavePackageArgs SavePackageArgs;</span><br><span class="line">	SavePackageArgs.TopLevelFlags = RF_Public | RF_Standalone;</span><br><span class="line">	SavePackageArgs.SaveFlags = SAVE_NoError;</span><br><span class="line">	<span class="keyword">bool</span> bSaved = UPackage::<span class="built_in">SavePackage</span>(Package,<span class="literal">NULL</span>,*PackageFileName,SavePackageArgs);</span><br><span class="line">	<span class="built_in">check</span>(bSaved)</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>texture</tag>
      </tags>
  </entry>
  <entry>
    <title>创建自定义编辑器</title>
    <url>/2021/04/21/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久以前项目需求Paper2D动画, Paper2D切换动画不是很方便, 最好还是用类似动画蓝图的状态机,但是UE目前的状态机只有动画蓝图和AI行为树, 于是那个时候就想做一个自定义的状态机,但是后来项目搁浅就没动机继续研究了, 现在凑空来搞一搞这个蛮有用的东西(也很利于了解UE编辑器)</p>
<p><img src="https://img.supervj.top//img/image-20210421113343319.png" alt="image-20210421113343319"></p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_04_21_15_01_58_451.gif" alt="录制_2021_04_21_15_01_58_451"></p>
<span id="more"></span>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>自定义编辑器涉及到的类特别的多, 刚入手非常头疼, 我们先大概罗列一下需要用到的类及用途</p>
<ul>
<li><p><strong>UBlueprint</strong>: 编辑器界面的资源, 注意: 这个类不是被编辑和生成的对象</p>
</li>
<li><p><strong>Instance</strong>类: 一般继承自UObject, 是UBlueprint的ParentClass, 这个是编辑器编辑的类和生成的对象</p>
</li>
<li><p><strong>AssetEdtor</strong>: 资源编辑器,双击资源以后第一时间打开的界面的总管理者</p>
</li>
<li><p><strong>ApplicationMode</strong>: 界面模式, 用于自定义布局和添加自定义界面, 在<strong>AssetEdtor</strong>中注册</p>
</li>
<li><p><strong>AssetTypeAction</strong>: 定义创建资源的样式, 包括分类,颜色,对应的资源类和关键的<code>OpenAssetEditor()</code>操作</p>
</li>
<li><p><strong>Factory</strong>: 创建和托管资源, 定义了点击图标创建蓝图资源的过程</p>
</li>
<li><p><strong>Graph</strong> : <code>Editor</code>中的视图,比如蓝图中带网格的那种; 在<code>Editor</code>中创建和获取</p>
</li>
<li><p><em><strong>Schema</strong></em>: 定义视图中的规则, 比如连线规则,创建Node规则等;  在<code>Graph</code>创建的时候指定, 与<code>Graph</code>一般是组合出现</p>
</li>
<li><p><strong>ActionMenu</strong>: <code>Slate</code>类, 右键点击视图的菜单,用于选择节点</p>
</li>
<li><p><strong>SchemaAction</strong>:  <code>ActionMenu</code>中的每一个功能节点, 用于创建Node等</p>
</li>
<li><p><strong>Node</strong>: 视图中的蓝图节点, 表示的是一个函数或者状态机</p>
<ul>
<li><strong>UEdGraphNode</strong> : <code>Node</code>对象</li>
<li><strong>SGraphNode</strong>: <code>Slate</code>类, 定义<code>Node</code>的显示样式</li>
</ul>
</li>
<li><p><strong>GraphXXXXFactory</strong>: 实现节点/引脚/连线的创建的工厂类, 同时也定义了Node的对象与于此对应Slate类</p>
</li>
<li><p><strong>Pin</strong>: Node之间连接的引脚</p>
</li>
<li><p><em><strong>Connection Drawing Policy</strong></em>: <code>Pin</code>之间连接的样式定义,包含颜色,线条样式等</p>
</li>
<li><p><strong>INameValidatorInterface</strong> : 负责<code>Node</code>重命名逻辑的类接口, 通过重写<code>Node</code>中的<code>MakeNameValidator()</code>方法指定重命名对象;如果要判断名字有效性和重复等就需要用到此类</p>
</li>
</ul>
<h2 id="创建资源"><a href="#创建资源" class="headerlink" title="创建资源"></a>创建资源</h2><p>第一部, 我们需要创建资源,  这一步我们参考我之前的文章<a href="https://supervj.top/2020/07/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90/?highlight=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90">自定义资源</a>, 如果需要自定义样式如图标/缩略图等, 请参考<a href="https://supervj.top/2021/04/12/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Slate%E7%AC%94%E5%88%B7/">使用自定义Slate笔刷</a></p>
<h2 id="AssetEditor"><a href="#AssetEditor" class="headerlink" title="AssetEditor"></a>AssetEditor</h2><p>我们在打开资源的地方对Editor进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FVSM_AssetTypeAction::OpenAssetEditor</span><span class="params">(<span class="keyword">const</span> TArray&lt;UObject*&gt;&amp; InObjects, TSharedPtr&lt;class IToolkitHost&gt; EditWithinLevelEditor <span class="comment">/*= TSharedPtr&lt;IToolkitHost&gt;()*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EToolkitMode::Type Mode = EditWithinLevelEditor.<span class="built_in">IsValid</span>() ? EToolkitMode::WorldCentric : EToolkitMode::Standalone;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> ObjIt = InObjects.<span class="built_in">CreateConstIterator</span>(); ObjIt; ++ObjIt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> Blueprint = Cast&lt;UBlueprint&gt;(*ObjIt);</span><br><span class="line">		<span class="keyword">if</span> (Blueprint &amp;&amp; Blueprint-&gt;SkeletonGeneratedClass &amp;&amp; Blueprint-&gt;GeneratedClass &amp;&amp; Blueprint-&gt;IsA&lt;UVSM_Blueprint&gt;())</span><br><span class="line">		&#123;</span><br><span class="line">			FVSMEditorModule&amp; VSMEModule = FModuleManager::LoadModuleChecked&lt;FVSMEditorModule&gt;(<span class="string">&quot;VSMEditor&quot;</span>);</span><br><span class="line">			VSMEModule.<span class="built_in">CreateEditor</span>(Mode,EditWithinLevelEditor,Blueprint);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			FMessageDialog::<span class="built_in">Open</span>(EAppMsgType::Ok, <span class="built_in">LOCTEXT</span>(<span class="string">&quot;OpenStateMachineBlueprint Failed!!&quot;</span>, <span class="string">&quot;State machine Blueprint could not be loaded because it derives from an invalid class.\nCheck to make sure the parent class for this blueprint hasn&#x27;t been removed!&quot;</span>));</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TSharedRef&lt;FVSM_Editor&gt; <span class="title">FVSMEditorModule::CreateEditor</span><span class="params">(<span class="keyword">const</span> EToolkitMode::Type Mode, <span class="keyword">const</span> TSharedPtr&lt; class IToolkitHost &gt;&amp; InitToolkitHost, UBlueprint* BP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CreateClassCache</span>();<span class="comment">//用于记录特定资源类</span></span><br><span class="line">	<span class="function">TSharedRef&lt;FVSM_Editor&gt; <span class="title">editor</span><span class="params">(<span class="keyword">new</span> FVSM_Editor())</span></span>;</span><br><span class="line">	editor-&gt;<span class="built_in">InitEditor</span>(Mode, InitToolkitHost, BP);</span><br><span class="line">	<span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化的内容比较多, 重点就是如下几条, 其实可以模仿动画蓝图的初始化或者蓝图编辑器的初始化过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//创建自定义视图</span></span><br><span class="line"><span class="keyword">if</span> (!SMBP-&gt;Graph)</span><br><span class="line">	&#123;</span><br><span class="line">		UVSM_Graph* StateMachineGraph = CastChecked&lt;UVSM_Graph&gt;(FBlueprintEditorUtils::<span class="built_in">CreateNewGraph</span>(SMBP, NAME_None, UVSM_Graph::<span class="built_in">StaticClass</span>(), UVSM_Schema::<span class="built_in">StaticClass</span>()));</span><br><span class="line">		<span class="keyword">if</span> (StateMachineGraph)</span><br><span class="line">			SMBP-&gt;Graph = StateMachineGraph;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//初始化视图</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">GetGraph</span>()-&gt;<span class="built_in">Init</span>(SMBP, ThisPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建工具栏</span></span><br><span class="line"></span><br><span class="line">Toolbar = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FVSM_Toolbar</span>(ThisPtr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并设置模式</span></span><br><span class="line">	<span class="built_in">AddApplicationMode</span>(FVSM_AppMode_BlueprintEditor::ModeName, <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FVSM_AppMode_BlueprintEditor</span>(ThisPtr, FVSM_AppMode_BlueprintEditor::ModeName)));</span><br><span class="line">	<span class="built_in">SetCurrentMode</span>(FVSM_AppMode_BlueprintEditor::ModeName);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们这里用了自定义的细节面板, 就需要使用<code>Persona</code>模块, 因为选中Node以后细节面板对应的信息我们需要自定义</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FPersonaModule&amp; PersonaModule = FModuleManager::GetModuleChecked&lt;FPersonaModule&gt;(<span class="string">&quot;Persona&quot;</span>);</span><br><span class="line"><span class="comment">//这一步需要放到最后, 否则Inspector还没创建</span></span><br><span class="line">PersonaModule.<span class="built_in">CustomizeBlueprintEditorDetails</span>(Inspector-&gt;<span class="built_in">GetPropertyView</span>().<span class="built_in">ToSharedRef</span>(), FOnInvokeTab::<span class="built_in">CreateSP</span>(<span class="keyword">this</span>, &amp;FAssetEditorToolkit::InvokeTab));</span><br></pre></td></tr></table></figure>







<h2 id="ApplicationMode"><a href="#ApplicationMode" class="headerlink" title="ApplicationMode"></a>ApplicationMode</h2><p>模式在Editor初始化的时候创建和添加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FVSM_AppMode_BlueprintEditor</span> :</span> <span class="keyword">public</span> FBlueprintEditorApplicationMode</span><br></pre></td></tr></table></figure>

<p>我们直接继承自蓝图编辑器模式(没必要自己造轮子)</p>
<p>关键就俩函数, 构造函数和<code>RegisterTabFactories()</code></p>
<p>构造函数需要传入<code>Editor</code>和模式名称</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FVSM_AppMode_BlueprintEditor::<span class="built_in">FVSM_AppMode_BlueprintEditor</span>(TSharedPtr&lt;class FVSM_Editor&gt; InStateMachineEditor, FName InModeName)</span><br><span class="line">	: <span class="built_in">FBlueprintEditorApplicationMode</span>(InStateMachineEditor, InModeName, FVSM_AppMode_BlueprintEditor::GetLocalizedMode, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	Editor = InStateMachineEditor;</span><br><span class="line"></span><br><span class="line">	TabLayout = FTabManager::<span class="built_in">NewLayout</span>(<span class="string">&quot;WidgetBlueprintEditor_Graph_Layout_v1&quot;</span>)</span><br><span class="line">		-&gt;<span class="built_in">AddArea</span></span><br><span class="line">		(</span><br><span class="line">			FTabManager::<span class="built_in">NewPrimaryArea</span>()-&gt;<span class="built_in">SetOrientation</span>(Orient_Vertical)</span><br><span class="line">			-&gt;<span class="built_in">Split</span></span><br><span class="line">			(</span><br><span class="line">				FTabManager::<span class="built_in">NewStack</span>()</span><br><span class="line">				-&gt;<span class="built_in">SetSizeCoefficient</span>(<span class="number">0.186721f</span>)</span><br><span class="line">				-&gt;<span class="built_in">SetHideTabWell</span>(<span class="literal">true</span>)</span><br><span class="line">				-&gt;<span class="built_in">AddTab</span>(InStateMachineEditor-&gt;<span class="built_in">GetToolbarTabId</span>(), ETabState::OpenedTab)</span><br><span class="line">			)</span><br><span class="line">			-&gt;<span class="built_in">Split</span></span><br><span class="line">			(</span><br><span class="line">				FTabManager::<span class="built_in">NewSplitter</span>()-&gt;<span class="built_in">SetOrientation</span>(Orient_Horizontal)</span><br><span class="line">				-&gt;<span class="built_in">Split</span></span><br><span class="line">				(</span><br><span class="line">					FTabManager::<span class="built_in">NewSplitter</span>()-&gt;<span class="built_in">SetOrientation</span>(Orient_Vertical)</span><br><span class="line">					-&gt;<span class="built_in">SetSizeCoefficient</span>(<span class="number">0.15f</span>)</span><br><span class="line">					-&gt;<span class="built_in">Split</span></span><br><span class="line">					(</span><br><span class="line">						FTabManager::<span class="built_in">NewStack</span>()-&gt;<span class="built_in">SetSizeCoefficient</span>(<span class="number">0.5f</span>)</span><br><span class="line">						-&gt;<span class="built_in">AddTab</span>(FBlueprintEditorTabs::MyBlueprintID, ETabState::OpenedTab)</span><br><span class="line">					)</span><br><span class="line">					-&gt;<span class="built_in">Split</span></span><br><span class="line">					(</span><br><span class="line">						FTabManager::<span class="built_in">NewStack</span>()-&gt;<span class="built_in">SetSizeCoefficient</span>(<span class="number">0.5f</span>)</span><br><span class="line">						-&gt;<span class="built_in">AddTab</span>(FBlueprintEditorTabs::DetailsID, ETabState::OpenedTab)</span><br><span class="line">					)</span><br><span class="line">				)</span><br><span class="line">				-&gt;<span class="built_in">Split</span></span><br><span class="line">				(</span><br><span class="line">					FTabManager::<span class="built_in">NewSplitter</span>()-&gt;<span class="built_in">SetOrientation</span>(Orient_Vertical)</span><br><span class="line">					-&gt;<span class="built_in">SetSizeCoefficient</span>(<span class="number">0.70f</span>)</span><br><span class="line">					-&gt;<span class="built_in">Split</span></span><br><span class="line">					(</span><br><span class="line">						FTabManager::<span class="built_in">NewStack</span>()</span><br><span class="line">						-&gt;<span class="built_in">SetSizeCoefficient</span>(<span class="number">0.80f</span>)</span><br><span class="line">						</span><br><span class="line">						-&gt;<span class="built_in">AddTab</span>(<span class="string">&quot;Document&quot;</span>, ETabState::ClosedTab)</span><br><span class="line">						-&gt;<span class="built_in">AddTab</span>(FVSM_Editor::TabId_GraphCanvas, ETabState::OpenedTab)</span><br><span class="line">						-&gt;<span class="built_in">SetForegroundTab</span>(FVSM_Editor::TabId_GraphCanvas)</span><br><span class="line">					)</span><br><span class="line">					-&gt;<span class="built_in">Split</span></span><br><span class="line">					(</span><br><span class="line">						FTabManager::<span class="built_in">NewStack</span>()</span><br><span class="line">						-&gt;<span class="built_in">SetSizeCoefficient</span>(<span class="number">0.20f</span>)</span><br><span class="line">						-&gt;<span class="built_in">AddTab</span>(FBlueprintEditorTabs::CompilerResultsID, ETabState::OpenedTab)</span><br><span class="line">						-&gt;<span class="built_in">AddTab</span>(FBlueprintEditorTabs::FindResultsID, ETabState::OpenedTab)</span><br><span class="line">					)</span><br><span class="line">				)</span><br><span class="line">				-&gt;<span class="built_in">Split</span></span><br><span class="line">				(</span><br><span class="line">					FTabManager::<span class="built_in">NewSplitter</span>()-&gt;<span class="built_in">SetOrientation</span>(Orient_Vertical)</span><br><span class="line">					-&gt;<span class="built_in">SetSizeCoefficient</span>(<span class="number">0.15f</span>)</span><br><span class="line">					-&gt;<span class="built_in">Split</span></span><br><span class="line">					(</span><br><span class="line">						FTabManager::<span class="built_in">NewStack</span>()</span><br><span class="line">						-&gt;<span class="built_in">AddTab</span>(FBlueprintEditorTabs::PaletteID, ETabState::ClosedTab)</span><br><span class="line">					)</span><br><span class="line">				)</span><br><span class="line">			)</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//InStateMachineEditor-&gt;GetToolbarBuilder()-&gt;AddWidgetBlueprintEditorModesToolbar(ToolbarExtender);</span></span><br><span class="line">	<span class="keyword">if</span> (UToolMenu* Toolbar = InStateMachineEditor-&gt;<span class="built_in">RegisterModeToolbarIfUnregistered</span>(<span class="built_in">GetModeName</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		InStateMachineEditor-&gt;<span class="built_in">GetToolbarBuilder</span>()-&gt;<span class="built_in">AddCompileToolbar</span>(Toolbar);</span><br><span class="line">		InStateMachineEditor-&gt;<span class="built_in">GetToolbarBuilder</span>()-&gt;<span class="built_in">AddBlueprintGlobalOptionsToolbar</span>(Toolbar);</span><br><span class="line">		InStateMachineEditor-&gt;<span class="built_in">GetToolbarBuilder</span>()-&gt;<span class="built_in">AddDebuggingToolbar</span>(Toolbar);</span><br><span class="line">		InStateMachineEditor-&gt;<span class="built_in">GetToolbarBuilder</span>()-&gt;<span class="built_in">AddScriptingToolbar</span>(Toolbar);</span><br><span class="line">		InStateMachineEditor-&gt;<span class="built_in">GetToolbarBuilder</span>()-&gt;<span class="built_in">AddNewToolbar</span>(Toolbar);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FVSM_AppMode_BlueprintEditor::RegisterTabFactories</span><span class="params">(TSharedPtr&lt;FTabManager&gt; InTabManager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TSharedPtr&lt;FVSM_Editor&gt; ed = <span class="built_in">GetEditor</span>();</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">auto</span> icon = FVSM_Style::<span class="built_in">GetBrush</span>(<span class="string">&quot;VSM.StateMachineGraphSmall&quot;</span>);</span><br><span class="line">	WorkspaceMenuCategory = InTabManager-&gt;<span class="built_in">AddLocalWorkspaceMenuCategory</span>(<span class="built_in">LOCTEXT</span>(<span class="string">&quot;WorkspaceMenu_StateMachineEditor&quot;</span>, <span class="string">&quot;State Machine&quot;</span>));</span><br><span class="line">	<span class="keyword">auto</span> WorkspaceMenuCategoryRef = WorkspaceMenuCategory.<span class="built_in">ToSharedRef</span>();</span><br><span class="line">	InTabManager-&gt;<span class="built_in">RegisterTabSpawner</span>(FVSM_Editor::TabId_GraphCanvas, FOnSpawnTab::<span class="built_in">CreateSP</span>(ed.<span class="built_in">Get</span>(), &amp;FVSM_Editor::SpawnTab_GraphCanvas))</span><br><span class="line">		.<span class="built_in">SetDisplayName</span>(<span class="built_in">LOCTEXT</span>(<span class="string">&quot;GraphCanvasTab&quot;</span>, <span class="string">&quot;State Machine Graph&quot;</span>))</span><br><span class="line">		.<span class="built_in">SetGroup</span>(WorkspaceMenuCategoryRef)</span><br><span class="line">		<span class="comment">//.SetIcon(FSlateIcon(FEditorStyle::GetStyleSetName(), &quot;GraphEditor.EventGraph_16x&quot;));</span></span><br><span class="line">		.<span class="built_in">SetIcon</span>(<span class="built_in">FSlateIcon</span>(FVSM_Style::<span class="built_in">GetStyleSetName</span>(), <span class="string">&quot;VSM.StateMachineGraphSmall&quot;</span>));</span><br><span class="line"></span><br><span class="line">	ed-&gt;<span class="built_in">RegisterToolbarTab</span>(InTabManager.<span class="built_in">ToSharedRef</span>());</span><br><span class="line">	ed-&gt;<span class="built_in">PushTabFactories</span>(CoreTabFactories);</span><br><span class="line">	<span class="comment">//如debug,details等所有常用标签</span></span><br><span class="line">	ed-&gt;<span class="built_in">PushTabFactories</span>(BlueprintEditorTabFactories);</span><br><span class="line">	ed-&gt;<span class="built_in">PushTabFactories</span>(TabFactories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VSMEDITOR_API</span> <span class="title">UVSM_Graph</span> :</span> <span class="keyword">public</span> UEdGraph</span><br></pre></td></tr></table></figure>

<p>由Editor初始化, 主要负责Node的操作</p>
<p>如对与一般State节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UVSM_Graph::RegisterNode</span><span class="params">(UVSM_State_Base* State, UVSM_Node* NewNode, UEdGraphPin* FromPin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Modify</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;SMBP-&gt;<span class="built_in">Modify</span>();</span><br><span class="line">	<span class="comment">//Register node to the nodes array</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;SMBP-&gt;Nodes.<span class="built_in">Add</span>(NewNode);</span><br><span class="line">	State-&gt;GraphNode = NewNode;</span><br><span class="line">	NewNode-&gt;State = State;</span><br><span class="line">	NewNode-&gt;<span class="built_in">ReallocateDefaultPins</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Previous node </span></span><br><span class="line">	<span class="keyword">if</span> (FromPin)</span><br><span class="line">	&#123;</span><br><span class="line">		UVSM_Node* FromNode = Cast&lt;UVSM_Node&gt;(FromPin-&gt;<span class="built_in">GetOwningNode</span>());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// apply current blueprint edited</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">SetCurrentStateMachineBlueprintToNode</span>(FromNode);</span><br><span class="line"></span><br><span class="line">				</span><br><span class="line">		<span class="keyword">if</span> (FromNode-&gt;<span class="built_in">IsRootNode</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">SetEntryState</span>(State);</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!NewNode-&gt;<span class="built_in">IsRootNode</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		NewNode-&gt;<span class="built_in">CreateBoundGraph</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">SetCurrentStateMachineBlueprintToNode</span>(NewNode);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// linking between pins</span></span><br><span class="line">	NewNode-&gt;<span class="built_in">AutowireNewNode</span>(FromPin);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NotifyGraphChanged</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VSMEDITOR_API</span> <span class="title">UVSM_Schema</span> :</span> <span class="keyword">public</span> UEdGraphSchema</span><br></pre></td></tr></table></figure>

<p>Schema一般分两种, 还有一种K2版本, 如果是一般蓝图中右键出现的菜单那种都是K2版本的, 能使用K2Node</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//~ Begin EdGraphSchema Interface</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetGraphContextActions</span><span class="params">(FGraphContextMenuBuilder&amp; ContextMenuBuilder)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetContextMenuActions</span><span class="params">(class UToolMenu* Menu, class UGraphNodeContextMenuContext* Context)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> FPinConnectionResponse <span class="title">CanCreateConnection</span><span class="params">(<span class="keyword">const</span> UEdGraphPin* PinA, <span class="keyword">const</span> UEdGraphPin* PinB)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">TryCreateConnection</span><span class="params">(UEdGraphPin* PinA, UEdGraphPin* PinB)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CreateAutomaticConversionNodeAndConnections</span><span class="params">(UEdGraphPin* PinA, UEdGraphPin* PinB)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ShouldHidePinDefaultValue</span><span class="params">(UEdGraphPin* Pin)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FLinearColor <span class="title">GetPinTypeColor</span><span class="params">(<span class="keyword">const</span> FEdGraphPinType&amp; PinType)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BreakNodeLinks</span><span class="params">(UEdGraphNode&amp; TargetNode)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BreakPinLinks</span><span class="params">(UEdGraphPin&amp; TargetPin, <span class="keyword">bool</span> bSendsNodeNotifcation)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BreakSinglePinLink</span><span class="params">(UEdGraphPin* SourcePin, UEdGraphPin* TargetPin)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="comment">//~ End EdGraphSchema Interface</span></span><br></pre></td></tr></table></figure>

<p>重写了很多方法, 从函数名称能看出来, 都是用来控制节点或者引脚之类的东西</p>
<p>重点说明几个函数</p>
<ul>
<li>GetContextMenuActions()</li>
</ul>
<p>右键点击Node以后的操作, 比如这里我们只需要重命名和删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UVSM_Schema::GetContextMenuActions</span><span class="params">(class UToolMenu* Menu, class UGraphNodeContextMenuContext* Context)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Context-&gt;Pin)</span><br><span class="line">	&#123;</span><br><span class="line">		FToolMenuSection&amp; Section = Menu-&gt;<span class="built_in">AddSection</span>(<span class="string">&quot;StateMachineGraphSchemaPinActions&quot;</span>, <span class="built_in">LOCTEXT</span>(<span class="string">&quot;PinActionsMenuHeader&quot;</span>, <span class="string">&quot;Actions&quot;</span>));</span><br><span class="line">		</span><br><span class="line">		Section.<span class="built_in">AddMenuEntry</span>(FGenericCommands::<span class="built_in">Get</span>().Delete);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Context-&gt;Node-&gt;bCanRenameNode)</span><br><span class="line">		&#123;</span><br><span class="line">			Section.<span class="built_in">AddMenuEntry</span>(FGenericCommands::<span class="built_in">Get</span>().Rename);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Super::<span class="built_in">GetContextMenuActions</span>(Menu, Context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>GetGraphContextActions()</li>
</ul>
<p>右键视图的操作, 我们需要讲自定义的Node添加到这里</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UVSM_Schema::GetGraphContextActions</span><span class="params">(FGraphContextMenuBuilder&amp; ContextMenuBuilder)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">TSharedPtr&lt;FVSM_SchemaAction_NewNode&gt; <span class="title">NewStateAction</span><span class="params">(<span class="keyword">new</span> FVSM_SchemaAction_NewNode(</span></span></span><br><span class="line"><span class="params"><span class="function">		LOCTEXT(<span class="string">&quot;DefaultCategory&quot;</span>,<span class="string">&quot;Default&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">		LOCTEXT(<span class="string">&quot;NewState&quot;</span>, <span class="string">&quot;New State ...&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">		LOCTEXT(<span class="string">&quot;NewStateTooltip&quot;</span>, <span class="string">&quot;Add a new Default State&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">	))</span></span>;</span><br><span class="line">	ContextMenuBuilder.<span class="built_in">AddAction</span>(NewStateAction);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">FCategorizedGraphActionListBuilder <span class="title">TasksBuilder</span><span class="params">(TEXT(<span class="string">&quot;Task&quot;</span>))</span></span>;</span><br><span class="line">	FVSMEditorModule&amp; EditorModule = FModuleManager::GetModuleChecked&lt;FVSMEditorModule&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;VSMEditor&quot;</span>));</span><br><span class="line">	FVSM_NodeClassHelper* ClassCache = EditorModule.<span class="built_in">GetClassCache</span>().<span class="built_in">Get</span>();</span><br><span class="line">	TArray&lt;FVSM_NodeClassData&gt; NodeClasses;</span><br><span class="line">	ClassCache-&gt;<span class="built_in">GatherClasses</span>(<span class="literal">false</span>, UVSM_TaskInstance::<span class="built_in">StaticClass</span>(), NodeClasses);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> FVSM_NodeClassData&amp; NodeClass : NodeClasses)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//auto data = NodeClass;</span></span><br><span class="line">		<span class="keyword">const</span> FText NodeTypeName = FText::<span class="built_in">FromString</span>(FName::<span class="built_in">NameToDisplayString</span>(NodeClass.<span class="built_in">ToString</span>()+<span class="built_in">TEXT</span>(<span class="string">&quot; ...&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">		TSharedPtr&lt;FVSM_SchemaAction_NewTaskNode&gt; AddOpAction = UVSM_Schema::<span class="built_in">AddNewTaskNode</span>(TasksBuilder, NodeClass.<span class="built_in">GetCategory</span>(), NodeTypeName, FText::<span class="built_in">GetEmpty</span>(), NodeClass);</span><br><span class="line">	&#125;</span><br><span class="line">	ContextMenuBuilder.<span class="built_in">Append</span>(TasksBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里用到一个类<code>FVSM_NodeClassHelper</code>, 写法完全参考行为树的一个类似的Helper类(<code>FGraphNodeClassHelper</code>), 主要就是检索资源中的类用于创建自定义节点(参考行为树的Task)</p>
<p>我们可以完全复制其代码过来, 然后就会发现引擎会崩溃, 只需要在构造函数和析构函数中加入一些判断, 毕竟我们的模块不是引擎亲生的, 如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (GEditor)</span><br><span class="line">&#123;</span><br><span class="line">   GEditor-&gt;<span class="built_in">OnBlueprintCompiled</span>().<span class="built_in">AddRaw</span>(<span class="keyword">this</span>, &amp;FVSM_NodeClassHelper::InvalidateCache);</span><br><span class="line">		GEditor-&gt;<span class="built_in">OnClassPackageLoadedOrUnloaded</span>().<span class="built_in">AddRaw</span>(<span class="keyword">this</span>, &amp;FVSM_NodeClassHelper::InvalidateCache); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在析构的时候对资源模块进行判断再引用, 否则在关闭编辑器后来个无聊的崩溃</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (FModuleManager::<span class="built_in">Get</span>().<span class="built_in">IsModuleLoaded</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;AssetRegistry&quot;</span>)))</span><br><span class="line">&#123;</span><br><span class="line">	FAssetRegistryModule&amp; AssetRegistryModule = FModuleManager::GetModuleChecked&lt;FAssetRegistryModule&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AssetRegistry&quot;</span>));</span><br><span class="line">	AssetRegistryModule.<span class="built_in">Get</span>().<span class="built_in">OnFilesLoaded</span>().<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line">	AssetRegistryModule.<span class="built_in">Get</span>().<span class="built_in">OnAssetAdded</span>().<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line">	AssetRegistryModule.<span class="built_in">Get</span>().<span class="built_in">OnAssetRemoved</span>().<span class="built_in">RemoveAll</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余基本抄袭</p>
<h3 id="连接和绘制规则"><a href="#连接和绘制规则" class="headerlink" title="连接和绘制规则"></a>连接和绘制规则</h3><p>需要定义一个<code>FConnectionDrawingPolicy</code>类,表述连接线的样式和连接规则等</p>
<h4 id="ECanCreateConnectionResponse-节点连接规则"><a href="#ECanCreateConnectionResponse-节点连接规则" class="headerlink" title="ECanCreateConnectionResponse/ 节点连接规则"></a><em>ECanCreateConnectionResponse</em>/ 节点连接规则</h4><table>
<thead>
<tr>
<th>ECanCreateConnectionResponse</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONNECT_RESPONSE_MAKE</td>
<td>AB能随意连接(N:N)</td>
</tr>
<tr>
<td>CONNECT_RESPONSE_DISALLOW</td>
<td>AB不能连接(0:0)</td>
</tr>
<tr>
<td>CONNECT_RESPONSE_BREAK_OTHERS_A</td>
<td>A只能连接一次(1:N)</td>
</tr>
<tr>
<td>CONNECT_RESPONSE_BREAK_OTHERS_B</td>
<td>B只能连接一次(N:1)</td>
</tr>
<tr>
<td>CONNECT_RESPONSE_BREAK_OTHERS_AB</td>
<td>AB都只能连接一次(1:1)</td>
</tr>
<tr>
<td>CONNECT_RESPONSE_MAKE_WITH_CONVERSION_NODE</td>
<td>通过中间强制转换节点或其他转换节点进行连接</td>
</tr>
</tbody></table>
<p>​    </p>
<h2 id="GraphFactory"><a href="#GraphFactory" class="headerlink" title="GraphFactory"></a>GraphFactory</h2><p>节点/引脚/连线的创建需要创建对应的工厂类来完成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VSMEDITOR_API</span> <span class="title">FVSM_GraphNodeFactory</span> :</span> <span class="keyword">public</span> FGraphPanelNodeFactory</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;class SGraphNode&gt; <span class="title">CreateNode</span><span class="params">(class UEdGraphNode* InNode)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VSMEDITOR_API</span> <span class="title">FVSM_PinConnectionFactory</span> :</span> <span class="keyword">public</span> FGraphPanelPinConnectionFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> class FConnectionDrawingPolicy* <span class="title">CreateConnectionPolicy</span><span class="params">(<span class="keyword">const</span> class UEdGraphSchema* Schema, int32 InBackLayerID, int32 InFrontLayerID, <span class="keyword">float</span> ZoomFactor, <span class="keyword">const</span> class FSlateRect&amp; InClippingRect, class FSlateWindowElementList&amp; InDrawElements, class UEdGraph* InGraphObj)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">class FConnectionDrawingPolicy* <span class="title">FVSM_PinConnectionFactory::CreateConnectionPolicy</span><span class="params">(<span class="keyword">const</span> class UEdGraphSchema* Schema, int32 InBackLayerID, int32 InFrontLayerID, <span class="keyword">float</span> ZoomFactor, <span class="keyword">const</span> class FSlateRect&amp; InClippingRect, class FSlateWindowElementList&amp; InDrawElements, class UEdGraph* InGraphObj)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Schema-&gt;<span class="built_in">IsA</span>(UVSM_Schema::<span class="built_in">StaticClass</span>()))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">FVSM_ConnectionPolicy</span>(InBackLayerID, InFrontLayerID, ZoomFactor, InClippingRect, InDrawElements, InGraphObj);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TSharedPtr&lt;class SGraphNode&gt; <span class="title">FVSM_GraphNodeFactory::CreateNode</span><span class="params">(class UEdGraphNode* InNode)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (UVSM_Node_Entry* EntryNode = Cast&lt;UVSM_Node_Entry&gt;(InNode))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SNew</span>(SVSM_Node_Entry, EntryNode);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (UVSM_Node_Transition* TransitionNode = Cast&lt;UVSM_Node_Transition&gt;(InNode))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SNew</span>(SVSM_Node_Transition, TransitionNode);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (UVSM_Node_Task* TaskNode = Cast&lt;UVSM_Node_Task&gt;(InNode))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SNew</span>(SVSM_Node_Task, TaskNode);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (UVSM_Node* Node = Cast&lt;UVSM_Node&gt;(InNode))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SNew</span>(SVSM_Node, Node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后在模块启动时注册到编辑器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FVSMEditorModule::RegisterFactories</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StateMachineGraphFactory = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FVSM_GraphNodeFactory</span>());</span><br><span class="line">	StateMachineGraphPinConnectionFactory = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FVSM_PinConnectionFactory</span>());</span><br><span class="line">	FEdGraphUtilities::<span class="built_in">RegisterVisualNodeFactory</span>(StateMachineGraphFactory);</span><br><span class="line">	FEdGraphUtilities::<span class="built_in">RegisterVisualPinConnectionFactory</span>(StateMachineGraphPinConnectionFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FVSMEditorModule::UnregisterFactories</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FEdGraphUtilities::<span class="built_in">UnregisterVisualNodeFactory</span>(StateMachineGraphFactory);</span><br><span class="line">	FEdGraphUtilities::<span class="built_in">UnregisterVisualPinConnectionFactory</span>(StateMachineGraphPinConnectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>节点继承自<code>UEdGraphNode</code>, 下列函数大多都是字面意思</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// UEdGraphNode interface.</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ReconstructNode</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span>	<span class="keyword">void</span> <span class="title">AllocateDefaultPins</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CanCreateUnderSpecifiedSchema</span><span class="params">(<span class="keyword">const</span> UEdGraphSchema* Schema)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CanUserDeleteNode</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;<span class="keyword">return</span> <span class="literal">true</span>; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AutowireNewNode</span><span class="params">(UEdGraphPin* FromPin)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DestroyNode</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SaveNode</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnNotifyGraphChanged</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPropertyUpdated</span><span class="params">(<span class="keyword">const</span> FPropertyChangedEvent&amp; PropertyChangedEvent, FProperty* PropertyThatChanged)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FLinearColor <span class="title">GetNodeTitleColor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetNodeTitle</span><span class="params">(ENodeTitleType::Type TitleType)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//重命名类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;class INameValidatorInterface&gt; <span class="title">MakeNameValidator</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRenameNode</span><span class="params">(<span class="keyword">const</span> FString&amp; NewName)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="comment">// End of UEdGraphNode interface.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三个函数跟双击以后的操作有关系, 比如跳转到某个视图或者打开某个资源</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UObject* <span class="title">GetJumpTargetForDoubleClick</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CanJumpToDefinition</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">JumpToDefinition</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Node与一个Runtime状态类(UVSM_State_Base*)同时存在, 选中Node以后, 细节面板显示的就是这个类,编辑的属性改的也是这个类,最终反馈到状态机类<code>UVSM_StateMachine</code></p>
<h2 id="SlateNode"><a href="#SlateNode" class="headerlink" title="SlateNode"></a>SlateNode</h2><p>每个Node都对应一个Slate类, 用于在视图中显示, 在GraphFactory中确定对应关系</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VSMEDITOR_API</span> <span class="title">SVSM_Node</span> :</span> <span class="keyword">public</span> SGraphNode</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">SLATE_BEGIN_ARGS</span>(SVSM_Node) &#123;&#125;</span><br><span class="line">	<span class="built_in">SLATE_END_ARGS</span>()</span><br><span class="line"></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/* FUNCTIONS                                                            */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Construct</span><span class="params">(<span class="keyword">const</span> FArguments&amp; InArgs, UVSM_Node* InNode)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// SGraphNode interface</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">UpdateGraphNode</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddPin</span><span class="params">(<span class="keyword">const</span> TSharedRef&lt;SGraphPin&gt;&amp; PinToAdd)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreatePinWidgets</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> FSlateBrush* <span class="title">GetShadowBrush</span><span class="params">(<span class="keyword">bool</span> bSelected)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnNameTextCommited</span><span class="params">(<span class="keyword">const</span> FText&amp; InText, ETextCommit::Type CommitInfo)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">OnVerifyNameTextChanged</span><span class="params">(<span class="keyword">const</span> FText&amp; InText, FText&amp; OutErrorMessage)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetNodeInfoPopups</span><span class="params">(FNodeInfoContext* Context, TArray&lt;FGraphInformationPopupInfo&gt;&amp; Popups)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="comment">// End of SGraphNode interface</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FSlateColor <span class="title">GetNodeColor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FSlateColor <span class="title">GetNodeBackgroundColor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetNodeTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">FText <span class="title">GetPreviewCornerText</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> FSlateBrush* <span class="title">GetNameIcon</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">FSlateColor <span class="title">GetBorderBackgroundColor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	 <span class="keyword">const</span>  FVSM_SlateStyle* Style;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 如果需要对debug的时候进行一些操作, 可以对一些函数进行改动, 比如如果要在Debug的时候提示一个信息框, 可以对<code>GetNodeInfoPopups()</code>函数进行如下操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SVSM_Node::GetNodeInfoPopups</span><span class="params">(FNodeInfoContext* Context, TArray&lt;FGraphInformationPopupInfo&gt;&amp; Popups)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UVSM_Blueprint* StateMachineBlueprint = Cast&lt;UVSM_Blueprint&gt;(Cast&lt;UVSM_Graph&gt;(GraphNode-&gt;<span class="built_in">GetGraph</span>())-&gt;SMBP);</span><br><span class="line">	UVSM_Node* StateMachineGraphNode = Cast&lt;UVSM_Node&gt;(GraphNode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (StateMachineGraphNode-&gt;<span class="built_in">IsRootNode</span>() || !StateMachineGraphNode-&gt;State)</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (StateMachineBlueprint)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (UVSM_StateMachine* StateMachine = Cast&lt;UVSM_StateMachine&gt;(StateMachineBlueprint-&gt;<span class="built_in">GetObjectBeingDebugged</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (StateMachine-&gt;CurrentState.<span class="built_in">IsValid</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				FString StateName = StateMachine-&gt;CurrentState.Name;</span><br><span class="line">				<span class="keyword">if</span> (StateName != StateMachineGraphNode-&gt;State-&gt;Data.Name)</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="function">FLinearColor <span class="title">CurrentStateColor</span><span class="params">(<span class="number">1.f</span>, <span class="number">0.5f</span>, <span class="number">0.25f</span>)</span></span>;</span><br><span class="line">				FString StateText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s ACTIVE&quot;</span>), *StateName);</span><br><span class="line">				<span class="keyword">new</span> (Popups) <span class="built_in">FGraphInformationPopupInfo</span>(<span class="literal">nullptr</span>, CurrentStateColor, StateText);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="INameValidatorInterface"><a href="#INameValidatorInterface" class="headerlink" title="INameValidatorInterface"></a>INameValidatorInterface</h2><p>用于重命名的类, 通过重写<code>Node</code>的函数 <code>virtual TSharedPtr&lt;class INameValidatorInterface&gt; MakeNameValidator() const override;</code>指定对象</p>
<p>一般需要重写下面几个方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> EValidatorResult <span class="title">IsValid</span><span class="params">(<span class="keyword">const</span> FString&amp; Name, <span class="keyword">bool</span> bOriginal)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> EValidatorResult <span class="title">IsValid</span><span class="params">(<span class="keyword">const</span> FName&amp; Name, <span class="keyword">bool</span> bOriginal)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsCurrentName</span><span class="params">(<span class="keyword">const</span> FName&amp; Name)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsExistingName</span><span class="params">(<span class="keyword">const</span> FName&amp; Name)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">EValidatorResult <span class="title">FVSM_NameValidatorBase::IsValid</span><span class="params">(<span class="keyword">const</span> FName &amp; Name, <span class="keyword">bool</span> bOriginal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Name.<span class="built_in">IsNone</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> EValidatorResult::EmptyName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!Name.<span class="built_in">IsValidXName</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> EValidatorResult::ContainsInvalidCharacters;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsCurrentName</span>(Name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> EValidatorResult::ExistingName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsExistingName</span>(Name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> EValidatorResult::AlreadyInUse;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EValidatorResult::Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部通过调用<code>IsValid()</code>来获取返回类型, 重命名的时候决定是成功还是失败</p>
<h2 id="Utilities"><a href="#Utilities" class="headerlink" title="Utilities"></a>Utilities</h2><p>一个比较重要的静态库类, 定义了所有创建节点和视图操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VSMEDITOR_API</span> <span class="title">FVSM_EditorUtilities</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/* FUNCTIONS                                                            */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">static</span> T* <span class="title">CreateNode</span><span class="params">(UEdGraph* Graph, int32 NodePosX, int32 NodePosY, <span class="keyword">bool</span> bSelectNewNode = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">FGraphNodeCreator&lt;T&gt; <span class="title">NodeCreator</span><span class="params">(*Graph)</span></span>;</span><br><span class="line">		T* GraphNode = NodeCreator.<span class="built_in">CreateNode</span>();</span><br><span class="line">		GraphNode-&gt;NodePosX = NodePosX;</span><br><span class="line">		GraphNode-&gt;NodePosY = NodePosY;</span><br><span class="line">		NodeCreator.<span class="built_in">Finalize</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> GraphNode;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VSMEDITOR_API</span> <span class="title">FVSM_StateMachineUtilities</span> :</span> <span class="keyword">public</span> FVSM_EditorUtilities</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/* PROPERTIES															*/</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> FString PREFIX_NAME;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> FString BEGIN_NAME;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> FString UPDATE_NAME;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> FString FINISH_NAME;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> FString SUFFIX_BEGIN_NAME;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> FString SUFFIX_UPDATE_NAME;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> FString SUFFIX_FINISH_NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/* FUNCTIONS                                                            */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NodeType, <span class="keyword">typename</span> StateType&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">static</span> NodeType* <span class="title">AddNewDefaultState</span><span class="params">(int32 NodePosX, int32 NodePosY, UVSM_Graph* Graph, UEdGraphPin* FromPin = <span class="literal">nullptr</span>, <span class="keyword">bool</span> bSelectNewNode = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		NodeType* NewNode = CreateNode&lt;NodeType&gt;(Graph, NodePosX, NodePosY, bSelectNewNode);</span><br><span class="line"></span><br><span class="line">		StateType* State = NewObject&lt;StateType&gt;(Graph-&gt;<span class="built_in">PrepareOuter</span>());</span><br><span class="line"></span><br><span class="line">		Graph-&gt;<span class="built_in">RegisterNode</span>(State, NewNode, FromPin);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> NewNode;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> UVSM_Node_Entry* <span class="title">AddNewEntry</span><span class="params">(int32 NodePosX, int32 NodePosY, UVSM_Graph* Graph, <span class="keyword">bool</span> bSelectNewNode = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		UVSM_Node_Entry* NewNode = CreateNode&lt;UVSM_Node_Entry&gt;(Graph, NodePosX, NodePosY, bSelectNewNode);</span><br><span class="line"></span><br><span class="line">		UVSM_State_Entry* Entry = NewObject&lt;UVSM_State_Entry&gt;(Graph-&gt;<span class="built_in">PrepareOuter</span>());</span><br><span class="line">		Entry-&gt;Data.Name = <span class="built_in">TEXT</span>(<span class="string">&quot;Entry&quot;</span>);</span><br><span class="line">		Graph-&gt;<span class="built_in">RegisterEntryNode</span>(Entry, NewNode);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> NewNode;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> UVSM_Node_Task* <span class="title">AddNewTask</span><span class="params">(int32 NodePosX, int32 NodePosY, UVSM_Graph* Graph, FVSM_NodeClassData InClassData, UEdGraphPin* FromPin = <span class="literal">nullptr</span>, <span class="keyword">bool</span> bSelectNewNode = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		UVSM_Node_Task* NewNode = CreateNode&lt;UVSM_Node_Task&gt;(Graph, NodePosX, NodePosY, bSelectNewNode);</span><br><span class="line"></span><br><span class="line">		UVSM_State_Task* Task = NewObject&lt;UVSM_State_Task&gt;(Graph-&gt;<span class="built_in">PrepareOuter</span>());</span><br><span class="line">		Task-&gt;TaskBP = InClassData.<span class="built_in">GetBlueprint</span>();</span><br><span class="line">		Task-&gt;Data.TaskClass = InClassData.<span class="built_in">GetClass</span>();</span><br><span class="line">		Task-&gt;Data.Name = <span class="string">&quot;Task_&quot;</span> + FString::<span class="built_in">FromInt</span>(Task-&gt;<span class="built_in">GetUniqueID</span>());</span><br><span class="line">		UVSM_Blueprint* Blueprint = Graph-&gt;SMBP;</span><br><span class="line">		Blueprint-&gt;<span class="built_in">GetSM</span>()-&gt;<span class="built_in">AddOrUpdateState</span>(Task-&gt;Data);</span><br><span class="line">		Graph-&gt;<span class="built_in">RegisterTaskNode</span>(Task, NewNode, FromPin);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> NewNode;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NodeType, <span class="keyword">typename</span> TransitionType&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">static</span> NodeType* <span class="title">AddNewTransition</span><span class="params">(int32 NodePosX, int32 NodePosY, UVSM_Graph* Graph, <span class="keyword">bool</span> bSelectNewNode = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		NodeType* NewNode = CreateNode&lt;NodeType&gt;(Graph, NodePosX, NodePosY, bSelectNewNode);</span><br><span class="line"></span><br><span class="line">		TransitionType* Transition = NewObject&lt;TransitionType&gt;(Graph-&gt;<span class="built_in">PrepareOuter</span>());</span><br><span class="line"></span><br><span class="line">		Graph-&gt;<span class="built_in">RegisterTransitionNode</span>(Transition, NewNode);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> NewNode;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddDefaultStateGraph</span><span class="params">(UVSM_Graph* Graph, UVSM_Node* StateNode)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (StateNode-&gt;<span class="built_in">IsRootNode</span>()) <span class="keyword">return</span>;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		UVSM_Blueprint* Blueprint = Graph-&gt;SMBP;</span><br><span class="line">		UVSM_State_Base* SmState = StateNode-&gt;State;</span><br><span class="line">		FVSM_StateData&amp; State = SmState-&gt;Data;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建名称</span></span><br><span class="line">		State.Name = <span class="string">&quot;State_&quot;</span> + FString::<span class="built_in">FromInt</span>(SmState-&gt;<span class="built_in">GetUniqueID</span>());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建视图， 视图名称与状态名称相同</span></span><br><span class="line">		SmState-&gt;StateGraph = FBlueprintEditorUtils::<span class="built_in">CreateNewGraph</span>(Blueprint, *State.Name, UEdGraph::<span class="built_in">StaticClass</span>(), UEdGraphSchema_K2::<span class="built_in">StaticClass</span>());</span><br><span class="line">		SmState-&gt;StateGraph-&gt;bAllowDeletion = <span class="literal">false</span>;</span><br><span class="line">		SmState-&gt;StateGraph-&gt;bAllowRenaming = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//添加新蓝图视图</span></span><br><span class="line">		FBlueprintEditorUtils::<span class="built_in">AddUbergraphPage</span>(Blueprint, SmState-&gt;StateGraph);</span><br><span class="line">		</span><br><span class="line">		State.BeginFunctionName = PREFIX_NAME + State.Name + SUFFIX_BEGIN_NAME;</span><br><span class="line">		State.UpdateFunctionName = PREFIX_NAME + State.Name + SUFFIX_UPDATE_NAME;</span><br><span class="line">		State.FinishFunctionName = PREFIX_NAME + State.Name + SUFFIX_FINISH_NAME;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建新事件节点</span></span><br><span class="line">		UFunction* BeginFunction = FindUField&lt;UFunction&gt;(Blueprint-&gt;<span class="built_in">GetSM</span>()-&gt;<span class="built_in">GetClass</span>(), <span class="string">&quot;BeginState_Internal&quot;</span>);</span><br><span class="line">		UK2Node_CustomEvent* BeginEvent = UK2Node_CustomEvent::<span class="built_in">CreateFromFunction</span>(<span class="built_in">FVector2D</span>(<span class="number">0</span>, <span class="number">0</span>), SmState-&gt;StateGraph, State.BeginFunctionName, BeginFunction, <span class="literal">false</span>);</span><br><span class="line">		BeginEvent-&gt;bCanRenameNode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		UFunction* UpdateFunction = FindUField&lt;UFunction&gt;(Blueprint-&gt;<span class="built_in">GetSM</span>()-&gt;<span class="built_in">GetClass</span>(), <span class="string">&quot;UpdateState_Internal&quot;</span>);</span><br><span class="line">		UK2Node_CustomEvent* UpdateEvent = UK2Node_CustomEvent::<span class="built_in">CreateFromFunction</span>(<span class="built_in">FVector2D</span>(<span class="number">0</span>, <span class="number">100.f</span>), SmState-&gt;StateGraph, State.UpdateFunctionName, UpdateFunction, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		TSharedPtr&lt;FUserPinInfo&gt; PinDefinition = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> FUserPinInfo);</span><br><span class="line">		FEdGraphPinType PinType;</span><br><span class="line">		<span class="keyword">const</span> UEdGraphSchema_K2* K2Schema = GetDefault&lt;UEdGraphSchema_K2&gt;();</span><br><span class="line">		PinType.bIsReference = <span class="literal">false</span>;</span><br><span class="line">		PinType.PinCategory = K2Schema-&gt;PC_Float;</span><br><span class="line">		PinDefinition-&gt;PinName = <span class="string">&quot;DeltaTime&quot;</span>;</span><br><span class="line">		PinDefinition-&gt;PinType = PinType;</span><br><span class="line">		UEdGraphPin* NewPin = UpdateEvent-&gt;<span class="built_in">CreatePinFromUserDefinition</span>(PinDefinition);</span><br><span class="line">		UpdateEvent-&gt;<span class="built_in">ReconstructNode</span>();</span><br><span class="line">		UpdateEvent-&gt;bCanRenameNode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		UFunction* FinishFunction = FindUField&lt;UFunction&gt;(Blueprint-&gt;<span class="built_in">GetSM</span>()-&gt;<span class="built_in">GetClass</span>(), <span class="string">&quot;FinishState_Internal&quot;</span>);</span><br><span class="line">		UK2Node_CustomEvent* FinishEvent = UK2Node_CustomEvent::<span class="built_in">CreateFromFunction</span>(<span class="built_in">FVector2D</span>(<span class="number">0</span>, <span class="number">250.f</span>), SmState-&gt;StateGraph, State.FinishFunctionName, FinishFunction, <span class="literal">false</span>);</span><br><span class="line">		FinishEvent-&gt;bCanRenameNode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		Blueprint-&gt;<span class="built_in">GetSM</span>()-&gt;<span class="built_in">AddOrUpdateState</span>(State);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddNewTransitionGraph</span><span class="params">(UVSM_Graph* Graph, UVSM_Node_Transition* TransNode)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		UVSM_Blueprint* Blueprint = Graph-&gt;SMBP;</span><br><span class="line">		<span class="keyword">if</span> ((!TransNode-&gt;<span class="built_in">GetInputPin</span>() || TransNode-&gt;<span class="built_in">GetInputPin</span>()-&gt;LinkedTo.<span class="built_in">Num</span>() == <span class="number">0</span>)</span><br><span class="line">			|| (!TransNode-&gt;<span class="built_in">GetOutputPin</span>() &amp;&amp; TransNode-&gt;<span class="built_in">GetOutputPin</span>()-&gt;LinkedTo.<span class="built_in">Num</span>() == <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		UVSM_Node* InputState = CastChecked&lt;UVSM_Node&gt;(TransNode-&gt;<span class="built_in">GetInputPin</span>()-&gt;LinkedTo[<span class="number">0</span>]-&gt;<span class="built_in">GetOwningNode</span>());</span><br><span class="line">		UVSM_Node* OutputState = CastChecked&lt;UVSM_Node&gt;(TransNode-&gt;<span class="built_in">GetOutputPin</span>()-&gt;LinkedTo[<span class="number">0</span>]-&gt;<span class="built_in">GetOwningNode</span>());</span><br><span class="line">		UVSM_State_Transition* Transition = TransNode-&gt;Transition;</span><br><span class="line">		FVSM_TransitionData&amp; RuntimeData = Transition-&gt;Data;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (InputState &amp;&amp; OutputState)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 创建过渡节点名称</span></span><br><span class="line">			RuntimeData.Name = InputState-&gt;State-&gt;Data.Name + <span class="string">&quot;_To_&quot;</span> + OutputState-&gt;State-&gt;Data.Name;</span><br><span class="line">			RuntimeData.FromState = InputState-&gt;State-&gt;Data.Name;</span><br><span class="line">			RuntimeData.ToState = OutputState-&gt;State-&gt;Data.Name;</span><br><span class="line">			InputState-&gt;State-&gt;Data.TransitionNames.<span class="built_in">Add</span>(RuntimeData.Name);</span><br><span class="line">			<span class="comment">// 创建函数视图，名字从RuntimeData获取</span></span><br><span class="line">			Transition-&gt;TransitionGraph = FBlueprintEditorUtils::<span class="built_in">CreateNewGraph</span>(Blueprint, *RuntimeData.Name, UEdGraph::<span class="built_in">StaticClass</span>(), UEdGraphSchema_K2::<span class="built_in">StaticClass</span>());</span><br><span class="line">			Transition-&gt;TransitionGraph-&gt;bAllowDeletion = <span class="literal">false</span>;</span><br><span class="line">			Transition-&gt;TransitionGraph-&gt;bAllowRenaming = <span class="literal">false</span>;</span><br><span class="line">			FBlueprintEditorUtils::AddFunctionGraph&lt;UClass&gt;(Blueprint, Transition-&gt;TransitionGraph, <span class="literal">true</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">			UK2Node_FunctionEntry* EntryNode = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">if</span> (Transition-&gt;TransitionGraph)</span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//获取所有输入节点</span></span><br><span class="line">				TArray&lt;UK2Node_FunctionEntry*&gt; EntryNodes;</span><br><span class="line">				Transition-&gt;TransitionGraph-&gt;<span class="built_in">GetNodesOfClass</span>(EntryNodes);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> ((EntryNodes.<span class="built_in">Num</span>() &gt; <span class="number">0</span>) &amp;&amp; EntryNodes[<span class="number">0</span>]-&gt;<span class="built_in">IsEditable</span>())</span><br><span class="line">					EntryNode = EntryNodes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 创建返回节点</span></span><br><span class="line">				<span class="keyword">if</span> (EntryNode)</span><br><span class="line">				&#123;</span><br><span class="line">					EntryNode-&gt;<span class="built_in">AddExtraFlags</span>(FUNC_BlueprintPure);</span><br><span class="line">					UK2Node_FunctionResult* ResultNode = FBlueprintEditorUtils::<span class="built_in">FindOrCreateFunctionResultNode</span>(EntryNode);</span><br><span class="line">					<span class="keyword">if</span> (ResultNode)</span><br><span class="line">					&#123;</span><br><span class="line">						</span><br><span class="line">						<span class="keyword">const</span> UEdGraphSchema_K2* K2Schema = GetDefault&lt;UEdGraphSchema_K2&gt;();</span><br><span class="line"></span><br><span class="line">						FEdGraphPinType PinType;</span><br><span class="line">						PinType.bIsReference = <span class="literal">false</span>;</span><br><span class="line">						PinType.PinCategory = K2Schema-&gt;PC_Boolean;</span><br><span class="line">						FName NewPinName = ResultNode-&gt;<span class="built_in">CreateUniquePinName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Result&quot;</span>));</span><br><span class="line">						UEdGraphPin* NewPin = ResultNode-&gt;<span class="built_in">CreateUserDefinedPin</span>(NewPinName, PinType, EGPD_Input, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">						ResultNode-&gt;<span class="built_in">ReconstructNode</span>();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Blueprint-&gt;<span class="built_in">GetSM</span>()-&gt;<span class="built_in">AddOrUpdateTransition</span>(RuntimeData);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenameStateGraph</span><span class="params">(UVSM_State_Base* State, FString OldName, FString NewName)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (State)</span><br><span class="line">		&#123;</span><br><span class="line">			FVSM_StateData&amp; RuntimeState = State-&gt;Data;</span><br><span class="line">			RuntimeState.Name = NewName;</span><br><span class="line">			<span class="keyword">if</span> (State-&gt;StateGraph)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				FBlueprintEditorUtils::<span class="built_in">RenameGraph</span>(State-&gt;StateGraph, RuntimeState.Name);</span><br><span class="line">				<span class="comment">//重命名函数名称</span></span><br><span class="line">				<span class="keyword">for</span> (UEdGraphNode* Node : State-&gt;StateGraph-&gt;Nodes)</span><br><span class="line">				&#123;</span><br><span class="line">					FString NodeName = Node-&gt;<span class="built_in">GetNodeTitle</span>(ENodeTitleType::MenuTitle).<span class="built_in">ToString</span>();</span><br><span class="line">					<span class="keyword">if</span> (NodeName == PREFIX_NAME + OldName + SUFFIX_BEGIN_NAME)</span><br><span class="line">						Node-&gt;<span class="built_in">OnRenameNode</span>(PREFIX_NAME + NewName + SUFFIX_BEGIN_NAME);</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (NodeName == PREFIX_NAME + OldName + SUFFIX_UPDATE_NAME)</span><br><span class="line">						Node-&gt;<span class="built_in">OnRenameNode</span>(PREFIX_NAME + NewName + SUFFIX_UPDATE_NAME);</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (NodeName == PREFIX_NAME + OldName + SUFFIX_FINISH_NAME)</span><br><span class="line">						Node-&gt;<span class="built_in">OnRenameNode</span>(PREFIX_NAME + NewName + SUFFIX_FINISH_NAME);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				RuntimeState.BeginFunctionName = PREFIX_NAME + RuntimeState.Name + SUFFIX_BEGIN_NAME;</span><br><span class="line">				RuntimeState.UpdateFunctionName = PREFIX_NAME + RuntimeState.Name + SUFFIX_UPDATE_NAME;</span><br><span class="line">				RuntimeState.FinishFunctionName = PREFIX_NAME + RuntimeState.Name + SUFFIX_FINISH_NAME;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			State-&gt;SMBP-&gt;<span class="built_in">GetSM</span>()-&gt;<span class="built_in">AddOrUpdateState</span>(RuntimeState, OldName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenameStateGraph</span><span class="params">(UVSM_State_Transition* Transition)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (Transition &amp;&amp; Transition-&gt;TransitionGraph)</span><br><span class="line">		&#123;</span><br><span class="line">			UVSM_Node_Transition* TransNode = CastChecked&lt;UVSM_Node_Transition&gt;(Transition-&gt;GraphNode);</span><br><span class="line">			FVSM_TransitionData&amp; RuntimeData = Transition-&gt;Data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((!TransNode-&gt;<span class="built_in">GetInputPin</span>() || TransNode-&gt;<span class="built_in">GetInputPin</span>()-&gt;LinkedTo.<span class="built_in">Num</span>() == <span class="number">0</span>)</span><br><span class="line">				|| (!TransNode-&gt;<span class="built_in">GetOutputPin</span>() &amp;&amp; TransNode-&gt;<span class="built_in">GetOutputPin</span>()-&gt;LinkedTo.<span class="built_in">Num</span>() == <span class="number">0</span>))</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">			UVSM_Node* InputState = CastChecked&lt;UVSM_Node&gt;(TransNode-&gt;<span class="built_in">GetInputPin</span>()-&gt;LinkedTo[<span class="number">0</span>]-&gt;<span class="built_in">GetOwningNode</span>());</span><br><span class="line">			UVSM_Node* OutputState = CastChecked&lt;UVSM_Node&gt;(TransNode-&gt;<span class="built_in">GetOutputPin</span>()-&gt;LinkedTo[<span class="number">0</span>]-&gt;<span class="built_in">GetOwningNode</span>());</span><br><span class="line">			</span><br><span class="line">			FString OldName = Transition-&gt;TransitionGraph-&gt;<span class="built_in">GetName</span>();</span><br><span class="line"></span><br><span class="line">			RuntimeData.Name = InputState-&gt;State-&gt;Data.Name + <span class="string">&quot;_To_&quot;</span> + OutputState-&gt;State-&gt;Data.Name;</span><br><span class="line">			RuntimeData.FromState = InputState-&gt;State-&gt;Data.Name;</span><br><span class="line">			RuntimeData.ToState = OutputState-&gt;State-&gt;Data.Name;</span><br><span class="line"></span><br><span class="line">			FBlueprintEditorUtils::<span class="built_in">RenameGraph</span>(Transition-&gt;TransitionGraph, RuntimeData.Name);</span><br><span class="line">			Transition-&gt;SMBP-&gt;<span class="built_in">GetSM</span>()-&gt;<span class="built_in">AddOrUpdateTransition</span>(RuntimeData, OldName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>动画_DistanceMatching</title>
    <url>/2021/09/08/%E5%8A%A8%E7%94%BBDistanceMatching/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_09_08_17_10_51_748.gif" alt="录制_2021_09_08_17_10_51_748"></p>
<p><code>Distance Matching</code>用于解决角色启动和停止的时候的滑步问题,  理论上我们可以用<code>RootMotion</code>的方式保证启动和停止的滑步问题, 但是动画序列的同步是个问题, 所以生产环境下一般会用程序化的位移来解决滑步问题</p>
<p><a href="https://www.youtube.com/watch?v=1UOY-FMm-xo&t=2592s">Paragon Feature Examples: Animation Techniques </a>里有讲到相关技术,  本文就简单的对此技术进行研究</p>
<span id="more"></span>



<h2 id="提取位移信息"><a href="#提取位移信息" class="headerlink" title="提取位移信息"></a>提取位移信息</h2><p>有朋友会问，起步和停步动作需要制作成<code>RootMotion</code>的模式吗? 我回答是需要, 这样我们方便提取里面的位移信息, 虽然我们还是会关闭<code>RootMotion</code>效果</p>
<p>对于帕拉共的资源, 这个位移信息都已经放在每个起步停步动画里了, 比如</p>
<p><img src="https://img.supervj.top//img/image-20210908164752720.png" alt="image-20210908164752720"></p>
<p>当然如果不适用帕拉共, 那么我们自己写一个<code>AnimationModify</code>修改器也可以简单实现</p>
<p><img src="https://img.supervj.top//img/image-20210908165935431.png" alt="image-20210908165935431"></p>
<h2 id="预估位移"><a href="#预估位移" class="headerlink" title="预估位移"></a>预估位移</h2><p><strong>UCharacterMovementComponent::ApplyVelocityBrakin</strong>方法里有相关的预估位移的方法, 稍微整理一下封装到函数库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UAnimExtensionBlueprintLibrary::PredictStopLocation</span><span class="params">(FVector&amp; OutStopLocation, <span class="keyword">const</span> FVector&amp; CurrentLocation, <span class="keyword">const</span> FVector&amp; Velocity,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> FVector&amp; Acceleration, <span class="keyword">float</span> Friction, <span class="keyword">float</span> BrakingDeceleration, <span class="keyword">const</span> <span class="keyword">float</span> TimeStep, <span class="keyword">const</span> <span class="keyword">int</span> MaxSimulationIterations <span class="comment">/*= 10*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> MIN_TICK_TIME = <span class="number">1e-6</span>;</span><br><span class="line">	<span class="keyword">if</span> (TimeStep &lt; MIN_TICK_TIME)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bZeroAcceleration = Acceleration.<span class="built_in">IsZero</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加速度方向与速度方向一致</span></span><br><span class="line">	<span class="keyword">if</span> ((Acceleration | Velocity) &gt; <span class="number">0.0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BrakingDeceleration = FMath::<span class="built_in">Max</span>(BrakingDeceleration, <span class="number">0.f</span>);</span><br><span class="line">	Friction = FMath::<span class="built_in">Max</span>(Friction, <span class="number">0.f</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bZeroFriction = (Friction == <span class="number">0.f</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bZeroBraking = (BrakingDeceleration == <span class="number">0.f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bZeroAcceleration &amp;&amp; bZeroFriction)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FVector LastVelocity = bZeroAcceleration ? Velocity : Velocity.<span class="built_in">ProjectOnToNormal</span>(Acceleration.<span class="built_in">GetSafeNormal</span>());</span><br><span class="line">	LastVelocity.Z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	FVector LastLocation = CurrentLocation;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> Iterations = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (Iterations &lt; MaxSimulationIterations)</span><br><span class="line">	&#123;</span><br><span class="line">		Iterations++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> FVector OldVel = LastVelocity;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 没有加速度</span></span><br><span class="line">		<span class="keyword">if</span> (bZeroAcceleration)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">float</span> RemainingTime = TimeStep;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">float</span> MaxTimeStep = (<span class="number">1.0f</span> / <span class="number">33.0f</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">const</span> FVector RevAccel = (bZeroBraking ? FVector::ZeroVector : (-BrakingDeceleration * LastVelocity.<span class="built_in">GetSafeNormal</span>()));</span><br><span class="line">			<span class="keyword">while</span> (RemainingTime &gt;= MIN_TICK_TIME)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 无摩擦的话就使用线性常量计算</span></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">float</span> dt = ((RemainingTime &gt; MaxTimeStep &amp;&amp; !bZeroFriction) ? FMath::<span class="built_in">Min</span>(MaxTimeStep, RemainingTime * <span class="number">0.5f</span>) : RemainingTime);</span><br><span class="line">				RemainingTime -= dt;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 应用摩擦力和减速度  Vt＝Vo+at</span></span><br><span class="line">				LastVelocity = LastVelocity + ((-Friction) * LastVelocity + RevAccel) * dt;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 保证不要反向</span></span><br><span class="line">				<span class="keyword">if</span> ((LastVelocity | OldVel) &lt;= <span class="number">0.f</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					LastVelocity = FVector::ZeroVector;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 小于一定速度就限制为0速度</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">float</span> VSizeSq = LastVelocity.<span class="built_in">SizeSquared</span>();</span><br><span class="line">			<span class="keyword">if</span> (VSizeSq &lt;= <span class="number">1.f</span> || (!bZeroBraking &amp;&amp; VSizeSq &lt;= FMath::<span class="built_in">Square</span>(<span class="number">10</span>)))</span><br><span class="line">			&#123;</span><br><span class="line">				LastVelocity = FVector::ZeroVector;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//有加速度</span></span><br><span class="line">		&#123;</span><br><span class="line">			FVector TotalAcceleration = Acceleration;</span><br><span class="line">			TotalAcceleration.Z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 摩擦影响我们改变方向的能力。这只适用于输入加速度，而不是路径跟踪</span></span><br><span class="line">			<span class="keyword">const</span> FVector AccelDir = TotalAcceleration.<span class="built_in">GetSafeNormal</span>();</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">float</span> VelSize = LastVelocity.<span class="built_in">Size</span>();</span><br><span class="line">			TotalAcceleration += -(LastVelocity - AccelDir * VelSize) * Friction;</span><br><span class="line"></span><br><span class="line">			LastVelocity += TotalAcceleration * TimeStep;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		LastLocation += LastVelocity * TimeStep;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//速度小于阈值就限制为0</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">float</span> VSizeSq = LastVelocity.<span class="built_in">SizeSquared</span>();</span><br><span class="line">		<span class="keyword">if</span> (VSizeSq &lt;= <span class="number">1.f</span></span><br><span class="line">			|| (LastVelocity | OldVel) &lt;= <span class="number">0.f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			OutStopLocation = LastLocation;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img.supervj.top//img/image-20210908170152836.png" alt="image-20210908170152836"></p>
<p>然后还需要一个函数来通过得到的预估距离来反向查找对应的时间点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">UAnimExtensionBlueprintLibrary::GetDistanceCurveTime</span><span class="params">(UAnimSequence* Sequence, <span class="keyword">float</span> Distance, FName DistanceCurveName<span class="comment">/* = &quot;DistanceCurve&quot;*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		FRawCurveTracks CurvesOfAnim = Sequence-&gt;<span class="built_in">GetCurveData</span>();</span><br><span class="line">		TArray&lt;FFloatCurve&gt; Curves = CurvesOfAnim.FloatCurves;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Curves.<span class="built_in">Num</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Curves[i].Name.DisplayName == DistanceCurveName)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span>&amp; Keys = Curves[i].FloatCurve.Keys;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Keys.<span class="built_in">Num</span>(); j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (Keys[j].Value &gt;= Distance)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">float</span> NextTime = Keys[j].Time;</span><br><span class="line">						<span class="keyword">float</span> NextValue = Keys[j].Value;</span><br><span class="line">						<span class="keyword">float</span> PrevValue = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">float</span> PrevTime = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							PrevValue = Keys[j - <span class="number">1</span>].Value;</span><br><span class="line">							PrevTime = Keys[j - <span class="number">1</span>].Time;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">float</span> Lerp = (Distance - PrevValue) / (NextValue - PrevValue);</span><br><span class="line">						<span class="keyword">return</span> PrevTime + (NextTime - PrevTime) * Lerp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="动画实例"><a href="#动画实例" class="headerlink" title="动画实例"></a>动画实例</h2><p>我在封装蓝图组件和使用动画实例之间犹豫了一段时间, 但是考虑到起步和停步动画的不确定性(不同角色, 混合等), 还是决定把逻辑计算部分放到动画实例比较好</p>
<p>在动画实例的<code>Tick</code>中, 我们先在有速度状态下刷新<strong>预估位置</strong><code>DistanceMatchingLocation</code>, 然后通过这个位置来获取并动态的设置起步和停步动画的播放时间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsAccelerating)</span><br><span class="line">&#123;</span><br><span class="line">    Time = UAnimExtensionBlueprintLibrary::<span class="built_in">GetDistanceCurveTime</span>(JogStartAnimSequence, Distance);</span><br><span class="line">    Target = &amp;JogDistanceCurveStartTime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Time = UAnimExtensionBlueprintLibrary::<span class="built_in">GetDistanceCurveTime</span>(JogStopAnimSequence, -Distance);</span><br><span class="line">    Target = &amp;JogDistanceCurveStopTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为了把动画播放完, 需要对时间进行累积</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Time &gt; *Target)</span><br><span class="line">&#123;</span><br><span class="line">    *Target = Time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    *Target += DeltaTimeX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol>
<li><code>DistanceMatching</code>效果需要修改<code>CharacterMovementComponent</code>组件的一些参数, 比如<code>BrakingDecelerationWalking</code>(参考500)需要适当改小一点, 不然减速太快根本也不需要播放停步动作, 强行播放就造成滑步 ; 需要减小<code>BrakingFrictionFactor</code>(参考0.05)或者打开<code>UseSeparateBrakingFriction</code>并设置<code>BrakingFriction</code>参数(参考0.1) </li>
</ol>
<ol start="2">
<li>起步动作还有优化空间, 现在遇到的问题是, 如果速度改变过大, 因为需要保证不滑步, 起步动作看上去就是修改了动画速率的感觉</li>
</ol>
<p><a href="https://github.com/VJien/AnimationExtension">插件地址</a></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>动画优化</title>
    <url>/2022/01/10/%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文专门记录最近对动画优化的一些研究和思考</p>
<p>参考文献</p>
<p><a href="https://docs.unrealengine.com/4.27/en-US/AnimatingObjects/SkeletalMeshAnimation/Optimization/">官方文档</a></p>
<p><a href="https://gameinstitute.qq.com/course/detail/10131">TGDC</a></p>
<span id="more"></span>

<h2 id="FastPath"><a href="#FastPath" class="headerlink" title="FastPath"></a>FastPath</h2><p>这个比较简单, 就是在动画图表中不要加入蓝图逻辑,  保证了只在引擎能够在内部复制参数，而不是执行蓝图代码（这涉及调用蓝图虚拟机）</p>
<p>如果是FastPath, 动画节点上会有个闪电的标志</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/AnimatingObjects/SkeletalMeshAnimation/Optimization/AccessNegatedBooleans.jpg" alt="AccessNegatedBooleans.png"></p>
<p><img src="https://docs.unrealengine.com/4.27/Images/AnimatingObjects/SkeletalMeshAnimation/Optimization/AccessDirectlyBPLogic.jpg" alt="AccessDirectlyBPLogic.png"></p>
<h2 id="模型刷新-Visibility-Based-Anim-Tick-Option"><a href="#模型刷新-Visibility-Based-Anim-Tick-Option" class="headerlink" title="模型刷新 Visibility Based Anim Tick Option"></a>模型刷新 Visibility Based Anim Tick Option</h2><p>在角色蓝图中，可以对Mesh组件设置Visibility Based Anim Tick Option，可选的选项分别是：</p>
<ul>
<li>AlwaysTickPoseAndRefreshBones：无论是否渲染，总是tick和Refresh Bone transforms。</li>
<li>AlwaysTickPose：总是tick，只在渲染时Refresh Bone transforms。</li>
<li>OnlyTickMontagesWhenNotRendered：只在渲染时tick pose和Refresh Bone transforms。 不渲染时，只更新montage，跳过其他操作。</li>
<li>OnlyTickPoseWhenRendered：只在渲染时tick和Refresh Bone transforms。</li>
</ul>
<p>需要注意的是, 在渲染的时候是一定都会TickPose和Refresh Bone transforms的, 枚举的命名可能有一些歧义</p>
<p>结合之前的文章<a href="https://supervj.top/2022/01/06/%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/">动画逻辑深入分析</a>, 可以判断,  TickPose就是跑动画蓝图的Tick流程和状态机,  Refresh Bone transforms 就是刷新骨骼, </p>
<p>为了验证上面的猜测我们做一下测试</p>
<p>我们让角色走路动画加一个通知, 如下</p>
<p><img src="https://img.supervj.top/imgimage-20220112095236833.png" alt="image-20220112095236833"></p>
<p><img src="https://img.supervj.top/imgimage-20220112095339663.png" alt="image-20220112095339663"></p>
<p>然后通知播放一个2D音效和打印当前时间</p>
<p>第一个情况是<strong>AlwaysTickPoseAndRefreshBones</strong></p>
<p><img src="https://img.supervj.top/imgtick1.gif" alt="tick1"></p>
<p>可以看到即使背对角色 角色还是正常播放动画, 也可以看到通知的正常运行</p>
<p>然后是<strong>AlwaysTickPose</strong></p>
<p><img src="https://img.supervj.top/imgtick2.gif" alt="tick2"></p>
<p>动画蓝图还在跑, 但是角色已经没有动作了</p>
<p>接下来是<strong>OnlyTickMontagesWhenNotRendered</strong></p>
<p>我们让角色移动一次结束以后播放一个蒙太奇动画, 顺便在蒙太奇动画里加上一串通知</p>
<p><img src="https://img.supervj.top/imgimage-20220112100149835.png" alt="image-20220112100149835"></p>
<p><img src="https://img.supervj.top/imgimage-20220112100213588.png" alt="image-20220112100213588"></p>
<p>看效果</p>
<p><img src="https://img.supervj.top/imgtick3%2000_00_00-00_00_30.gif" alt="tick3 00_00_00-00_00_30"></p>
<blockquote>
<p>结果就是蒙太奇逻辑还在跑, 但是骨骼照样没有刷新</p>
</blockquote>
<p>最后是<strong>OnlyTickPoseWhenRendered</strong></p>
<p><img src="https://img.supervj.top/imgtick4%2000_00_00-00_00_30.gif" alt="tick4 00_00_00-00_00_30"></p>
<p>这个就是不渲染的时候啥也不干了</p>
<h2 id="URO"><a href="#URO" class="headerlink" title="URO"></a>URO</h2><p>URO即Update Rate Optimization, 即刷新帧率优化</p>
<p>开启方式如下图, 在模型组件的优化标签下</p>
<p><img src="https://img.supervj.top/imgimage-20220112112918934.png" alt="image-20220112112918934"></p>
<p>开启以后如果不通过控制台设置强制的刷新频率 或者设置为0 如下图, 那么就使用引擎自己计算的刷新帧率</p>
<p><img src="https://img.supervj.top/imgimage-20220112113015780.png" alt="image-20220112113015780"></p>
<p>自己的刷新帧率怎么计算的? 看了一些代码大致如下</p>
<p>在<code>SkinnedMeshComponent::TickUpdateRate()</code>开始</p>
<p><img src="https://img.supervj.top/imgimage-20220112113356263.png" alt="image-20220112113356263"></p>
<p>首先判断是否开启了URO, 然后刷新URO需要用到的一个数据结构 <code>FAnimUpdateRateParametersTracker</code></p>
<p>一路F12看下去看到几个关键点</p>
<p><img src="https://img.supervj.top/imgimage-20220112113633782.png" alt="image-20220112113633782"></p>
<p>如果没有被渲染 , 那么走上面图片的帧率</p>
<p>否则就走到下面这里</p>
<p><img src="https://img.supervj.top/imgimage-20220112113753589.png" alt="image-20220112113753589"></p>
<p><img src="https://img.supervj.top/imgimage-20220112113810428.png" alt="image-20220112113810428"></p>
<p>期望的帧率<code>DesiredEvaluationRate</code>会跟<code>BaseVisibleDistanceFactorThesholds</code>的2个成员进行比对, 而<code>MaxDistanceFactor</code>的值来自下图</p>
<p><img src="https://img.supervj.top/imgimage-20220112114043037.png" alt="image-20220112114043037"></p>
<p>这个值最终来自<code>UpdateLODStatus_Internal()</code>函数, 跟LOD有关系, 我们可以用控制台<code>a.VisualizeLODs 1</code>看到模型的LOD信息, 如下图</p>
<p><img src="https://img.supervj.top/imgimage-20220112114237372.png" alt="image-20220112114237372"></p>
<p>所以如果按照小白人的情况, 根据距离<code>DesiredEvaluationRate</code>一般在<strong>1-3</strong>的值切换</p>
<hr>
<p>同样的, 我们可以用控制台命令强行设置刷新率</p>
<p>比如<code>a.URO.ForceAnimRate 10</code>, 看到下面效果, 妥妥的幻灯片</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_01_12_11_46_21_179.gif" alt="录制_2022_01_12_11_46_21_179"></p>
<p>但是还有一个选项, 用控制台输入<code>a.URO.ForceInterpolation 1</code>开启插值计算, 效果如下</p>
<p><img src="https://img.supervj.top/img%E5%BC%80%E5%90%AFinterp.gif" alt="开启interp"></p>
<p>效果已经得到很大的改善, 但是开销会增加, 不过模型中有一些优化选项可以视情况勾选</p>
<p><img src="https://img.supervj.top/imgimage-20220112115158316.png" alt="image-20220112115158316"></p>
<p>另外还有一个有趣的选项, <code>RenderStatic</code>如果勾选, 那么场景中的角色就不再渲染动画, 但是动画蓝图中实际上还是可以看到骨骼还是在刷新的</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_01_12_11_54_44_967.gif" alt="录制_2022_01_12_11_54_44_967"></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>动画蓝图IK更新时序问题</title>
    <url>/2024/05/21/%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE%E6%9B%B4%E6%96%B0%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假设你人物双手开启了IK，然后这个IK数据来自于武器模型上的某个骨骼，这在FPS游戏中是很常见的情况，正常情况下，你会发现人物双手的位置永远是有延迟的，像卡顿一样</p>
<span id="more"></span>

<h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><ul>
<li>玩家角色 BP_TestChar</li>
<li>玩家模型ABP ： ABP_Arms</li>
<li>武器蓝图：BP_TestWeapon</li>
<li>武器动画蓝图：ABP_Barrel</li>
</ul>
<p>玩家蓝图在Tick的时候，从武器蓝图中通过API →GetLeftIK获取Barrel中保存的IK骨骼的Transform信息（简称TM），并打印</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240521160505038.png" alt="image-20240521160505038"></p>
<p>武器蓝图在Tick的时候打印GetLeftIK的TM数据</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240521160523031.png" alt="image-20240521160523031"></p>
<p>玩家模型动画蓝图在UpdateAnimation中从玩家角色中获取保存的IK的TM数据， 并保存和打印</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240521160532325.png" alt="image-20240521160532325"></p>
<p>武器动画蓝图直接从模型获取IK骨骼的TM信息</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240521160539087.png" alt="image-20240521160539087"></p>
<p>结果</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240521160551380.png" alt="image-20240521160551380"></p>
<p>红色框是同一帧，时序是先ABP再武器和角色蓝图</p>
<p>黄色框内发现同一帧的TM数据是不一样的，看到蓝色框是一样的</p>
<p>所以ABP获取的TM数据是蓝图上一帧的数据</p>
<p>所以为什么ABP从其他蓝图比如角色蓝图中获取位置然后设置到IK会有晚一帧的表现</p>
<p>比如下面动图演示的</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_05_21_15_37_37_829.gif" alt="录制_2024_05_21_15_37_37_829"></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>因为UE默认的tick时序是先执行组件，然后再执行actor本身，同时不同的actor和不同的组件之间的时序是没法保证的</p>
<p>所以先执行了ABP，再执行actor的刷新，导致ABP获取的数据就晚一帧</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240521160710641.png" alt="image-20240521160710641"></p>
<p>组件可以添加依赖的Tick组件或者Actor</p>
<p>角色模型添加对武器Actor的依赖</p>
<p>角色模型添加对自身Actor的依赖</p>
<p>如果有必要，武器的模型也要对武器自身的Actor添加依赖</p>
<p>那么最后的时序就会是</p>
<ul>
<li><p>武器Actor</p>
</li>
<li><p>武器ABP</p>
</li>
<li><p>角色Actor</p>
</li>
<li><p>角色ABP</p>
</li>
</ul>
<p>测试一下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20240521161556310.png" alt="image-20240521161556310"></p>
<p>看视频就没有延迟了</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/img%E5%BD%95%E5%88%B6_2024_05_21_15_50_10_923.gif" alt="录制_2024_05_21_15_50_10_923"></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>动画逻辑深入分析</title>
    <url>/2022/01/06/%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前虽然写过一些动画节点和AnimInstance相关的逻辑, 但是对整体动画模块的逻辑路线还是不是很熟, 所以本文大致研究一下</p>
<img src="https://img.supervj.top/img%E5%8A%A8%E7%94%BB%E9%80%BB%E8%BE%912.png" alt="动画逻辑2" style="zoom:150%;" />



<span id="more"></span>



<h2 id="关系梳理"><a href="#关系梳理" class="headerlink" title="关系梳理"></a>关系梳理</h2><p>开始研究之前需要先梳理一下动画逻辑中的各个类的关系</p>
<p>首先是SkeletalMeshComponent, 这东西继承自USkinnedMeshComponent, 就是我们一般播放动画依赖的模型组件,</p>
<p>SkeletalMeshComponent一般会有一个AnimInstance对象, 这个就是动画蓝图的Cpp类, 不记得从什么版本开始, AnimInstance的逻辑慢慢的开始迁往AnimInstanceProxy,  目的是动画系统的多线程优化, 他可以分担动画蓝图的更新工作，将部分动画蓝图的任务分配到其他线程去做。</p>
<p>一般而言，不能从动画图形节点（Update/Evaluate calls）访问或修改<code>UAnimInstance</code>，因为它们可以在其他线程上运行。 有一些锁定封装器（GetProxyOnAnyThread 和GetProxyOnGameThread ）可以在任务运行期间阻止访问FAnimInstanceProxy。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>动画蓝图的初始化要从SkeletalMeshComponent的注册开始, 会调用到<code>InitAnim()</code>函数</p>
<p>InitAnim中做了下面几件事</p>
<ol>
<li><p>ClearAnimScriptInstance();     清理之前的AnimInstance对象</p>
</li>
<li><p>RecalcRequiredBones();   根据Lod计算特定的骨骼信息,  数据来自<code>FSkeletalMeshRenderData</code>,  然后如果有物理资产PhysicsAsset会刷新<code>PhysAssetBones</code></p>
</li>
<li><p>InitializeAnimScriptInstance();  这里主要是创建指定的动画蓝图实例对象, 也就是我们<code>GetAnimInstance()</code>返回的对象, 这里需要注意一点, 动画蓝图的骨架与MeshComponent的骨架需要匹配,否则这个对象就是空. 然后执行<code>AnimInstance</code>对象的<code>InitializeAnimation()</code>, 这里也会重置链接的子动画蓝图.另外还有要分几个情况,</p>
<p>如果是选用了播放单个动画的AnimMode, 那么就会创建一个<code>UAnimSingleNodeInstance</code>来播放动画序列</p>
<p>另外, 如果指定了PostAnimInstance类型, 视情况也会创建</p>
</li>
<li><p>如果符合条件, 会先执行一次<code>TickAnimation()</code> 和 <code>RefreshBoneTransforms()</code>  </p>
</li>
</ol>
<blockquote>
<p><a href="#TickAnimation"><code>TickAnimation()</code></a> 和 <a href="#RefreshBoneTransforms"><code>RefreshBoneTransforms()</code> </a> 是本文重点, 下面会讲到</p>
</blockquote>
<h3 id="InitializeAnimation"><a href="#InitializeAnimation" class="headerlink" title="InitializeAnimation"></a>InitializeAnimation</h3><p>这里按顺序主要调用了</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">RecalcRequiredBones</span>(); <span class="comment">//重新刷新骨架信息</span></span><br><span class="line">GetProxyOnGameThread&lt;FAnimInstanceProxy&gt;().<span class="built_in">Initialize</span>(<span class="keyword">this</span>); <span class="comment">//调用Proxy的初始化函数</span></span><br><span class="line"><span class="built_in">NativeInitializeAnimation</span>();</span><br><span class="line"><span class="built_in">BlueprintInitializeAnimation</span>();<span class="comment">//蓝图的初始化Impl函数</span></span><br><span class="line">GetProxyOnGameThread&lt;FAnimInstanceProxy&gt;().<span class="built_in">InitializeRootNode</span>(bInDeferRootNodeInitialization);<span class="comment">//初始化Node</span></span><br><span class="line"><span class="built_in">BlueprintLinkedAnimationLayersInitialized</span>(); <span class="comment">//动画层的初始化</span></span><br></pre></td></tr></table></figure>

<h2 id="动画更新"><a href="#动画更新" class="headerlink" title="动画更新"></a>动画更新</h2><p>首先我们需要知道, 动画更新默认是多线程的, 在项目设置中有相关设置</p>
<p><img src="https://img.supervj.top/imgimage-20220111101708427.png" alt="image-20220111101708427"></p>
<p>同时在动画蓝图中也有选项</p>
<p><img src="https://img.supervj.top/imgimage-20220111101850615.png" alt="image-20220111101850615"></p>
<p>以下讨论都基于多线程动画更新</p>
<p>动画更新要从<code>SkeletalMeshComponent::TickComponent()</code>开始, SkeletalMeshComponent相对于其父类USkinnedMeshComponent, 在Tick中额外多了一些布料和物理相关的一部分逻辑</p>
<p>接下来讨论Tick流程, <strong>因为类比较多, 下面会区分每个类进行讨论</strong></p>
<p>Tick中主要执行了<code> TickPose ()</code>和 <code> RefreshBoneTransforms()</code></p>
<p><code>TickPose()</code>有一些前置判定, 首先模型的刷新模式<code>VisibilityBasedAnimTickOption</code>必须是<strong>AlwaysTickPoseAndRefreshBones</strong>或者<strong>AlwaysTickPose</strong></p>
<p>然后如果有帧率优化那就需要符合对应的条件(如果是3帧跑一次,那么就是其中一帧会执行)</p>
<p>然后判断是否刷新Transform信息</p>
<p><img src="https://img.supervj.top/imgimage-20220110111219588.png" alt="image-20220110111219588"></p>
<p><img src="https://img.supervj.top/imgimage-20220110111241906.png" alt="image-20220110111241906"></p>
<p>我们可以看到, 如果正在渲染或者设定了<strong>AlwaysTickPoseAndRefreshBones</strong> 就会通过判定</p>
<p>一般情况下(用到MasterPoseComponent的情况除外), 我们就执行到了<code>RefreshBoneTransforms()</code>  </p>
<p>如果上面没通过判定, 如果刷新模式设置了<code>AlwaysTickPose</code>, 那么就会执行并行任务<code>DispatchParallelTickPose()</code></p>
<p>最后一种情况就是只执行<code>RefreshMorphTargets()</code></p>
<h3 id="SkeletalMeshComponent-SkinnedMeshComponent"><a href="#SkeletalMeshComponent-SkinnedMeshComponent" class="headerlink" title="SkeletalMeshComponent/SkinnedMeshComponent"></a>SkeletalMeshComponent/SkinnedMeshComponent</h3><h4 id="TickPose"><a href="#TickPose" class="headerlink" title="TickPose"></a>TickPose</h4><p><code>TickPose()</code>主要是调用<code>TickAnimation()</code>来执行<code>RecalcRequiredCurves()</code>刷新曲线, 调用<code>TickAnimInstances()</code>来执行<code>AnimInstance</code>的<a href="#UpdateAnimation"><code>UpdateAnimation()</code> </a></p>
<blockquote>
<p>TickPose的主要作用就是刷新动画蓝图和相关Node的数据, 为后面的骨骼更新做准备</p>
</blockquote>
<h4 id="RefreshBoneTransforms"><a href="#RefreshBoneTransforms" class="headerlink" title="RefreshBoneTransforms"></a>RefreshBoneTransforms</h4><p>RefreshBoneTransforms也接受动画帧优化RateOptimization</p>
<p>如果在之前的步骤里没有正确计算骨架和曲线信息, 这里也会补充计算一次</p>
<p>接下来的主要任务就是 填充 <code>AnimEvaluationContext</code> 数据</p>
<p>然后执行动画蓝图对象AnimInstance以及子动画蓝图的<code>PreEvaluateAnimation()</code></p>
<p>然后开始并行任务<code>ParallelAnimationEvaluation()</code></p>
<p><code>EvaluationContext</code>在组件上是有非常多的缓存，存储着主要的数据。我们把AnimEvaluationContext上的缓存进行交换。根据<code>bDoParallelEvaluation</code>的结果(经过一系列判定)决定是否分发并行任务, 如果为true就执行<code>DispatchParallelEvaluationTasks()</code></p>
<p><img src="https://img.supervj.top/imgimage-20220111103106848.png" alt="image-20220111103106848"></p>
<p>在这个函数里面调用<code>SwapEvaluationContextBuffers()</code>将我们在上面操作的<code>AnimEvaluationContext</code>与本地缓存进行交换，然后创建<code>FParallelAnimationEvaluationTask</code>执行任务和<code>FParallelAnimationCompletionTask</code>完成任务。</p>
<p>如果为false就主动在game线程执行下图函数, 这里先调用<code>SwapEvaluationContextBuffers()</code>交换，然后调用<code>ParallelAnimationEvaluation()</code>，最后再调用<code>SwapEvaluationContextBuffers()</code>交换回来。最后回到上层调用<code>PostAnimEvaluation()</code>。</p>
<p><img src="https://img.supervj.top/imgimage-20220110113011014.png" alt="image-20220110113011014"></p>
<p>并行任务会一路执行经过<code>PerformAnimationProcessing()</code>, 然后到下图</p>
<p><img src="https://img.supervj.top/imgimage-20220110142956958.png" alt="image-20220110142956958"></p>
<p>这里先执行动画蓝图实例的<a href="#ParallelUpdateAnimation"><code>ParallelUpdateAnimation()</code></a>,即并行Update 任务</p>
<p>然后再通过<code>EvaluateAnimation</code>执行动画蓝图实例的<a href="#ParallelEvaluateAnimation"><code>ParallelEvaluateAnimation()</code></a>即并行Evalute任务,</p>
<blockquote>
<p>RefreshBoneTransforms的作用就是刷新骨骼数据, 然后提供给骨骼模型做最终的渲染</p>
</blockquote>
<h3 id="AnimInstance"><a href="#AnimInstance" class="headerlink" title="AnimInstance"></a>AnimInstance</h3><a name = "UpdateAnimation">

<h4 id="UpdateAnimation"><a href="#UpdateAnimation" class="headerlink" title="UpdateAnimation"></a>UpdateAnimation</h4><p>这里会再次用到<code>VisibilityBasedAnimTickOption</code>, 如果是<code>OnlyTickMontagesWhenNotRendered</code>  同时模型<strong>正在被渲染</strong>, 那么只跑蒙太奇相关的逻辑, 否则继续往下看</p>
<p>然后开始<code>PreUpdateAnimation()</code>, 再是蒙太奇相关的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UpdateMontage</span>(DeltaSeconds);</span><br><span class="line"><span class="built_in">UpdateMontageSyncGroup</span>();</span><br><span class="line"><span class="built_in">UpdateMontageEvaluationData</span>();</span><br></pre></td></tr></table></figure>

<p>再是执行到几个虚函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NativeUpdateAnimation</span>(DeltaSeconds);</span><br><span class="line"><span class="built_in">NativeUpdateAnimation_WorkerThread</span>(DeltaSeconds);</span><br><span class="line"><span class="built_in">BlueprintUpdateAnimation</span>(DeltaSeconds);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们蓝图动画蓝图的Update函数就是上面的<code>BlueprintUpdateAnimation</code></p>
</blockquote>
<p>到最后执行了最重要的函数 <a href="#ParallelUpdateAnimation"><code>ParallelUpdateAnimation()</code></a> 以及<code>PostUpdateAnimation()</code></p>
<h4 id="PreUpdateAnimation"><a href="#PreUpdateAnimation" class="headerlink" title="PreUpdateAnimation"></a>PreUpdateAnimation</h4><p><img src="https://img.supervj.top/imgimage-20220110151205848.png" alt="image-20220110151205848"></p>
<p>更新动画通知数据以及调用Proxy的<a href="#ProxyPreUpdate">PreUpdate</a></p>
<h4 id="UpdateMontage"><a href="#UpdateMontage" class="headerlink" title="UpdateMontage"></a>UpdateMontage</h4><p>蒙太奇的数据主要是存在于动画实例中MontageInstances。首先更新他的权重，并且计算其对应的骨骼和curve的比重。</p>
<p><img src="https://img.supervj.top/imgimage-20220110105559089.png" alt="image-20220110105559089"></p>
<p>蒙太奇的Instance对象的操作很多是在这里执行的, 包括RootMotionParams(包含RootMotion位移信息)的赋值等等,  以及Blend,Stop, Section跳转等等</p>
<h4 id="UpdateMontageSyncGroup"><a href="#UpdateMontageSyncGroup" class="headerlink" title="UpdateMontageSyncGroup"></a>UpdateMontageSyncGroup</h4><p>同步组 使相关的动画相互保持同步</p>
<h4 id="UpdateMontageEvaluationData"><a href="#UpdateMontageEvaluationData" class="headerlink" title="UpdateMontageEvaluationData"></a>UpdateMontageEvaluationData</h4><p>刷新蒙太奇动画的Eval数据, 包含了当前位置, 混合数据等等</p>
<h4 id="PostUpdateAnimation"><a href="#PostUpdateAnimation" class="headerlink" title="PostUpdateAnimation"></a>PostUpdateAnimation</h4><p>主要调用子动画蓝图的<code>PostUpdateAnimation</code>,  对Proxy对象执行<code>PostUpdate</code>, 最后是对<code>ExtractedRootMotion</code>数据进行一些写入操作</p>
<hr>
<a name = "ParallelUpdateAnimation">

<h4 id="ParallelUpdateAnimation"><a href="#ParallelUpdateAnimation" class="headerlink" title="ParallelUpdateAnimation"></a>ParallelUpdateAnimation</h4><p><img src="https://img.supervj.top/imgimage-20220110143145829.png" alt="image-20220110143145829"></p>
<p>调用了Proxy的<a href="#ProxyUpdateAnimation"><code>UpdateAnimation</code></a></p>
<h4 id="PreEvaluateAnimation"><a href="#PreEvaluateAnimation" class="headerlink" title="PreEvaluateAnimation"></a>PreEvaluateAnimation</h4><p>调用Proxy的<code>PreEvaluateAnimation()</code></p>
<a name = "ParallelEvaluateAnimation">

<h4 id="ParallelEvaluateAnimation"><a href="#ParallelEvaluateAnimation" class="headerlink" title="ParallelEvaluateAnimation"></a>ParallelEvaluateAnimation</h4><p><img src="https://img.supervj.top/imgimage-20220110114554230.png" alt="image-20220110114554230"></p>
<p>Instance做的不多,就是直接获取当前游戏线程的Proxy对象, 执行了他的<a href="#EvaluateAnimation">EvaluateAnimation</a></p>
<h3 id="AnimInstanceProxy"><a href="#AnimInstanceProxy" class="headerlink" title="AnimInstanceProxy"></a>AnimInstanceProxy</h3><a name = "ProxyPreUpdate">

<h4 id="PreUpdate"><a href="#PreUpdate" class="headerlink" title="PreUpdate"></a>PreUpdate</h4><p>这里主要做的是在更新前的准备工作，诸如时间的计算，lod的切换，整体的Transform 的移动，通知事件的重置，所有的权重重置等等</p>
<p>当然, AnimInstanceProxy内保存了相关的AnimNode的信息, 这里也会对Node进行PreUpdate操作</p>
<p><img src="https://img.supervj.top/imgimage-20220110104656477.png" alt="image-20220110104656477"></p>
<a name = "ProxyUpdateAnimation">

<h4 id="UpdateAnimation-1"><a href="#UpdateAnimation-1" class="headerlink" title="UpdateAnimation"></a>UpdateAnimation</h4><p><img src="https://img.supervj.top/imgimage-20220110143158226.png" alt="image-20220110143158226"></p>
<p>这里就是调用AnimNode的<code>Update_AnyThread</code>的入口</p>
<a name = "EvaluateAnimation">

<h4 id="EvaluateAnimation"><a href="#EvaluateAnimation" class="headerlink" title="EvaluateAnimation"></a>EvaluateAnimation</h4><p><img src="https://img.supervj.top/imgimage-20220110150653179.png" alt="image-20220110150653179"></p>
<p>这里就是大名鼎鼎的<code>EvaluateAnimation_WithRoot()</code>的入口</p>
<h3 id="AnimNode"><a href="#AnimNode" class="headerlink" title="AnimNode"></a>AnimNode</h3><p>每个AnimGraphNode实际上都是一个<code>FAnimNode_Base</code></p>
<p>FAnimNode_Base的刷新主要来自AnimInstanceProxy的XX_WithRoot函数,  是从Root开始递归的倒退这找到最末端的Node, 然后把Pose数据一路传递下来的</p>
<p>这里主要看一下FAnimNode_Base的几个多线程虚函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Initialize_AnyThread</span><span class="params">(<span class="keyword">const</span> FAnimationInitializeContext&amp; Context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CacheBones_AnyThread</span><span class="params">(<span class="keyword">const</span> FAnimationCacheBonesContext&amp; Context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update_AnyThread</span><span class="params">(<span class="keyword">const</span> FAnimationUpdateContext&amp; Context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Evaluate_AnyThread</span><span class="params">(FPoseContext&amp; Output)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EvaluateComponentSpace_AnyThread</span><span class="params">(FComponentSpacePoseContext&amp; Output)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="Initialize-AnyThread"><a href="#Initialize-AnyThread" class="headerlink" title="Initialize_AnyThread"></a>Initialize_AnyThread</h4><p>会在很多地方调用到, 比如编译以后也会调用一次, 在USkeletalMeshComponent::OnRegister时也会通过Proxy调用<code>InitializeRootNode_WithRoot()</code>一路初始化, 还有状态机<code>SetState()</code>时一路通过LinkedNode找到每个节点进行初始化等等</p>
<p>总而言之, 一般在运行时会调用一次, 如果在状态机内会调用多次</p>
<h4 id="CacheBones-AnyThread"><a href="#CacheBones-AnyThread" class="headerlink" title="CacheBones_AnyThread"></a>CacheBones_AnyThread</h4><p>在骨骼信息发生变换的时候引用到,  比如LOD变化时就会调用到. 主要用于刷新该节点所引用的骨骼索引。</p>
<h4 id="Update-AnyThread"><a href="#Update-AnyThread" class="headerlink" title="Update_AnyThread"></a>Update_AnyThread</h4><p>这个调用就比较频繁了, 在TickPose和RefreshBoneTransform的过程中都可能被调用</p>
<p>这个函数通常用来对刷新骨骼位置所需要的变量进行计算</p>
<h4 id="Evaluate-AnyThread"><a href="#Evaluate-AnyThread" class="headerlink" title="Evaluate_AnyThread"></a>Evaluate_AnyThread</h4><p>用来计算并刷新Local空间的骨骼数据的函数, 一般我们自定义动画节点通常会重写这个函数大作文章</p>
<h4 id="EvaluateComponentSpace-AnyThread"><a href="#EvaluateComponentSpace-AnyThread" class="headerlink" title="EvaluateComponentSpace_AnyThread"></a>EvaluateComponentSpace_AnyThread</h4><p>同上, 但是是在组件空间的, 两者只选其一即可</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>流程分三部分, 本文主要研究了前两部分</p>
<ol>
<li><p>初始化: 在Game线程中执行。在游戏启动时，需要先注册USkeletalMeshComponent组件，然后调用执行注册事件。注册事件做了以下内容：<strong>初始化Anim、更新Animation、刷新骨骼变换、创建渲染状态并分配MeshObject、创建物理状态</strong>。</p>
</li>
<li><p>动画更新：</p>
<ol>
<li>刷新动画蓝图和相关Node的数据, 为后面的骨骼更新做准备.判断是否需要执行蒙太奇更新优化；进行预更新——重置动画通知队列和RootMotionBlendQueue，赋值；蒙太奇更新、蒙太奇同步组更新、蓝图更新。</li>
<li>分发并行任务. 先更Proxy和其他骨骼更新所需的数据，后刷新骨骼数据, 再把骨骼数据提供给后面的渲染线程。</li>
</ol>
</li>
<li><p>渲染：游戏线程创建渲染命令，渲染线程执行渲染命令，最后更新骨骼。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>动画通知深入分析</title>
    <url>/2022/04/19/%E5%8A%A8%E7%94%BB%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文通过源码对动画通知进行深入分析</p>
<span id="more"></span>

<h2 id="Notify"><a href="#Notify" class="headerlink" title="Notify"></a>Notify</h2><p>动画通知先从Notify开始看, 这里先看默认的<strong>Queue</strong>即队列类型的通知,  <strong>BranchPoint</strong>的通知最后再看</p>
<p><img src="https://img.supervj.top/imgimage-20220418160141678.png" alt="image-20220418160141678"></p>
<p>先看调用栈, 一般的通知都是到<code>TriggerSingleAnimNotify()</code>触发, 当然还有蒙太奇通知的特殊处理, 这个后面看</p>
<p><img src="https://img.supervj.top/imgimage-20220418160509060.png" alt="image-20220418160509060"></p>
<p>这部分没什么难度和内容, 关键是这个队列数据是怎么维护的?</p>
<p>查找引用后发现, 这个队列数组在每一次PreUpdateAnimation()时会被Reset, 在多线程Proxy中, 会在PostUpdate()中对队列进行Append</p>
<p><img src="https://img.supervj.top/imgimage-20220418163341561.png" alt="image-20220418163341561"></p>
<p>这个NotifyQueue成员变量是来自Proxy::UpdateAnimation() 中对动画资源的更新</p>
<p><img src="https://img.supervj.top/imgimage-20220418200254914.png" alt="image-20220418200254914"></p>
<p><img src="https://img.supervj.top/imgimage-20220418200357670.png" alt="image-20220418200357670"></p>
<p>关注一下关键的判定条件, 通知触发的条件就是</p>
<p><code>(NotifyStartTime &lt;= CurrentPosition) &amp;&amp; (NotifyEndTime &gt; PreviousPosition)</code></p>
<p>翻译一下通知触发条件就是 :<strong>通知的时间位于当前帧时间与前一帧时间中间</strong></p>
<p>总结一下</p>
<ol>
<li>AnimInstance执行PreUpdate重置通知队列, 同时也会执行Proxy的PreUpdate方法来重置Proxy内的队列</li>
<li>Proxy执行Update刷新动画资源, 刷新Proxy的通知队列</li>
<li>Proxy执行PostUpdate操作把本地的队列数据Append到AnimInstance</li>
<li>MeshComponent执行PostAnimEvaluation一路执行到TriggerSingleAnimNotify</li>
</ol>
<blockquote>
<p>补充:以上流程全是多线程</p>
</blockquote>
<p>另外, 不需要资源直接右键创建的动画通知也是在TriggerSingleAnimNotify中执行, 看下面代码, 通过ProcessEvent执行蓝图事件</p>
<p><img src="https://img.supervj.top/imgimage-20220418203343912.png" alt="image-20220418203343912"></p>
<h2 id="NotifyState"><a href="#NotifyState" class="headerlink" title="NotifyState"></a>NotifyState</h2><p>NotifyState即动画通知窗口中可以拖动起点和重点的带时长的动画通知, 可以接受Begin/Tick/End事件</p>
<p>NotifyState的调用栈与前者类似,  在<code>TriggerAnimNotifies</code>中分别处理的Notify和NotifyState的调用</p>
<p><img src="https://img.supervj.top/imgimage-20220418204155763.png" alt="image-20220418204155763"></p>
<p>用伪代码描述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">    遍历旧的激活中的通知(上一帧还在,这一帧没有了的)</span><br><span class="line">    &#123;</span><br><span class="line">       执行End</span><br><span class="line">    &#125;</span><br><span class="line">    遍历Begin类型的通知(这一帧新出现的)</span><br><span class="line">    &#123;</span><br><span class="line">        执行Begin</span><br><span class="line">    &#125;</span><br><span class="line">    遍历正在激活的通知</span><br><span class="line">    &#123;</span><br><span class="line">        执行Tick</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为他是先检测End并触发End, 所以说通知的<strong>End一定至少落后Begin一帧</strong>, 这在绝大多数情况下是没有问题的, 但是如果是下面这样</p>
<p><img src="https://img.supervj.top/imgimage-20220418205813769.png" alt="image-20220418205813769"></p>
<p>第一个通知打印1, 第二个打印2,得到的结果如下图</p>
<p><img src="https://img.supervj.top/imgimage-20220418205749772.png" alt="image-20220418205749772"></p>
<p>按照动画通知是配置按道理应该是第一个通知的Begin早于第二个的End, 但是由于前面说的机制, 导致了End会落后Begin一帧,这个在某些时候会导致不必要的问题</p>
<p>当然, 有几个解决办法, 要么尽量把前面通知的End与后面通知的Begin至少间隔一帧执行</p>
<p>或者还可以用<code>BranchPoint</code>的方式来解决一部分问题, 这个在下面会讲</p>
<h2 id="BranchPoint"><a href="#BranchPoint" class="headerlink" title="BranchPoint"></a>BranchPoint</h2><p>BranchPoint类型的动画通知是比较特殊的通知, 他与Queue不同的是不会排队处理, 而是统一到一个地方集中处理.</p>
<p>而且不同与Queue的多线程, BranchPoint的通知是统一在游戏线程同步执行的</p>
<p>官方说比较适合蒙太奇不同section之间有跳转的场合使用</p>
<p>先看一下一个普通的蓝图类Notify调用栈</p>
<p><img src="https://img.supervj.top/imgimage-20220418144400820.png" alt="image-20220418144400820"></p>
<p>从Montage的Advance开始看, 这个函数不断的推进蒙太奇动画</p>
<p><img src="https://img.supervj.top/imgimage-20220418144531240.png" alt="image-20220418144531240"></p>
<p><img src="https://img.supervj.top/imgimage-20220418145044104.png" alt="image-20220418145044104"></p>
<p><img src="https://img.supervj.top/imgimage-20220418145129007.png" alt="image-20220418145129007"></p>
<p>上面的图中获取一个<code>BranchingPointMarkerPtr</code>, 这个指针记录了这个BranchPoint的触发时机和类型</p>
<blockquote>
<p>补充: 如果是State通知, 那么 将保存Begin和End两份数据</p>
<p><img src="https://img.supervj.top/imgimage-20220418155211999.png" alt="image-20220418155211999"></p>
</blockquote>
<p>然后调用 HandleEvents() </p>
<p>在HandleEvents中会先处理队列通知,  把所有通知里的BranchPoint过滤掉</p>
<p> 然后是 UpdateActiveStateBranchingPoints()</p>
<p>这里会调用NotifyState的Begin和End事件, 用的方法是记录一个Active的事件数组<code>ActiveStateBranchingPoints</code>, 通过时间判断触发Begin或者End</p>
<p>最后是调用BranchingPointEventHandler()</p>
<p>这一步先处理一写被标记为转成Queue的BranchPoint通知, 通过宏可以关闭BranchPoint的通知,强制转成Queue, 看下图</p>
<p><img src="https://img.supervj.top/imgimage-20220419101840632.png" alt="image-20220419101840632"></p>
<p>然后<strong>再处理一遍State类型的Begin和End触发</strong>, 最后是才是处理Notify的触发</p>
<blockquote>
<p>那么问题来了, 为什么UpdateActiveStateBranchingPoints()和BranchingPointEventHandler()都有对State通知的触发</p>
<p>首先机制不一样, 前者是通过当前时间来触发, 后者是通过序列化到资源的BranchingPointMarkerPtr数据来判定触发与否,</p>
<p>这是因为蒙太奇动画经常会跳转section导致动画的position会瞬切, 这当中涉及到的问题很多,  前后这两者加起来保证了正常的触发</p>
</blockquote>
<p>最后还有一个函数Termnate()会确保所有State通知如果在动画结束了还没有被End, 来保证触发通知的End事件</p>
<blockquote>
<p>补充: Sequence的BranchPoint也是会当作Queue通过TriggerSingleAnimNotify()等形式触发</p>
</blockquote>
<blockquote>
<p> 补充:  引擎自带的蒙太奇通知都是BranchPoint执行的</p>
</blockquote>
<p>回到上面2个State通知的情况, 如果前者使用的是BranchPoint, 那么看一下结果</p>
<p><img src="https://img.supervj.top/imgimage-20220419095456222.png" alt="image-20220419095456222"></p>
<p><img src="https://img.supervj.top/imgimage-20220419095523247.png" alt="image-20220419095523247"></p>
<p>结果就是前面的通知的End可以在正确的时机触发而不用等到下一帧了</p>
<p>但是BranchPoint有个问题, 在同一帧中的不能有太多的BranchPoint, 否则可能会导致部分通知丢失, 这个在添加通知的时候就会有警告</p>
<p><img src="https://img.supervj.top/imgimage-20220419095915331.png" alt="image-20220419095915331"></p>
<p>这是由BranchPoint的触发逻辑决定的, 因为在触发逻辑中, BranchPoint会去查找当前时间点第一个找到的BranchPoint通知, 同一时间的其他会被丢弃掉</p>
<p><img src="https://img.supervj.top/imgimage-20220419100312295.png" alt="image-20220419100312295"></p>
<p><img src="https://img.supervj.top/imgimage-20220419100126891.png" alt="image-20220419100126891"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>关于Queue与BranchPoint</li>
</ul>
<p>Queue与BranchPoint 主要区别在于Queue方法是异步的，而BranchPoint 是同步的。</p>
<p>Queue方法：当动画的 Evalutate 阶段结束时触发通知。不适合改变部分或跳跃蒙太奇位置。</p>
<p>BranchPoint 方法：到达分支点时，在正确的时间触发通知,精度较高。适合更改部分或跳转到蒙太奇位置。</p>
<p>如果一个特定的动画需要跳转到一个非常精确的点，最好使用BranchPoint 方法以获得更高的精度。</p>
<p>如果由于Queue方法的异步特性而在另一个帧中触发了事件，或者如果出现挂起，请使用BranchPoint方法。</p>
<p>BranchPoint方法以高开销为代价达到高精度，有好处也有缺点。如果允许若干帧的精度差距, 不会跳帧, 那么使用队列是足够了</p>
<blockquote>
<p>补充: 在大幅度的跳帧的情况下, 两者都可能不能触发</p>
</blockquote>
<ul>
<li>Notify和NotifyState</li>
</ul>
<p>Notify是一次性事件,  如果跳帧了可能会被跳过</p>
<p>NotifyState是持续性的一个状态, 有Begin/End/Tick事件, 除非整个被跳过, 否则<strong>有头必有尾</strong></p>
<p>另外,两者的蓝图Notify事件都是const的, 如果需要进行非const操作还是建议到cpp中去执行(老版本UE4中的Notify的蓝图事件不是const)</p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>动画:朝向适配OrientationWarping</title>
    <url>/2021/09/02/%E5%8A%A8%E7%94%BB%EF%BC%9AOrientationWarping/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_09_02_14_24_43_123.gif" alt="录制_2021_09_02_14_24_43_123"></p>
<p>用过动画混合空间的同学肯定遇到过上图这种情况, 多数4方向或者8方向位移的混合空间在其中2个朝向上会遇到如此问题, 如何解决这个问题呢?  一种方式是类似大名鼎鼎的ALS项目的使用额外的动画来完成混合</p>
<span id="more"></span>

<p><img src="https://i.loli.net/2020/10/29/TZ3YyD4ol5hzOUk.png"></p>
<p><img src="https://i.loli.net/2020/10/29/aNtJ7mBHYkV9Zrq.png"></p>
<p><img src="https://i.loli.net/2020/10/29/1tEQj8oqGLcaeuN.png"></p>
<p>那么如果没有那么多的动画资源, 甚至只有4方向的动画呢? 本文就此进行研究讨论</p>
<h2 id="OrientationWarping"><a href="#OrientationWarping" class="headerlink" title="OrientationWarping"></a>OrientationWarping</h2><p>我们的思路是获取应该旋转的角度, 通过<code>TransoformBone</code>来旋转脊椎线上的骨骼, 因为骨骼有层级关系, 所以我们得先旋转<code>pelvis</code>骨骼, 再把<code>spine</code>骨骼反着转回去, 这样就就把下半身单独旋转了</p>
<p><img src="https://img.supervj.top//img/image-20210902143147611.png" alt="image-20210902143147611"></p>
<p>至于怎么计算角度,  用<code>CalculateDirecton</code>来获取<code>[-180,180]</code>的角度, 然后转换到<code>[0,360]</code>再一顿操作换算成<code>0</code>到<code>3</code>的4个整形数字(分别对应FRBL，方便blend), 随后计算骨骼旋转所需要的<code>Yaw</code></p>
<p><img src="https://img.supervj.top//img/image-20210902152544977.png" alt="image-20210902152544977"></p>
<p><img src="https://img.supervj.top//img/image-20210902153104332.png" alt="image-20210902153104332"></p>
<p>最后把这个<code>Yaw</code>构造成<code>Rotator</code>就行了</p>
<p><img src="https://img.supervj.top//img/image-20210902175126237.png" alt="image-20210902175126237"></p>
<p>结合起来就是这个样子</p>
<p><img src="https://img.supervj.top//img/image-20210902175210709.png" alt="image-20210902175210709"></p>
<p>然后要对这个方向整型变量做一个边界处理,  打个比方, 目前是正前方朝向, 那么45度的时候应该还是保持正前方, 在60度的时候再切换成向右, 这样才不会造成中间角度来回抽风的情况</p>
<hr>
<p>看最后效果</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_09_02_17_57_09_488.gif" alt="录制_2021_09_02_17_57_09_488"></p>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>UE4自带一个朝向适配节点</p>
<p><img src="https://img.supervj.top//img/image-20210902180528440.png" alt="image-20210902180528440"></p>
<p><img src="https://img.supervj.top//img/image-20210902180632618.png" alt="image-20210902180632618"></p>
<p>原理跟自己用<code>TransformBone</code>怼出来的差不多,   不过毕竟用于生产的话肯定还是一个动画节点来的按安逸更舒服</p>
<hr>
<p>另外的<a href="https://www.unrealengine.com/marketplace/zh-CN/product/strider-animation-warping">Strider - Animation Warping</a>这一类的第三方插件也有类似节点</p>
<p><img src="https://img.supervj.top//img/image-20210902180915202.png" alt="image-20210902180915202"></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>动画：脚步适配/Strider Warping</title>
    <url>/2021/08/26/%E5%8A%A8%E7%94%BB%EF%BC%9AStrideWarping/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前我们在处理Locomotion的滑步情况一般都会调整动画速率来达到看上去还凑合的效果, 然而在速度缩放值超过一定范围以后, 展现的情况就非常诡异了, 这个时候就需要通过其他方法来达到这一目的</p>
<p>下面是<a href="https://www.youtube.com/watch?v=1UOY-FMm-xo&t=2592s">Paragon Feature Examples: Animation Techniques </a>里面展示的两者的区别</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_08_30_14_14_07_398.gif" alt="录制_2021_08_30_14_14_07_398"></p>
<span id="more"></span>

<p>UE5中有一个对应的动画节点<code>FAnimNode_StrideWarping</code>,  但是我发现这个节点有错误(望打脸), 先把他移植到UE4,再慢慢讲</p>
<p><img src="https://img.supervj.top//img/image-20210830142057182.png" alt="image-20210830142057182"></p>
<h2 id="脚步适配-StrideWarping"><a href="#脚步适配-StrideWarping" class="headerlink" title="脚步适配(StrideWarping)"></a>脚步适配(StrideWarping)</h2><p>从上面的动图可以看到, 脚步适配其实就是让脚步迈的更大/更小来取代动画速率, 那么执行的操作就比较类似用IK来控制脚步的落点的感觉, 但是如果用<code>TwoBone IK</code>来实施起来会发现比较困难, 还是建议到c++中用动画节点来完成</p>
<p>知乎大佬有一篇文章用<code>Control Rig</code>来模拟这个过程, 实际上效果会有点差别, 在步伐放大以后的效果比较差</p>
<p><a href="https://zhuanlan.zhihu.com/p/363656339">传送门</a></p>
<p>一句话概括脚步适配的计算</p>
<blockquote>
<p>脚步位置 = 初始的位置 + 初始的位置沿着脚步平面运动方向的偏移 * 缩放值</p>
</blockquote>
<p>看一下<code>FAnimNode_StrideWarping</code>节点的参数</p>
<p><img src="https://img.supervj.top//img/image-20210830143736595.png" alt="image-20210830143736595"></p>
<p>参数比较多,  而且没有注释, 果然只是beta版本</p>
<blockquote>
<p>在动画蓝图模式下调试此节点的CMD命令是   <code>a.AnimNode.StrideWarping.Debug 1</code></p>
</blockquote>
<h3 id="脚步缩放"><a href="#脚步缩放" class="headerlink" title="脚步缩放"></a>脚步缩放</h3><p>下面这段代码在我看来有问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//臀部朝下的射线与(IK骨骼与地面组成的平面)的交点</span></span><br><span class="line"><span class="keyword">const</span> FVector StrideWarpingPlaneOrigin = (FMath::<span class="built_in">Abs</span>(GravityDir | FloorPlaneNormal) &gt; DELTA) ? FMath::<span class="built_in">LinePlaneIntersection</span>(HipBoneLocation, HipBoneLocation + GravityDir, IKFootLocation, FloorPlaneNormal) : IKFootLocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IK骨骼位置投影到(前者交点与设定的平面法线的交点), 该点为缩放起始点</span></span><br><span class="line"><span class="keyword">const</span> FVector ScaleOrigin = FVector::<span class="built_in">PointPlaneProject</span>(IKFootLocation, StrideWarpingPlaneOrigin, StrideWarpingPlaneNormal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后的位置就是[ 缩放起始点 +  缩放起始点到更新的脚步IK位置的方向 * 缩放值 ]</span></span><br><span class="line"><span class="keyword">const</span> FVector WarpedLocation = ScaleOrigin + (IKFootLocation - ScaleOrigin) * ActualStrideScaling;</span><br><span class="line">FootData.IKBoneTransform.<span class="built_in">SetLocation</span>(WarpedLocation);</span><br></pre></td></tr></table></figure>

<p>按照我的理解,我们的目的是根据<code>foot_l</code>骨骼的位置变换来设置<code>ik_foot_l</code>的实时位置, 那么上面代码的<code>StrideWarpingPlaneOrigin</code>做的是大腿顶部的位置投影到IK平面, 这个可以有, 然后把IK骨骼位置投影到适配的平面作为起始点, 这个也可以理解, 那么<code>(IKFootLocation - ScaleOrigin)</code>这个操作就有点不理解了, 这俩位置都是固定, 是否应该把<code>IKFootLocation </code>改成<code>FKFootLocation </code>?</p>
<p>那么先按照现有的代码配置<code>FeetDefinitions</code>参数的时候, 理所当然的想到是这样设置的</p>
<p><img src="https://img.supervj.top//img/image-20210830143933520.png" alt="image-20210830143933520"></p>
<p>然而如何尝试都是原地踏步运动, 看下图的右腿</p>
<img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_08_30_14_40_43_902.gif" alt="录制_2021_08_30_14_40_43_902" style="zoom:50%;" />





<p>于是, 重点来了, 手动魔改了一下代码</p>
<p>首先<code>FStrideWarpingFootData</code>加了一个FK位置信息的成员变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FStrideWarpingFootData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">GENERATED_USTRUCT_BODY</span>()</span><br><span class="line"></span><br><span class="line">	FCompactPoseBoneIndex IKFootBoneIndex;</span><br><span class="line">	FCompactPoseBoneIndex FKFootBoneIndex;</span><br><span class="line">	FCompactPoseBoneIndex HipBoneIndex;</span><br><span class="line">	FTransform IKBoneTransform;</span><br><span class="line">	<span class="comment">//新</span></span><br><span class="line">	FTransform FKBoneTransform;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后就是主要计算部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; FootData : FeetData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> FVector IKFootLocation = FootData.IKBoneTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> FVector FKFootLocation = FootData.FKBoneTransform.<span class="built_in">GetLocation</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FVector HipBoneLocation = Output.Pose.<span class="built_in">GetComponentSpaceTransform</span>(FootData.HipBoneIndex).<span class="built_in">GetLocation</span>();</span><br><span class="line"></span><br><span class="line">    FVector StrideWarpingPlaneOrigin = (FMath::<span class="built_in">Abs</span>(GravityDir | FloorPlaneNormal) &gt; DELTA) ? FMath::<span class="built_in">LinePlaneIntersection</span>(HipBoneLocation, HipBoneLocation + GravityDir, FKFootLocation, FloorPlaneNormal) : IKFootLocation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FVector ScaleOrigin = FVector::<span class="built_in">PointPlaneProject</span>(FKFootLocation, StrideWarpingPlaneOrigin, StrideWarpingPlaneNormal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里直接拿Y轴来计算, 实际上应该是可配置的</span></span><br><span class="line">    FVector WarpedLocation;</span><br><span class="line">    WarpedLocation.Y = ScaleOrigin.Y + (FKFootLocation- ScaleOrigin).Y * ActualStrideScaling;</span><br><span class="line">    WarpedLocation.Z = FKFootLocation.Z;</span><br><span class="line">    WarpedLocation.X = FKFootLocation.X;</span><br><span class="line">    FootData.IKBoneTransform.<span class="built_in">SetLocation</span>(WarpedLocation);</span><br><span class="line">    FootData.IKBoneTransform.<span class="built_in">SetRotation</span>(FootData.FKBoneTransform.<span class="built_in">GetRotation</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_09_01_15_02_27_139.gif" alt="录制_2021_09_01_15_02_27_139"></p>
<p>效果还可以, <code>pelvis</code>位置校正的那一块沿用了旧的代码</p>
<h3 id="盆骨校正"><a href="#盆骨校正" class="headerlink" title="盆骨校正"></a>盆骨校正</h3><p>因为只缩放脚步, 步子迈的大了, <code>pelvis</code>位置必然会需要下降, 不然人要不就腾空, 要不就脚步被IK拉直了,  这里大致思路就是利用脚步位置到盆骨位置的距离值来校正盆骨位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FVector AdjustedPelvisLocation = InitialPelvisLocation;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">check</span>(IKFeetLocation.<span class="built_in">Num</span>() &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> PerFootWeight = (<span class="number">1.f</span> / <span class="built_in"><span class="keyword">float</span></span>(IKFeetLocation.<span class="built_in">Num</span>()));</span><br><span class="line"></span><br><span class="line">    int32 Iterations = FMath::<span class="built_in">Clamp</span>(PelvisAdjustmentMaxIter, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span> (Iterations-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> FVector PreAdjustmentLocation = AdjustedPelvisLocation;</span><br><span class="line">        AdjustedPelvisLocation = FVector::ZeroVector;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int32 Index = <span class="number">0</span>; Index &lt; IKFeetLocation.<span class="built_in">Num</span>(); Index++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> FVector IdealPelvisLoc = IKFeetLocation[Index] + (PreAdjustmentLocation - IKFeetLocation[Index]).<span class="built_in">GetSafeNormal</span>() * FKFeetDistToPelvis[Index];</span><br><span class="line">            AdjustedPelvisLocation += IdealPelvisLoc * PerFootWeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码简单理解为 <code>pelvis</code>骨骼朝着两个脚步骨骼偏移以后取平均</p>
<p>然后是做一个插值计算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FVector TargetAdjustment = (AdjustedPelvisLocation - InitialPelvisLocation);</span><br><span class="line">PelvisAdjustmentInterp.<span class="built_in">Update</span>(TargetAdjustment, CachedDeltaTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FVector SmoothAdjustedPelvisLocation = InitialPelvisLocation + FMath::<span class="built_in">Lerp</span>(FVector::ZeroVector, PelvisAdjustmentInterp.<span class="built_in">GetPosition</span>(), PelvisPostAdjustmentAlpha);</span><br><span class="line">PelvisTransform.<span class="built_in">SetLocation</span>(SmoothAdjustedPelvisLocation);</span><br></pre></td></tr></table></figure>



<p>对比一下有没有偏移的效果</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_09_02_09_18_39_771.gif" alt="录制_2021_09_02_09_18_39_771"></p>
<p>靠后靠下一点的是应用了盆骨偏移的</p>
<h3 id="大腿骨校正"><a href="#大腿骨校正" class="headerlink" title="大腿骨校正"></a>大腿骨校正</h3><p>盆骨偏移了以后, 那么大腿骨也要跟着偏移一下, 不然姿势就会变得非常奇怪, 利用从盆骨得到的偏移量应用到大腿骨</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AdjustedHipTransform.<span class="built_in">AddToTranslation</span>(PelvisOffset);</span><br><span class="line"><span class="comment">//...............</span></span><br><span class="line">AdjustedHipTransform.<span class="built_in">SetRotation</span>(DeltaRotation * AdjustedHipTransform.<span class="built_in">GetRotation</span>());</span><br></pre></td></tr></table></figure>

<p>因为旋转了大腿骨， 所以在不适用脚步IK的情况下也可以有比较好的表现</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img.supervj.top//img/image-20210902102034513.png" alt="image-20210902102034513"></p>
<p>上图是开启了debug模式的所有debug图形</p>
<p>先看两条线</p>
<ul>
<li>绿色线表示的是IK骨骼到校正后的大腿骨的连线</li>
<li>红色线是FK骨骼到校正之前的大腿骨的连线</li>
</ul>
<p>然后看盆骨附近的连城一条线的3个球</p>
<ul>
<li>红色球表示盆骨默认位置</li>
<li>绿色是计算后的<code>AdjustedPelvisLocation</code>位置</li>
<li>蓝色是插值以后的中间值</li>
</ul>
<p>中轴线上的2个黄色球表示脚步适配的起始点位置</p>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>虚幻商城还有其他第三方的插件也实现了脚步适配效果， 个人觉得<a href="https://www.unrealengine.com/marketplace/zh-CN/product/strider-animation-warping">Strider - Animation Warping</a>是个可行方案, 不过需要搭配脚步IK使用</p>
<p>效果如下</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_09_02_11_14_00_733.gif" alt="录制_2021_09_02_11_14_00_733"></p>
<p>在缩放大于1.5的时候有点奇怪</p>
<hr>
<p>还有免费的过期好久的插件<a href="https://www.unrealengine.com/marketplace/zh-CN/product/animgraphnode">Custom Speed &amp; Orientation Warping</a></p>
<p>原理都差不多, 无非就是算法有区别, 不过这个插件我试了一下也是有问题的,  不想细究了, 谁有兴趣谁去整一波</p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>地形及关卡流简单记录</title>
    <url>/2021/01/08/%E5%9C%B0%E5%BD%A2%E5%8F%8A%E5%85%B3%E5%8D%A1%E6%B5%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>从遥远的2019年搬运而来, 仅作为记录,后续视情况补充</p>
</blockquote>
<p>[官方文档][<a href="https://docs.unrealengine.com/zh-CN/Engine/Landscape/index.html]">https://docs.unrealengine.com/zh-CN/Engine/Landscape/index.html]</a></p>
<h2 id="地形的内存"><a href="#地形的内存" class="headerlink" title="地形的内存"></a>地形的内存</h2><ul>
<li><p>对于顶点数据，Landscape为每个顶点使用4个字节。静态网格体（Static Mesh）以12字节矢量的形式存储位置，每个切线X和Z矢量封装为4个字节，并为每个顶点的共24或28个字节存储16位或32位浮点UV。</p>
</li>
<li><p>这意味着，对于相同的顶点密度，<strong>静态网格体（Static Mesh）将使用6或7倍于Landscape的内存</strong>。Landscape还将它们的数据存储为纹理，并且可以为遥远的区域流送未使用的LOD关卡，并在您接近它们时从后台的磁盘加载它们。Landscape使用一个常规的高度场，因此其碰撞数据也能够比静态网格体（Static Mesh）的碰撞数据更高效地存储。</p>
</li>
</ul>
<h3 id="地形存储方式"><a href="#地形存储方式" class="headerlink" title="地形存储方式"></a>地形存储方式</h3><ul>
<li>Landscape系统在GPU内存中以纹理的形式存储地形的渲染数据，允许在顶点着色器中查找数据。数据被打包成32位纹理，<strong>高度以R和G信道的形式占据16位</strong>，<strong>X和Y偏移量以8位数值分别存储在B和A信道中</strong>。</li>
</ul>
<span id="more"></span>

<h2 id="地形创建"><a href="#地形创建" class="headerlink" title="地形创建"></a>地形创建</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SectionSize</td>
<td>用于设置地形 LOD 和消隐的分段尺寸。<strong>较小的尺寸使地形更积极地对分段设置 LOD</strong>，但 CPU 的消耗将增大。较大的尺寸即意味着组件较少，CPU 的消耗较小。创建<strong>大型地形时须使用较大的分段尺寸</strong>，因为在较小的分段尺寸下放大地形比例对 CPU 的消耗过大。</td>
</tr>
<tr>
<td>SectionPerComponent</td>
<td>此属性对地形 LOD 有辅助作用。每个分段都是地形 LOD 的基础单元。一个组件可能拥有 2 x 2 的分段，意味着<strong>一个组件一次可渲染四个不同的 LOD</strong>。<u>使用较大的分段尺寸可减少 CPU 计算时间</u>，从而获得额外的益处。然而，地形同时渲染数量过多的顶点时可能出现问题。使用超大的地形区域时问题将普遍存在。这些问题在移动设备上可能尤为严重，因为绘制调用的数量将受到硬件限制。</td>
</tr>
<tr>
<td>Numbers of Components</td>
<td>和 section size 一同用于地形尺寸的设置。此数值的上限为 32 x 32，因为每个组件均会产生 CPU 消耗；超过此上限可能引起地形的性能问题。</td>
</tr>
<tr>
<td>OverallResolution</td>
<td>顶点数</td>
</tr>
<tr>
<td>TotalComponents</td>
<td>组件数，CPU消耗主要决定因素</td>
</tr>
</tbody></table>
<ul>
<li>以下是简单理解</li>
<li>Component：地形基本单元，一个Component会被整体裁剪或者渲染以及处理碰撞</li>
<li>Section：Lod基本单元</li>
<li>Quad：网格数量，或者说顶点数</li>
</ul>
<h2 id="地形碰撞"><a href="#地形碰撞" class="headerlink" title="地形碰撞"></a>地形碰撞</h2><h3 id="CollisionMipLevel"><a href="#CollisionMipLevel" class="headerlink" title="CollisionMipLevel"></a>CollisionMipLevel</h3><p>处理<strong>复杂</strong>碰撞精细度，越高越不精确</p>
<h3 id="SimpleCollisionMipLevel"><a href="#SimpleCollisionMipLevel" class="headerlink" title="SimpleCollisionMipLevel"></a>SimpleCollisionMipLevel</h3><p><strong>简单</strong>碰撞的处理精细度，越高越不精确</p>
<blockquote>
<p><img src="https://img.supervj.top//img/01.png" alt="01"></p>
</blockquote>
<blockquote>
<p><img src="https://img.supervj.top//img/02.png" alt="02"></p>
</blockquote>
<ul>
<li>上图是用playerCollision模式查看简单碰撞模式，分别是0，3的显示结果</li>
<li>用VisibilityCollision模式查看复杂碰撞的结果类似</li>
<li>同理可以对不同地形component的碰撞精细度进行处理</li>
</ul>
<h2 id="关卡流"><a href="#关卡流" class="headerlink" title="关卡流"></a>关卡流</h2><p>目前提供两种加载方式</p>
<ul>
<li>蓝图或者c++手动加载</li>
<li>LevelStreamingVolume盒子自动加载</li>
</ul>
<h3 id="蓝图加载"><a href="#蓝图加载" class="headerlink" title="蓝图加载"></a>蓝图加载</h3><blockquote>
<p><img src="https://img.supervj.top//img/image-20191211152428687.png" alt="image-20191211152428687"></p>
</blockquote>
<h3 id="C-加载"><a href="#C-加载" class="headerlink" title="C++加载"></a>C++加载</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UGameplayStatics::<span class="built_in">LoadStreamLevel</span>(GEngine-&gt;<span class="built_in">GetWorld</span>(), LevelName, <span class="number">1</span>, <span class="number">0</span>, FLatentActionInfo&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UGameplayStatics::LoadStreamLevel</span><span class="params">(<span class="keyword">const</span> UObject* WorldContextObject, FName LevelName,<span class="keyword">bool</span> bMakeVisibleAfterLoad,<span class="keyword">bool</span> bShouldBlockOnLoad,FLatentActionInfo LatentInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (UWorld* World = GEngine-&gt;<span class="built_in">GetWorldFromContextObject</span>(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull))</span><br><span class="line">	&#123;</span><br><span class="line">		FLatentActionManager&amp; LatentManager = World-&gt;<span class="built_in">GetLatentActionManager</span>();</span><br><span class="line">		<span class="keyword">if</span> (LatentManager.FindExistingAction&lt;FStreamLevelAction&gt;(LatentInfo.CallbackTarget, LatentInfo.UUID) == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			FStreamLevelAction* NewAction = <span class="keyword">new</span> <span class="built_in">FStreamLevelAction</span>(<span class="literal">true</span>, LevelName, bMakeVisibleAfterLoad, bShouldBlockOnLoad, LatentInfo, World);</span><br><span class="line">			LatentManager.<span class="built_in">AddNewAction</span>(LatentInfo.CallbackTarget, LatentInfo.UUID, NewAction);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LevelStreamingVolume"><a href="#LevelStreamingVolume" class="headerlink" title="LevelStreamingVolume"></a>LevelStreamingVolume</h3><blockquote>
<p><img src="https://img.supervj.top//img/image-20191211152559630.png" alt="image-20191211152559630"></p>
</blockquote>
<ul>
<li>如上图，在关卡细节里面需要指定子关卡对应的盒子（绑定）</li>
<li>多个盒子可以一起作用</li>
</ul>
<hr>
<ul>
<li>两者不能同时作用，必须把盒子disable后才可以用方法去控制</li>
</ul>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>地形</tag>
        <tag>流关卡</tag>
      </tags>
  </entry>
  <entry>
    <title>实时加载本地图片和音效</title>
    <url>/2021/03/25/%E5%AE%9E%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E5%92%8C%E9%9F%B3%E6%95%88/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从本地路径加载图片和音效数据, 得到<code>UTexture2D</code>和<code>USoundWave</code></p>
<p><img src="https://img.supervj.top//img/UE4Editor_dmHYzjuVWx.png" alt="UE4Editor_dmHYzjuVWx"></p>
<span id="more"></span>



<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="从文件加载UTexture2D"><a href="#从文件加载UTexture2D" class="headerlink" title="从文件加载UTexture2D"></a>从文件加载UTexture2D</h3><p>一切尽在注释中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//加载ImageWrapper模块，同时创建一个针对格式操作的辅助对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TSharedPtr&lt;IImageWrapper&gt; <span class="title">GetImageWrapperByExtention</span><span class="params">(<span class="keyword">const</span> FString InImagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IImageWrapperModule&amp; ImageWrapperModule = FModuleManager::GetModuleChecked&lt;IImageWrapperModule&gt;(<span class="built_in">FName</span>(<span class="string">&quot;ImageWrapper&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (InImagePath.<span class="built_in">EndsWith</span>(<span class="string">&quot;.png&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ImageWrapperModule.<span class="built_in">CreateImageWrapper</span>(EImageFormat::PNG);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (InImagePath.<span class="built_in">EndsWith</span>(<span class="string">&quot;.jpg&quot;</span>) || InImagePath.<span class="built_in">EndsWith</span>(<span class="string">&quot;.jpeg&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ImageWrapperModule.<span class="built_in">CreateImageWrapper</span>(EImageFormat::JPEG);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (InImagePath.<span class="built_in">EndsWith</span>(<span class="string">&quot;.bmp&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ImageWrapperModule.<span class="built_in">CreateImageWrapper</span>(EImageFormat::BMP);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (InImagePath.<span class="built_in">EndsWith</span>(<span class="string">&quot;.ico&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ImageWrapperModule.<span class="built_in">CreateImageWrapper</span>(EImageFormat::ICO);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (InImagePath.<span class="built_in">EndsWith</span>(<span class="string">&quot;.exr&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ImageWrapperModule.<span class="built_in">CreateImageWrapper</span>(EImageFormat::EXR);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (InImagePath.<span class="built_in">EndsWith</span>(<span class="string">&quot;.icns&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ImageWrapperModule.<span class="built_in">CreateImageWrapper</span>(EImageFormat::ICNS);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UTexture2D* <span class="title">UFlib_IO::LoadTexture2DFromFile</span><span class="params">(<span class="keyword">const</span> FString&amp; FilePath, <span class="keyword">bool</span>&amp; IsValid, int32&amp; Width, int32&amp; Height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	IsValid = <span class="literal">false</span>;</span><br><span class="line">	UTexture2D* LoadedT2D = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	TSharedPtr&lt;IImageWrapper&gt; ImageWrapper = <span class="built_in">GetImageWrapperByExtention</span>(FilePath);</span><br><span class="line"><span class="comment">//得到解压后的源数据</span></span><br><span class="line">	TArray&lt;uint8&gt; RawFileData;</span><br><span class="line">	<span class="keyword">if</span> (!FFileHelper::<span class="built_in">LoadFileToArray</span>(RawFileData, *FilePath, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ImageWrapper.<span class="built_in">IsValid</span>() &amp;&amp; ImageWrapper-&gt;<span class="built_in">SetCompressed</span>(RawFileData.<span class="built_in">GetData</span>(), RawFileData.<span class="built_in">Num</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		TArray&lt;uint8&gt; UncompressedBGRA;</span><br><span class="line">        <span class="comment">//设置格式并获取未压缩的数据</span></span><br><span class="line">		<span class="keyword">if</span> (ImageWrapper-&gt;<span class="built_in">GetRaw</span>(ERGBFormat::BGRA, <span class="number">8</span>, UncompressedBGRA))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//创建UTexture2D*</span></span><br><span class="line">			LoadedT2D = UTexture2D::<span class="built_in">CreateTransient</span>(ImageWrapper-&gt;<span class="built_in">GetWidth</span>(), ImageWrapper-&gt;<span class="built_in">GetHeight</span>(), PF_B8G8R8A8);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!LoadedT2D) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			<span class="comment">//得到高度和宽度</span></span><br><span class="line">			Width = ImageWrapper-&gt;<span class="built_in">GetWidth</span>();</span><br><span class="line">			Height = ImageWrapper-&gt;<span class="built_in">GetHeight</span>();</span><br><span class="line"> 			<span class="comment">// 锁住他的数据  </span></span><br><span class="line">			<span class="keyword">void</span>* TextureData = LoadedT2D-&gt;PlatformData-&gt;Mips[<span class="number">0</span>].BulkData.<span class="built_in">Lock</span>(LOCK_READ_WRITE);</span><br><span class="line">            <span class="comment">//获取纹理数据</span></span><br><span class="line">			FMemory::<span class="built_in">Memcpy</span>(TextureData, UncompressedBGRA.<span class="built_in">GetData</span>(), UncompressedBGRA.<span class="built_in">Num</span>());</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">			LoadedT2D-&gt;PlatformData-&gt;Mips[<span class="number">0</span>].BulkData.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">			LoadedT2D-&gt;<span class="built_in">UpdateResource</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	IsValid = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> LoadedT2D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="RenderTarget2D导出成本地图片"><a href="#RenderTarget2D导出成本地图片" class="headerlink" title="RenderTarget2D导出成本地图片"></a>RenderTarget2D导出成本地图片</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UFlib_IO::ExportTextureRenderTarget2D2PNG</span><span class="params">(UTextureRenderTarget2D* TextureRenderTarget, <span class="keyword">const</span> FString&amp; FilePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	FTextureRenderTargetResource* rtResource = TextureRenderTarget-&gt;<span class="built_in">GameThread_GetRenderTargetResource</span>();</span><br><span class="line">	<span class="function">FReadSurfaceDataFlags <span class="title">readPixelFlags</span><span class="params">(RCM_UNorm)</span></span>;</span><br><span class="line"></span><br><span class="line">	TArray&lt;FColor&gt; outBMP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (FColor&amp; color : outBMP)</span><br><span class="line">	&#123;</span><br><span class="line">		color.A = <span class="number">255</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	outBMP.<span class="built_in">AddUninitialized</span>(TextureRenderTarget-&gt;<span class="built_in">GetSurfaceWidth</span>() * TextureRenderTarget-&gt;<span class="built_in">GetSurfaceHeight</span>());</span><br><span class="line">	rtResource-&gt;<span class="built_in">ReadPixels</span>(outBMP, readPixelFlags);</span><br><span class="line"></span><br><span class="line">	<span class="function">FIntPoint <span class="title">destSize</span><span class="params">(TextureRenderTarget-&gt;GetSurfaceWidth(), TextureRenderTarget-&gt;GetSurfaceHeight())</span></span>;</span><br><span class="line">	TArray&lt;uint8&gt; CompressedBitmap;</span><br><span class="line">	FImageUtils::<span class="built_in">CompressImageArray</span>(destSize.X, destSize.Y, outBMP, CompressedBitmap);</span><br><span class="line">	<span class="keyword">bool</span> imageSavedOk = FFileHelper::<span class="built_in">SaveArrayToFile</span>(CompressedBitmap, *FilePath);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> imageSavedOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h2><h3 id="从本地文件加载USoundWave"><a href="#从本地文件加载USoundWave" class="headerlink" title="从本地文件加载USoundWave"></a>从本地文件加载USoundWave</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">class USoundWave* <span class="title">UFlib_IO::LoadWaveDataFromFile</span><span class="params">(<span class="keyword">const</span> FString&amp; FilePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	USoundWave* sw = NewObject&lt;USoundWave&gt;(USoundWave::<span class="built_in">StaticClass</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sw)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	TArray &lt; uint8 &gt; rawFile;</span><br><span class="line"></span><br><span class="line">	FFileHelper::<span class="built_in">LoadFileToArray</span>(rawFile, FilePath.<span class="built_in">GetCharArray</span>().<span class="built_in">GetData</span>());</span><br><span class="line">	FWaveModInfo WaveInfo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WaveInfo.<span class="built_in">ReadWaveInfo</span>(rawFile.<span class="built_in">GetData</span>(), rawFile.<span class="built_in">Num</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		sw-&gt;<span class="built_in">InvalidateCompressedData</span>();</span><br><span class="line"></span><br><span class="line">		sw-&gt;RawData.<span class="built_in">Lock</span>(LOCK_READ_WRITE);</span><br><span class="line">		<span class="keyword">void</span>* LockedData = sw-&gt;RawData.<span class="built_in">Realloc</span>(rawFile.<span class="built_in">Num</span>());</span><br><span class="line">		FMemory::<span class="built_in">Memcpy</span>(LockedData, rawFile.<span class="built_in">GetData</span>(), rawFile.<span class="built_in">Num</span>());</span><br><span class="line">		sw-&gt;RawData.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">		int32 DurationDiv = *WaveInfo.pChannels * *WaveInfo.pBitsPerSample * *WaveInfo.pSamplesPerSec;</span><br><span class="line">		<span class="keyword">if</span> (DurationDiv)</span><br><span class="line">		&#123;</span><br><span class="line">			sw-&gt;Duration = *WaveInfo.pWaveDataSize * <span class="number">8.0f</span> / DurationDiv;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			sw-&gt;Duration = <span class="number">0.0f</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sw-&gt;<span class="built_in">SetSampleRate</span>(*WaveInfo.pSamplesPerSec);</span><br><span class="line">		sw-&gt;NumChannels = *WaveInfo.pChannels;</span><br><span class="line">		sw-&gt;RawPCMDataSize = WaveInfo.SampleDataSize;</span><br><span class="line">		sw-&gt;SoundGroup = ESoundGroup::SOUNDGROUP_Default;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>图片</tag>
        <tag>音效</tag>
      </tags>
  </entry>
  <entry>
    <title>TortoiseGit简单使用说明</title>
    <url>/2020/09/22/%E5%B0%8F%E4%B9%8C%E9%BE%9FGit/</url>
    <content><![CDATA[<blockquote>
<p>此文讲解如何使用Git版本的小乌龟插件</p>
</blockquote>
<p>由于git默认的黑窗口对于部分开发人员特别是美术人员比较不太友好，所以很多人会选择使用可视化的<code>TortoiseGit</code>(小乌龟)插件来协作开发</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先必须先安装git，</p>
<p><a href="https://git-scm.com/">Git链接</a></p>
<p>无脑下一步安装完毕，如需了解git如何使用，可以参考本人另外一篇文章</p>
<p><a href="https://supervj.top/2020/05/12/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/">Git使用指北</a></p>
<p>然后下载小乌龟插件，可以随意搜索下载，或者使用如下地址下载</p>
<p><a href="https://tortoisegit.org/download/">TortoiseGit</a></p>
<p>无脑下一步安装，成功以后右键菜单会添加小乌龟按钮</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921102026347.png" alt="image-20200921102026347"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>先来一张最简化的流程图，上下两部分分别用文字或者命令来解释流程</p>
<p><img src="https://img.supervj.top/img/advVR/%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%20(1).jpg" alt="协作开发流程 (1)"></p>
<p>如果有使用过<code>SVN</code>的同学，在这里要说明<code>git</code>与<code>SVN</code>在使用上会多一步操作，也就是<code>git</code>分布式特点的体现，</p>
<p><code>git</code>会有本地仓库一个概念，<code>SVN</code>的<code>Commit</code>意味着已经把本地修改推送到了远程服务器端，但是<code>git</code>的<code>commit</code>只是提交到本地仓库，在本地仓库存储着几乎与远程服务器同步的信息，包括所有文件信息、提交日志、分支信息等，也就意味着<code>git</code>可以在没有网络的时候也同样可以维护着一个仓库内容，在需要的时候在同步到远程服务器，这一点对于人数比较多的团队协作开发是优于<code>svn</code>的</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>在正常使用小乌龟之前，需要先配置一下环境</p>
<p>如果使用<code>GitHub</code>仓库，需要到<code>GitHub</code>去注册一个账号，比较简单此步忽略</p>
<p>如果是本地仓库的协作开发的，用已经搭建好的本地仓库ip去注册(例如192.168.1.111)，然后需要管理员授权以后就可以参与开发</p>
<p><a href="https://supervj.top/2020/08/18/%E7%94%A8GitLab%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/">关于如何搭建本地Git仓库</a></p>
<p>然后在开发之前，需要生成本地密钥，作为开发权限的一种判定</p>
<p>打开小乌龟安装目录，打开<code>PuTTYgen</code></p>
<p>界面如下</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921110129186.png" alt="image-20200921110129186"></p>
<p>用<code>Generate</code>来生成密钥，或者如果你已经用git生成过密钥，就可以使用<code>Load</code>选项来加载之前生成的私钥，记得勾选<code>AllFile</code>选项</p>
<p>然后进入如下界面</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921110352117.png" alt="image-20200921110352117"></p>
<p>用    <code>SavePublicKey</code>和<code>SavePrivateKey</code>按钮来保存一份本地的密钥文件，我这里把私钥保存为了<code>toPrivate.ppk</code>文件</p>
<p>接下来进入下一步</p>
<p>打开软件<code>Pageant</code>，双击以后如果没有出现窗口记得在右下角找到一个图标，打开以后如下窗口</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921110554461.png" alt="image-20200921110554461"></p>
<p>点击<code>AddKey</code>添加刚才保存的密钥(<code>toPrivate.ppk</code>)</p>
<blockquote>
<p>如果到这里之前的步骤提示你需要输入账户/密码的，这是git初始化的时候需要初始化账户，请参考我的git文档完成这一步</p>
</blockquote>
<blockquote>
<p> 目前掌握的信息每次电脑启动时都需要手动添加key，此坑先留着，以后研究</p>
</blockquote>
<p>至此，小乌龟的环境已经配置完毕</p>
<h3 id="拉取测试"><a href="#拉取测试" class="headerlink" title="拉取测试"></a>拉取测试</h3><p>我在<code>github</code>上有一个测试仓库，我们直接用此仓库来进行测试</p>
<p>地址为<code>git@github.com:VJien/Test.git</code></p>
<p>右键<code>GitClone</code>,输入URL，保持其他默认，点击<code>OK</code></p>
<p>拉取成功</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921111331388.png" alt="image-20200921111331388"></p>
<h3 id="修改-提交"><a href="#修改-提交" class="headerlink" title="修改/提交"></a>修改/提交</h3><p>我们来对<code>test.txt</code>文件做个修改，然后在新建要给文件 <code>1.txt</code></p>
<p><code>test</code>文件里面我们加入一些字符串，保存以后该文件变为红色感叹号</p>
<p>在该目录下右键小乌龟选择<code>Dif</code>,我们在同时用GitBase窗口来对比一下</p>
<p>看到如下提示，表示该文件被修改了</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921112548067.png" alt="image-20200921112548067"></p>
<p>可以右键单击一个文件来选择回退(Revert)或者提交(Commit)，似乎不需要<code>Add</code>操作，对于新创建的文件<code>1.txt</code>会不一样，一般需要先<code>Add</code>    再<code>Commit</code>，对于用惯了黑窗口的我来说，这里还是有区别的</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921113125132.png" alt="image-20200921113125132"></p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921113134620.png" alt="image-20200921113134620"></p>
<p>这里我们直接点击大窗口下面的<code>Commit</code>提交测试一番</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921113351447.png" alt="image-20200921113351447"></p>
<p>在<code>Message</code>里输入本次提交的名称，记得输入容易查找的名称，万一以后翻看日志如果发现都是 一对0102之类的会很崩溃</p>
<p>点击<code>Commit</code>显示成功</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921113532839.png" alt="image-20200921113532839"></p>
<p>在该窗口上有<code>Push</code>按钮，不过一般我们需要先<code>Pull</code>合并远程仓库的内容(除非是单人开发)</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921113633715.png" alt="image-20200921113633715"></p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921113647229.png" alt="image-20200921113647229"></p>
<p>无论是<code>Pull</code>还是<code>Push</code>都需要选择正确的分支，即上图的<code>RemoteBranch</code>,因为不同的分支是用于不同功能或者人员使用的，同时也需要比对本地的分支信息</p>
<p>拉取成功以后可以在窗口按钮里找到拉取信息差异对比等，这个自行测试</p>
<p>然后是提交，一般选好分支，其他保持默认选项</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921113927421.png" alt="image-20200921113927421"></p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921114022126.png" alt="image-20200921114022126"></p>
<h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><p>先来一个所有功能的图</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921114112053.png" alt="image-20200921114112053"></p>
<h5 id="add"><a href="#add" class="headerlink" title="add"></a><code>add</code></h5><p>标记需要提交的文件，在<code>GitBase</code>内是所有修改和新创建的都需要add的，在小乌龟里需要对新创建的进行add操作</p>
<h5 id="Switch-Checkout-CreateBranch"><a href="#Switch-Checkout-CreateBranch" class="headerlink" title="Switch/Checkout/CreateBranch"></a>Switch/Checkout/CreateBranch</h5><p><img src="https://img.supervj.top/img/advVR/image-20200921115129773.png" alt="image-20200921114312815"></p>
<p>创建新的分支和切换分支，类似<code>GitBase</code>的<code>git checkout -b 分支</code>/<code>git checkout 分支</code>操作</p>
<ul>
<li>Revert</li>
</ul>
<p>回退操作，<code>test</code>文件修改以后即红色感叹号的形况下，点击<code>Revert</code>后见下图</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921115129773.png" alt="image-20200921114553268"></p>
<p>选中点击OK以后就将此文件回退到之前版本</p>
<h5 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h5><p>解决冲突，这个是新手非常头大的一个问题，也是经常会出现的问题</p>
<p>我在其他文件拉取了这个工程，然后对<code>test</code>文件做了修改，然后回到此文件下同时对<code>test</code>文件修改，这一操作就模拟了协作开发时的冲突问题</p>
<p>然后拉取以后就发生冲突了</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921115129773.png" alt="image-20200921115129773"></p>
<p>然后点击<code>resolve</code>选项进行处理</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921135405643.png" alt="image-20200921135405643"></p>
<p>第一个选项可以看冲突信息，当然不是所有文件都可以看到；同时也可以在下图所示的地方选择使用哪个版本的内容</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200921135028147.png" alt="image-20200921135028147"></p>
<p>第3，4选项分别选择使用远程还是本地</p>
<p>解决完成后就再commit-&gt;pull-&gt;push操作，中间如果有警告出现可以忽略直接进行下一步</p>
<h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>在合并分支之前，首先要确保本地有需要合并的分支信息，比如<code>master</code>分支需要合并<code>test</code>分支，但是<code>test</code>分支是在远程电脑上创建的，本地还没有这个分支，那就先需要进行<code>fetch</code>操作</p>
<p>然后就可以找到所有分支了</p>
<p>使用<code>merge</code>操作就可以把<code>test</code>分支合并到本地</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>TortoiseGit</tag>
      </tags>
  </entry>
  <entry>
    <title>开源图形库Assimp</title>
    <url>/2021/03/21/%E5%BC%80%E6%BA%90%E5%9B%BE%E5%BD%A2%E5%BA%93Assimp/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>引用一段介绍</p>
<blockquote>
<p>Assimp,开源图形库(Open Asset Import Library)是一种便携式的可支持读取多种模型资源的开源库，它可以用统一的方式输入各种格式的3D模型，而其最新版本能实现输出3D模型的文件，因此该资源库也作为通用的3D模型转换器。assimp旨在提供用于游戏引擎实时渲染系统的一种完整的资源转换管道，但它不局限于这个目的，但在过去已被广泛应用。Assimp是用C++编写的，可以基于C语言应用程序编程接口或者绑定其它其它语言，如C#、.net、Python。为了进一步处理资源，Assimp加载了输入的模型格式为一个简单的数据结构，这个功能是由后处理工具加强的，包括一些常用的操作比如计算正常和切向量。</p>
<p>assimp是一种库，它主要用来加载和处理各种数据格式的几何场景。它主要针对的是那些支持节点层次、静态表层网格、材料、具有质感的动画和潜在纹理数据。assimp库不是为了提高速度而设计的，它最重要的用处就是，将每一个不同来源的资源导入并且在每一次的加载中以一种特殊的格式将它方便、快捷的存储起来。assimp也能够运用各种后处理步骤导入相应的数据，如转换为索引网格，计算法线和切线/双切线或转换从右手到左手坐标系统。assimp目前支持以下文件格式（请注意，一些装载机缺乏格式的一些特点，因为有些文件格式包含assimp不支持的数据，所以会需要很多的转换工作，而因此缺乏适当的格式规范并没有实现）</p>
</blockquote>
<p>本文主要对库本身的主要内容进行一波分析, 然后顺手封装成UE的蓝图插件</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_03_22_10_06_11_380.gif" alt="录制_2021_03_22_10_06_11_380"></p>
<span id="more"></span>

<p><a href="https://github.com/assimp/assimp">github官方</a></p>
<h2 id="支持格式"><a href="#支持格式" class="headerlink" title="支持格式"></a>支持格式</h2><p>Collada ( <em>.dae;</em>.xml )<br>Blender ( *.blend ) 3<br>Biovision BVH ( *.bvh )<br>3D Studio Max 3DS ( *.3ds )<br>3D Studio Max ASE ( *.ase )<br>Wavefront Object ( *.obj )<br>Stanford Polygon Library ( *.ply )<br>AutoCAD DXF ( *.dxf )<br>IFC-STEP, Industry Foundation Classes ( *.ifc )<br>Neutral File Format ( *.nff )<br>Sense8 WorldToolkit ( *.nff )<br>Valve Model ( <em>.smd,</em>.vta ) 3<br>Quake I ( *.mdl )<br>Quake II ( *.md2 )<br>Quake III ( *.md3 )<br>Quake 3 BSP ( *.pk3 ) 1<br>RtCW ( <em>.mdc )<br>Doom 3 ( <em>.md5mesh;</em>.md5anim;</em>.md5camera )<br>DirectX X ( *.x ).<br>Quick3D ( *.q3o;q3s ).<br>Raw Triangles ( .raw ).<br>AC3D ( *.ac ).<br>Stereolithography ( *.stl ).<br>Autodesk DXF ( *.dxf ).<br>Irrlicht Mesh ( <em>.irrmesh;</em>.xml ).<br>Irrlicht Scene ( <em>.irr;</em>.xml ).<br>Object File Format ( *.off ).<br>Terragen Terrain ( *.ter )<br>3D GameStudio Model ( *.mdl )<br>3D GameStudio Terrain ( <em>.hmp )<br>Ogre (</em>.mesh.xml, *.skeleton.xml, *.material)3<br>Milkshape 3D ( *.ms3d )<br>LightWave Model ( *.lwo )<br>LightWave Scene ( *.lws )<br>Modo Model ( *.lxo )<br>CharacterStudio Motion ( *.csm )<br>Stanford Ply ( *.ply )<br>TrueSpace ( *.cob, *.scn )2<br>XGL ( *.xgl, *.zgl )<br>支持以下格式的导出：<br>Collada(.dae)<br>Wavefront Object(.obj)<br>Stereolithography(.stl)<br>Stanford Polygon Library(.ply)</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>一般情况建议自己通过cmake编译assimp源文件, 部分情况可能需要用到win32的链接库(我在学习opengl用的是win32);</p>
<p>从<a href="https://github.com/assimp/assimp">这里</a>下载assimp最新版本的源文件</p>
<p><img src="https://img.supervj.top//img/image-20210618151217958.png" alt="image-20210618151217958"></p>
<p>cmake生成项目之前记得选择需要的系统版本</p>
<p>然后就到vs内编译</p>
<img src="https://img.supervj.top//img/image-20210618151318217.png" alt="image-20210618151318217" style="zoom:50%;" />



<p>完成以后把assimp项目内的include文件复制到所需要的第三方库include内</p>
<p>然后找到<code>\code\Debug</code>目录,把里面的文件复制到第三方库的<code>lib</code>文件夹中作为链接库文件</p>
<p><img src="https://img.supervj.top//img/image-20210618151624413.png" alt="image-20210618151624413"></p>
<ul>
<li>UE4</li>
</ul>
<p>对于UE, 那么需要在buid.cs文件中添加第三方库的包含</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PublicIncludePaths.AddRange(</span><br><span class="line">			new string[] &#123;</span><br><span class="line">                Path.Combine(ThirdPartyPath, &quot;assimp/include&quot;),</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ((Target.Platform == UnrealTargetPlatform.Win64) || (Target.Platform == UnrealTargetPlatform.Win32))</span><br><span class="line">      &#123;</span><br><span class="line">          string PlatformString = (Target.Platform == UnrealTargetPlatform.Win64) ? &quot;Win64&quot; : &quot;Win32&quot;;</span><br><span class="line">          PublicAdditionalLibraries.Add(Path.Combine(ThirdPartyPath, &quot;assimp/lib&quot;,PlatformString, &quot;assimp-vc140-mt.lib&quot;));</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	string BinariesDirectory = Path.Combine(ProjectDirectory, &quot;Binaries&quot;, PlatformString);</span><br><span class="line">	string SourceFile = Path.Combine(ThirdPartyPath, &quot;assimp/bin&quot;, PlatformString, &quot;assimp-vc140-mt.dll&quot;);</span><br><span class="line">	string TargetFile = Path.Combine(BinariesDirectory, &quot;assimp-vc140-mt.dll&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (!Directory.Exists(BinariesDirectory))</span><br><span class="line">          &#123;</span><br><span class="line">		Directory.CreateDirectory(BinariesDirectory);</span><br><span class="line">          &#125;</span><br><span class="line">	if(File.Exists(SourceFile) &amp;&amp; !File.Exists(TargetFile))</span><br><span class="line">          &#123;</span><br><span class="line">		File.Copy(SourceFile, TargetFile, false);</span><br><span class="line">          &#125;</span><br><span class="line">	</span><br><span class="line">	RuntimeDependencies.Add(Path.Combine(BinariesDirectory, &quot;assimp-vc140-mt.dll&quot;));</span><br><span class="line">&#125;</span><br><span class="line">else if(Target.Platform == UnrealTargetPlatform.Mac)</span><br><span class="line">&#123;</span><br><span class="line">	string PlatformString =  &quot;Mac&quot;;</span><br><span class="line">          PublicAdditionalLibraries.Add(Path.Combine(ThirdPartyPath, &quot;assimp/lib&quot;,PlatformString, &quot;libassimp.4.1.0.dylib&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>windows(openGl项目)</li>
</ul>
<p>在include和lib目录添加对应的目录, 在链接输入中填上<code>assimp-vc142-mtd.lib</code>, 否则我这边会出现<code>GetTextureCount()</code>之类的函数出现奇怪的连接错误</p>
<p><img src="https://img.supervj.top//img/image-20210618151910929.png" alt="image-20210618151910929"></p>
<p><img src="https://img.supervj.top//img/image-20210618151925599.png" alt="image-20210618151925599"></p>
<p><img src="https://img.supervj.top//img/image-20210618151950225.png" alt="image-20210618151950225"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://img.supervj.top//img/20200630154409945.png" alt="20200630154409945"></p>
<p>引用OpenGL的图片, <code>Assimp&#39;</code>从文件读取数据以后的数据结构就如上图所示, 所有数据都包含在<code>aiScene</code>指针内</p>
<p><img src="https://img.supervj.top//img/image-20210319180134014.png" alt="image-20210319180134014"></p>
<p>从此图可以大概看到<code>aiScene</code>内有哪些成员变量和函数,后面我们从实例中逐步分析</p>
<h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Assimp::Importer Importer;<span class="comment">//导入器</span></span><br><span class="line">	<span class="keyword">const</span> aiScene* scene = Importer.<span class="built_in">ReadFile</span>(FilePath, 配置参数);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如下是常用的配置参数, 点<a href="http://assimp.sourceforge.net/lib_html/postprocess_8h.html">这里</a>查看所有参数</p>
<ul>
<li>aiProcess_SplitLargeMeshes : 将比较大的网格分割成更小的子网格，如果你的渲染有最大顶点数限制，只能渲染较小的网格，那么它会非常有用</li>
<li>aiProcess_OptimizeMeshes: 和上个选项相反，它会将多个小网格拼接为一个大的网格，减少绘制调用从而进行优化。</li>
<li>aiProcess_FlipUVsv: 沿着y方向翻转纹理坐标，这在渲染quake模型时候是必须的</li>
<li>aiProcess_SortByPType: 将不同图元放置到不同的模型中去，图片类型可能是点、直线、三角形等</li>
<li>aiProcess_JoinIdenticalVertices :自动合并相同的顶点 </li>
<li>aiProcess_GenSmoothNormals :如果原始顶点没有法向数据，Assimp会为顶点产生法向数据</li>
<li>aiProcess_CalcTangentSpace:自动计算切线和副法线</li>
<li>aiProcess_Triangulate  :自动将四边形面转换为三角面</li>
<li>aiProcess_MakeLeftHanded: 使用作手坐标系</li>
</ul>
<h2 id="获取模型信息"><a href="#获取模型信息" class="headerlink" title="获取模型信息"></a>获取模型信息</h2><p>模型的基本信息保存在 <code>aiScene.mMeshes[]</code>数组中,每个<code>aiNode</code>内也保存了每个<code>aiNode</code>所对应的模型信息</p>
<p>我们先声明一个USTRUCT来保存相应数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FMeshData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">		<span class="built_in">FMeshData</span>()</span><br><span class="line">		&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="string">&quot;MeshData&quot;</span>)</span><br><span class="line">		TArray&lt;FVector&gt; Vertices;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="string">&quot;MeshData&quot;</span>)</span><br><span class="line">		TArray&lt;int32&gt; Triangles;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="string">&quot;MeshData&quot;</span>)</span><br><span class="line">		TArray&lt;FVector&gt; Normals;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="string">&quot;MeshData&quot;</span>)</span><br><span class="line">		TArray&lt;FVector2D&gt; UV0;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="string">&quot;MeshData&quot;</span>)</span><br><span class="line">		TArray&lt;FLinearColor&gt; VertexColors;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="string">&quot;MeshData&quot;</span>)</span><br><span class="line">		TArray&lt;FProcMeshTangent&gt; Tangents;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="string">&quot;MeshData&quot;</span>)</span><br><span class="line">		FTransform RelativeTransform;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后通过一个方法获取对应<code>aiNode</code>的模型数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindMeshData</span><span class="params">(<span class="keyword">const</span> aiScene* scene, aiNode* node, FLoadedMeshData&amp; outLoadedMeshData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (scene == <span class="literal">nullptr</span> || node == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(RIELog, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;FindMeshData Failed : invalid scene or node!&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumMeshes; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(RIELog, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;FindMeshData : %s&quot;</span>), node-&gt;mName.<span class="built_in">C_Str</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此成员保存了node对应mesh的序号</span></span><br><span class="line"><span class="comment">        unsigned int* mMeshes;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="keyword">int</span> meshesIdx = *node-&gt;mMeshes;</span><br><span class="line">		aiMesh* mesh = scene-&gt;mMeshes[meshesIdx];</span><br><span class="line">		FMeshData&amp; meshData = outLoadedMeshData.meshData[meshesIdx];</span><br><span class="line"></span><br><span class="line">		<span class="comment">//conv aiMatrix4x4 to FTransform</span></span><br><span class="line">		aiMatrix4x4 trans = node-&gt;mTransformation;</span><br><span class="line">		FMatrix matrix;</span><br><span class="line">		matrix.M[<span class="number">0</span>][<span class="number">0</span>] = trans.a1; matrix.M[<span class="number">0</span>][<span class="number">1</span>] = trans.b1; matrix.M[<span class="number">0</span>][<span class="number">2</span>] = trans.c1; matrix.M[<span class="number">0</span>][<span class="number">3</span>] = trans.d1;</span><br><span class="line">		matrix.M[<span class="number">1</span>][<span class="number">0</span>] = trans.a2; matrix.M[<span class="number">1</span>][<span class="number">1</span>] = trans.b2; matrix.M[<span class="number">1</span>][<span class="number">2</span>] = trans.c2; matrix.M[<span class="number">1</span>][<span class="number">3</span>] = trans.d2;</span><br><span class="line">		matrix.M[<span class="number">2</span>][<span class="number">0</span>] = trans.a3; matrix.M[<span class="number">2</span>][<span class="number">1</span>] = trans.b3; matrix.M[<span class="number">2</span>][<span class="number">2</span>] = trans.c3; matrix.M[<span class="number">2</span>][<span class="number">3</span>] = trans.d3;</span><br><span class="line">		matrix.M[<span class="number">3</span>][<span class="number">0</span>] = trans.a4; matrix.M[<span class="number">3</span>][<span class="number">1</span>] = trans.b4; matrix.M[<span class="number">3</span>][<span class="number">2</span>] = trans.c4; matrix.M[<span class="number">3</span>][<span class="number">3</span>] = trans.d4;</span><br><span class="line">		meshData.RelativeTransform = <span class="built_in">FTransform</span>(matrix);</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//vertex</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span> ; j &lt; mesh-&gt;mNumVertices; ++j)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			FVector vertex = <span class="built_in">FVector</span>(mesh-&gt;mVertices[j].x, mesh-&gt;mVertices[j].y, mesh-&gt;mVertices[j].z);</span><br><span class="line">			vertex = meshData.RelativeTransform.<span class="built_in">TransformFVector4</span>(vertex);</span><br><span class="line">			meshData.Vertices.<span class="built_in">Push</span>(vertex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//normal</span></span><br><span class="line">			<span class="keyword">if</span> (mesh-&gt;<span class="built_in">HasNormals</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				FVector normal = <span class="built_in">FVector</span>(mesh-&gt;mNormals[j].x, mesh-&gt;mNormals[j].y, mesh-&gt;mNormals[j].z);</span><br><span class="line">				meshData.Normals.<span class="built_in">Push</span>(normal);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				meshData.Normals.<span class="built_in">Push</span>(FVector::ZeroVector);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//UV</span></span><br><span class="line">			<span class="keyword">if</span> (mesh-&gt;<span class="built_in">HasTextureCoords</span>(<span class="number">0</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				FVector2D uv = <span class="built_in">FVector2D</span>(mesh-&gt;mTextureCoords[<span class="number">0</span>][j].x, mesh-&gt;mTextureCoords[<span class="number">0</span>][j].y);</span><br><span class="line">				meshData.UV0.<span class="built_in">Push</span>(uv);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//tangent</span></span><br><span class="line">			<span class="keyword">if</span> (mesh-&gt;<span class="built_in">HasTangentsAndBitangents</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				FProcMeshTangent tangent = <span class="built_in">FProcMeshTangent</span>(mesh-&gt;mTangents[j].x, mesh-&gt;mTangents[j].y, mesh-&gt;mTangents[j].z);</span><br><span class="line">				meshData.Tangents.<span class="built_in">Push</span>(tangent);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (mesh-&gt;<span class="built_in">HasVertexColors</span>(<span class="number">0</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				FLinearColor color = <span class="built_in">FLinearColor</span>(mesh-&gt;mColors[<span class="number">0</span>][j].r, mesh-&gt;mColors[<span class="number">0</span>][j].g,</span><br><span class="line">					mesh-&gt;mColors[<span class="number">0</span>][j].b,mesh-&gt;mColors[<span class="number">0</span>][j].a);</span><br><span class="line">				meshData.VertexColors.<span class="built_in">Push</span>(color);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过一个递归方法来获取所有的节点模型信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindMeshDataRecursive</span><span class="params">(<span class="keyword">const</span> aiScene* scene, aiNode* node, FLoadedMeshData&amp; outLoadedMeshData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FindMeshData</span>(scene, node, outLoadedMeshData);</span><br><span class="line">	<span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; node-&gt;mNumChildren; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">FindMeshDataRecursive</span>(scene, node-&gt;mChildren[i], outLoadedMeshData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后从递归得到的数据再得到顶点序号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; Scene-&gt;mNumMeshes; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//Triangle number</span></span><br><span class="line">			<span class="keyword">for</span> (uint32 l = <span class="number">0</span>; l &lt; Scene-&gt;mMeshes[i]-&gt;mNumFaces; ++l)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (uint32 m = <span class="number">0</span>; m &lt; Scene-&gt;mMeshes[i]-&gt;mFaces[l].mNumIndices; ++m)</span><br><span class="line">				&#123;</span><br><span class="line">					out.meshData[i].Triangles.<span class="built_in">Push</span>(Scene-&gt;mMeshes[i]-&gt;mFaces[l].mIndices[m]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		out.bSuccess = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>



<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://img.supervj.top//img/UE4Editor_AWsxBHcz2H.png" alt="UE4Editor_AWsxBHcz2H"></p>
<p>我们用<code>ProceduralMesh</code>正好可以创建出模型,如上图所示即可</p>
<h2 id="获取材质信息"><a href="#获取材质信息" class="headerlink" title="获取材质信息"></a>获取材质信息</h2><p>材质信息保存在<code>aiScene.mMaterials</code>中, 官方文档中说了可以获取是所有材质属性</p>
<p>下图截取一部分</p>
<p><img src="https://img.supervj.top//img/chrome_A0rKxl2bTt.png" alt="chrome_A0rKxl2bTt"></p>
<p>通过如下方式获取材质, 其中类型前面统一加上<code>AI_MATKEY_</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aiMaterial* mat = .....</span><br><span class="line"></span><br><span class="line"><span class="comment">// The generic way</span></span><br><span class="line"><span class="keyword">if</span>(AI_SUCCESS != mat-&gt;<span class="built_in">Get</span>(&lt;material-key&gt;,&lt;where-to-store&gt;)) &#123;</span><br><span class="line">   <span class="comment">// handle epic failure here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">aiColor3D <span class="title">color</span> <span class="params">(<span class="number">0.f</span>,<span class="number">0.f</span>,<span class="number">0.f</span>)</span></span>;</span><br><span class="line">mat-&gt;<span class="built_in">Get</span>(AI_MATKEY_COLOR_DIFFUSE,color);</span><br></pre></td></tr></table></figure>

<p>所以我们就可以通过此封装UE库</p>
<p>但是考虑到各个类型的返回值不同, 我们就干脆一口气封装成K2Node泛型节点来方便使用,具体效果如下</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_03_22_10_06_11_380.gif" alt="录制_2021_03_22_10_06_11_380"></p>
<p>对于这里图片的返回值的字符串表示的是路径信心, 但是这个还有个问题, 参考文档中的一段话</p>
<blockquote>
<p>There are two cases:</p>
<ul>
<li>The texture is NOT compressed. Its color data is directly stored in the aiTexture structure as an array of aiTexture::mWidth * aiTexture::mHeight aiTexel structures. Each aiTexel represents a pixel (or “texel”) of the texture image. The color data is stored in an unsigned RGBA8888 format, which can be easily used for both Direct3D and OpenGL (swizzling the order of the color components might be necessary). RGBA8888 has been chosen because it is well-known, easy to use and natively supported by nearly all graphics APIs.</li>
<li>This applies if aiTexture::mHeight == 0 is fulfilled. Then, texture is stored in a compressed format such as DDS or PNG. The term “compressed” does not mean that the texture data must actually be compressed, however the texture was found in the model file as if it was stored in a separate file on the harddisk. Appropriate decoders (such as libjpeg, libpng, D3DX, DevIL) are required to load theses textures. aiTexture::mWidth specifies the size of the texture data in bytes, aiTexture::pcData is a pointer to the raw image data and aiTexture::achFormatHint is either zeroed or contains the most common file extension of the embedded texture’s format. This value is only set if assimp is able to determine the file format.</li>
</ul>
</blockquote>
<p>我们一般情况下都是使用的注入<code>PNG</code>或者<code>JPG</code>等压缩格式的图片, 那么在获取图片信息的时候基本都是 上述第二种情况, 从返回的数据和路径信息都是不能直接使用的,需要借助其他工具来解析这些数据,此文就不讨论这个问题了</p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p><img src="https://img.supervj.top//img/3dsmax_fHQyk1D1Jg.png" alt="3dsmax_fHQyk1D1Jg"></p>
<p>如上图, 在max内创建一个简单的box和材质,贴上一个简单的贴图</p>
<p><img src="https://img.supervj.top//img/image-20210322104048429.png" alt="image-20210322104048429"></p>
<p><img src="https://img.supervj.top//img/UE4Editor_qdTxG1JLQB.png" alt="UE4Editor_qdTxG1JLQB"></p>
<blockquote>
<p> 打印得到opacity值为0.94</p>
</blockquote>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>图形库</tag>
        <tag>assimp</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4模块启动顺序</title>
    <url>/2021/08/12/%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文大致梳理一下UE4编辑器启动后各个模块的加载顺序， 重点看一下<code>ELoadingPhase</code>枚举对应的类型的加载时机</p>
<span id="more"></span>





<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>任何可执行程序都会有一个执行入口，在 UE 中，每一个 Target 都会编译出一个可执行程序。引擎启动是从 <code>Launch</code> 模块开始的，<code>main</code> 函数也是定义在其中的</p>
<p>简化代码表示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">GuardedMain</span><span class="params">( <span class="keyword">const</span> TCHAR* CmdLine )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">EnginePreInit</span>( CmdLine );</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">    <span class="keyword">if</span> (GIsEditor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">EditorInit</span>(GEngineLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">EngineInit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">IsEngineExitRequested</span>() )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">EngineTick</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码的字面意思就可以理解为启动步骤大概就是 预初始化-&gt;初始化, 然后是Tick循环</p>
<p>这里不得不说到一个引擎类 <code>FEngineLoop </code></p>
<p><code>FEngineLoop </code>管理了程序的初始化与主循环</p>
<p>因为整个UE是模块化的架构，引擎的实现就是靠各个模块组合驱动的, 那么就拿模块的启动来看一下引擎的启动顺序</p>
<h2 id="模块启动"><a href="#模块启动" class="headerlink" title="模块启动"></a>模块启动</h2><p>先看一下模块加载的类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ELoadingPhase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        EarliestPossible,</span><br><span class="line">        PostConfigInit,</span><br><span class="line">        PostSplashScreen,</span><br><span class="line">        PreEarlyLoadingScreen,</span><br><span class="line">        PreLoadingScreen,</span><br><span class="line">        PreDefault,</span><br><span class="line">        Default,</span><br><span class="line">        PostDefault,</span><br><span class="line">        PostEngineInit,</span><br><span class="line">        None,</span><br><span class="line">        Max,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看一下<code>PreDefault</code>模式的插件到<code>StartupModule</code>的调用栈</p>
<img src="https://img.supervj.top//img/image-20210809164503801.png" alt="image-20210809164503801"  />



<p>先看下面代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FEngineLoop::LoadStartupModules</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FScopedSlowTask <span class="title">SlowTask</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    SlowTask.<span class="built_in">EnterProgressFrame</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Load any modules that want to be loaded before default modules are loaded up.</span></span><br><span class="line">    <span class="keyword">if</span> (!IProjectManager::<span class="built_in">Get</span>().<span class="built_in">LoadModulesForProject</span>(ELoadingPhase::PreDefault) || !IPluginManager::<span class="built_in">Get</span>().<span class="built_in">LoadModulesForEnabledPlugins</span>(ELoadingPhase::PreDefault))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SlowTask.<span class="built_in">EnterProgressFrame</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Load modules that are configured to load in the default phase</span></span><br><span class="line">    <span class="keyword">if</span> (!IProjectManager::<span class="built_in">Get</span>().<span class="built_in">LoadModulesForProject</span>(ELoadingPhase::Default) || !IPluginManager::<span class="built_in">Get</span>().<span class="built_in">LoadModulesForEnabledPlugins</span>(ELoadingPhase::Default))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SlowTask.<span class="built_in">EnterProgressFrame</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Load any modules that want to be loaded after default modules are loaded up.</span></span><br><span class="line">    <span class="keyword">if</span> (!IProjectManager::<span class="built_in">Get</span>().<span class="built_in">LoadModulesForProject</span>(ELoadingPhase::PostDefault) || !IPluginManager::<span class="built_in">Get</span>().<span class="built_in">LoadModulesForEnabledPlugins</span>(ELoadingPhase::PostDefault))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面是几种类型加载模式的模块启动都在编辑器引擎启动之前, 意味着<code>UEditorEngine::InitEditor()</code>还未执行.</p>
<p>那么其他类型比如常见的<code>PostEngineInit</code>是啥时候启动的呢?</p>
<p>在<code>FEngineLoop::Init()</code>中,  先执行了<code>GEditor</code>的初始化, 然后再执行<code>PostEngineInit</code>类型的模块的加载</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">SCOPED_BOOT_TIMING</span>(<span class="string">&quot;GEngine-&gt;Init&quot;</span>);</span><br><span class="line">    GEngine-&gt;<span class="built_in">Init</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//............</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">SCOPED_BOOT_TIMING</span>(<span class="string">&quot;IProjectManager::Get().LoadModulesForProject(ELoadingPhase::PostEngineInit)&quot;</span>);</span><br><span class="line">    <span class="comment">// Load all the post-engine init modules</span></span><br><span class="line">    <span class="keyword">if</span> (!IProjectManager::<span class="built_in">Get</span>().<span class="built_in">LoadModulesForProject</span>(ELoadingPhase::PostEngineInit) || !IPluginManager::<span class="built_in">Get</span>().<span class="built_in">LoadModulesForEnabledPlugins</span>(ELoadingPhase::PostEngineInit))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RequestEngineExit</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;One or more modules failed PostEngineInit&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>简单梳理各类模块加载的顺序,以及部分常见的功能的初始化顺序</p>
</blockquote>
<ul>
<li>多种平台调用 <code>GuardedMain() //Launch.cpp</code></li>
<li><code>GuardedMain</code> 依次调用<code>EnginePreInit</code>, <code>EditorInit</code>或<code>EngineInit</code>, 然后循环<code>EngineTick</code></li>
<li><code>Launch.cpp</code>内有全局变量 <code>FEngineLoop GEngineLoop;</code>, 上述方法通过<code>GEngineLoop</code>执行</li>
<li>GEngineLoop<ul>
<li><code>FEngineLoop::PreInit </code>会执行<code>PreInitPreStartupScreen</code>, <code>PreInitPostStartupScreen</code><ul>
<li>前者会执行如命令行, 本地化等等大量初始化和逻辑, 先通过<code>FEngineLoop::AppInit</code>加载*<code>EarliestPossible</code><em>和</em><code>PostConfigInit</code><em>类型的模块, 随后加载</em>*<code>PostSplashScreen</code><strong>类型的模块 (<strong>0%-18%</strong>), 退出函数时加载至</strong>39%**</li>
<li>后者加载*<code>PreEarlyLoadingScreen</code>*类型的模块(<strong>39%</strong>); 随后播放开场动画等, <em>然后加载<code>AssetRegistry</code>模块</em>,  然后通过<code>LoadStartupCoreModules</code>(<strong>45% - 55%</strong>)方法加载核心模块, 随后是*<code>PreLoadingScreen</code>*类型的模块(<strong>55% - 59%</strong>),  接着开始渲染线程<code>StartRenderingThread</code> (<strong>59% - 75%</strong>), 然后通过<code>LoadStartupModules</code>(<strong>75%</strong>)方法加载*<code>PreDefault</code>, <code>Default</code>, <code>PostDefault</code>*类型的模块, </li>
<li></li>
<li>随后创建几个单例并调用<code>Init</code>(<strong>%79 - 86%</strong>)<ul>
<li>创建<code>GEditor</code>并调用<code>GEditorEngine::InitEditor</code> , 该方法会加载编辑器资源</li>
<li>创建<code>GEngine</code>并调用<code>GEngine::Init</code>, 该方法也有大量初始化比如创建<code>FWorldContext</code>, <code>Config</code>的加载, 音效设备的初始化, 加载一些系统模块(<code>MovieScene</code>,<code>LevelSequence</code>等等)</li>
</ul>
</li>
</ul>
</li>
<li>然后通过执行 <code>FEngineLoop::Init</code>加载*<code>PostEngineInit</code>*类型的模块(<strong>86% - 90%</strong>)</li>
</ul>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><blockquote>
<p>加载核心模块在 45%进度, <code>EarliestPossible</code>, <code>PostConfigInit</code> , <code>PostSplashScreen</code>和<code>PreEarlyLoadingScreen</code>会在此之前</p>
<p>核心模块有<code>Core</code>, <code>Networking</code>, <code>UnrealEd</code>, <code>Slate</code>等等</p>
<p>编辑器资源初始化在75%之后, 也就是在<code>PreLoadingScreen</code>, <code>PreDefault</code>, <code>Default</code>, <code>PostDefault</code>之后, 所以如果需要对资源进行操作需要使用最后加载的<code>PostEngineInit</code></p>
</blockquote>
<p>另外, 引擎提供了几个全局代理,  可以来监听比如编辑器初始化完毕等事件 , 比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FCoreDelegates::OnPostEngineInit.<span class="built_in">AddRaw</span>(<span class="keyword">this</span>, &amp;FAdvancedFrameworkEditorModule::RegisterPlaceActors);</span><br></pre></td></tr></table></figure>

<p>详情可以参考文件<code>CoreDelegates.h</code></p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
  </entry>
  <entry>
    <title>UE4添加自定义项目设置</title>
    <url>/2020/08/31/%E6%89%A9%E5%B1%95%E6%B8%B8%E6%88%8F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>我们在项目开发的过程中，经常需要在项目设置里面添加一些参数，本文介绍如何添加这些参数</p>
<p>另外介绍一些特殊的资源类参数的添加和使用</p>
</blockquote>
<p>先上图</p>
<p><img src="https://img.supervj.top/img/advVR/image-20200831114210083.png" alt="image-20200831114210083"></p>
<h2 id="添加自定义项目设置"><a href="#添加自定义项目设置" class="headerlink" title="添加自定义项目设置"></a>添加自定义项目设置</h2><p>一般情况下，我们需要创建一个插件来添加这类属性，我们创建一个蓝图函数库模板的插件</p>
<p>然后创建一个UObject类来添加属性</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(config = ExtensionSetting,defaultconfig)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAMESETTINGEXTENSION_API</span> <span class="title">USettingObj</span> :</span> <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config, BlueprintReadOnly, EditAnywhere)</span><br><span class="line">		FSoftClassPath SoftClassPath;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config, BlueprintReadOnly, EditAnywhere)</span><br><span class="line">		FSoftObjectPath SoftObjectPath;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config, BlueprintReadOnly, EditAnywhere)</span><br><span class="line">		TSoftObjectPtr&lt;AActor&gt; SoftObjectPtr;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config, BlueprintReadOnly, EditAnywhere)</span><br><span class="line">		TSoftClassPtr&lt;AActor&gt; SoftClassPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>configdonotcheckdefaults</strong> 与 <strong>defaultconfig</strong></p>
<ul>
<li><strong>defaultconfig</strong>:配置会写入到引擎默认配置里, 路径一般是<code>./Config</code>内而不是<code>./Save/*/Config</code>内.另外打包出来后运行以后会自动生成配置文件信息,但是无法再手动修改<code>ini</code>文件; 可以运行时修改但是会保存到<code>./Save/*/Windows/Config</code>内对应名称的<code>ini</code>内</li>
<li><strong>configdonotcheckdefaults</strong> :会写入到<code>./Save</code>内, 运行运行时的修改;打包以后不会自动生成<code>ini</code>文件, 可以手动复制到对应目录</li>
</ul>
<hr>
<ul>
<li>**CLASS(config=FileName)**：表示这个类默认条件下将配置信息保存到哪个配置文件，config后面的文件名可以是任意字符串。</li>
<li>**UPROPERTY(globalconfig)**：不指定Section的情况下，标记config的这个属性在保存到配置文件里面的时候会保存在基类对应的Section部分。同理，加载的时候也会从基类对应的Section下加载。</li>
</ul>
<hr>
<p>注意要在<code>UPROPERTY</code>后加<code>config</code>关键字</p>
<p>一般的值类型变量都都可以配置，如<code>FString</code>,<code>FRotator</code>,<code>TSubclassOf</code>，但是不能添加继承于<code>UObject</code>的类,可以用<code>FSlot***</code>代替</p>
<p>然后我们需要将此类注册到游戏设置里面，一般是在模块启动的时候添加，看下面代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGameSettingExtensionModule::RegisterSetting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ISettingsModule* SettingModule = FModuleManager::GetModulePtr&lt;ISettingsModule&gt;(<span class="string">&quot;Settings&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		SettingModule-&gt;<span class="built_in">RegisterSettings</span>(<span class="string">&quot;Project&quot;</span>, <span class="string">&quot;Game&quot;</span>, <span class="string">&quot;ExtensionSetting&quot;</span>,</span><br><span class="line">			<span class="built_in">LOCTEXT</span>(<span class="string">&quot;RuntimeSettingsName&quot;</span>, <span class="string">&quot;GameSetting&quot;</span>),</span><br><span class="line">			<span class="built_in">LOCTEXT</span>(<span class="string">&quot;RuntimeSettingsDescription&quot;</span>, <span class="string">&quot;Configure my GameSetting&quot;</span>),</span><br><span class="line">			GetMutableDefault&lt;USettingObj&gt;()</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGameSettingExtensionModule::UnregisterSetting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ISettingsModule* SettingsModule = FModuleManager::GetModulePtr&lt;ISettingsModule&gt;(<span class="string">&quot;Settings&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		SettingsModule-&gt;<span class="built_in">UnregisterSettings</span>(<span class="string">&quot;Project&quot;</span>, <span class="string">&quot;Game&quot;</span>, <span class="string">&quot;ExtensionSetting&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>上面代码在模块启动和注销的时候分别调用</p>
<ul>
<li>“Game”:表示分类，对应的就是项目设置的Game标签</li>
<li>“ExtensionSetting”:配置时的分类名称</li>
<li>“Configure my GameSetting”：上图中的文字描述</li>
</ul>
<h2 id="使用自定义设置"><a href="#使用自定义设置" class="headerlink" title="使用自定义设置"></a>使用自定义设置</h2><p>因为我们本身就是一个蓝图函数库插件，我们直接在函数库类里面添加新的方法，如果不是此类插件，自己新建一个蓝图函数库类</p>
<blockquote>
<p>需要注意的问题，编辑器类型的插件不能使用蓝图函数库</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;GameSettingExtension&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> UObject* <span class="title">GetObjBySoftPath</span><span class="params">(<span class="keyword">const</span> FSoftObjectPath&amp; softPath)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;GameSettingExtension&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> UObject* <span class="title">GetObjRefBySoftPtr</span><span class="params">(<span class="keyword">const</span> TSoftObjectPtr&lt;UObject&gt;&amp; softPathPtr)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;GameSettingExtension&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> UClass* <span class="title">GetClassBySoftPath</span><span class="params">(<span class="keyword">const</span> FSoftClassPath&amp; softPath)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;GameSettingExtension&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> UClass* <span class="title">GetClassByClassSoftPtr</span><span class="params">(<span class="keyword">const</span> TSoftClassPtr&lt;UObject&gt;&amp; softPathPtr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们申明4个变量对应的4个函数，因为例如<code>FSoftObjectPath</code>类型的变量在蓝图里面不方便使用，所以需要我们用<code>C++</code>    封装一层</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UObject* <span class="title">UGameSettingExtensionBPLibrary::GetObjBySoftPath</span><span class="params">(<span class="keyword">const</span> FSoftObjectPath&amp; softPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UObject* obj = LoadObject&lt;UObject&gt;(<span class="literal">NULL</span>, *softPath.<span class="built_in">ToString</span>());</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UObject* <span class="title">UGameSettingExtensionBPLibrary::GetObjRefBySoftPtr</span><span class="params">(<span class="keyword">const</span> TSoftObjectPtr&lt;UObject&gt;&amp; softPathPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TSoftObjectPtr&lt;UObject&gt; p = TSoftObjectPtr&lt;UObject&gt;(softPathPtr);</span><br><span class="line">	<span class="keyword">return</span> p.<span class="built_in">Get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UClass* <span class="title">UGameSettingExtensionBPLibrary::GetClassBySoftPath</span><span class="params">(<span class="keyword">const</span> FSoftClassPath&amp; softPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UClass* c = LoadClass&lt;UObject&gt;(<span class="literal">NULL</span>, *softPath.<span class="built_in">ToString</span>());</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UClass* <span class="title">UGameSettingExtensionBPLibrary::GetClassByClassSoftPtr</span><span class="params">(<span class="keyword">const</span> TSoftClassPtr&lt;UObject&gt;&amp; softPathPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TSoftClassPtr&lt;UObject&gt; p = TSoftClassPtr&lt;UObject&gt;(softPathPtr);</span><br><span class="line">	<span class="keyword">return</span>  p.<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top/img/advVR/image-20200831115229327.png" alt="image-20200831115229327"></p>
<p>这样我们就实现了蓝图里面调用项目设置内的属性了</p>
<h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><p>只要继承自<code>UObject</code>类就有两个方法<code>SaveConfig()</code>和<code>LoadConfig()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveConfig</span><span class="params">( uint64 Flags=CPF_Config, <span class="keyword">const</span> TCHAR* Filename=<span class="literal">NULL</span>, FConfigCacheIni* Config=GConfig, <span class="keyword">bool</span> bAllowCopyToDefaultObject=<span class="literal">true</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>Flags</code>: 一般不用改变, 可以设置为<code>CPF_GlobalConfig</code>标记为全局</p>
<p>第二个参数<code>Filename</code>:保存的文件, 如果不填写则使用前面<code>UCLASS</code>定义的路径</p>
<p>第三个参数保持默认即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoadConfig</span><span class="params">( UClass* ConfigClass=<span class="literal">NULL</span>, <span class="keyword">const</span> TCHAR* Filename=<span class="literal">NULL</span>, uint32 PropagationFlags=UE4::LCPF_None, class FProperty* PropertyToLoad=<span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>LoadConfig()</code>的功能是从配置文件里面读取特定的属性值并赋给指定类的对应属性。第一个参数指定了要把值赋给哪个类的属性，第二个参数表示到哪个配置文件找对应的配置信息，第三个参数表示是哪种标记（Config还是GlobalConfig），第四个参数表示指定要赋值的属性。</p>
<p>如果不指定第4个参数，就会读取配置并给所有标记<code>UProperty(Config)</code>的属性赋值。</p>
<p>可以在注册的位置就绑定<code>Setting</code>类的修改, 然后实时保存到<code>ini</code>文件内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ISettingsModule* SettingModule = FModuleManager::GetModulePtr&lt;ISettingsModule&gt;(<span class="string">&quot;Settings&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		ISettingsSectionPtr SettingsSection = SettingModule-&gt;<span class="built_in">RegisterSettings</span>(<span class="string">&quot;Project&quot;</span>, <span class="string">&quot;Game&quot;</span>, <span class="string">&quot;SuperRoad&quot;</span>,</span><br><span class="line">			<span class="built_in">LOCTEXT</span>(<span class="string">&quot;RuntimeSettingsName&quot;</span>, <span class="string">&quot;SuperRoad&quot;</span>),</span><br><span class="line">			<span class="built_in">LOCTEXT</span>(<span class="string">&quot;RuntimeSettingsDescription&quot;</span>, <span class="string">&quot;Configure my GameSetting&quot;</span>),</span><br><span class="line">			GetMutableDefault&lt;USRDefaultSettings&gt;());</span><br><span class="line">    <span class="keyword">if</span> (SettingsSection.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			SettingsSection-&gt;<span class="built_in">OnModified</span>().<span class="built_in">BindRaw</span>(<span class="keyword">this</span>, &amp;FSuperRoadModule::HandleSettingsSaved);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FSuperRoadModule::HandleSettingsSaved</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	USRDefaultSettings* s = GetMutableDefault&lt;USRDefaultSettings&gt;();</span><br><span class="line">	<span class="keyword">if</span> (s)</span><br><span class="line">	&#123;</span><br><span class="line">		s-&gt;<span class="built_in">SaveConfig</span>();</span><br><span class="line">		<span class="built_in">SRLOG</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Save Settings&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然, 运行时直接拿到对象修改变量是无法调用到这里的, 需要自己调用或者封装<code>Save</code>函数</p>
<hr>
<p>还有一个方式也可以读写变量, 使用<code>GConfig</code></p>
<p><code>GConfig</code>可以理解为是一个全局的变量(类型是<code>FConfigIni</code>), 所有配置文件都可以通过此来获取和设置变量</p>
<p>以下是Wiki的案例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in your player controller class</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVictoryController::VictoryConfigGetTests</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Basic Syntax</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    bool GetString( </span></span><br><span class="line"><span class="comment">        const TCHAR* Section, </span></span><br><span class="line"><span class="comment">        const TCHAR* Key, </span></span><br><span class="line"><span class="comment">        FString&amp;amp; Value, </span></span><br><span class="line"><span class="comment">        const FString&amp;amp; Filename </span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!GConfig) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//~~</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Retrieve Default Game Type</span></span><br><span class="line">    FString ValueReceived;</span><br><span class="line">    GConfig-&gt;<span class="built_in">GetString</span>(</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.WorldInfo&quot;</span>),</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;GlobalDefaultGameType&quot;</span>),</span><br><span class="line">        ValueReceived,</span><br><span class="line">        GGameIni</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ClientMessage</span>(<span class="string">&quot;GlobalDefaultGameType&quot;</span>);</span><br><span class="line">    <span class="built_in">ClientMessage</span>(ValueReceived);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Retrieve Max Objects not considered by GC</span></span><br><span class="line">    int32 IntValueReceived = <span class="number">0</span>;</span><br><span class="line">    GConfig-&gt;<span class="built_in">GetInt</span>(</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;Core.System&quot;</span>),</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;MaxObjectsNotConsideredByGC&quot;</span>),</span><br><span class="line">        IntValueReceived,</span><br><span class="line">        GEngineIni</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ClientMessage</span>(<span class="string">&quot;MaxObjectsNotConsideredByGC&quot;</span>);</span><br><span class="line">    <span class="built_in">ClientMessage</span>(FString::<span class="built_in">FromInt</span>(IntValueReceived));</span><br><span class="line"></span><br><span class="line">         <span class="comment">//Retrieve Near Clip Plane (how close things can get to camera)</span></span><br><span class="line">    <span class="keyword">float</span> floatValueReceived = <span class="number">0</span>;</span><br><span class="line">    GConfig-&gt;<span class="built_in">GetFloat</span>(</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.Engine&quot;</span>),</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;NearClipPlane&quot;</span>),</span><br><span class="line">        floatValueReceived,</span><br><span class="line">        GEngineIni</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ClientMessage</span>(<span class="string">&quot;NearClipPlane&quot;</span>);</span><br><span class="line">    <span class="built_in">ClientMessage</span>(FString::<span class="built_in">SanitizeFloat</span>(floatValueReceived));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//write to existing Game.ini</span></span><br><span class="line"><span class="comment">//the results get stored in YourGameDir\Saved\Config\Windows</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVictoryController::VictoryConfigSetTests</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!GConfig) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//~~</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//New Section to Add</span></span><br><span class="line">    FString VictorySection = <span class="string">&quot;Victory.Core&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String</span></span><br><span class="line">    GConfig-&gt;<span class="built_in">SetString</span> (</span><br><span class="line">        *VictorySection,</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;RootDir&quot;</span>),</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;E:\UE4\IsAwesome&quot;</span>),</span><br><span class="line">        GGameIni</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FColor</span></span><br><span class="line">    GConfig-&gt;<span class="built_in">SetColor</span> (</span><br><span class="line">        *VictorySection,</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;Red&quot;</span>),</span><br><span class="line">        <span class="built_in">FColor</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),</span><br><span class="line">        GGameIni</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FVector</span></span><br><span class="line">    GConfig-&gt;<span class="built_in">SetVector</span> (</span><br><span class="line">        *VictorySection,</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;PlayerStartLocation&quot;</span>),</span><br><span class="line">        <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">512</span>),</span><br><span class="line">        GGameIni</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FRotator</span></span><br><span class="line">    GConfig-&gt;<span class="built_in">SetRotator</span> (</span><br><span class="line">        *VictorySection,</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;SunRotation&quot;</span>),</span><br><span class="line">        <span class="built_in">FRotator</span>(<span class="number">-90</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">        GGameIni</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ConfigCacheIni.h</span></span><br><span class="line">    <span class="comment">//void Flush( bool Read, const FString&amp;amp; Filename=TEXT(&quot;&quot;) );</span></span><br><span class="line">    GConfig-&gt;<span class="built_in">Flush</span>(<span class="literal">false</span>,GGameIni);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 写入操作以后需要调用<code>GConfig-&gt;Flush(false,GGameIni);</code></p>
<p>否则配置文件不会修改</p>
</blockquote>
<h2 id="其他可配置变量"><a href="#其他可配置变量" class="headerlink" title="其他可配置变量"></a>其他可配置变量</h2><h3 id="FSoftObjectPath"><a href="#FSoftObjectPath" class="headerlink" title="FSoftObjectPath"></a>FSoftObjectPath</h3><p>软对象路径，可以直接转换成<code>FString</code>然后从路径得到具体的类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UObject* obj = LoadObject&lt;UObject&gt;(<span class="literal">NULL</span>, *softPath.<span class="built_in">ToString</span>());</span><br></pre></td></tr></table></figure>

<p>用meta参数类刷选特定类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">meta = (AllowedClasses =<span class="string">&quot;Material,StaticMesh&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="FSoftClassPath"><a href="#FSoftClassPath" class="headerlink" title="FSoftClassPath"></a>FSoftClassPath</h3><p>同上，得到一个蓝图类的UClass</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UClass* c = LoadClass&lt;UObject&gt;(<span class="literal">NULL</span>, *softPath.<span class="built_in">ToString</span>());</span><br></pre></td></tr></table></figure>

<p>可以用meta参数来刷选特定类，与<code>FSoftObjectPath</code>的meta参数不一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">meta = (MetaClass = <span class="string">&quot;MyActor&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="TSoftObjectPtr"><a href="#TSoftObjectPtr" class="headerlink" title="TSoftObjectPtr"></a>TSoftObjectPtr</h3><p>TSoftObjectPtr是封装了FSoftObjectPtr的模板，同样是用于“在给予文件路径下检测一个资源是否已经加载进了内存,获取资源对应的对象指针”，类似上面的一种写法, 直接帮我们省掉了“Cast”转为对象的过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TSoftObjectPtr&lt;UObject&gt; p = TSoftObjectPtr&lt;UObject&gt;(softPathPtr);</span><br><span class="line"><span class="keyword">return</span> p.<span class="built_in">Get</span>();<span class="comment">//UObject*</span></span><br></pre></td></tr></table></figure>

<p>实测发现该变量指向的是场景中的具体对象，与<code>FSoftObjectPath</code>指向不同</p>
<h3 id="TSoftClassPtr"><a href="#TSoftClassPtr" class="headerlink" title="TSoftClassPtr"></a>TSoftClassPtr</h3><p>跟TSoftObjectPtr类似，只不过TSoftClassPtr是仅仅用于UClass*</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TSoftClassPtr&lt;UObject&gt; p = TSoftClassPtr&lt;UObject&gt;(softPathPtr);</span><br><span class="line"><span class="keyword">return</span>  p.<span class="built_in">Get</span>();</span><br></pre></td></tr></table></figure>





<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://ue4community.wiki/legacy/config-files-read-and-write-to-config-files-zuoaht01">WiKi:Legacy/Config Files, Read &amp; Write to Config Files</a></p>
<p><a href="https://ue4community.wiki/legacy/customsettings-yrdju84k">Wiki:Legacy/CustomSettings</a></p>
<p><a href="https://blog.csdn.net/u012999985/article/details/52801264">CSDN:UE4 Config配置文件详解</a></p>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>编辑器开发</tag>
      </tags>
  </entry>
  <entry>
    <title>插件:批量重命名</title>
    <url>/2020/07/19/%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<blockquote>
<p>由于自己平时在项目开发中经常遇到大批量的资源需要重命名，特别是美术资源如贴图、动画这些</p>
<p>而UE自带的批量操作又没有发现有重命名方法</p>
<p>所以就制作了这个简单的批量重命名的小插件</p>
</blockquote>
<p><a href="https://github.com/VJien/BatchRename">Github下载链接</a></p>
<ul>
<li>动图演示</li>
</ul>
<p><img src="https://img.supervj.top/img/other/Rename.gif" alt="Rename"></p>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><ul>
<li>Prefix前缀</li>
<li>Name:修改后的名称</li>
<li>StartIndex:在多选的情况下会自动生成序号，此选项为起始序号</li>
<li>Suffix:后缀</li>
<li>点击Rename按键就执行重命名</li>
</ul>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>重命名</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中的数学随笔</title>
    <url>/2022/04/11/%E6%95%B0%E5%AD%A6%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录UE开发时常用的数学方法</p>
<span id="more"></span>


<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><h2 id="三角函数-1"><a href="#三角函数-1" class="headerlink" title="三角函数"></a>三角函数</h2><p><img src="https://img.supervj.top/imgimage-20191204153528725.png" alt="image-20191204153528725"></p>
<h3 id="特殊角"><a href="#特殊角" class="headerlink" title="特殊角"></a>特殊角</h3><p><img src="https://img.supervj.top/imgimage-20191204153628400.png" alt="image-20191204153628400"></p>
<h3 id="几何性质"><a href="#几何性质" class="headerlink" title="几何性质"></a>几何性质</h3><p><img src="https://img.supervj.top/imgimage-20191204153914418.png" alt="image-20191204153914418"></p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><table>
<thead>
<tr>
<th>公式1</th>
<th>公式2</th>
</tr>
</thead>
<tbody><tr>
<td><em>sin（2kπ+α）=sin α</em></td>
<td><em>sin（π+α）=-sin α</em></td>
</tr>
<tr>
<td><em>cos（2kπ+α）=cos α</em></td>
<td><em>cos（π+α）=-cos α</em></td>
</tr>
<tr>
<td><em>tan（2kπ+α）=tan α</em></td>
<td><em>tan（π+α）=tan α</em></td>
</tr>
<tr>
<td><em>cot（2kπ+α）=cot α</em></td>
<td><em>cot（π+α）=cot α</em></td>
</tr>
<tr>
<td><em>sec（2kπ+α）=sec α</em></td>
<td><em>sec（π+α）=-sec α</em></td>
</tr>
<tr>
<td><em>csc（2kπ+α）=csc α</em></td>
<td><em>csc（π+α）=-csc α</em></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>公式3</th>
<th>公式4</th>
</tr>
</thead>
<tbody><tr>
<td><em>sin（-α）=-sin α</em></td>
<td><em>sin（π-α）=sin α</em></td>
</tr>
<tr>
<td><em>cos（-α）=cos α</em></td>
<td><em>cos（π-α）=-cos α</em></td>
</tr>
<tr>
<td><em>tan（-α）=-tan α</em></td>
<td><em>tan（π-α）=-tan α</em></td>
</tr>
<tr>
<td><em>cot（-α）=-cot α</em></td>
<td><em>cot（π-α）=-cot α</em></td>
</tr>
<tr>
<td><em>sec（-α）=sec α</em></td>
<td><em>sec（π-α）=-sec α</em></td>
</tr>
<tr>
<td><em>csc（-α）=-csc α</em></td>
<td><em>csc（π-α）=csc α</em></td>
</tr>
</tbody></table>
<h2 id="UE4的三角函数"><a href="#UE4的三角函数" class="headerlink" title="UE4的三角函数"></a>UE4的三角函数</h2><ul>
<li><strong>Radius</strong>就是用三角函数来计算，横轴是(0,kPI),纵轴是(0,1)</li>
<li><strong>Degree</strong>就是用的基础的<u>直角三角形</u>函数,例如Sine是<code> Sinθ=a/c</code>计算，输入参数是角度，得到的是[0,1]</li>
</ul>
<h3 id="Sine-ASine"><a href="#Sine-ASine" class="headerlink" title="Sine,ASine"></a>Sine,ASine</h3><h5 id="蓝图Sine-Radius"><a href="#蓝图Sine-Radius" class="headerlink" title="蓝图Sine(Radius)"></a>蓝图Sine(Radius)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">UKismetMathLibrary::Sin</span><span class="params">(<span class="keyword">float</span> A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> FMath::<span class="built_in">Sin</span>(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">UKismetMathLibrary::Asin</span><span class="params">(<span class="keyword">float</span> A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> FMath::<span class="built_in">Asin</span>(A);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Sine(PI)–&gt;0</p>
<p>Sine(PI/2)–&gt;1</p>
<p>ASine(1)–&gt;PI/2</p>
<p>ASine(-1)–&gt;-PI/2</p>
</blockquote>
<h5 id="蓝图Sine-Degree"><a href="#蓝图Sine-Degree" class="headerlink" title="蓝图Sine(Degree)"></a>蓝图Sine(Degree)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">UKismetMathLibrary::DegSin</span><span class="params">(<span class="keyword">float</span> A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> FMath::<span class="built_in">Sin</span>(PI/(<span class="number">180.f</span>) * A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">UKismetMathLibrary::DegAsin</span><span class="params">(<span class="keyword">float</span> A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">180.f</span>)/PI * FMath::<span class="built_in">Asin</span>(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SineD(30)–&gt;0.5</p>
<p>SineD(90)–&gt;1</p>
<p>ASineD(0.5)–&gt;30</p>
<p>ASineD(1)–&gt;90</p>
</blockquote>
<h3 id="Cos-ACos"><a href="#Cos-ACos" class="headerlink" title="Cos,ACos"></a>Cos,ACos</h3><h5 id="Cos-Radius"><a href="#Cos-Radius" class="headerlink" title="Cos(Radius)"></a>Cos(Radius)</h5><blockquote>
<p><img src="https://img.supervj.top/imgu=3876543124,717556611&fm=26&gp=0.jpg" alt="Alt text"></p>
</blockquote>
<blockquote>
<p>Cos(PI)–&gt;-1</p>
<p>ACos(1)–&gt;0</p>
<p>ACos(-1)–&gt;PI</p>
</blockquote>
<h5 id="Cos-Degree"><a href="#Cos-Degree" class="headerlink" title="Cos(Degree)"></a>Cos(Degree)</h5><blockquote>
<p>Cos(60)–&gt;0.5</p>
<p>Cos(0)–&gt;1</p>
</blockquote>
<hr>
<h3 id="Tan"><a href="#Tan" class="headerlink" title="Tan"></a>Tan</h3><ul>
<li>蓝图没有提供Cot方法，本质上就是tan的2个参数反转一下</li>
</ul>
<h5 id="特殊角度的值"><a href="#特殊角度的值" class="headerlink" title="特殊角度的值"></a>特殊角度的值</h5><blockquote>
<p>Tan(PI)–&gt;0</p>
<p>Tan(PI/2) –&gt;垃圾值，如图</p>
<p>ATan(0)–&gt;0</p>
<p>ATan(无穷)–&gt;接近于PI/2,如图</p>
<hr>
<p>TanD(45)–&gt;1</p>
<p>TanD(90)–&gt;垃圾值，因为分母=0</p>
<p>ATanD(1)–&gt;45</p>
<p>ATanD(0)–&gt;0</p>
<p>ATanD( 无穷大)–&gt;接近于90</p>
</blockquote>
<h5 id="蓝图额外Tan方法"><a href="#蓝图额外Tan方法" class="headerlink" title="蓝图额外Tan方法"></a>蓝图额外Tan方法</h5><blockquote>
<p> ATan2有2个方法，简单说就是提供了2个输入参数：A,B</p>
<p> 计算就是A/B</p>
<p> ATan2D，可以输入2条边的长度，得到比例</p>
</blockquote>
<h3 id="三角函数应用"><a href="#三角函数应用" class="headerlink" title="三角函数应用"></a>三角函数应用</h3><h5 id="求两个向量夹角"><a href="#求两个向量夹角" class="headerlink" title="求两个向量夹角"></a>求两个向量夹角</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cosx=a*b/[|a|*|b|]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetTwoVectorAngle</span><span class="params">(FVector a,FVector b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">Size</span>()==<span class="number">0</span>||b.<span class="built_in">Size</span>()==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">float</span> cos = UKismetMathLibrary::<span class="built_in">Dot_VectorVector</span>(a, b) / (a.<span class="built_in">Size</span>()*b.<span class="built_in">Size</span>());</span><br><span class="line">	<span class="keyword">return</span> UKismetMathLibrary::<span class="built_in">DegAcos</span>(cos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>得到的是[-180,180]的值</p>
</blockquote>
<h5 id="UMG中的箭头"><a href="#UMG中的箭头" class="headerlink" title="UMG中的箭头"></a>UMG中的箭头</h5><blockquote>
<p>由于UMG的旋转是[-180，180]的范围</p>
<p>所以可以对方向向量与(-1,0)做夹角计算，如下图得到旋转值</p>
<p><img src="https://img.supervj.top/imgimage-20191209104410038.png" alt="image-20191209104410038"></p>
</blockquote>
<h5 id="按角度旋转向量"><a href="#按角度旋转向量" class="headerlink" title="按角度旋转向量"></a>按角度旋转向量</h5><ul>
<li>已知点(x1,y1),绕(x2,y2)旋转θ</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x= (x1 - x2)*<span class="built_in">cos</span>(θ) - (y1 - y2)*<span class="built_in">sin</span>(θ) + x2 ;</span><br><span class="line">y= (x1 - x2)*<span class="built_in">sin</span>(θ) + (y1 - y2)*<span class="built_in">cos</span>(θ) + y2 ;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是绕原点旋转，公式可以简化成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x= x1*<span class="built_in">cos</span>(θ) - y1*<span class="built_in">sin</span>(θ)  ;</span><br><span class="line">y= x1*<span class="built_in">sin</span>(θ) + y1*<span class="built_in">cos</span>(θ)  ;</span><br></pre></td></tr></table></figure>



<p>在UE中已经封装了很多比较方便的库来旋转向量</p>
<p><img src="https://img.supervj.top/imgimage-20220411095224059.png" alt="image-20220411095224059"></p>
<h2 id="UE中的矩阵变换"><a href="#UE中的矩阵变换" class="headerlink" title="UE中的矩阵变换"></a>UE中的矩阵变换</h2><h3 id="相对关系"><a href="#相对关系" class="headerlink" title="相对关系"></a>相对关系</h3><p>A相对于B的变换信息, 用<code>TransformA.GetRelativeTransform(TransformB);</code></p>
<p>蓝图有两个类似的API, 但是有点容易造成歧义</p>
<p> 我们看实现</p>
<p><img src="https://img.supervj.top/imgimage-20220411104130037.png" alt="image-20220411104130037"></p>
<p><code>MakeRelativeTransform</code>的第二个参数输入Parent这个没问题,</p>
<p>但是看<code>ConvertTransformToRelative</code>的第二个输入Parent获取到的实际上是夫相对于子的相对变换信息, 那么两者等价的情况要如下图所示</p>
<p><img src="https://img.supervj.top/imgimage-20220411104050270.png" alt="image-20220411104050270"></p>
<h3 id="空间转换"><a href="#空间转换" class="headerlink" title="空间转换"></a>空间转换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把Location转换至T的空间，如果是GetActorTransform获取Transoform，即世界空间</span></span><br><span class="line">T.<span class="built_in">TransformPosition</span>(Location);</span><br><span class="line"><span class="comment">//相反, Location是T空间的相对位置,通过这个方法转换成T的世界空间</span></span><br><span class="line">T.<span class="built_in">InverseTransformPosition</span>(Location);</span><br></pre></td></tr></table></figure>

<p>上面即Location的空间转换, 同理还有Direction和Rotation, 方法类似</p>
<p>蓝图只是套了一层,没有实质性区别</p>
<p><img src="https://img.supervj.top/imgimage-20220411134541635.png" alt="image-20220411134541635"></p>
<h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T.<span class="built_in">Inverse</span>();</span><br></pre></td></tr></table></figure>





<h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>c++中可以直接对Transofomr进行*运算符运算, 在蓝图中包了一层, 使用的是<code>FTransform UKismetMathLibrary::ComposeTransforms(const FTransform&amp; A, const FTransform&amp; B)</code></p>
<p><img src="https://img.supervj.top/imgimage-20220411134736654.png" alt="image-20220411134736654"></p>
<p>乘法需要区分左乘和右乘, 这个跟图形中常用的运算比较类似,<code>ComposeTransforms</code>注释中的用法是很多场合中会用到的</p>
<p>先通过一个案例了了解一下矩阵乘法</p>
<hr>
<p>经常需要用到角色的RootMotion信息转换成角色世界空间的位移信息， 这个如何做？</p>
<p>首先从动画提取RootMotion信息， 这个有很多已有的API了， 如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FTransform <span class="title">UAnimSequence::ExtractRootMotionFromRange</span><span class="params">(<span class="keyword">float</span> StartTrackPosition, <span class="keyword">float</span> EndTrackPosition)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>提取出来的RootMotion数据（假设叫RM）是模型空间的， 那么需要在世界空间进行这个偏移得到RMWS</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RMWS = RM * MeshTransformWS;<span class="comment">//模型世界空间变换信息进行rootmotion偏移</span></span><br></pre></td></tr></table></figure>

<p>然后需要把RMWS数据通过<strong>逆矩阵</strong>转换到Character空间的，因为模型可能会有相对偏移和旋转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FTransform Mesh2CharInverse = StartChacterFootTransform.GetRelativeTransform(MeshTransformWS);</span><br><span class="line">const FTransform  ActorTransformWS =  Mesh2CharInverse * TargetTransform;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的StartChacterFootTransform是角色脚底的Transform， 因为RootMotion都是基于脚底的</p>
</blockquote>
<hr>
<p>如果还是不知道如何使用, 可以暴力的记住几个常用场景的用法</p>
<ol>
<li>Actor本地空间进行旋转和偏移,那么使用左乘变换信息, 即 <code>变换Transform * ActorTransform</code></li>
<li>在世界空间中进行变换, 那么可以是变换 <code>ActorTransform * 变换Transform </code></li>
</ol>
<p>上面的1没什么问题, 对2再进一步解释</p>
<p>比如<img src="https://img.supervj.top/imgimage-20220411135758367.png" alt="image-20220411135758367"></p>
<p>这个几何意义即, 当前这个Actor先绕世界0点进行90度偏移, 然后再基于世界空间的X轴偏移100</p>
<p>上面的操作等价于下图</p>
<p><img src="https://img.supervj.top/imgimage-20220411135928476.png" alt="image-20220411135928476"></p>
<p>具体的过程如下图</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_04_11_14_01_20_647.gif" alt="录制_2022_04_11_14_01_20_647"></p>
<hr>
<h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p>范数是函数，几何意义即比较向量的大小</p>
<blockquote>
<p>向量X={2，3，-5，7}</p>
</blockquote>
<ul>
<li>1范数：各个元素的绝对值之和</li>
</ul>
<p>||X||<sub>1</sub>=2+3+5+7=17;</p>
<ul>
<li>2范数：各个元素的平方和再开更号</li>
</ul>
<p>||X||<sub>2</sub>=(2x2+3x3+5x5+7x7)<sup>1/2</sup>=9.3274</p>
<ul>
<li>p范数：各个向量元素绝对值p次方和的1/p次方</li>
<li>无穷范数：各个元素绝对值最大的哪个元素的绝对值</li>
</ul>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5本地化</title>
    <url>/2023/09/12/%E6%9C%AC%E5%9C%B0%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本地化一般指的是文本的本地化,  UE5的本地化工具保持了UE4的风格, 当然, 文档也一如既往的渣渣, 本文对本地化进行一点的记录</p>
<span id="more"></span>



<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912141059296.png" alt="image-20230912141059296"></p>
<p>上图为UE5的入口, </p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912141355688.png" alt="image-20230912141355688"></p>
<p>打开以后的界面如下, 我们主要关注红色框框部分</p>
<h3 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912141902700.png" alt="image-20230912141902700"></p>
<p>GatherFromTextFile针对的是代码中的<code>FText</code>数据, 一般路径是项目的source目录和插件的source中</p>
<p>一般可以用宏<code>NSLOCTEXT</code>或者<code>LOCTEXT</code>, 比如</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912141620470.png" alt="image-20230912141620470"></p>
<p>包括函数中输入参数也会被收集到</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912141819416.png" alt="image-20230912141819416"></p>
<h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912141953102.png" alt="image-20230912141953102"></p>
<p>这一部分针对的就是所有的蓝图资源文件, 包含了所有蓝图中的FText数据结构, 常见的是UMG中所有的TextBlock等空间, 蓝图中的成员变量, DataTable中的FText字段等等</p>
<h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><p>接下来就是收集所有需要本地化的数据, 在收集之前先添加所有需要翻译的语种, </p>
<p>确认我们的编辑器当前语言,为然后点击<code>Gather Text/ 收集文本</code></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912142459657.png" alt="image-20230912142459657"></p>
<p>然后执行计算字数, 等待一段时间以后, 就会出现当前语言的字数, 如上图我们的中文字数就有4150个</p>
<h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p>由于开发过程中的不确定性, 以及多员工开发的个人习惯问题, 也许我们开发的时候填写的FText变量值是中英文混杂的,  那么这里我们先要处理当前语种的翻译文件</p>
<blockquote>
<p>所以非常建议, 开发之初大家就统一规范, 统一用中文或者英文, 这样后期可以减少很多翻译时间成本</p>
</blockquote>
<p>打开中文翻译</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912142657204.png" alt="image-20230912142657204"></p>
<p>我们会看到有中英文混杂的情况</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912142735052.png" alt="image-20230912142735052"></p>
<p>首先先把所有非中文的都处理成中文</p>
<p>翻译过程可以在编辑器内直接点击输入, 也可以导出成<code>*.po</code>文件到外面翻译, 但是吧…似乎不能用excel打开, 用其他文本工具打开的话界面清晰度不如在编辑器内</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912142951327.png" alt="image-20230912142951327"></p>
<p>这个就仁者见仁了, 如果处理的是po文件, 那么外面翻译完了按单个语种导入回来即可</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912143102159.png" alt="image-20230912143102159"></p>
<p>翻译完了主语言后, 点击再点击生成字数+翻译文件;</p>
<p>然后所有其他语种的翻译文件内对应的源都会成为主语言的显示</p>
<blockquote>
<p>如果其他语言没有未翻译信息, 那么再点击一次收集文本就有了</p>
</blockquote>
<p>接下来就是漫长的多语种翻译过程</p>
<h3 id="切换语言"><a href="#切换语言" class="headerlink" title="切换语言"></a>切换语言</h3><p>切换语言可以直接调用接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UKismetInternationalizationLibrary::SetCurrentCulture</span><span class="params">(<span class="keyword">const</span> FString&amp; Culture, <span class="keyword">const</span> <span class="keyword">bool</span> SaveToConfig)</span></span></span><br></pre></td></tr></table></figure>

<p>当然为了方便, 可以自己封装一个接口, 用枚举来选择还是更方便一点</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230912151854392.png" alt="image-20230912151854392"></p>
<blockquote>
<p>游戏内测试切换语言需要使用standalone模式, 或者打包出来测试,否则结果不一定正确</p>
</blockquote>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>本地化</tag>
      </tags>
  </entry>
  <entry>
    <title>物理动画深入分析</title>
    <url>/2021/12/29/%E7%89%A9%E7%90%86%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文打算对物理动画这个自从出现以后一直处于实验性的功能进行深入分析,  并尝试用一些常见的动画进行测试</p>
<p><a href="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Physics/PhysicsAssetEditor/HowTo/ApplyPhysicalAnimationProfile/">官方文档</a></p>
<p><a href="https://www.youtube.com/watch?v=N1tDjbFXeOo">官方视频教程</a></p>
<p><a href="https://www.youtube.com/watch?v=TmAU8aPekEo&t=668s">星球大战物理动画演示</a></p>
<span id="more"></span>



<h2 id="何为物理动画"><a href="#何为物理动画" class="headerlink" title="何为物理动画"></a>何为物理动画</h2><p>物理动画不是Ragdoll(布娃娃), 这个概念很容易被误解</p>
<p><img src="https://img.supervj.top/imgimage-20211229095759908.png" alt="image-20211229095759908"></p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_29_17_04_10_262.gif" alt="录制_2021_12_29_17_04_10_262"></p>
<p>简单说, 物理动画就是为了让角色播放动画的时候有物理效果(不仅限于碰撞)而存在的一个特殊功能</p>
<h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><p>配置方式不难(详见官方文档), 我们简述一下流程</p>
<ol>
<li>开启模型的物理碰撞效果(角色的模型默认是<strong>NoCollision</strong>), 设置成类似<code>PhysicsActor</code>之类的接受Block的类型</li>
<li>将Mesh的物理刷新类型改成Kinematic即动力学驱动</li>
<li>添加<code>PhysicalAnimationComponent</code></li>
<li>将Mesh作为参数调用<code>PhysicalAnimationComponent::SetSkeletalMesh()</code></li>
<li>将Mesh开启物理效果, 一般会通过调用<code>SetAllBodiesBelowSimulatePhysics </code>基于某个骨骼开启</li>
<li>调用物理动画组件的<code>ApplyPhysicalAnimationProfileBelow</code> 提供物理动画配置</li>
</ol>
<p>没几个API, 核心问题还是要配置好合适的参数, 以及理解每个参数的作用</p>
<h2 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h2><h3 id="SetSkeletalMeshComponent"><a href="#SetSkeletalMeshComponent" class="headerlink" title="SetSkeletalMeshComponent()"></a>SetSkeletalMeshComponent()</h3><p><img src="https://img.supervj.top/imgimage-20211229105025648.png" alt="image-20211229105025648"></p>
<p>使用物理动画的必要API, 需要将Mesh作为参数传递给组件, 当然也允许传空指针</p>
<p>设置新的Mesh会将之前保存的Drive参数和物理引擎数据都清空或重新设置, 然后将新的Mesh对应的物理实体对象(FBodyInstance)唤醒</p>
<h3 id="Drive参数"><a href="#Drive参数" class="headerlink" title="Drive参数"></a>Drive参数</h3><p><img src="https://img.supervj.top/imgimage-20211229105424341.png" alt="image-20211229105424341"></p>
<p>这个参数也许是影响物理动画最关键的参数, 也是刚开始最不容易理解的参数</p>
<p>其实我们在物理资产编辑的时候就可以通过预览界面预览其中的效果</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_22_11_38_39_726.gif" alt="录制_2021_12_22_11_38_39_726"></p>
<p>简单说, 这些参数就是动画对骨骼的牵引力效果, 即</p>
<ul>
<li>OrientationStrength : 旋转牵引力, 一般1000左右就可以保持比较快速的返回动画状态</li>
<li>AngularVelocityStrength: 角速度的牵引力,  这个值对人物影响不大, 一般设置成100即可</li>
<li>PositionStrength: 位置的牵引力, 类似旋转牵引力一般设置成1000</li>
<li>VelocityStrength: 速度牵引力,一般设置成100, 较低的值会导致类似弹簧一样的效果让位置返回的过程中反复</li>
</ul>
<blockquote>
<p>上面的值是一般而言,针对不同的效果, 比如死亡/受伤/攀爬以及不同的身体部位是需要使用不同的参数的</p>
</blockquote>
<h3 id="SetAllBodiesBelowSimulatePhysics"><a href="#SetAllBodiesBelowSimulatePhysics" class="headerlink" title="SetAllBodiesBelowSimulatePhysics()"></a>SetAllBodiesBelowSimulatePhysics()</h3><p><img src="https://img.supervj.top/imgimage-20211229134307280.png" alt="image-20211229134307280"></p>
<p>其实即就是对所有BodyInstance遍历操作一遍, 设置了每个BodyInstance对象的物理权重<code>PhysicsBlendWeight</code>, 剩下的就交给PhyX完成了</p>
<p>所以这个API后面就不需要跟一个<code>SetAllBodiesBelowPhysicsBlendWeight()</code>用来设置权重为1了</p>
<p>这里有一个特殊设定, 看下图</p>
<p><img src="https://img.supervj.top/imgimage-20211229151110112.png" alt="image-20211229151110112"></p>
<p>即如果骨骼名称为None, 同时满足下面2个bool值(默认)的情况下, 就相当于对所有骨骼进行操作</p>
<h3 id="SetStrengthMultiplyer"><a href="#SetStrengthMultiplyer" class="headerlink" title="SetStrengthMultiplyer()"></a>SetStrengthMultiplyer()</h3><p><img src="https://img.supervj.top/imgimage-20211229134758749.png" alt="image-20211229134758749"></p>
<p><img src="https://img.supervj.top/imgimage-20211229134903307.png" alt="image-20211229134903307"></p>
<p>这个缩放系数最终<strong>作用的就是上面的Drive参数</strong>(同样也可以看到对<code>Chaos</code>也有处理, 说明物理动画现在或者至少未来肯定支持Chaos)</p>
<p>所以我们也可以通过动态的设置这个参数来控制牵引力</p>
<blockquote>
<p>有个地方需要注意, 在刚开始设置基本profile等参数的时候需要在delay一点时间以后(或者一直Tick)调用一次SetStrengthMultiplyer(), 不然人物会没有牵引力而躺下就像使用了纯粹的布娃娃效果. 原因是整个物理动画初始化过程有一些异步过程</p>
</blockquote>
<h2 id="动画测试"><a href="#动画测试" class="headerlink" title="动画测试"></a>动画测试</h2><p><img src="https://img.supervj.top/imgphyAnim1.gif" alt="phyAnim1"></p>
<p>上面演示了开启全身物理动画的效果, 虽然是可以明显的看到动画与物理的共存, 但是实际用于生成还是需要经过非常细致的处理的</p>
<p>再来看一个死亡动画</p>
<p><img src="https://img.supervj.top/imgphyAnim2.gif" alt="phyAnim2"></p>
<p>已经看到, 如果角色模型在动画过程中与场景其他物体有严重的穿插, 那么必然就会得到奇怪的结果, 我们可以试想一下, 动画希望模型往前走, 但是物理不允许</p>
<p>那么如果是平地上的效果呢</p>
<p><img src="https://img.supervj.top/imgphyAnim3.gif" alt="phyAnim3"></p>
<p>虽然没有大问题, 但是最后的姿势并不算理想,  因为多数情况我们希望在躺下以后开启正真的物理效果, 一来可以让躺下的姿势更自然(需要较好的物理约束和碰撞配置), 最主要的是能让角色满足各种地形情况</p>
<p>如何做到?</p>
<p>我们可以简单的设置 一个TimeLine来快速实现这个功能</p>
<p><img src="https://img.supervj.top/imgimage-20211229155857050.png" alt="image-20211229155857050"></p>
<p>因为我们已经知道, Strength控制是整个Drive数据, 那么这里就用1秒时间让这个Strength从1到0, 即动画牵引力从有到无</p>
<p>看效果</p>
<p><img src="https://img.supervj.top/imgphyAnim4.gif" alt="phyAnim4"></p>
<p>这样已经可以比较好的躺倒在各种地形上了, 到是还有一个问题, 看下图</p>
<p><img src="https://img.supervj.top/imgphyAnim5.gif" alt="phyAnim5"></p>
<p>实际上在动画牵引力完全淡出之前如果碰到其他物体, 还是会有很奇怪的现象出现, 这种情况下可以用提前的射线检测等方式来让物理提前开启(动画提前淡出)来实现</p>
<p>下图展示了提前进行碰撞预测和悬空检测的效果, 蓝色虚影为动画原本表现效果</p>
<p><img src="https://img.supervj.top/imgphyAnim6.gif" alt="phyAnim6"></p>
<p><img src="https://img.supervj.top/imgphyAnim6%20(2).gif" alt="phyAnim6 (2)"></p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>在简单场景中创建108个角色, 统一使用单一跑步动画, 做几个维度的对比, 通过UE抓帧工具对比性能开销</p>
<ul>
<li>正常开启全身物理动画模拟</li>
</ul>
<p><img src="https://img.supervj.top/imgimage-20211229175230754.png" alt="image-20211229175230754"></p>
<p><img src="https://img.supervj.top/imgimage-20211229174750536.png" alt="image-20211229174750536"></p>
<ul>
<li>不开启物理动画</li>
</ul>
<p><img src="https://img.supervj.top/imgimage-20211229175313293.png" alt="image-20211229175313293"></p>
<ul>
<li>去掉物理资产</li>
</ul>
<p><img src="https://img.supervj.top/imgimage-20211229175406429.png" alt="image-20211229175406429"></p>
<p><img src="https://img.supervj.top/imgimage-20211229175456964.png" alt="image-20211229175456964"></p>
<ul>
<li><p>不开启物理模拟</p>
<p><img src="https://img.supervj.top/imgimage-20211229191241851.png" alt="image-20211229191241851"></p>
</li>
</ul>
<p><img src="https://img.supervj.top/imgimage-20211229175717148.png" alt="image-20211229175717148"></p>
<ul>
<li>开启物理动画但是物理权重为0</li>
</ul>
<p><img src="https://img.supervj.top/imgimage-20211229191317905.png" alt="image-20211229191317905"></p>
<p><img src="https://img.supervj.top/imgimage-20211229190816430.png" alt="image-20211229190816430"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>只看游戏线程, 找到跟物理和动画有关系的Tick调用开销, 粗略判断</p>
<ul>
<li>默认:18.3ms</li>
<li>关闭: 10.5ms</li>
<li>去掉物理资产: 13.1ms</li>
<li>关闭物理模拟: 12.6ms</li>
<li>权重为0: 18.0ms</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>物理动画在追求品质的游戏当中还是非常有必要的, 但是就现在的效果而言还是有很多地方值得深入研究, 当然也有可能是目前效果确实有待改善(为啥一直处于实验性?), 在有些时候很难确定物理和动画的边界容易造成奇怪的现象, 同时不同的行为使用的各种参数也会不同, 需要长时间的尝试才能有较好的用于生产的方案</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="BodyInstance"><a href="#BodyInstance" class="headerlink" title="BodyInstance"></a>BodyInstance</h3><p>个人理解BodyInstance是UE物理世界里的基本单元, 同样也是与PhyX产生对应关系的一个具体对象</p>
<p>对于一个静态网格物体StaticMesh，他的物理一般在建模软件里面就应该创建好, 本质上都是在编辑器里给UStaticMeshComponent构建一个UBodySetup，在开始游戏的时候在创建运行时的基本物理数据UBodyInstance。</p>
<p>这里我们重点讨论骨骼模型</p>
<p>对于骨骼网格物体SkeletalMesh，由于数据比较多，他的物理数据存储在PhysicsAsset里面。在游戏运行的时候，SkeletalMeshComponent会读取物理资产里面的数据UBodySetup随后再通过UBodySetup给角色创建对应的基本物理数据UBodyInstance。再进一步深入就是NVIDA的PhysX物理引擎了<br>我们看一下BodyInstance对象大概有那些东西</p>
<p><img src="https://img.supervj.top/imgimage-20211229113748264.png" alt="image-20211229113748264"></p>
<p><img src="https://img.supervj.top/imgimage-20211229113651832.png" alt="image-20211229113651832"></p>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>物理材质的深入思考</title>
    <url>/2022/05/31/%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>以静态模型举例, 物理材质是配置在两个地方, 两个地方跟检测方式有关</p>
<p>如果是复杂检测的, 那么物理材质配置在每个材质内, 这个比较精确, 但是开销是非常感人的, 特别是有些次世代模型动辄上百万面</p>
<p>如果是简单检测, 物理材质是统一跟着模型走的, 也就是一个模型不管你配置了多少个碰撞盒子, 物理材质都只有一个, 看下图</p>
<p><img src="https://img.supervj.top/imgimage-20220531163529620.png" alt="image-20220531163529620"></p>
<p>图中的正方体和球各自有自己的碰撞框, 如果一个是金属的,一个是橡胶的, 那么此套方案就行不同了</p>
<span id="more"></span>

<h2 id="魔改源码"><a href="#魔改源码" class="headerlink" title="魔改源码"></a>魔改源码</h2><p><img src="https://img.supervj.top/imgimage-20220531163554003.png" alt="image-20220531163554003"></p>
<p>每个碰撞体在模型中都是保存在BodySetup中以FKAggregateGeom数据保存的, 里面保存了所有的FKShapeElem, 即对应各种形状的数据结构</p>
<p>于是可不可以把物理材质放到这里呢?</p>
<p><img src="https://img.supervj.top/imgimage-20220531163606551.png" alt="image-20220531163606551"></p>
<p>直接放进去, 记得要兼顾构造函数和一些工具函数</p>
<p>这样就已经可以在编辑器模式下编辑这个物理材质了</p>
<p><img src="https://img.supervj.top/imgimage-20220531163616696.png" alt="image-20220531163616696"></p>
<p>接下来要查看射线逻辑中的物理材质是怎么赋值的</p>
<p>具体赋值的是在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SetHitResultFromShapeAndFaceIndex()中</span><br></pre></td></tr></table></figure>

<p>见下图</p>
<p><img src="https://img.supervj.top/imgimage-20220531163631266.png" alt="image-20220531163631266"></p>
<p>这个环节大致是从具体的三角面中查找材质, 从材质中找到物理材质, 对于简单检测, 这里就会返回简单碰撞设置的物理材质, 这里行不通</p>
<p>所以思考着有没有地方可以找到我们配置的物理材质</p>
<p>这里发现, 射线流程中所传递的我们击中的几何体数据Shape并非是FKAggregateGeom数据, 看下图</p>
<p><img src="https://img.supervj.top/imgimage-20220531163641335.png" alt="image-20220531163641335"></p>
<p>这里是因为游戏在运行之初, UE会把生成一套运行时的数据, 如果是PhyX环境可以参考</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FPhysicsInterface_PhysX::AddGeometry()</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top/imgimage-20220531163653630.png" alt="image-20220531163653630"></p>
<p><img src="https://img.supervj.top/imgimage-20220531163703142.png" alt="image-20220531163703142"></p>
<p>上面两图可以看到 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FKShapeElem的UserData就是他自己</span><br></pre></td></tr></table></figure>

<p>而这个UserData是传递到了Shape数据中的用void*保存下来的</p>
<p>再看UE已经封装好了转换函数(下图是PhyX)</p>
<p><img src="https://img.supervj.top/imgimage-20220531163713479.png" alt="image-20220531163713479"></p>
<p>那么问题就解决了, 尝试从这个UserData拿到我们  <code>FKShapeElem</code>中配置的物理材质</p>
<p><img src="https://img.supervj.top/imgimage-20220531163722422.png" alt="image-20220531163722422"></p>
<p>最终的配置方式如下</p>
<p><img src="https://img.supervj.top/imgimage-20220531175628977.png" alt="image-20220531175628977"></p>
<p>测试一下</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_05_31_16_49_15_70.gif" alt="录制_2022_05_31_16_49_15_70"></p>
<p>搞定</p>
]]></content>
      <categories>
        <category>physical</category>
      </categories>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>物理资产PhysicsAsset编辑指南</title>
    <url>/2021/12/22/%E7%89%A9%E7%90%86%E8%B5%84%E4%BA%A7PhysicsAsset%E7%BC%96%E8%BE%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>物理资产在Rigdoll和物理动画的引用中非常重要, 当然还有角色模型的碰撞检测也需要物理资产支持, 但是有很多细节在<a href="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Physics/PhysicsAssetEditor/">官方文档</a>和其他文章或者教程中并没有提及, 导致编辑过程中踩了很多坑, 本文主要是记录这些细节问题</p>
<span id="more"></span>



<h2 id="碰撞体"><a href="#碰撞体" class="headerlink" title="碰撞体"></a>碰撞体</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>很多时候我们会一键自动生成全身的碰撞体, 但是我们需要注意一个选项</p>
<p><img src="https://img.supervj.top/imgimage-20211222102200980.png" alt="image-20211222102200980"></p>
<p>默认是勾上的, 意味着默认是没有碰撞的,  这个选项我们下面重点讨论;</p>
<p>实际项目中很多时候我们会手动一个个创建碰撞体然后再一个个添加约束, 主要是为了可控, 因为自动生成经常会遇到下面这种现象, 比较难排查</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_22_10_27_52_366.gif" alt="录制_2021_12_22_10_27_52_366"></p>
<p>另外, 一个骨骼是可以创建多个碰撞体的, 如果需要严格的对模型进行包裹, 那么可以尽可能的使用多个碰撞体来实现, 但是要<strong>注意重量问题</strong>, 骨骼的重量会因为添加多个碰撞体而增加, 当然手动设置不受此影响.</p>
<h3 id="碰撞编辑"><a href="#碰撞编辑" class="headerlink" title="碰撞编辑"></a>碰撞编辑</h3><p>项目中发现模型自身没有碰撞, 比如手会穿到身体内, 苦思冥想找遍百度骨骼也找不到相关的内容, 点开碰撞体也只能看到下图数据</p>
<p><img src="https://img.supervj.top/imgimage-20211222103520406.png" alt="image-20211222103520406"></p>
<p>但是此数据是与外部交互的设置, 比如射线检测等等, 但是内部自身的碰撞于此并不相关</p>
<p>最后发现其实上编辑方式在<strong>右键菜单</strong>内, 可以看下面动图</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_22_10_39_02_778~1.gif" alt="录制_2021_12_22_10_39_02_778~1"></p>
<p>于是除非是在上面有提到的在创建的时候不勾选<code>DisableCollisionsByDefault</code>, 否则就需要手动的一个个编辑每一个碰撞体, 一般做法就是对全局开启碰撞呢,然后临近的碰撞体关闭碰撞</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>手动创建也在右键菜单内, 一般建议点击父骨骼链接到子骨骼的方式创建约束, 这样一般会创建在两个骨骼的连接处, 反过来约束会创建在父骨骼的顶部, 虽然说也可以手动把位置调整, 但是没必要浪费时间在这里何况还容易出偏差.</p>
<p><img src="https://img.supervj.top/imgimage-20211222105051556.png" alt="image-20211222105051556"></p>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>缺省情况下, 约束的朝向一般是随骨骼朝向的, 但是很多时候我们需要修改他的朝向来控制约束角度, 比如上下手臂中间肘关节的约束, 还有膝盖位置的约束, 不调整的话姿势会非常奇怪.比如膝盖位置会出现下面的反人类的角度</p>
<p><img src="https://img.supervj.top/imgimage-20211222105420551.png" alt="image-20211222105420551"></p>
<p>但是UE这里有点坑, 你旋转约束是没用的, 你必须找到隐藏的彩蛋!!!!</p>
<p>关键的Key就是<code>Alt</code>键, 旋转约束需要按住此键才能实现我们要的效果, 看下图</p>
<p><img src="https://img.supervj.top/imgimage-20211222105625229.png" alt="image-20211222105625229"></p>
<p>不带箭头的红色轴是骨骼朝向, 带箭头的是我们约束的朝向, 这样我们的膝盖就正常了</p>
<h3 id="Soft-Constraint"><a href="#Soft-Constraint" class="headerlink" title="Soft Constraint"></a>Soft Constraint</h3><p>这里主要有刚度和阻尼两个参数是可以设置一下的, 刚度越大关节恢复力越大, 阻尼正好有点相反的感觉, 阻尼越大恢复速度就越慢, 看下图演示</p>
<ul>
<li>刚度=2000, 阻尼=5</li>
</ul>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_22_11_03_21_998.gif" alt="录制_2021_12_22_11_03_21_998"></p>
<ul>
<li>刚度=1,  阻尼=5</li>
</ul>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_22_11_03_55_241.gif" alt="录制_2021_12_22_11_03_55_241"></p>
<ul>
<li>阻尼=500, 刚度=50</li>
</ul>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_22_11_09_34_941.gif" alt="录制_2021_12_22_11_09_34_941"></p>
<ul>
<li>阻尼=1, 刚度=50</li>
</ul>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_22_11_10_04_901.gif" alt="录制_2021_12_22_11_10_04_901"></p>
<p>这个参数在运行时也可以动态的修改, 比如在死亡的时候, 可以考虑让身体从硬的逐渐变成松弛状态</p>
<p><img src="https://img.supervj.top/imgimage-20211222111215643.png" alt="image-20211222111215643"></p>
<h2 id="物理动画相关设置"><a href="#物理动画相关设置" class="headerlink" title="物理动画相关设置"></a>物理动画相关设置</h2><p>关于物理动画内容我们会另开一篇文章, 这里主要说的是碰撞体的物理动画属性设置, 如下图</p>
<p><img src="https://img.supervj.top/imgimage-20211222112306761.png" alt="image-20211222112306761"></p>
<p><img src="https://img.supervj.top/imgimage-20211222112718459.png" alt="image-20211222112718459"></p>
<p>很多时候我们可能会在蓝图api中设置而不用Profile的形式, 但是在物理资产里我们可以很方便的预览这个参数带来的效果</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_12_22_11_38_39_726.gif" alt="录制_2021_12_22_11_38_39_726"></p>
]]></content>
      <categories>
        <category>physics</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>物理资产</tag>
      </tags>
  </entry>
  <entry>
    <title>用GitLab搭建本地代码仓库</title>
    <url>/2020/08/18/%E7%94%A8GitLab%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<blockquote>
<p>git 是一种基于命令的版本控制系统，全命令操作，没有可视化界面</p>
<p>gitlab 是一个基于git实现的在线代码仓库软件，提供web可视化管理界面，通常用于企业团队内部协作开发</p>
<p>当然还有github也可以用作代码仓库，较多用于个人</p>
</blockquote>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h5 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h5><p>git的使用和安装推荐本人另外一篇博客<a href="%5Bhttps://supervj.top/2020/05/12/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/%5D(https://supervj.top/2020/05/12/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/)">git使用指北</a></p>
<h5 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h5><p>推荐下载VMwareWorkstation，可以到<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">官网下载</a>,然后百度搜索绿色方法</p>
<p>然后我们安装Linux镜像，本人使用的是Ubuntu20.4版本，这个网上一搜一大堆，随意选择版本，初学者可以选择桌面版本，如这里<a href="https://cn.ubuntu.com/download">下载</a></p>
<p>然后一路安装，运行，设置root账户等</p>
<p>这里推荐虚拟机的使用2核，至少使用超过4GB的内存，本人直接上40GB</p>
<h3 id="搭建基本环境"><a href="#搭建基本环境" class="headerlink" title="搭建基本环境"></a>搭建基本环境</h3><h5 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h5><p>如果是桌面版，右键进入终端，非桌面版忽略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install ca-certificates curl openssh-server postfix</span><br></pre></td></tr></table></figure>



<h5 id="安装GitLab"><a href="#安装GitLab" class="headerlink" title="安装GitLab"></a>安装GitLab</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">curl -LO https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh</span><br></pre></td></tr></table></figure>

<p>到<code>tmp</code>目录安装gitlab，当然你可以自己选择目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo bash /tmp/script.deb.sh</span><br></pre></td></tr></table></figure>

<p>该脚本将设置您的服务器以使用GitLab维护的存储库。这使您可以使用与其他系统软件包相同的软件包管理工具来管理GitLab。完成后，您可以使用以下<code>apt</code>命令安装实际的GitLab应用程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gitlab-ce</span><br></pre></td></tr></table></figure>

<p>此条命令将在系统上安装必要组件</p>
<blockquote>
<p>如果在安装gitlab使有如下报错，可以今夏如下操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># apt-get install gitlab-ce</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package gitlab-ce</span><br></pre></td></tr></table></figure>

<p>修改安装脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list.d/gitlab_gitlab-ce.list</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>OLD</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ focal main</span><br><span class="line">deb-src https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ focal main</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>NEW</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu focal main</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu focal main</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>再次执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gitlab-ce</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://gitlab.com/gitlab-org/gitlab-foss/-/issues/2370">https://gitlab.com/gitlab-org/gitlab-foss/-/issues/2370</a></p>
<h5 id="修改防火墙"><a href="#修改防火墙" class="headerlink" title="修改防火墙"></a>修改防火墙</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure>

<p>检查防火墙状态，如果没有防火墙需要apt安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw allow http</span><br><span class="line">sudo ufw allow https</span><br><span class="line">sudo ufw allow OpenSSH</span><br></pre></td></tr></table></figure>

<p>然后通过上述3条命令让防火墙支持<code>http\https\OpenSSH</code></p>
<p>再次检查以后大概会有如下状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">80                         ALLOW       Anywhere                  </span><br><span class="line">22                         ALLOW       Anywhere                  </span><br><span class="line">80/tcp                     ALLOW       Anywhere                  </span><br><span class="line">443/tcp                    ALLOW       Anywhere                  </span><br><span class="line">OpenSSH                    ALLOW       Anywhere                  </span><br><span class="line">80 (v6)                    ALLOW       Anywhere (v6)             </span><br><span class="line">22 (v6)                    ALLOW       Anywhere (v6)             </span><br><span class="line">80/tcp (v6)                ALLOW       Anywhere (v6)             </span><br><span class="line">443/tcp (v6)               ALLOW       Anywhere (v6)             </span><br><span class="line">OpenSSH (v6)               ALLOW       Anywhere (v6) </span><br></pre></td></tr></table></figure>

<h5 id="修改GitLab配置文件"><a href="#修改GitLab配置文件" class="headerlink" title="修改GitLab配置文件"></a>修改GitLab配置文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure>

<p>该文件比较大，在顶部找到``external_url `，按照如下注释修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">external_url &#x27;https://example.com&#x27; // 此处修改为您的域名或ip地址，不用加端口</span><br></pre></td></tr></table></figure>

<p>然后查找<code>letsencrypt[&#39;contact_emails&#39;]</code>,如果没有先忽略跳过，如果有则进行如下修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">letsencrypt[&#x27;contact_emails&#x27;] = [&#x27;sammy@example.com&#x27;] // 此处修改为您的邮箱地址</span><br></pre></td></tr></table></figure>

<p>然后重新配置GitLab</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure // 每次修改配置文件都需要重新配置</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本人在这一步遇到一个报错，最后一句是<code>Please upgrade your ACME client to a version that supports ACMEv2 / RFC</code></p>
<p>解决方法是在 <code>/etc/gitlab/gitlab.rb</code> 中添加 <code>letsencrypt[&#39;enable&#39;] = false</code></p>
</blockquote>
<p>重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl restart</span><br></pre></td></tr></table></figure>

<h5 id="GitLab常用命令"><a href="#GitLab常用命令" class="headerlink" title="GitLab常用命令"></a>GitLab常用命令</h5><table>
<thead>
<tr>
<th>常用命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sudo gitlab-ctl reconfigure</td>
<td>重新加载配置，每次修改<code>/etc/gitlab/gitlab.rb</code>文件之后执行</td>
</tr>
<tr>
<td>sudo gitlab-ctl status</td>
<td>查看 GitLab 状态</td>
</tr>
<tr>
<td>sudo gitlab-ctl start</td>
<td>启动 GitLab</td>
</tr>
<tr>
<td>sudo gitlab-ctl stop</td>
<td>停止 GitLab</td>
</tr>
<tr>
<td>sudo gitlab-ctl restart</td>
<td>重启 GitLab</td>
</tr>
<tr>
<td>sudo gitlab-ctl tail</td>
<td>查看所有日志</td>
</tr>
<tr>
<td>sudo gitlab-ctl tail nginx/gitlab_acces.log</td>
<td>查看 nginx 访问日志</td>
</tr>
<tr>
<td>sudo gitlab-ctl tail postgresql</td>
<td>查看 postgresql 日志</td>
</tr>
<tr>
<td>systemctl enable gitlab-runsvdir.service</td>
<td>开机启动</td>
</tr>
<tr>
<td>systemctl disable gitlab-runsvdir.service</td>
<td>禁止开机自启动</td>
</tr>
</tbody></table>
<h5 id="首次登陆"><a href="#首次登陆" class="headerlink" title="首次登陆"></a>首次登陆</h5><p>在Web浏览器中访问GitLab服务器的域名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://example.com // 您external_url配置的地址</span><br></pre></td></tr></table></figure>

<p>第一次访问需要设置管理员密码，记得保存，之后如果没有gitlab账户就需要创建一个并登陆，然后就可以正常创建项目了</p>
<h3 id="证书问题"><a href="#证书问题" class="headerlink" title="证书问题"></a>证书问题</h3><p>有时候因为各种原因需要修改仓库端的虚拟机ip，也就意味着gitlab需要修改ip地址</p>
<p>这些操作很基础，在上面也讲了，但是修改IP以后本人发现原有的证书就无效了，应该是第一次部署的时候默认会生成我们IP对应的证书，我这边的第一次部署的ip地址是<code>192.168.1.111</code>如下图</p>
<p><img src="https://img.supervj.top/img/advVR/image-20201021104015652.png" alt="image-20201021104015652"></p>
<p>后面因为网段改为了2，所以整体把虚拟机和gitlab地址都改成了2段，然后运行gitlab就发现如下日志</p>
<p><img src="https://img.supervj.top/img/advVR/image-20201021104134810.png" alt="image-20201021104134810"></p>
<p>直接告诉我招不到证书文件，于是翻遍资料最后找到一个粗暴的方法，手动生成证书文件</p>
<ol>
<li>创建私钥和证书请求</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">openssl req -nodes -newkey rsa:<span class="number">2048</span> -keyout <span class="number">192.168</span><span class="number">.2</span><span class="number">.110</span>.key -out <span class="number">192.168</span><span class="number">.2</span><span class="number">.110</span>.csr</span><br></pre></td></tr></table></figure>

<p>上面的ip地址需要替换你对应的地址</p>
<p>私钥会提示输入密码，记住了跟着提示输入</p>
<p>输入以后跟着提示输入你的信息，我这边老老实实的输入了正确信息，不确定可否随意输入</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Country Name (2 letter code) [XX]:CN</span><br><span class="line">State or Province Name (full name) []:zhejiang</span><br><span class="line">Locality Name (eg, city) [Default City]:hangzhou</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:xiaoshan</span><br><span class="line">Organizational Unit Name (eg, section) []:xiaoshan</span><br><span class="line">Common Name (eg, your name or your server&#x27;s hostname) []:xiaoshan</span><br><span class="line">Email Address []:自己的邮箱地址</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>移除私钥的密码短语</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">cp -v /etc/gitlab/ssl/192.168.2.110.&#123;key,original&#125;</span><br><span class="line">openssl rsa -in /etc/gitlab/ssl/192.168.2.110</span><br><span class="line">-out /etc/gitlab/ssl/192.168.2.110.key</span><br><span class="line">rm -v /etc/gitlab/ssl/192.168.2.110.original</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建证书</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days 1460 -in /etc/gitlab/ssl/192.168.2.110.csr -signkey /etc/gitlab/ssl/192.168.2.110.key -out /etc/gitlab/ssl/192.168.2.110.crt</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>设置权限</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chmod</span> <span class="number">600</span> /etc/gitlab/ssl/<span class="number">192.168.2.110</span>.*</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有文章提示可以删除<code>.csr</code>文件，我这里没删除也没遇到问题</p>
<p>如果需要删除，运行<code>rm -v /etc/gitlab/ssl/192.168.2.110.csr</code></p>
</blockquote>
<p>然后重新配置gitlab，重启gitlab就可以了</p>
<h3 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h3><p>创建仓库流程于github非常类似而且非常简单</p>
<p><img src="https://img.supervj.top/img/gitlab/image-20200818071803709.png" alt="image-20200818071803709"></p>
<p>然后我们需要为项目添加成员，如下图输入其他成员的邮箱或者用户名，添加以后其他用户自己登陆后也能看到项目了</p>
<p><img src="https://img.supervj.top/img/gitlab/image-20200818073638776.png" alt="image-20200818073638776"></p>
<p>完成仓库操作以后可以添加SSH Key来允许用户提交</p>
<p><img src="https://img.supervj.top/img/gitlab/image-20200818071718978.png" alt="image-20200818071718978"></p>
<p>然后我们可以在windows端clone下来，就可以正常git流程操作了</p>
<p><img src="https://img.supervj.top/img/oss/image-20200818071856868.png" alt="image-20200818071856868"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitLab</tag>
      </tags>
  </entry>
  <entry>
    <title>用Niagara的Ribbon绘制样条线</title>
    <url>/2020/05/21/%E7%94%A8Niagara%E7%BB%98%E5%88%B6%E6%A0%B7%E6%9D%A1%E7%BA%BF/</url>
    <content><![CDATA[<blockquote>
<p>最近由于项目需要用到鼠标在场景利绘制曲线，方案有很多，比如SplineMesh，ProceduralMesh 等等，回头一想用特效也可以试试</p>
<p>本案例使用虚幻4.22版本演示</p>
<p>用Niagara的Ribbon绘制样条线的功能</p>
</blockquote>
<p><img src="https://img.supervj.top/img/niagara/niagara_0.gif"></p>
<h5 id="模块函数-NiagaraModuleScript"><a href="#模块函数-NiagaraModuleScript" class="headerlink" title="模块函数 NiagaraModuleScript"></a>模块函数 NiagaraModuleScript</h5><ul>
<li>模块函数是Niagara系统的函数库，是niagara系统最主要区别于老例子系统的其中一点</li>
</ul>
<p>创建函数库 <code>NM_Test1</code></p>
<p><img src="https://img.supervj.top/img/niagara/niagara_1.jpg"></p>
<p>完成如上节点连接</p>
<p>注意：变量的前缀是对应模块，这个不能随意更改，创建的时候就选好模块会自动添加前缀；如果是系统已有变量，就不需要自己更改名称，如<code>Emitter.age</code>，表示发射器的生命周期</p>
<ul>
<li>User.SP：User分类下的Spline变量，本案例用下面参数代替</li>
<li>Module.Count：函数输入参数，本函数中用于控制发射数量</li>
<li>SampleSplinePositionByUnitDistanceWS:输入0-1输出曲线从开始到结束的世界空间位置</li>
<li>ExecutionIndex:当前粒子的序号</li>
</ul>
<p>简单描述这个函数的功能就是根据发射粒子在所有发射粒子中的百分比对应到曲线spline的长度百分比</p>
<h5 id="粒子发射器-Emitter"><a href="#粒子发射器-Emitter" class="headerlink" title="粒子发射器 Emitter"></a>粒子发射器 Emitter</h5><p><img src="https://img.supervj.top/img/niagara/niagara_2.jpg"></p>
<p>随意创建一个发射器，删除多余节点，配置图所示</p>
<p>刚开始比较容易混淆的概念是 Emitter的spawn，update与Particle的Spawn，Update的概念</p>
<ul>
<li>Emitter针对的就是整个发射器的操作，约等于老系统的Required和部分Spawn的内容，如整个发射器的生命周期，是否循环</li>
<li>Particle控制每个粒子的属性和功能，如每个粒子的大小颜色等</li>
<li>不恰当的比喻就是Emitter就是Actor，Particle就是Component</li>
</ul>
<p>图中关键节点解释</p>
<ul>
<li>创建3个User变量，User变量可以到外部设置</li>
<li>创建Emitter模块的<code>Emitter.SpawnCount</code>变量，暴力一点可以直接跳过直接用User的</li>
<li>发射器创建的时候用<code>User.SpawnCount</code>设置<code>Emitter.SpawnCount</code></li>
<li><code>Emitter.SpawnCount</code>去设置<code>SpawnBurstInstaneous</code>的发射数量</li>
<li>修改<code>Render</code>模块中的粒子类型为<code>Ribbon</code></li>
<li>设置Ribbon的宽度</li>
<li>在Spawn（在Update也可以） 中加上自定义的函数<code>NM_Test1</code>，并把<code>EmitterSpawnCount</code>设置为输入参数</li>
</ul>
<h5 id="粒子系统-NiagaraSystem"><a href="#粒子系统-NiagaraSystem" class="headerlink" title="粒子系统 NiagaraSystem"></a>粒子系统 NiagaraSystem</h5><blockquote>
<p> 汇总所有Emitter的集合，同时可以实例化到场景或者类里的类;同时也可以再次修改Emitter中所有参数</p>
</blockquote>
<p><img src="https://img.supervj.top/img/niagara/niagara_3.jpg"></p>
<p>如图所示，可以使用多个发射器，可以设置User模块的参数，可以拖拽不同发射器的作用时间（类似动画）</p>
<p>本案例中只需要添加一个发射器</p>
<h5 id="画线类-DrawItem"><a href="#画线类-DrawItem" class="headerlink" title="画线类 DrawItem"></a>画线类 DrawItem</h5><p><img src="https://img.supervj.top/img/niagara/niagara_4.jpg"></p>
<ul>
<li><p>目前版本貌似没有更直观的方法设置Spline变量，强行用设置Actor变量尽然是可以的(lll￢ω￢)</p>
</li>
<li><p>提供对外函数<code>AddPoint(FVector)</code>用于添加曲线点</p>
</li>
</ul>
<h5 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h5><blockquote>
<p>不要忘记开启项目设置里Input模块下的UseMouseForTouch</p>
</blockquote>
<p><img src="https://img.supervj.top/img/niagara/niagara_5.jpg"></p>
<p>蓝图比较简单，简单描述就是在鼠标按下移动后用射线点通过DrawItem添加曲线点</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>用Niagara类绘制曲线模型算是比较简单方便的，Niagara在性能优化上也不错</li>
<li>曲线在长度到一定程度后会有明显分段情况出现，不够圆滑，目前版本没有公开Ribbon的设置段数的变量</li>
<li>据说Niagara在4.25才是正式版，目前无法保证bug问题</li>
</ol>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Niagara</tag>
        <tag>特效</tag>
      </tags>
  </entry>
  <entry>
    <title>用UMG代替Slate编辑常见插件的界面</title>
    <url>/2023/01/16/%E7%94%A8UMG%E4%BB%A3%E6%9B%BFSlate%E7%BC%96%E8%BE%91%E5%B8%B8%E8%A7%81%E6%8F%92%E4%BB%B6%E7%9A%84%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用过Slate的同学都知道, 这玩意儿有多难用, 可读性差, 编译还贼慢, 那么能不能用UMG来代替Slate扩展和编写编辑器界面呢? 在一定程度上是可以实现的, 我们以UE默认的几种插件来简单介绍一下</p>
<span id="more"></span>

<p><img src="https://github.com/VJien/img/blob/master/image-20230117105145775.png?raw=true" alt="image-20230117105145775"></p>
<p>UE4与UE5在编辑器扩展方面有很大区别, 以下会提到一些, 本文以目前最新的UE5.1作为案例</p>
<h2 id="EditorMode"><a href="#EditorMode" class="headerlink" title="EditorMode"></a>EditorMode</h2><p>EditorMode相对而言是最复杂的, 而且也有很特殊的作用, 比如在进入一个EditorMode以后, 场景里的某些Actor都不能选取, 这个基本上只有在这里才能灵活的使用(通过重写<code>IsSelectionAllowed</code>函数)</p>
<p>这里有兴趣的可以去看一下源码, 这个UE4和UE5差别很大</p>
<p>UE4在<code> UUnrealEdEngine::CanSelectActor</code>里面, UE5在<code>FActorElementLevelEditorSelectionCustomization::CanSelectActorElement</code>中</p>
<p>EditorMode插件在UE4和UE5的实现也是天差地别, 主要是UE4的Mode继承自<code>FEdMode</code>, 而UE5改成了继承自<code>UEdMode</code>;</p>
<p>可以通过创建一个默认的EditorMode插件看一下</p>
<p>个人觉得, UE4.27是当中的一个过渡版本, 因为看了下源码,  BSP编辑使用的是<code>FEdMode</code>, 而Landscape已经改成了<code>UEdMode</code>, 想要研究<code>EditorMode</code>的同学还是找个合适的版本开始写, 不然这个跨版本的改动真的挺大的</p>
<p>回归正题,  不过两者在界面中加入UMG的方法没有什么本质差别</p>
<p>工具集类<code>FModeToolkit</code>的内容大差不差,  可以重写<code>GetInlineContent</code>方法直接塞进去UMG, 或者在这个函数中返回一个SWidget对象, 然后在初始化函数<code>Init()</code>中SNew出来, 比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TSharedPtr&lt;SWidget&gt; <span class="title">FNLDEditor_ModeToolkit::GetInlineContent</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ToolkitWidget; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FNLDEditor_ModeToolkit::Init</span><span class="params">(<span class="keyword">const</span> TSharedPtr&lt;IToolkitHost&gt;&amp; InitToolkitHost)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="built_in">SAssignNew</span>(ToolkitWidget, SNLDEditor_MainUI);</span><br><span class="line">	FModeToolkit::<span class="built_in">Init</span>(InitToolkitHost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接丢到<code>GetInlineContent()</code>中去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TSharedPtr&lt;SWidget&gt; <span class="title">FEdModeTestEditorModeToolkit::GetInlineContent</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> WidgetClass =  LoadClass&lt;UObject&gt;(<span class="literal">NULL</span>, 	 <span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Blutility.EditorUtilityWidgetBlueprint&#x27;/Game/EU_Test.EU_Test_C&#x27;&quot;</span>));</span><br><span class="line">	UUserWidget* EdUI = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (WidgetClass)</span><br><span class="line">	&#123;</span><br><span class="line">		UWorld* WidgetWorld = GEditor-&gt;<span class="built_in">GetEditorWorldContext</span>().<span class="built_in">World</span>();</span><br><span class="line">		<span class="keyword">if</span> (WidgetWorld)</span><br><span class="line">		&#123;</span><br><span class="line">			EdUI = CreateWidget&lt;UUserWidget&gt;(WidgetWorld, WidgetClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (EdUI)</span><br><span class="line">	&#123;</span><br><span class="line">		TSharedPtr&lt;SWidget&gt; WidgetTemp = FModeToolkit::<span class="built_in">GetInlineContent</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SNew</span>(SVerticalBox)</span><br><span class="line">		+ SVerticalBox::<span class="built_in">Slot</span>()</span><br><span class="line">		   .<span class="built_in">AutoHeight</span>()</span><br><span class="line">		  [</span><br><span class="line">			  EdUI-&gt;<span class="built_in">TakeWidget</span>()</span><br><span class="line">		  ]</span><br><span class="line">		   + SVerticalBox::<span class="built_in">Slot</span>()</span><br><span class="line">		   .<span class="built_in">AutoHeight</span>()</span><br><span class="line">		   [</span><br><span class="line">			   WidgetTemp.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">		   ];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FModeToolkit::<span class="built_in">GetInlineContent</span>();</span><br><span class="line">	&#125;	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看一下UE5中的效果</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/6ee2800ebc6b57e7a22ca13dc3c6adaf6665102b/image-20230116205002923.png" alt="image-20230116205002923"></p>
<p>用蓝图UMG来代替slate, 好处当然就是方便, 不用每次调个尺寸都编译一下, 效率杠杠的. 不过蓝图中修改以后需要重新初始化一下插件, 也就是你需要切换至其他Mode然后再切回来</p>
<p>另外, 针对一些蓝图中没有的编辑器功能, 还是需要一个蓝图库来支持一下</p>
<blockquote>
<p>UMG的Class类型可以丢到一个配置中, 比如游戏ini设置文件, 直接字符串写死不容易维护, 下同</p>
</blockquote>
<h2 id="Standalone-Window"><a href="#Standalone-Window" class="headerlink" title="Standalone Window"></a>Standalone Window</h2><p>这个比较简单, 原本就有一个创建<code>SDockTab</code>的流程, 在<code>SDockTab</code>内把UMG加进去就可以了, 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TSharedRef&lt;SDockTab&gt; <span class="title">FWindowTestModule::OnSpawnPluginTab</span><span class="params">(<span class="keyword">const</span> FSpawnTabArgs&amp; SpawnTabArgs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> WidgetClass =  LoadClass&lt;UObject&gt;(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Blutility.EditorUtilityWidgetBlueprint&#x27;/Game/EU_Test.EU_Test_C&#x27;&quot;</span>));</span><br><span class="line">	UUserWidget* EdUI = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (WidgetClass)</span><br><span class="line">	&#123;</span><br><span class="line">		UWorld* WidgetWorld = GEditor-&gt;<span class="built_in">GetEditorWorldContext</span>().<span class="built_in">World</span>();</span><br><span class="line">		<span class="keyword">if</span> (WidgetWorld)</span><br><span class="line">		&#123;</span><br><span class="line">			EdUI = CreateWidget&lt;UUserWidget&gt;(WidgetWorld, WidgetClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (EdUI)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SNew</span>(SDockTab)</span><br><span class="line">			.<span class="built_in">TabRole</span>(ETabRole::NomadTab)</span><br><span class="line">			[</span><br><span class="line">				<span class="comment">// Put your tab content here!</span></span><br><span class="line">				<span class="built_in">SNew</span>(SBox)</span><br><span class="line">				.<span class="built_in">HAlign</span>(HAlign_Center)</span><br><span class="line">				.<span class="built_in">VAlign</span>(VAlign_Center)</span><br><span class="line">				[</span><br><span class="line">					EdUI-&gt;<span class="built_in">TakeWidget</span>()</span><br><span class="line">				]</span><br><span class="line">			];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>点击以后效果如下</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/4a962acd8d9fa9fd98bb8cbf390d6444e963932e/img/image-20230117105608635.png" alt="image-20230117105608635"></p>
<h2 id="Toolbar-Button"><a href="#Toolbar-Button" class="headerlink" title="Toolbar Button"></a>Toolbar Button</h2><p>这个稍微特殊一点,  他其实完全可以照着前者创建一个<code>SDockTab</code>来弹出一个窗口,  但是我们这里做一个区别, 可不可以点击以后直接弹出UMG窗口呢? 答案是可以的, 之前有过一篇文章<a href="https://supervj.top/2021/01/09/%E5%85%B3%E4%BA%8EEditorUtilityWiget%E7%94%A8cpp%E6%9D%A5%E8%BF%90%E8%A1%8C/?highlight=editoruti">关于EditorUtilityWiget用cpp来运行</a></p>
<p>我们讲里面的方法再优化一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FToolbarButtonTestModule::PluginButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UEditorUtilitySubsystem* Subsys = GEditor-&gt;GetEditorSubsystem&lt;UEditorUtilitySubsystem&gt;();</span><br><span class="line">	<span class="keyword">auto</span> BP = UEditorAssetLibrary::<span class="built_in">LoadAsset</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Game/EU_Test.EU_Test&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">auto</span> EdBp = Cast&lt;UEditorUtilityWidgetBlueprint&gt;(BP))</span><br><span class="line">	&#123;</span><br><span class="line">		Subsys-&gt;<span class="built_in">SpawnAndRegisterTab</span>(EdBp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击以后直接找到蓝图, 通过Subsystem方法直接显示出来</p>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>Slate</tag>
        <tag>UMG</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝图扩展ToolBar</title>
    <url>/2022/07/22/%E7%94%A8%E8%93%9D%E5%9B%BE%E6%89%A9%E5%B1%95ToolBar/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前写过一篇文章 <a href="https://supervj.top/2021/08/09/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E6%A0%8F/?highlight=%E8%8F%9C%E5%8D%95">编辑器扩展：自定义菜单栏</a></p>
<p>现在发现蓝图也可以在某些功能上代替cpp来扩展工具栏,  这样当然是非常方便的, 谁用Slate谁都一个头两个大</p>
<p>这里来简单尝试一下</p>
<p><img src="https://github.com/VJien/img/blob/master/img%E5%BD%95%E5%88%B6_2022_07_22_11_16_44_915.gif?raw=true" alt="录制_2022_07_22_11_16_44_915"></p>
<span id="more"></span>



<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>开始之前先打开编辑器偏好设置里的一个选项, 方便我们观察UI的分类</p>
<p><img src="https://img.supervj.top/imgimage-20220722102851012.png" alt="image-20220722102851012"></p>
<p>接着我们需要先给项目加一个配置</p>
<p>在项目Config目录的DefaultEditorPerProjectUserSettings.ini(如果没有就创建一个)中添加如下命令</p>
<p><code>[/Script/UnrealEd.EditorExperimentalSettings] bEnableEditToolMenusUI=True</code></p>
<p>这样在windows下拉菜单里会多一个按钮</p>
<p><img src="https://img.supervj.top/imgimage-20220722102735392.png" alt="image-20220722102735392"></p>
<p>确认以后我们的编辑器就变成了这个鸟样</p>
<p><img src="https://img.supervj.top/imgimage-20220722103033752.png" alt="image-20220722103033752"></p>
<p>点开这些图标可以看到我们的toolbar分类名称</p>
<p>比如我们这个用户自定义的分类叫这个,这里要记一下后面要用</p>
<p><img src="https://img.supervj.top/imgimage-20220722103128123.png" alt="image-20220722103128123"></p>
<p>然后创建蓝图对象继承自 <code>EditorUtilityToolMenuEntry</code></p>
<p>所有的配置都在这里</p>
<p><img src="https://img.supervj.top/imgimage-20220722102537845.png" alt="image-20220722102537845"></p>
<p>重点说一下</p>
<ul>
<li>Menu: 这个就是上面看到的分类名称, 这里填写LevelEditor.LevelEditorToolBar.User</li>
<li>Section: 每个Menu需要有一个Section, 这个Section就是看到的那种绿色的,这里填写Next</li>
<li>Name: 当前按钮的名称, 不会在编辑器下显示, 会在编辑菜单时显示, 如下图<img src="https://img.supervj.top/imgimage-20220722103504205.png" alt="image-20220722103504205"></li>
<li>Label: 同Name</li>
<li>ToolTip: 鼠标放到按钮上时的注释</li>
<li>Icon<ul>
<li>StyleSetName: 没啥好说的就是Icon的对应的Style</li>
<li>StyleName/SmallStyleName: 样式名称</li>
</ul>
</li>
</ul>
<blockquote>
<p>建议用自己的Style, 可以看之前的文章<a href="https://supervj.top/2021/04/12/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Slate%E7%AC%94%E5%88%B7/?highlight=style">使用自定义Slate笔刷</a>, 我们这里图省事用了引擎的</p>
<p>随手一找找了个<code>CoreStyle</code>,名字怎么来? 看这里</p>
<p><img src="https://img.supervj.top/imgimage-20220722103822219.png" alt="image-20220722103822219"></p>
<p>然后下面随便找一个看着顺眼的</p>
<p><img src="https://img.supervj.top/imgimage-20220722103848252.png" alt="image-20220722103848252"></p>
</blockquote>
<ul>
<li>InsertPosition: 插入位置, 目前发现代码并没有完全用到这个数据的完整部分, 我们这里用First, 名字无所谓</li>
<li>Advanced: 高级功能, 有几个是比较重要的<ul>
<li>EntryType: 类型, 不能瞎选, 实测我们如果要用一个简单的按钮那么就选<code>ToolBarButton</code>, 有一些规则, 可以去看<code>UToolMenus::PopulateToolBarBuilder()</code>细看</li>
<li>UserInterfaceActionType: 一般选Button, 有些类型不适合ToolBar会报错</li>
</ul>
</li>
</ul>
<p>然后就是运行, 可以右键资源点击RunEditroUtilityWidget运行, 但是这样很麻烦</p>
<p>我们还是在<code>DefaultEditorPerProjectUserSettings.ini</code>中添加编辑器启动自动运行的命令</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[/Script/Blutility.EditorUtilitySubsystem]</span></span><br><span class="line"><span class="attr">StartupObjects</span>=/Game/Next/GamePlay/BluePrint/EditorUtility/EU_ToolBar_1.EU_ToolBar_1</span><br></pre></td></tr></table></figure>

<p>注意是我们资源的名称</p>
<p>然后网上有资料说要创建自定义事件Run来运行, 我心想为啥? 没有对应的重载函数吗?</p>
<p>看了代码, 瞬间石化</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220722113215437.png" alt="image-20220722113215437"></p>
<p>可能是为了照顾有些编辑器扩展蓝图自带的Run函数, 那你为什么不给<code>EditorUtilityToolMenuEntry</code>加一个呢?</p>
<p>接下来就比较简单了, 如下图</p>
<p><img src="https://github.com/VJien/img/blob/master/imgimage-20220722111155885.png?raw=true" alt="image-20220722113241615"></p>
<p>这个Get是获取ToolMenus的单例,然后调用里面的添加Menu的方法</p>
<p>试过也可以用下图这种展开来的方法</p>
<p><img src="https://github.com/VJien/img/blob/master/imgimage-20220722111421705.png?raw=true" alt="image-20220722111421705"></p>
<p>本质上AddMenuEntryObject是把当前这个资源的Data数据构造成Args来调用AddEntry</p>
<p><img src="https://github.com/VJien/img/blob/master/imgimage-20220722111357777.png?raw=true" alt="image-20220722111357777"></p>
<p>但是蓝图侧面略有区别,  用后者方法没法自定义Icon….伤脑筋. 这样就不优雅了</p>
<hr>
<p>好了, 重启编辑器以后按钮就在了, 点击以后会执行Execute方法, 我们执行下图逻辑</p>
<p><img src="https://github.com/VJien/img/blob/master/imgimage-20220722111542964.png?raw=true" alt="image-20220722111542964"></p>
<p>打开的是另一个编辑器UMG, 非常方便</p>
<p><img src="https://github.com/VJien/img/blob/master/img%E5%BD%95%E5%88%B6_2022_07_22_11_16_44_915.gif?raw=true" alt="录制_2022_07_22_11_16_44_915"></p>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>编辑器扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>由SetActorLocation分析渲染流程</title>
    <url>/2020/06/04/%E7%94%B1SetActorLocation%E5%88%86%E6%9E%90%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>角色位移本质上就是渲染问题，从这条思路我们去看看角色怎么实现这一部分渲染的</p>
</blockquote>
<h5 id="起点：SetActorLocation"><a href="#起点：SetActorLocation" class="headerlink" title="起点：SetActorLocation"></a>起点：SetActorLocation</h5><blockquote>
<p>蓝图调用的API实际调用的是K2_SetActorLocation，然后调用到此函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> RootComponent-&gt;<span class="built_in">MoveComponent</span>(Delta, <span class="built_in">GetActorQuat</span>(), bSweep, OutSweepHitResult, MOVECOMP_NoFlags, Teleport);</span><br></pre></td></tr></table></figure>

<p>只看这个关键代码，调用<code>RootComponent</code>的<code>MoveComponent</code></p>
<h5 id="USceneComponent"><a href="#USceneComponent" class="headerlink" title="USceneComponent"></a>USceneComponent</h5><h6 id="MoveComponent"><a href="#MoveComponent" class="headerlink" title="MoveComponent"></a>MoveComponent</h6><blockquote>
<p>外部调用此函数后里面直接调用到带<code>Impl</code>后缀的虚函数</p>
<p>这个函数在UPrimitiveComponent内有重写</p>
</blockquote>
<p><code>USceneComponent</code>内主要调用了函数<code>ConditionalUpdateComponentToWorld</code>,而<code>UPrimitiveComponent</code>因为有碰撞等属性所以又多了很多逻辑，这里不多描述</p>
<h6 id="UpdateComponentToWorldWithParent"><a href="#UpdateComponentToWorldWithParent" class="headerlink" title="UpdateComponentToWorldWithParent"></a>UpdateComponentToWorldWithParent</h6><blockquote>
<p>此函数通过<code>ConditionalUpdateComponentToWorld</code>调用，后又调用到虚函数<code>UpdateComponentToWorld</code>,此虚函数在<code>UActorComponent</code>声明，在<code>USceneComponent</code>重写</p>
<p>然后再直接调用到此函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Parent &amp;&amp; !Parent-&gt;bComponentToWorldUpdated)</span><br><span class="line">&#123;</span><br><span class="line">	Parent-&gt;<span class="built_in">UpdateComponentToWorld</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bComponentToWorldUpdated)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有父级组件，先去处理他</p>
<p>然后调用到函数<code>PropagateTransformUpdate</code></p>
<h6 id="PropagateTransformUpdate"><a href="#PropagateTransformUpdate" class="headerlink" title="PropagateTransformUpdate"></a>PropagateTransformUpdate</h6><p>该函数执行了</p>
<ul>
<li>更新体积(Bounds)</li>
<li>更新变换(Transform)<ul>
<li>更新Attach的子组件的变换信息</li>
</ul>
</li>
<li>更新寻路信息</li>
</ul>
<p>其中有个关键的函数<code>UActorComponent::MarkRenderTransformDirty</code></p>
<p>然后经过简单判断以后调用<code>UActorComponent::MarkForNeededEndOfFrameUpdate</code></p>
<p>然后调用了<code>UWorld</code> 的<code>MarkActorComponentForNeededEndOfFrameUpdate</code></p>
<p>看主要代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UActorComponent::MarkRenderTransformDirty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsRegistered</span>() &amp;&amp; bRenderStateCreated)</span><br><span class="line">	&#123;</span><br><span class="line">		bRenderTransformDirty = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">MarkForNeededEndOfFrameUpdate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UActorComponent::MarkForNeededEndOfFrameUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bNeverNeedsRenderUpdate)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UWorld* ComponentWorld = <span class="built_in">GetWorld</span>();</span><br><span class="line">	<span class="keyword">if</span> (ComponentWorld)</span><br><span class="line">	&#123;</span><br><span class="line">		ComponentWorld-&gt;<span class="built_in">MarkActorComponentForNeededEndOfFrameUpdate</span>(<span class="keyword">this</span>, <span class="built_in">RequiresGameThreadEndOfFrameUpdates</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">IsUnreachable</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果没有世界，执行如下代码</span></span><br><span class="line">		<span class="built_in">DoDeferredRenderUpdates_Concurrent</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="UWorld"><a href="#UWorld" class="headerlink" title="UWorld"></a>UWorld</h5><h6 id="MarkActorComponentForNeededEndOfFrameUpdate"><a href="#MarkActorComponentForNeededEndOfFrameUpdate" class="headerlink" title="MarkActorComponentForNeededEndOfFrameUpdate"></a>MarkActorComponentForNeededEndOfFrameUpdate</h6><blockquote>
<p>代码在LevelTick.cpp L883</p>
</blockquote>
<p>主要执行了把组件添加到了等待渲染的列表<code>ComponentsThatNeedEndOfFrameUpdate_OnGameThread</code>里,当然还有一个非游戏线程的<code>ComponentsThatNeedEndOfFrameUpdate</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bForceGameThread)</span><br><span class="line">		&#123;</span><br><span class="line">			FMarkComponentEndOfFrameUpdateState::<span class="built_in">Set</span>(Component, ComponentsThatNeedEndOfFrameUpdate_OnGameThread.<span class="built_in">Num</span>(), EComponentMarkedForEndOfFrameUpdateState::MarkedForGameThread);</span><br><span class="line">			ComponentsThatNeedEndOfFrameUpdate_OnGameThread.<span class="built_in">Add</span>(Component);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			FMarkComponentEndOfFrameUpdateState::<span class="built_in">Set</span>(Component, ComponentsThatNeedEndOfFrameUpdate.<span class="built_in">Num</span>(), EComponentMarkedForEndOfFrameUpdateState::Marked);</span><br><span class="line">			ComponentsThatNeedEndOfFrameUpdate.<span class="built_in">Add</span>(Component);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>到此我们大概知道了这一条线的终点了，然后去看看哪里使用到了这个数组</p>
<h6 id="SendAllEndOfFrameUpdates"><a href="#SendAllEndOfFrameUpdates" class="headerlink" title="SendAllEndOfFrameUpdates"></a>SendAllEndOfFrameUpdates</h6><p>确认使用上面数组是在此函数内，查找引用发现此函数在很多地方被调用，如<code>SceneRendering.cpp</code>,<code>UnrealEngine.cpp</code>大概就是要更新场景最新的渲染的时候就会调用，先不理会，看这个函数内实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (UActorComponent* Component : ComponentsThatNeedEndOfFrameUpdate_OnGameThread)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Component)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (Component-&gt;<span class="built_in">IsRegistered</span>() &amp;&amp; !Component-&gt;<span class="built_in">IsTemplate</span>() &amp;&amp; !Component-&gt;<span class="built_in">IsPendingKill</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="function">FScopeCycleCounterUObject <span class="title">ComponentScope</span><span class="params">(Component)</span></span>;</span><br><span class="line">					<span class="function">FScopeCycleCounterUObject <span class="title">AdditionalScope</span><span class="params">(STATS ? Component-&gt;AdditionalStatObject() : <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">					Component-&gt;<span class="built_in">DoDeferredRenderUpdates_Concurrent</span>();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">check</span>(Component-&gt;<span class="built_in">IsPendingKill</span>() || Component-&gt;<span class="built_in">GetMarkedForEndOfFrameUpdateState</span>() == EComponentMarkedForEndOfFrameUpdateState::MarkedForGameThread);</span><br><span class="line">				FMarkComponentEndOfFrameUpdateState::<span class="built_in">Set</span>(Component, INDEX_NONE, EComponentMarkedForEndOfFrameUpdateState::Unmarked);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ComponentsThatNeedEndOfFrameUpdate_OnGameThread.<span class="built_in">Reset</span>();</span><br><span class="line">		ComponentsThatNeedEndOfFrameUpdate.<span class="built_in">Reset</span>();</span><br></pre></td></tr></table></figure>

<p>遍历了所有数组成员，主要执行了<code>DoDeferredRenderUpdates_Concurrent</code>，回头看<code>USceneComponent</code>内的如果没有<code>UWorld</code>就直接调用了这个函数</p>
<h5 id="UActorComponent"><a href="#UActorComponent" class="headerlink" title="UActorComponent"></a>UActorComponent</h5><h6 id="DoDeferredRenderUpdates-Concurrent"><a href="#DoDeferredRenderUpdates-Concurrent" class="headerlink" title="DoDeferredRenderUpdates_Concurrent"></a>DoDeferredRenderUpdates_Concurrent</h6><p><code>RecreateRenderState_Concurrent</code>,<code>SendRenderTransform_Concurrent</code>,<code>SendRenderDynamicData_Concurrent</code>告诉引擎需要处理相应的渲染任务</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UActorComponent::DoDeferredRenderUpdates_Concurrent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">checkf</span>(!<span class="built_in">IsUnreachable</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), *<span class="built_in">GetFullName</span>());</span><br><span class="line">	<span class="built_in">checkf</span>(!<span class="built_in">IsTemplate</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), *<span class="built_in">GetFullName</span>());</span><br><span class="line">	<span class="built_in">checkf</span>(!<span class="built_in">IsPendingKill</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), *<span class="built_in">GetFullName</span>());</span><br><span class="line"></span><br><span class="line">	<span class="function">FScopeCycleCounterUObject <span class="title">ContextScope</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">IsRegistered</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogActorComponent, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;UpdateComponent: (%s) Not registered, Aborting.&quot;</span>), *<span class="built_in">GetPathName</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(bRenderStateDirty)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_PostTickComponentRecreate);</span><br><span class="line">		<span class="built_in">RecreateRenderState_Concurrent</span>();</span><br><span class="line">		<span class="built_in">checkf</span>(!bRenderStateDirty, <span class="built_in">TEXT</span>(<span class="string">&quot;Failed to route CreateRenderState_Concurrent (%s)&quot;</span>), *<span class="built_in">GetFullName</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_PostTickComponentLW);</span><br><span class="line">		<span class="keyword">if</span>(bRenderTransformDirty)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Update the component&#x27;s transform if the actor has been moved since it was last updated.</span></span><br><span class="line">			<span class="built_in">SendRenderTransform_Concurrent</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(bRenderDynamicDataDirty)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SendRenderDynamicData_Concurrent</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="SendRenderTransform-Concurrent"><a href="#SendRenderTransform-Concurrent" class="headerlink" title="SendRenderTransform_Concurrent"></a>SendRenderTransform_Concurrent</h6><p>这个函数在基类只做了基础实现，主要是派生类重写实现主要逻辑，类似的也包括<code>SendRenderDynamicData_Concurrent</code>,<code>CreateRenderState_Concurrent</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="built_in">check</span>(bRenderStateCreated);</span><br><span class="line">	bRenderTransformDirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LOG_RENDER_STATE</span></span><br><span class="line">	<span class="built_in">UE_LOG</span>(LogActorComponent, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;SendRenderTransform_Concurrent: %s&quot;</span>), *<span class="built_in">GetPathName</span>());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="UPrimitiveComponent"><a href="#UPrimitiveComponent" class="headerlink" title="UPrimitiveComponent"></a>UPrimitiveComponent</h5><p>紧接上面，我们看看有形状体积等信息的<code>UPrimitiveComponent</code></p>
<h6 id="SendRenderTransform-Concurrent-1"><a href="#SendRenderTransform-Concurrent-1" class="headerlink" title="SendRenderTransform_Concurrent"></a>SendRenderTransform_Concurrent</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UPrimitiveComponent::SendRenderTransform_Concurrent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UpdateBounds</span>();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bDetailModeAllowsRendering	= DetailMode &lt;= <span class="built_in">GetCachedScalabilityCVars</span>().DetailMode;</span><br><span class="line">	<span class="keyword">if</span>( bDetailModeAllowsRendering &amp;&amp; (<span class="built_in">ShouldRender</span>() || bCastHiddenShadow))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">GetWorld</span>()-&gt;Scene-&gt;<span class="built_in">UpdatePrimitiveTransform</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Super::<span class="built_in">SendRenderTransform_Concurrent</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到在实现基类逻辑之前执行了<code>FScene</code>内的函数<code>UpdatePrimitiveTransform</code></p>
<h5 id="FScene"><a href="#FScene" class="headerlink" title="FScene"></a>FScene</h5><blockquote>
<p>代码在 RendererScene.cpp中</p>
</blockquote>
<h6 id="UpdatePrimitiveTransform"><a href="#UpdatePrimitiveTransform" class="headerlink" title="UpdatePrimitiveTransform"></a>UpdatePrimitiveTransform</h6><p>在<code>UpdatePrimitiveTransform</code>函数中会判断该<code>Primitive</code>有没有<code>SceneProxy</code>，如果有<code>SceneProxy</code>则判断该<code>Primitive</code>是否需要重新创建，如果需要重新创建则需要先删除，然后再添加该<code>Primitive</code>；如果没有<code>SceneProxy</code>则直接加入到场景中。接着我们具体看一下<code>AddPrimitive</code>函数的具体实现：</p>
<h6 id="AddPrimitive"><a href="#AddPrimitive" class="headerlink" title="AddPrimitive"></a>AddPrimitive</h6><p> 此函数主要做了如下几件事情</p>
<ul>
<li>创建<code>SceneProxy</code>和<code>PrimitiveSceneInfo</code></li>
<li>利用<code>FPrimitiveSceneInfo</code>封装<code>UPrimitiveComponent</code>的信息，继续在<code>render</code>线程中进行操作</li>
<li>给渲染线程发送2个命令，分别是设置<code>Primitive</code>的<code>Transform</code>信息和将<code>PrimitiveSceneInfo</code>加入到渲染线程的数据集合中</li>
</ul>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FPrimitiveSceneProxy* PrimitiveSceneProxy = Primitive-&gt;<span class="built_in">CreateSceneProxy</span>();</span><br><span class="line">	Primitive-&gt;SceneProxy = PrimitiveSceneProxy;</span><br><span class="line"><span class="comment">// Create the primitive scene info.</span></span><br><span class="line">	FPrimitiveSceneInfo* PrimitiveSceneInfo = <span class="keyword">new</span> <span class="built_in">FPrimitiveSceneInfo</span>(Primitive, <span class="keyword">this</span>);</span><br><span class="line">	PrimitiveSceneProxy-&gt;PrimitiveSceneInfo = PrimitiveSceneInfo;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create any RenderThreadResources required.</span></span><br><span class="line">	<span class="built_in">ENQUEUE_RENDER_COMMAND</span>(CreateRenderThreadResourcesCommand)(</span><br><span class="line">		[Params](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">	&#123;</span><br><span class="line">		FPrimitiveSceneProxy* SceneProxy = Params.PrimitiveSceneProxy;</span><br><span class="line">		FScopeCycleCounter <span class="built_in">Context</span>(SceneProxy-&gt;<span class="built_in">GetStatId</span>());</span><br><span class="line">		SceneProxy-&gt;<span class="built_in">SetTransform</span>(Params.RenderMatrix, Params.WorldBounds, Params.LocalBounds, Params.AttachmentRootPosition);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create any RenderThreadResources required.</span></span><br><span class="line">		SceneProxy-&gt;<span class="built_in">CreateRenderThreadResources</span>();</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ENQUEUE_RENDER_COMMAND</span>(AddPrimitiveCommand)(</span><br><span class="line">	[Scene, PrimitiveSceneInfo](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">	&#123;</span><br><span class="line">		FScopeCycleCounter <span class="built_in">Context</span>(PrimitiveSceneInfo-&gt;Proxy-&gt;<span class="built_in">GetStatId</span>());</span><br><span class="line">		Scene-&gt;<span class="built_in">AddPrimitiveSceneInfo_RenderThread</span>(RHICmdList, PrimitiveSceneInfo);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="AddPrimitiveSceneInfo-RenderThread"><a href="#AddPrimitiveSceneInfo-RenderThread" class="headerlink" title="AddPrimitiveSceneInfo_RenderThread"></a>AddPrimitiveSceneInfo_RenderThread</h6><p><code>AddPrimitiveSceneInfo_RenderThread</code>函数是在渲染线程执行的，完成<code>PrimitiveBounds</code>、<code>PrimitiveFlagsCompact</code>等数据的初始化后，并调用<code>LinkAttachmentGroup</code>处理<code>primitive</code>的父子关系，调用<code>LinkLODParentComponent</code>处理LOD父子关系，然后调用<code>FPrimitiveSceneInfo::AddToScene</code></p>
<p><code>AddToScene</code>最终会把物体添加到列表<code>DrawList</code> 中去完成绘制，这里不继续深挖了,埋个扣子，以后来解开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add the primitive to its shadow parent&#x27;s linked list of children.</span></span><br><span class="line">	<span class="comment">// Note: must happen before AddToScene because AddToScene depends on LightingAttachmentRoot</span></span><br><span class="line">PrimitiveSceneInfo-&gt;<span class="built_in">LinkAttachmentGroup</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set lod Parent information if valid</span></span><br><span class="line">PrimitiveSceneInfo-&gt;<span class="built_in">LinkLODParentComponent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the primitive to the scene.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> bAddToDrawLists = !(CVarDoLazyStaticMeshUpdate.<span class="built_in">GetValueOnRenderThread</span>() &amp;&amp; !WITH_EDITOR);</span><br><span class="line"><span class="keyword">if</span> (bAddToDrawLists)</span><br><span class="line">&#123;</span><br><span class="line">	PrimitiveSceneInfo-&gt;<span class="built_in">AddToScene</span>(RHICmdList, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	PrimitiveSceneInfo-&gt;<span class="built_in">AddToScene</span>(RHICmdList, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">	PrimitiveSceneInfo-&gt;<span class="built_in">BeginDeferredUpdateStaticMeshes</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote>
<p>由此我们就大致整理一下思路</p>
</blockquote>
<p>设置Actor的位置，其实就是把新旧位置做一个插值，把这个插值传递给继承自<code>USceneComponent</code>的<code>MoveComponent</code>方法，然后在下一帧渲染出新的位置</p>
<p>这里也接上了并解释了之前<a href="%5Bhttps://supervj.top/2020/05/27/AI_MoveTo%E7%A0%94%E7%A9%B6/%5D(https://supervj.top/2020/05/27/AI_MoveTo%E7%A0%94%E7%A9%B6/)">AI_MoveTo</a>的内容了</p>
<p>上一张流程简图</p>
<p><img src="https://img.supervj.top/img/%E6%B8%B2%E6%9F%93.jpg"></p>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><h6 id="场景中静态物体的渲染顺序堆栈表参考"><a href="#场景中静态物体的渲染顺序堆栈表参考" class="headerlink" title="场景中静态物体的渲染顺序堆栈表参考"></a>场景中静态物体的渲染顺序堆栈表参考</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ActorComponet::ExecuteRegisterEvents</span><br><span class="line">UPrimitiveComponent::CreateRenderState_Concurrent</span><br><span class="line">FScene:: AddPrimitive</span><br><span class="line">FScene:: AddPrimitiveSceneInfo_RenderThread</span><br><span class="line">FScene:: AddStaticMeshes</span><br><span class="line">FStaticMesh::AddToDrawLists</span><br><span class="line">FMobileBasePassOpaqueDrawingPolicyFactory::AddStaticMesh</span><br><span class="line">ProcessMobileBasePassMesh</span><br><span class="line">FDrawMobileBasePassStaticMeshAction:: Process</span><br><span class="line">AddMeshToStaticDrawList</span><br><span class="line"><span class="comment">//加入到scene GetMobileBasePassDrawList中</span></span><br></pre></td></tr></table></figure>

<p>最终加入队列 以<code>DrawingPolicy</code> 为<code>key </code>的<code>map</code>队列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TStaticMeshDrawList&lt;TMobileBasePassDrawingPolicy&lt;FUniformLightMapPolicy, <span class="number">0</span>&gt; &gt; MobileBasePassUniformLightMapPolicyDrawList[EBasePass_MAX];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>渲染流程</tag>
      </tags>
  </entry>
  <entry>
    <title>细说UE的碰撞与检测</title>
    <url>/2022/04/28/%E7%A2%B0%E6%92%9E%E5%92%8C%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>本文从应用角度分析一下UE的碰撞和检测系统,  模型主要看静态模型即StaticMesh, 骨骼模型涉及到物理资产的使用和编辑, 本文暂不做分析</p>
<span id="more"></span>

<p><strong>目录</strong></p>
<ul>
<li><a href="#ObjectChannel">碰撞类型</a></li>
<li><a href="#CollisionResponses">碰撞响应</a></li>
<li><a href="#Trace">射线通道和射线检测</a></li>
<li><a href="#Complex">简单碰撞和复杂碰撞</a></li>
<li><a href="#CollisionEdit">碰撞编辑</a></li>
<li><a href="#Sweap">其他检测</a></li>
<li><a href="#Custom">关于Custom</a></li>
</ul>
<a name ="ObjectChannel">

<h2 id="碰撞类型"><a href="#碰撞类型" class="headerlink" title="碰撞类型"></a>碰撞类型</h2><p> 每一个参与物理世界的对象都必须配置一个碰撞类型(见下图), 在引擎中这个类型叫<code>ObjectChannel</code>,  与其翻译成物体通道或者物体类型不如理解为碰撞类型更为确切</p>
<p><img src="https://img.supervj.top/imgimage-20220429095531095.png" alt="image-20220429095531095"></p>
<p>这里先要看一下UE默认的类型, 如下图</p>
<p><img src="https://img.supervj.top/imgimage-20220428175137478.png" alt="image-20220428175137478"></p>
<p>一般的理解</p>
<ul>
<li>WorldStatic: 场景中的静态物体</li>
<li>WorldDynamic: 场景中的动态物体</li>
<li>Pawn: 角色(默认包含了外层Capsule和骨骼模型)</li>
<li>PhysicsBody: 开启物理的物体</li>
<li>Vehicle: 载具</li>
<li>Destructible: 可破碎物体</li>
</ul>
<p>但是这个也只是建议, 很多时候根据项目需求可以视情况变动, 而且一般情况下, 这几个碰撞类型是远远不够的, 那么在哪里添加呢?</p>
<p>找到 ProjectSettings -&gt; Collision -&gt; ObjectChannels -&gt; NewObjectChannel 添加即可, 也可以看下图</p>
<p><img src="https://img.supervj.top/imgimage-20220428190023906.png" alt="image-20220428190023906"></p>
<blockquote>
<p>通道有数量限制, 自定义的所有Object和TraceChannel总数只能有18个, 系统已经带了7个(5个Object,2个Trace), 也就是自定义加起来最多只有11个</p>
</blockquote>
<ul>
<li>预设</li>
</ul>
<p>下面可以设置预设, <strong>预设非常有用</strong>, 可以方便我们给物体设置碰撞的时候直接使用, 毕竟custom还是有点麻烦的, 也不容易维护, 预设可以设定这个碰撞类型对其他类型的响应类型(Responses), 以及通道响应类型</p>
<p><img src="https://img.supervj.top/imgimage-20220428190834969.png" alt="image-20220428190834969"></p>
<p>配置预设的时候记得要设置碰撞是否开启, 是否开启物理或者查询</p>
<p><img src="https://img.supervj.top/imgimage-20220428204620707.png" alt="image-20220428204620707"></p>
<p>同一种碰撞类型有时候会设置成多种预设, 比如引擎自带的Pawn和ChacterMesh</p>
<p>两者的碰撞类型都是Pawn(还有一个不常用的Spectator也是Pawn), 但是这里的预设Pawn是给角色的Capsule用的,  而后者是给SkeletalMesh用的, 所以ChacterMesh的预设里就把对Pawn的响应设置成了Ignore了</p>
<p><img src="https://img.supervj.top/imgimage-20220429100239397.png" alt="image-20220429100239397"></p>
<a name ="CollisionResponses">

<h2 id="碰撞响应"><a href="#碰撞响应" class="headerlink" title="碰撞响应"></a>碰撞响应</h2><p>上面解释了物体的碰撞类型, 那么两个物体之间是怎么来处理这个相互间的碰撞的呢?</p>
<p>我们在编辑模型的碰撞的时候肯定会看到这3个CollisionResponses即碰撞响应类型</p>
<p><img src="https://img.supervj.top/imgimage-20220428191835387.png" alt="image-20220428191835387"></p>
<ul>
<li>ignore: 忽略</li>
<li>overlap:重叠</li>
<li>block: 阻挡</li>
</ul>
<p>那么如果A对B的响应与B对A的响应不相同怎么办呢?</p>
<p>直接上图</p>
<p><img src="https://img.supervj.top/imgimage-20220428174622511.png" alt="image-20220428174622511"></p>
<p>简单总结</p>
<ol>
<li>两者有ignore的那么一定ignore</li>
<li>没有ignore的情况那么有overlap一定是overlap</li>
</ol>
<p>那么然后怎么使用呢?</p>
<p><img src="https://img.supervj.top/imgimage-20220428192919782.png" alt="image-20220428192919782"></p>
<p>首先<strong>碰撞事件接收方</strong>需要开启对应的事件,  Overlap默认是开启的, Hit默认关闭</p>
<blockquote>
<p>如果这个物体你确定不用参与overlap那么建议关闭这个选项, 开启是有开销的</p>
</blockquote>
<p><img src="https://img.supervj.top/imgimage-20220428193353529.png" alt="image-20220428193353529"></p>
<p><img src="https://img.supervj.top/imgimage-20220428193258284.png" alt="image-20220428193258284"></p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_04_28_19_32_08_376.gif" alt="录制_2022_04_28_19_32_08_376"></p>
<p>上面的案例是2个Dynamic类型的物体, 相互间是Block的, 而且开启了Hit事件, 那么为什么没有收到Hit消息?</p>
<p>Hit事件的触发需要参与碰撞的2者中的任意一者开启了物理模拟效果, 当然角色是个例外, 角色的胶囊体也能触发Hit事件</p>
<hr>
<p>如果是Overlap呢?</p>
<p>我们测试的2个对象改成相互Overlap</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_04_28_19_41_40_56.gif" alt="录制_2022_04_28_19_41_40_56"></p>
<p>在这个情况下, 即使我们开启了接受Hit事件同时开了物理, Hit事件也是没有触发的. 然后两个对象都有BeginOverlap和EndOverlap事件</p>
<a name = "Trace">

<h2 id="射线通道和射线检测"><a href="#射线通道和射线检测" class="headerlink" title="射线通道和射线检测"></a>射线通道和射线检测</h2><p>在上面也说到 碰撞类型和这个TraceChannel加起来一共能自定义11个, 那么这个TraceChannel又是什么? </p>
<p>这个Trace很容易造成一定歧义,很多新手同学会想当然的理解这个就是射线检测的类型, 这句话也对也不对,  这个确实是为射线准备的, 但是射线检测又不只是用这个TraceChannel.</p>
<p>对于射线检测, 如果简单直白的讲, <strong>可以把TraceChannel和ObjectChannel理解为2个维度</strong></p>
<p>下面用2个简单案例解释</p>
<p><img src="https://img.supervj.top/imgimage-20220428195223269.png" alt="image-20220428195223269"></p>
<p>先设定3个碰撞类型, 正方形,菱形和梯形</p>
<p>2个射线通道 四边形和平行四边形</p>
<p>设定3个预设, 已梯形举例</p>
<p><img src="https://img.supervj.top/imgimage-20220428200120426.png" alt="image-20220428200120426"></p>
<blockquote>
<p>射线检测只接受Block</p>
<p><strong>Overlap基本等价于Ignore</strong></p>
</blockquote>
<p>显而易见, 梯形是四边形但是不是平行四边形, 正方形和菱形都是四边形和平行四边形</p>
<p>所以我们把梯形的预设里面对平行四边形设置成Ignore, 对四边形设置成Block</p>
<p><img src="https://img.supervj.top/imgimage-20220428195455248.png" alt="image-20220428195455248"></p>
<p>我们选择通道<code>平行四边形</code>来查询</p>
<p><img src="https://img.supervj.top/imgimage-20220428200214222.png" alt="image-20220428200214222"></p>
<p>结果显而易见如上图所示, 射线打到了第一个对<code>平行四边形</code>Block的菱形</p>
<hr>
<p>再来一个案例</p>
<p><img src="https://img.supervj.top/imgimage-20220428200937006.png" alt="image-20220428200937006"></p>
<p>如图中, 设置5个碰撞类型对应5种动物</p>
<p>3个射线通道对应的是另外的3种维度</p>
<p><img src="https://img.supervj.top/imgimage-20220428201302154.png" alt="image-20220428201302154"></p>
<p>我们还是用一样的方式查询<code>四足动物</code></p>
<p><img src="https://img.supervj.top/imgimage-20220428201331131.png" alt="image-20220428201331131"></p>
<p>同学肯定会有疑问了, 猫不是四足动物吗? </p>
<p>因为我们调用射线API的时候勾选了 bTraceComplex(细节请看下面<a href="#Complex">简单和复杂碰撞</a>), 射线从猫的脚中间穿了过去</p>
<p>如果勾选了简单碰撞, 我们再结合看猫的简单碰撞, 结果就正确了</p>
<p><img src="https://img.supervj.top/imgimage-20220428202422956.png" alt="image-20220428202422956"></p>
<p><img src="https://img.supervj.top/imgimage-20220428202437498.png" alt="image-20220428202437498"></p>
<p>如果是查询爬行动物呢?</p>
<p>直接上结果</p>
<p><img src="https://img.supervj.top/imgimage-20220428202646484.png" alt="image-20220428202646484"></p>
<p>下一个问题, 如果我们不想射线打到前面的动物, 直接想打鲸鱼, 但是通过TraceChannel我们没法避开其他动物直接打到鲸鱼</p>
<p>这就要用到我们另外一种射线查询方式了, 也就是通过另外一种维度来查询</p>
<p><img src="https://img.supervj.top/imgimage-20220428202840311.png" alt="image-20220428202840311"></p>
<p>如上图, 我们就指定射线只查询碰撞类型:<code>鲸鱼</code></p>
<p><img src="https://img.supervj.top/imgimage-20220428204153309.png" alt="image-20220428204153309"></p>
<p>另外, 这个通过ObjectType来查询的,  这个类型可以是数组, 我们可以用下图这种方式来同时查询多个碰撞类型</p>
<p><img src="https://img.supervj.top/imgimage-20220428204301667.png" alt="image-20220428204301667"></p>
<a name = "Complex">

<h2 id="简单碰撞和复杂碰撞"><a href="#简单碰撞和复杂碰撞" class="headerlink" title="简单碰撞和复杂碰撞"></a>简单碰撞和复杂碰撞</h2><p>前面对猫进行射线的时候已经遇到了这个问题, 那么什么是简单碰撞, 什么是复杂碰撞呢?</p>
<p>这个要进入模型碰撞编辑页面</p>
<p><img src="https://img.supervj.top/imgimage-20220428205030072.png" alt="image-20220428205030072"></p>
<p>上图红色框内的选项生成的都是简单碰撞, 复杂碰撞就是我们模型本身的多边形组成的形体(图中浅蓝色)</p>
<p>在右侧编辑栏有一个选项</p>
<p><img src="https://img.supervj.top/imgimage-20220428205154803.png" alt="image-20220428205154803"></p>
<p>一般保持默认或者<strong>SimpleAndComplex</strong>(简单和复杂共存)</p>
<blockquote>
<p><strong>简单和复杂碰撞是可以共存的!!!!!!</strong></p>
</blockquote>
<a name = "CollisionEdit">

<h2 id="碰撞编辑"><a href="#碰撞编辑" class="headerlink" title="碰撞编辑"></a>碰撞编辑</h2><p><img src="https://img.supervj.top/imgimage-20220429102921726.png" alt="image-20220429102921726"></p>
<p>静态模型在导入的时候会有选项是否自动生成碰撞, 自动生成的碰撞对于一般的规则物体还凑合, 但是如果是遇到下图的这种就比较尴尬了</p>
<p><img src="https://img.supervj.top/imgimage-20220429103053221.png" alt="image-20220429103053221"></p>
<p>UE静态物体的编辑界面可以直接像控制碰撞体做移动/旋转/缩放编辑, 但是<strong>不能调整点线面</strong></p>
<p>可以添加多个, 所以如果有必要也可以放进去很多个Box慢慢的调整</p>
<p>也可以通过引擎的几种不同算法生成碰撞体, 如下图</p>
<p><img src="https://img.supervj.top/imgimage-20220429103505419.png" alt="image-20220429103505419"></p>
<p>可以视情况尝试, 但是对于我们这个模型这里都不能提供较为满意的结果</p>
<p>这种情况可以打开ConvexDecomposition工具(默认关闭)</p>
<p><img src="https://img.supervj.top/imgimage-20220429103541568.png" alt="image-20220429103541568"></p>
<p><img src="https://img.supervj.top/imgimage-20220429103617906.png" alt="image-20220429103617906"></p>
<p>用默认参数点击Apply, 效果如下图, 已经不错了</p>
<p><img src="https://img.supervj.top/imgimage-20220429103718821.png" alt="image-20220429103718821"></p>
<p>如果把参数拉满, 则是下图的结果</p>
<p><img src="https://img.supervj.top/imgimage-20220429103754227.png" alt="image-20220429103754227"></p>
<ul>
<li>外部软件的碰撞编辑</li>
</ul>
<p>碰撞体也可以在外部的美术软件中编辑好以后导入到UE, 只需要遵循一个命名规范即可</p>
<p><img src="https://img.supervj.top/imgimage-20220429110401447.png" alt="image-20220429110401447"></p>
<p>用Box堆起来的碰撞体,  命名用 <code>UCX_模型名字_序号</code> 这种形式</p>
<p>导入UE的时候要去掉自动生成碰撞, 导进来以后就生成的跟maya中一样的碰撞</p>
<p><img src="https://img.supervj.top/imgimage-20220429110510189.png" alt="image-20220429110510189"></p>
<p>这种方式的优势也是有的, 毕竟在maya中编辑模型比UE中是要容易的多</p>
<a name = "Sweap">

<h2 id="Sweap和其他射线检测-美术同学请跳过"><a href="#Sweap和其他射线检测-美术同学请跳过" class="headerlink" title="Sweap和其他射线检测(美术同学请跳过)"></a>Sweap和其他射线检测(美术同学请跳过)</h2><p>前面的射线检测都是用Line的形式, UE其实封装了很多种类型的射线检测方式</p>
<p>搜索Trace可以看到下图中的检测方式</p>
<p><img src="https://img.supervj.top/imgimage-20220429111256427.png" alt="image-20220429111256427"></p>
<p>cpp中都放在<code>UKismetSystemLibrary</code>中</p>
<p>可以看到不仅只有通道的选择, 还有各种形状的区别</p>
<p>这里要看一下源码</p>
<p>以LineTrace举例,  蓝图的<code>LineTraceByChannel</code>在cpp中其实叫 <code>LineTraceSingle</code>,   <code>LineTraceForObjects</code>叫<code>LineTraceSingleForObjects</code></p>
<p>两者的实现如下</p>
<p><img src="https://img.supervj.top/imgimage-20220429113225626.png" alt="image-20220429113225626"></p>
<p><img src="https://img.supervj.top/imgimage-20220429112320036.png" alt="image-20220429112320036"></p>
<p>通过UWorld的中间层接口, 最终调用的都是物理层的接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FGenericPhysicsInterface::RaycastSingle</span><span class="params">(<span class="keyword">const</span> UWorld* World, struct FHitResult&amp; OutHit, <span class="keyword">const</span> FVector Start, <span class="keyword">const</span> FVector End, ECollisionChannel TraceChannel, <span class="keyword">const</span> struct FCollisionQueryParams&amp; Params, <span class="keyword">const</span> struct FCollisionResponseParams&amp; ResponseParams, <span class="keyword">const</span> struct FCollisionObjectQueryParams&amp; ObjectParams)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以如果你熟悉UWorld的接口, 也可以自己构造这些参数, 直接用UWorld的接口也是可以的, 好不好用另说, 理论上可以支持同时支持TraceChannel和ObjectChannel的查询, 自己封装即可</p>
<blockquote>
<p>使用起来还是Kismet的直观, 也方便</p>
</blockquote>
<hr>
<p>再看各种带形状的Trace</p>
<p>都是构造好一个定义形状的数据结构<code>FCollisionShape</code>, 然后调用<code> UWorld::SweepSingleByChannel()</code>来做Sweap查询的</p>
<hr>
<ul>
<li>关于Multi和Single</li>
</ul>
<p>Multi即字面意思多重, 查询会返回所有检测范围内的数据</p>
<h3 id="Overlap检测"><a href="#Overlap检测" class="headerlink" title="Overlap检测"></a>Overlap检测</h3><p><img src="https://img.supervj.top/imgimage-20220429151938533.png" alt="image-20220429151938533"></p>
<p>我们看物理层的接口就可以看到, 除了上面的射线和带形状的Sweap检测, 实际上还有一种Overlap检测, 到上层接口就是下图</p>
<p><img src="https://img.supervj.top/imgimage-20220429152037605.png" alt="image-20220429152037605"></p>
<p>顾名思义, 用Box的形状就检测这个空间的Actor或Components, 这个在做一些空间检查的时候还是蛮有用的</p>
<h3 id="鼠标和触摸射线"><a href="#鼠标和触摸射线" class="headerlink" title="鼠标和触摸射线"></a>鼠标和触摸射线</h3><p><img src="https://img.supervj.top/imgimage-20220505112004536.png" alt="image-20220505112004536"></p>
<p>如上图, 鼠标和手指触摸直接有封装好的API</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><img src="https://img.supervj.top/imgimage-20220429152205828.png" alt="image-20220429152205828"></p>
<p>其实SetLocation本质上也给物体一个速度做瞬间偏移, 这个也可以打开Sweap检查, 也能收到</p>
<p><img src="https://img.supervj.top/imgimage-20220429152540682.png" alt="image-20220429152540682"></p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2022_04_29_15_26_19_341.gif" alt="录制_2022_04_29_15_26_19_341"></p>
<hr>
<a name = "Custom">

<h2 id="关于Custom"><a href="#关于Custom" class="headerlink" title="关于Custom"></a>关于Custom</h2><p>对于场景中的对象的碰撞类型是可以使用<code>Custom</code>来自定义碰撞类型和响应等, 此举一般情况下是解决一些特殊的对象的碰撞检测, 实际情况一般还是推荐使用预设</p>
<p><img src="https://img.supervj.top/imgimage-20220505144414298.png" alt="image-20220505144414298"></p>
]]></content>
      <categories>
        <category>physics</category>
      </categories>
      <tags>
        <tag>物理</tag>
        <tag>碰撞</tag>
        <tag>检测</tag>
      </tags>
  </entry>
  <entry>
    <title>角色移动随笔</title>
    <url>/2022/02/25/%E7%A7%BB%E5%8A%A8%E7%BB%84%E4%BB%B6%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>角色移动相关的林林总总</p>
<p><strong>QA</strong></p>
<ul>
<li>Q: 角色移动来自哪里</li>
<li>A: <ul>
<li>按键输入</li>
<li><a href="#Force">物理力(Force) </a></li>
<li><a href="#Launch">Launch</a></li>
<li><a href="#ARM">动画RootMotion</a></li>
<li><a href="#RMS">RootMotionSource</a></li>
<li><a href="#RequestVelocity">RequestVelocity</a></li>
<li>Gravity</li>
</ul>
</li>
</ul>
<ul>
<li>Q: 角色的Z方向是速度是哪里处理的?</li>
<li>A: <a href="#MaintainHorizontalGroundVelocity">MaintainHorizontalGroundVelocity</a>, 而且不止调用了一次;  Z速度比较复杂, 地面移动的Z速度不能通过重写这个函数来找回</li>
</ul>
<ul>
<li>Q:刹车是怎么处理的</li>
<li>A:<a href="#%E5%88%B6%E5%8A%A8">刹车/制动</a></li>
</ul>
<ul>
<li>Q:怎么判断角色处于Falling</li>
<li>A:<a href="#CheckInAir">空中判断</a></li>
</ul>
<ul>
<li>Q:怎么处理角色处于边缘的情况</li>
<li>A:<a href="#%E8%BE%B9%E7%BC%98%E6%A3%80%E6%9F%A5">14.1.9 边缘检查</a></li>
</ul>
<ul>
<li>Q:速度和加速度是哪里 计算的</li>
<li>A:<a href="#CalcVelocity">14.1.3 CalcVelocity</a></li>
</ul>
<ul>
<li>Q:有没有处理撞墙(Hit)事件的逻辑</li>
<li>A:相比于监听Capsule的Hit回调事件, 移动逻辑里有一部分相关代码也是类似情形, 大致在<a href="#Hit">这里</a></li>
</ul>
<span id="more"></span>







<h2 id="PerformMovement"><a href="#PerformMovement" class="headerlink" title="PerformMovement"></a>PerformMovement</h2><p>角色移动的核心就是这里, 从这里展开</p>
<h3 id="1-清理过期数据"><a href="#1-清理过期数据" class="headerlink" title="1.清理过期数据"></a>1.清理过期数据</h3><p><img src="https://img.supervj.top/imgimage-20220428150346256.png" alt="image-20220428150346256"></p>
<p>这个阶段判断是否<strong>处于不能移动或者物理状态</strong>, 如果是那么清理</p>
<p>如果条件允许同时处于RootMotion状态, 那么Tick一次Pose然后清理<code>RootMotionParams</code></p>
<p>如果有激活的RootMotionSource(下简称RMS), 那么清理RMS数据</p>
<p>清理Force</p>
<h3 id="2-处理RMS的LastPreAdditiveVelocity"><a href="#2-处理RMS的LastPreAdditiveVelocity" class="headerlink" title="2.处理RMS的LastPreAdditiveVelocity"></a>2.处理RMS的LastPreAdditiveVelocity</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FVector Adjustment = (Velocity - LastUpdateVelocity);</span><br><span class="line">CurrentRootMotion.LastPreAdditiveVelocity += Adjustment;</span><br></pre></td></tr></table></figure>

<p>根据当前速度与上一帧的Velocity差, 补偿到LastPreAdditiveVelocity</p>
<h3 id="3-MaybeUpdateBasedMovement"><a href="#3-MaybeUpdateBasedMovement" class="headerlink" title="3.MaybeUpdateBasedMovement"></a>3.MaybeUpdateBasedMovement</h3><p>这里主要处理了如果角色站在了<strong>动态地面</strong>(即Moveable的模型)上的变化, 不过角色的速度不会得加动态物体的速度</p>
<h3 id="4-清理过期RMS"><a href="#4-清理过期RMS" class="headerlink" title="4.清理过期RMS"></a>4.清理过期RMS</h3><p><img src="https://img.supervj.top/imgimage-20220428150414316.png" alt="image-20220428150414316"></p>
<p>过期的RMS即被标记为<code>MarkedForRemoval</code>或者<code>Finished</code>的RMS, 在这一步清理掉</p>
<a name = "Force">

<h3 id="5-应用力"><a href="#5-应用力" class="headerlink" title="5.应用力"></a>5.应用力</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ApplyAccumulatedForces</span>(DeltaSeconds);</span><br></pre></td></tr></table></figure>

<p>我们对角色调用的AddImpulse等接口添加的力在这一步被换算成Velocity</p>
<p>如果有Z速度, Mode可能会被设置成Falling</p>
<h3 id="6-UpdateCharacterStateBeforeMovement"><a href="#6-UpdateCharacterStateBeforeMovement" class="headerlink" title="6.UpdateCharacterStateBeforeMovement"></a>6.UpdateCharacterStateBeforeMovement</h3><p>这里刷新一次Crouch/Uncrouch状态</p>
<h3 id="7-TryToLeaveNavWalking"><a href="#7-TryToLeaveNavWalking" class="headerlink" title="7.TryToLeaveNavWalking"></a>7.TryToLeaveNavWalking</h3><p>如果是<code>MOVE_NavWalking</code>, 这里尝试离开这个状态</p>
<a name = "Launch">

<h3 id="8-HandlePendingLaunch"><a href="#8-HandlePendingLaunch" class="headerlink" title="8.HandlePendingLaunch"></a>8.HandlePendingLaunch</h3><p>处理LaunchCharacter产生的推力, 把推力换算成Velocity,  <strong>这里一定会把Mode改成Falling</strong></p>
<h3 id="9-清理所有力"><a href="#9-清理所有力" class="headerlink" title="9.清理所有力"></a>9.清理所有力</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ClearAccumulatedForces</span>();</span><br></pre></td></tr></table></figure>

<p>清理第5和第8步的力</p>
<h3 id="10-再次处理RMS的LastPreAdditiveVelocity"><a href="#10-再次处理RMS的LastPreAdditiveVelocity" class="headerlink" title="10.再次处理RMS的LastPreAdditiveVelocity"></a>10.再次处理RMS的LastPreAdditiveVelocity</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FVector Adjustment = (Velocity - OldVelocity);</span><br><span class="line">CurrentRootMotion.LastPreAdditiveVelocity += Adjustment;</span><br></pre></td></tr></table></figure>

<p>因为上面几步与第2步之间有力的作用, 所以这里通过前后Velocity的变化, 把这个插值记录到<code>LastPreAdditiveVelocity</code>中</p>
<h3 id="11-预处理RootMotion"><a href="#11-预处理RootMotion" class="headerlink" title="11.预处理RootMotion"></a>11.预处理RootMotion</h3><p><img src="https://img.supervj.top/imgimage-20220425150948103.png" alt="image-20220425150948103"></p>
<p>这里预处理了两种RootMotion, 包括动画RootMotion(下简称ARM)和RMS</p>
<p>如果是动画RootMotion, 那么这里会<code>TickCharacterPose(DeltaSeconds);</code>, 这个会产生RootMotion数据<code>RootMotionParams</code>,然后保存客户端的<code>ClientRootMotionParams</code></p>
<p>如果是RMS, 这里会执行<code>CurrentRootMotion.PrepareRootMotion()</code>, 这个函数就是通过各种不同的RMS算法把速度记录到<code>RootMotionParams</code></p>
<h3 id="12-处理RootMotion"><a href="#12-处理RootMotion" class="headerlink" title="12.处理RootMotion"></a>12.处理RootMotion</h3><p>同11步, 同样处理了两者</p>
<a name = "ARM">

<h4 id="12-1-ARM"><a href="#12-1-ARM" class="headerlink" title="12.1 ARM"></a>12.1 ARM</h4><p><img src="https://img.supervj.top/imgimage-20220425151154463.png" alt="image-20220425151154463"></p>
<p>TickPose产生的RootMotionParams转换成世界空间, , 然后转化成Velocity</p>
<blockquote>
<p>UE5插件<code>MotionWarping</code>监听的就是ConvertLocalRootMotionToWorld()当中的事件</p>
</blockquote>
<p>我们知道, 如果保持正常的移动Mode, ARM的Z速度经常是没有的, 但是这里的Velocity还是有Z速度的, Z速度会在后面被处理掉</p>
<h5 id="12-1-1-CalcAnimRootMotionVelocity"><a href="#12-1-1-CalcAnimRootMotionVelocity" class="headerlink" title="12.1.1 CalcAnimRootMotionVelocity"></a>12.1.1 CalcAnimRootMotionVelocity</h5><p><img src="https://img.supervj.top/imgimage-20220426104001900.png" alt="image-20220426104001900"></p>
<p>把RootMotionParams中的偏移转换成速度</p>
<h5 id="12-1-2-ConstrainAnimRootMotionVelocity"><a href="#12-1-2-ConstrainAnimRootMotionVelocity" class="headerlink" title="12.1.2 ConstrainAnimRootMotionVelocity"></a>12.1.2 ConstrainAnimRootMotionVelocity</h5><p><img src="https://img.supervj.top/imgimage-20220426104048929.png" alt="image-20220426104048929"></p>
<p>如果处于Falling 那么速度用的是本身的速度, RootMotion中的Z速度会被替换</p>
<a name = "RMS">

<h4 id="12-2-RMS"><a href="#12-2-RMS" class="headerlink" title="12.2 RMS"></a>12.2 RMS</h4><p><img src="https://img.supervj.top/imgimage-20220425151702742.png" alt="image-20220425151702742"></p>
<p>这一步就是把把RMS中的数据换算成Velocity</p>
<h3 id="13-清理Jump输入"><a href="#13-清理Jump输入" class="headerlink" title="13.清理Jump输入"></a>13.清理Jump输入</h3><p><img src="https://img.supervj.top/imgimage-20220425152534520.png" alt="image-20220425152534520"></p>
<p>Jump是可以有HoldTime的, 这里就是处理这个</p>
<h3 id="14-StartNewPhysics"><a href="#14-StartNewPhysics" class="headerlink" title="14.StartNewPhysics *"></a>14.<strong>StartNewPhysics</strong> *</h3><p>这里内容非常庞大, 也是移动输入的核心场所, 分条展开</p>
<h4 id="14-1-PhysWalking"><a href="#14-1-PhysWalking" class="headerlink" title="14.1 PhysWalking *"></a>14.1 PhysWalking *</h4><p>正常的地面移动都在这里处理</p>
<h5 id="14-1-1-RestorePreAdditiveRootMotionVelocity"><a href="#14-1-1-RestorePreAdditiveRootMotionVelocity" class="headerlink" title="14.1.1 RestorePreAdditiveRootMotionVelocity"></a>14.1.1 RestorePreAdditiveRootMotionVelocity</h5><p>如果RMS有有叠加的, 那么这一步会把第2和10步处理的LastPreAdditiveVelocity设置成Velocity</p>
<a name = "MaintainHorizontalGroundVelocity">

<h5 id="14-1-2-MaintainHorizontalGroundVelocity"><a href="#14-1-2-MaintainHorizontalGroundVelocity" class="headerlink" title="14.1.2 MaintainHorizontalGroundVelocity"></a>14.1.2 MaintainHorizontalGroundVelocity</h5><p><img src="https://img.supervj.top/imgimage-20220425155829483.png" alt="image-20220425155829483"></p>
<p>两种方式, 要么单纯把Z速度变成0但是总速度大小会变(其实后面还会补上来), 要么总速度大小不变的情况下把Z速度去掉</p>
<blockquote>
<p>其实这一步本质上区别不大</p>
</blockquote>
<a name = "CalcVelocity">

<h5 id="14-1-3-CalcVelocity"><a href="#14-1-3-CalcVelocity" class="headerlink" title="14.1.3 CalcVelocity *"></a>14.1.3 CalcVelocity *</h5><p>这个函数非常重要,  核心的速度计算都在这里.</p>
<p>进入这里有几个条件, 需要不是ARM或者RMS状态</p>
<h6 id="14-1-3-1-计算RequestedMove"><a href="#14-1-3-1-计算RequestedMove" class="headerlink" title="14.1.3.1 计算RequestedMove"></a>14.1.3.1 计算RequestedMove</h6><p><img src="https://img.supervj.top/imgimage-20220425160159695.png" alt="image-20220425160159695"></p>
<p>先计算Requested速度, 这个是一个比较特殊的速度, 是作为额外一个叠加速度存在的, 通过下面2个UCharacterMovementComponent的接口设置(目前未暴露给蓝图)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RequestDirectMove</span><span class="params">(<span class="keyword">const</span> FVector&amp; MoveVelocity, <span class="keyword">bool</span> bForceMaxSpeed)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RequestPathMove</span><span class="params">(<span class="keyword">const</span> FVector&amp; MoveInput)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top/imgimage-20220425160850994.png" alt="image-20220425160850994"></p>
<p>上图中有个需要注意的开关<strong>bRequestedMoveUseAcceleration</strong>, 这个在蓝图中是可编辑的</p>
<p>如果true那么之类会计算出来一个加速度, 等后续的时候加到速度上去, 否则就直接会把当前速度替换成RequestedVelocity</p>
<p>另外的细节可以看[RequestVelocity](#Request Velocity)</p>
<h6 id="14-1-3-2-处理加速度"><a href="#14-1-3-2-处理加速度" class="headerlink" title="14.1.3.2 处理加速度"></a>14.1.3.2 处理加速度</h6><p>如果bForceMaxAccel为true, 那么在这里会把加速度大小强制设置成最大的</p>
<h6 id="14-1-3-3-制动流程"><a href="#14-1-3-3-制动流程" class="headerlink" title="14.1.3.3 制动流程"></a>14.1.3.3 制动流程</h6><p>这里会有几个判断,  制动流程的进入条件是<code>(bZeroAcceleration &amp;&amp; bZeroRequestedAcceleration) || bVelocityOverMax</code></p>
<p>翻译一下是 没有加速度同时没有Requested速度, 或者是当前速度大于了最大速度. 后者比较容易被忽略</p>
<p>制动流程可以看↑<a href="#%E5%88%B6%E5%8A%A8">制动流程</a></p>
<p>然后如果速度还是大于最大速度, 这里有个保护, 这里把速度大小设置成最大速度</p>
<h6 id="14-1-3-4-阻力对速度的影响"><a href="#14-1-3-4-阻力对速度的影响" class="headerlink" title="14.1.3.4 阻力对速度的影响"></a>14.1.3.4 阻力对速度的影响</h6><p><img src="https://img.supervj.top/imgimage-20220425210056186.png" alt="image-20220425210056186"></p>
<p>阻力参数<code>Friction</code>(需要区别BrakingFriction)对由加速度造成的速度变化是有影响的,  阻力越大, 加速和切换方向会慢</p>
<h6 id="14-1-3-5-流体对加速的影响"><a href="#14-1-3-5-流体对加速的影响" class="headerlink" title="14.1.3.5 流体对加速的影响"></a>14.1.3.5 流体对加速的影响</h6><p><img src="https://img.supervj.top/imgimage-20220426102131633.png" alt="image-20220426102131633"></p>
<p>然后是处理流体速度的影响</p>
<h6 id="14-1-3-6-输入对速度的加速"><a href="#14-1-3-6-输入对速度的加速" class="headerlink" title="14.1.3.6 输入对速度的加速"></a>14.1.3.6 输入对速度的加速</h6><p><img src="https://img.supervj.top/imgimage-20220426102953748.png" alt="image-20220426102953748"></p>
<p>如果有按键输入, 那么这里通过加速度对速度进行加速</p>
<h6 id="14-1-3-7-处理Requested速度"><a href="#14-1-3-7-处理Requested速度" class="headerlink" title="14.1.3.7 处理Requested速度"></a>14.1.3.7 处理Requested速度</h6><p><img src="https://img.supervj.top/imgimage-20220426103052807.png" alt="image-20220426103052807"></p>
<p>然后是处理前面产生的Request速度, 如果<code>bRequestedMoveUseAcceleration</code>为true, 那么这里会对速度进行一个增量, 如果为false, 那么这里可以忽略</p>
<h6 id="14-1-3-8-处理RVO"><a href="#14-1-3-8-处理RVO" class="headerlink" title="14.1.3.8 处理RVO"></a>14.1.3.8 处理RVO</h6><p>涉及到RVO的内容比较多, 这里先不展开</p>
<h5 id="14-1-4-ApplyRootMotionToVelocity"><a href="#14-1-4-ApplyRootMotionToVelocity" class="headerlink" title="14.1.4 ApplyRootMotionToVelocity"></a>14.1.4 ApplyRootMotionToVelocity</h5><p>这个函数的字面意思跟实际用途略有差别, 这里主要处理的是RootMotion(包含ARM和RMS)+Falling状态下的DecayingFormerBaseVelocity的处理</p>
<p>DecayingFormerBaseVelocity会在站在动态地面上时才会有变换的速度值</p>
<h5 id="14-1-5-处理如果是Fallinig"><a href="#14-1-5-处理如果是Fallinig" class="headerlink" title="14.1.5 处理如果是Fallinig"></a>14.1.5 处理如果是Fallinig</h5><p><img src="https://img.supervj.top/imgimage-20220426105204619.png" alt="image-20220426105204619"></p>
<p>这一步如果是Falling了, 那么重新执行<code>StartNewPhysics()</code></p>
<h5 id="14-1-6-MoveAlongFloor"><a href="#14-1-6-MoveAlongFloor" class="headerlink" title="14.1.6 MoveAlongFloor *"></a>14.1.6 MoveAlongFloor *</h5><p>在地面上的移动处理, 这个函数也比较庞大, 返回一个脚步数据<code>FStepDownResult</code>, 这个数据包含了我们经常用的<code>CurrentFloor</code></p>
<h6 id="14-1-6-1-ComputeGroundMovementDelta"><a href="#14-1-6-1-ComputeGroundMovementDelta" class="headerlink" title="14.1.6.1 ComputeGroundMovementDelta"></a>14.1.6.1 ComputeGroundMovementDelta</h6><p><img src="https://img.supervj.top/imgimage-20220426114218973.png" alt="image-20220426114218973"></p>
<p>这里处理的是斜坡上的速度, 传入的Delta是水平速度, 经过Dot计算得到了Z的速度, 这里也有<code>bMaintainHorizontalGroundVelocity</code>的判断, 但是返回值都是带Z速度的(目的是什么?)</p>
<h6 id="14-1-6-2-SafeMoveUpdatedComponent"><a href="#14-1-6-2-SafeMoveUpdatedComponent" class="headerlink" title="14.1.6.2 SafeMoveUpdatedComponent"></a>14.1.6.2 SafeMoveUpdatedComponent</h6><p>这个函数在很多地方都会调用, CharacterMovementComponent没有重写任何东西, 核心内容在<code>UPrimitiveComponent::MoveComponentImpl()</code>中</p>
<p>里面一大堆的数据初始化, 最核心的就是下面这里</p>
<p><img src="https://img.supervj.top/imgimage-20220426143535492.png" alt="image-20220426143535492"></p>
<p>之后就是调用物理接口了</p>
<p>所以就是利用前面算出来的delta速度, 对capsule进行一个短距离的Multi的Sweap操作,获取了Hit数据, 如果有必要就移动</p>
<p>如果bStartPenetrating(出生点跟其他物体有重叠/穿透), 那么会需要解决穿透问题, 这个就是角色如果出生在模型内然后被挤出模型的操作,  如果要特化这个操作可以重写<code>ResolvePenetrationImpl()</code></p>
<h6 id="14-1-6-3-处理穿透"><a href="#14-1-6-3-处理穿透" class="headerlink" title="14.1.6.3 处理穿透"></a>14.1.6.3 处理穿透</h6><p><img src="https://img.supervj.top/imgimage-20220426151944767.png" alt="image-20220426151944767"></p>
<p>如果出生的时候与其他物体有穿透, 那么其实前面的<code>SafeMoveUpdatedComponent()</code>已经处理了这个问题, 一般走不进这里, 感觉这个是做了一层保护, 因为前面的<code>SafeMoveUpdatedComponent</code>是可以重写的</p>
<a name = "Hit">

<h6 id="14-1-6-4-处理Hit事件"><a href="#14-1-6-4-处理Hit事件" class="headerlink" title="14.1.6.4 处理Hit事件"></a>14.1.6.4 处理Hit事件</h6><p><img src="https://img.supervj.top/imgimage-20220426161939931.png" alt="image-20220426161939931"></p>
<p>撞墙和撞台阶都会走到这里, 需要判定是否能上台阶</p>
<p>bMaintainHorizontalGroundVelocity在这里又发挥了奇怪的作用, 在判断是否可以StepUp的过程中有查询地面数据, 该数据包含在<code>FStepDownResult</code>中</p>
<h5 id="14-1-7-再次处理Falling-Swimming"><a href="#14-1-7-再次处理Falling-Swimming" class="headerlink" title="14.1.7 再次处理Falling/Swimming"></a>14.1.7 再次处理Falling/Swimming</h5><p>同14.1.5一样的处理, 经过上一步的处理以后如果进入了这两个状态, 那么就切换</p>
<h5 id="14-1-8-记录或者查询Floor"><a href="#14-1-8-记录或者查询Floor" class="headerlink" title="14.1.8 记录或者查询Floor"></a>14.1.8 记录或者查询Floor</h5><p><img src="https://img.supervj.top/imgimage-20220426163301687.png" alt="image-20220426163301687"></p>
<p>如果有step查询, 那么这里就已经有了floor数据, 否则就要通过FindFloor查询floor数据</p>
<h6 id="14-1-8-1-FindFloor"><a href="#14-1-8-1-FindFloor" class="headerlink" title="14.1.8.1 FindFloor"></a>14.1.8.1 FindFloor</h6><p>这里通过了一个Sweap操作获取地面数据, 主要计算在<code>ComputeFloorDist()</code>中, 大部分内容可以看<a href="#CheckInAir">是否在空中判断</a></p>
<a name = "边缘检查">

<h5 id="14-1-9-边缘检查"><a href="#14-1-9-边缘检查" class="headerlink" title="14.1.9 边缘检查"></a>14.1.9 边缘检查</h5><p><img src="https://img.supervj.top/imgimage-20220426164227611.png" alt="image-20220426164227611"></p>
<p>移动组件有这么两个参数, 如果false, 那么角色不能从边缘通过走路掉下去(可以通过Jump)</p>
<p><img src="https://img.supervj.top/imgimage-20220426164321195.png" alt="image-20220426164321195"></p>
<p>这里就限制了角色下落</p>
<p>如果可以下落, 那么接下来就是适配角色的高度, 因为角色的胶囊体底部是圆形的, 所以默认的就是保持胶囊体底部跟地面是接触的, 在边缘会出现这样的情况</p>
<p><img src="https://img.supervj.top/imgimage-20220426164600831.png" alt="image-20220426164600831"></p>
<p>如果要自定义这个效果, 可以重写<code>ShouldCatchAir()</code>(这个默认直接false)和<code>HandleWalkingOffLedge()</code>做处理, 也可以重写<code>AdjustFloorHeight()</code>进行补充</p>
<h6 id="14-1-9-1-Swimming检查"><a href="#14-1-9-1-Swimming检查" class="headerlink" title="14.1.9.1 Swimming检查"></a>14.1.9.1 Swimming检查</h6><p><img src="https://img.supervj.top/imgimage-20220426165041282.png" alt="image-20220426165041282"></p>
<p>可能到这一步从边缘掉进水里, 就进入Swimming逻辑</p>
<h6 id="14-1-9-2-进入Falling"><a href="#14-1-9-2-进入Falling" class="headerlink" title="14.1.9.2 进入Falling"></a>14.1.9.2 进入Falling</h6><p>正常情况, 到这一步就进入了Falling, 然后直接return</p>
<h5 id="14-1-10-最后处理地面速度"><a href="#14-1-10-最后处理地面速度" class="headerlink" title="14.1.10 最后处理地面速度"></a>14.1.10 最后处理地面速度</h5><p><img src="https://img.supervj.top/imgimage-20220426165449693.png" alt="image-20220426165449693"></p>
<p>到这里如果在地面上, 那么通过这时候的组件的位置与<code>PhysWalking</code>刚开始的位置偏差计算得到最终的Velocity</p>
<blockquote>
<p>如果撞墙了, 那么这里的速度只有墙面切向方向的速度, 而且大小没有变化</p>
<p>比如Velocity(100,20,0)撞到了切线是Y方向的墙面, 这里的速度是Velocity(0,20,0)</p>
</blockquote>
<h3 id="15-UpdateCharacterStateAfterMovement"><a href="#15-UpdateCharacterStateAfterMovement" class="headerlink" title="15.UpdateCharacterStateAfterMovement"></a>15.UpdateCharacterStateAfterMovement</h3><p>参考第6步, 也是更新了Crouch状态</p>
<h3 id="16-PhysicsRotation"><a href="#16-PhysicsRotation" class="headerlink" title="16.PhysicsRotation"></a>16.PhysicsRotation</h3><p>这里有几个前提</p>
<ol>
<li><code>bAllowPhysicsRotationDuringAnimRootMotion</code>(默认关闭)或处于非RootMotion</li>
<li>需要开启bOrientRotationToMovement, 同时关闭bUseControllerDesiredRotation</li>
</ol>
<p>其实就是小白人默认的移动模式就可以走到这里, 角色永远会面朝速度方向, 你转动镜头的时候角色通过一定速度转向速度方向</p>
<h3 id="17-处理RootMotion的旋转"><a href="#17-处理RootMotion的旋转" class="headerlink" title="17.处理RootMotion的旋转"></a>17.处理RootMotion的旋转</h3><p><img src="https://img.supervj.top/imgimage-20220425153635384.png" alt="image-20220425153635384"></p>
<p>前面第12步处理了ARM和RMS的Velocity, 这一步单独处理两者的旋转</p>
<blockquote>
<p>发出疑问, 所以RMS是可以有旋转的, 虽然引擎自带的API和案例没有进行这个计算</p>
</blockquote>
<h3 id="18-OnMovementUpdated"><a href="#18-OnMovementUpdated" class="headerlink" title="18.OnMovementUpdated"></a>18.OnMovementUpdated</h3><p>虚函数, 无实现, 到这一步需要处理的事情可以重写这个函数实现</p>
<h3 id="19-CallMovementUpdateDelegate"><a href="#19-CallMovementUpdateDelegate" class="headerlink" title="19.CallMovementUpdateDelegate"></a>19.CallMovementUpdateDelegate</h3><p><img src="https://img.supervj.top/imgimage-20220425153810696.png" alt="image-20220425153810696"></p>
<p>虽然命名是Call***Delegate, 但是这里刷新了组件的速度</p>
<h3 id="20-根据动态地面保存位置"><a href="#20-根据动态地面保存位置" class="headerlink" title="20.根据动态地面保存位置"></a>20.根据动态地面保存位置</h3><p><img src="https://img.supervj.top/imgimage-20220425154100712.png" alt="image-20220425154100712"></p>
<p>如果站在动态地面上, 那么这一步会更新对于动态地面的相对位置和旋转信息</p>
<h3 id="21-UpdateComponentVelocity"><a href="#21-UpdateComponentVelocity" class="headerlink" title="21. UpdateComponentVelocity()"></a>21. UpdateComponentVelocity()</h3><p><img src="https://img.supervj.top/imgimage-20220425154413751.png" alt="image-20220425154413751"></p>
<p>所以, 为什么这里又刷新一次, 前面<code>CallMovementUpdateDelegate</code>中已经刷新了一次</p>
<h3 id="22-处理若干网络数据"><a href="#22-处理若干网络数据" class="headerlink" title="22.处理若干网络数据"></a>22.处理若干网络数据</h3><p><img src="https://img.supervj.top/imgimage-20220425154514338.png" alt="image-20220425154514338"></p>
<h3 id="23-保存旧数据"><a href="#23-保存旧数据" class="headerlink" title="23.保存旧数据"></a>23.保存旧数据</h3><p><img src="https://img.supervj.top/imgimage-20220425154547787.png" alt="image-20220425154547787"></p>
<p>把当前最终的数据保存为Last版本</p>
<h2 id="AddMovementInput"><a href="#AddMovementInput" class="headerlink" title="AddMovementInput"></a>AddMovementInput</h2><p><img src="https://img.supervj.top/imgimage-20220228164034051.png" alt="image-20220228164034051"></p>
<p>这个接口是玩家移动输入的入口</p>
<p>通过一个方向和一个缩放值计算得到是一个加速度方向, 我们看下面分析</p>
<p><img src="https://img.supervj.top/imgimage-20220228152835493.png" alt="image-20220228152835493"></p>
<p>Tick中每一帧消耗掉上一次的输入信息并赋值给<code>InputVector</code>, 看下图, 主要内容就在这里面</p>
<p><img src="https://img.supervj.top/imgimage-20220228152955556.png" alt="image-20220228152955556"></p>
<p>然后Tick流程继续, 在下面判定并执行了<code>ControlledCharacterMove(InputVector, DeltaTime);</code></p>
<p><img src="https://img.supervj.top/imgimage-20220228153110566.png" alt="image-20220228153110566"></p>
<p>这个函数把<code>InputVector</code>转变成加速度<code>Acceleration</code>(带长度的), 然后就进入大名鼎鼎的<code>PerformMovement()</code>, 一路走到</p>
<p><code>PhysWalking()</code>中的<code>CalcVelocity()</code>函数中, 正常情况下会判定是否是制动流程, 如果不是就进入速度与摩擦力的计算</p>
<p><img src="https://img.supervj.top/imgimage-20220228155341035.png" alt="image-20220228155341035"></p>
<p>上图可以看到关键计算代码,  跟参数<code>Friction</code>和<code>Delta</code>值有很大关系, 如果最终得到的值大于1, 那么速度瞬间改变, 否则就是做插值过渡, 那么就意味着<code>GroundFriction</code>参数越大, 移动速度改变越快</p>
<p>接下来会计算流体的速度影响, 这里跳过</p>
<p>然后再根据加速度和delta计算速度</p>
<p><img src="https://img.supervj.top/imgimage-20220228160245335.png" alt="image-20220228160245335"></p>
<p>后面的是<code>RequestedAcceleration</code>和RVO的相关的计算</p>
<a name = "制动">

<h2 id="制动-减速"><a href="#制动-减速" class="headerlink" title="制动/减速"></a>制动/减速</h2><p>角色在两种情况下会执行制动流程</p>
<ol>
<li>没有加速度,即没有移动输入</li>
<li>当前速度大于最大速度</li>
</ol>
<p>减速相关的主要的配置属性如下</p>
<p><img src="https://img.supervj.top/imgimage-20220214154836007.png" alt="image-20220214154836007"></p>
<ul>
<li>bUseSeparateBrakingFriction:  如果为true, 那么单独设置阻力, 否则就使用GroundFriction或者其他外部的阻力</li>
<li>BrakingFrictionFactor: 阻力系数</li>
<li>BrakingFriction: 阻力, 计算的时候一般就是 <code>BrakingFrictionFactor * BrakingFriction</code></li>
<li>BrakingSubStepTime: 计算阻力的时候分段模拟的时间, 会clamp在 1/75与1/20之间,数值小能更平滑, 一般也不用设置</li>
<li>BrakingDecelerationWalking: 移动制动力, 还有类似的有falling,flying等等</li>
</ul>
<p>角色移动的减速流程就在下面<code>ApplyVelocityBraking</code>代码当中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::ApplyVelocityBraking</span><span class="params">(<span class="keyword">float</span> DeltaTime, <span class="keyword">float</span> Friction, <span class="keyword">float</span> BrakingDeceleration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Velocity.<span class="built_in">IsZero</span>() || !<span class="built_in">HasValidData</span>() || <span class="built_in">HasAnimRootMotion</span>() || DeltaTime &lt; MIN_TICK_TIME)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//缩放系数</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> FrictionFactor = FMath::<span class="built_in">Max</span>(<span class="number">0.f</span>, BrakingFrictionFactor);</span><br><span class="line">    <span class="comment">//阻力 = 阻力 * 系数</span></span><br><span class="line">	Friction = FMath::<span class="built_in">Max</span>(<span class="number">0.f</span>, Friction * FrictionFactor);</span><br><span class="line">    <span class="comment">//制动力</span></span><br><span class="line">	BrakingDeceleration = FMath::<span class="built_in">Max</span>(<span class="number">0.f</span>, BrakingDeceleration);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bZeroFriction = (Friction == <span class="number">0.f</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bZeroBraking = (BrakingDeceleration == <span class="number">0.f</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (bZeroFriction &amp;&amp; bZeroBraking)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> FVector OldVel = Velocity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 细分制动以在较低的帧率下获得合理一致的结果</span></span><br><span class="line">	<span class="comment">//(对于丢包的情况很重要)</span></span><br><span class="line">	<span class="keyword">float</span> RemainingTime = DeltaTime;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> MaxTimeStep = FMath::<span class="built_in">Clamp</span>(BrakingSubStepTime, <span class="number">1.0f</span> / <span class="number">75.0f</span>, <span class="number">1.0f</span> / <span class="number">20.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 减速到刹车停止</span></span><br><span class="line">	<span class="keyword">const</span> FVector RevAccel = (bZeroBraking ? FVector::ZeroVector : (-BrakingDeceleration * Velocity.<span class="built_in">GetSafeNormal</span>()));</span><br><span class="line">	<span class="keyword">while</span>( RemainingTime &gt;= MIN_TICK_TIME )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 零摩擦使用恒定的减速，所以不需要迭代。</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">float</span> dt = ((RemainingTime &gt; MaxTimeStep &amp;&amp; !bZeroFriction) ? FMath::<span class="built_in">Min</span>(MaxTimeStep, RemainingTime * <span class="number">0.5f</span>) : RemainingTime);</span><br><span class="line">		RemainingTime -= dt;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 应用制动力和摩擦力</span></span><br><span class="line">		Velocity = Velocity + ((-Friction) * Velocity + RevAccel) * dt ; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 保证不会反向</span></span><br><span class="line">		<span class="keyword">if</span> ((Velocity | OldVel) &lt;= <span class="number">0.f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Velocity = FVector::ZeroVector;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果接近零，或如果低于最小阈值和制动，速度也会设置为0</span></span><br><span class="line">    <span class="comment">//BRAKE_TO_STOP_VELOCITY默认值为10.0</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> VSizeSq = Velocity.<span class="built_in">SizeSquared</span>();</span><br><span class="line">	<span class="keyword">if</span> (VSizeSq &lt;= KINDA_SMALL_NUMBER || (!bZeroBraking &amp;&amp; VSizeSq &lt;= FMath::<span class="built_in">Square</span>(BRAKE_TO_STOP_VELOCITY)))</span><br><span class="line">	&#123;</span><br><span class="line">		Velocity = FVector::ZeroVector;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 概括一下减速流程分2部分, 一个是阻力, 一个是制动力;</p>
<p>阻力是一个变速减速运动, 制动力是匀减速运动</p>
<p><strong>所以如果把阻力设为0,  把制动力设置为当前速度一致, 那么得到的结果就是1秒内(会有大约一帧的误差)减速到0</strong></p>
<a name ="RequestVelocity">

<h2 id="Request-Velocity"><a href="#Request-Velocity" class="headerlink" title="Request Velocity"></a>Request Velocity</h2><p>我们直接通过设置角色或者移动组件的速度是不符合UE设计的, 因为他有自己的一套计算流程, 比如下面这样</p>
<p><img src="https://img.supervj.top/imgimage-20220228163002143.png" alt="image-20220228163002143"></p>
<p>事实上UE提供了一个接口, 让我们可以手动的设置速度(叠加速度)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RequestDirectMove</span><span class="params">(<span class="keyword">const</span> FVector&amp; MoveVelocity, <span class="keyword">bool</span> bForceMaxSpeed)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p>在计算整体速度的时候会用到这个速度</p>
<p><img src="https://img.supervj.top/imgimage-20220228163214104.png" alt="image-20220228163214104"></p>
<p><img src="https://img.supervj.top/imgimage-20220228163235918.png" alt="image-20220228163235918"></p>
<p>上面图中可以看到, 在计算完普通的速度以后, 在最后叠加上了这个<code>RequestVelocity</code>, 同时也保证了总速度大小保持一致</p>
<a name = "CheckInAir">

<h2 id="是否在空中的判定"><a href="#是否在空中的判定" class="headerlink" title="是否在空中的判定"></a>是否在空中的判定</h2><p>角色是否在空中的判定主要来自当前地面数据<code>CurrentFloor</code>, 通过<code>CurrentFloor.IsWalkableFloor()</code>来判定</p>
<p>满足条件下就开始执行 <code>StartFalling()</code></p>
<p>那就需要看<code>CurrentFloor</code>是如何判断是否在地面的</p>
<p>从角色移动组件的<code>UCharacterMovementComponent::ComputeFloorDist()</code>开始, 里面有下图这一段</p>
<p><img src="https://img.supervj.top/imgimage-20220310165554207.png" alt="image-20220310165554207"></p>
<p>可以理解, 角色胶囊体会进行基于形状的<strong>向下的sweap检测</strong>,  检测距离跟宽高差有关系, 意味着越细长这个检测距离越长, 距离范围是 <code>20 + [0, 半高/10)</code></p>
<p><img src="https://img.supervj.top/imgimage-20220310171952535.png" alt="image-20220310171952535"></p>
<p>一般情况下这样就够了, 但是有一些特殊情况还需要再进行sweap检测, 比如初始就有重叠等情况</p>
<p>还有就是遇到超过能走路的斜坡这种, 虽然block了但是不是walkable, 那就还需要进行一次射线检测来判断是否是站在地面上</p>
<a name = "FindFloor">

<h2 id="胶囊体与地面的距离"><a href="#胶囊体与地面的距离" class="headerlink" title="胶囊体与地面的距离"></a>胶囊体与地面的距离</h2><p><img src="https://img.supervj.top/imgimage-20220401161819905.png" alt="image-20220401161819905"></p>
<p>如上图所示, 我们从角色往下打射线检测到的地面的点 与我们角色脚底位置的点实际上是有偏差的, 这个偏差可以从移动组件里面获取到,就是下图这个东西</p>
<p><img src="https://img.supervj.top/imgimage-20220401161933973.png" alt="image-20220401161933973"></p>
<p>这个距离怎么来的呢?</p>
<p>实际上就是角色在计算地面数据的sweap过程中产生的,  大概理解为sweap前后的距离差,具体代码在<code>UCharacterMovementComponent::ComputeFloorDist()</code>中</p>
<p>大致如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> ShrinkHeight = (PawnHalfHeight - PawnRadius) * (<span class="number">1.f</span> - ShrinkScale);</span><br><span class="line">    <span class="keyword">float</span> TraceDist = SweepDistance + ShrinkHeight;</span><br><span class="line">    <span class="comment">//.................</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> MaxPenetrationAdjust = FMath::<span class="built_in">Max</span>(MAX_FLOOR_DIST, PawnRadius);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> SweepResult = FMath::<span class="built_in">Max</span>(-MaxPenetrationAdjust, Hit.Time * TraceDist - ShrinkHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个SweepResult就是我们要的Dist</p>
</blockquote>
<p>orm</p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>移动</tag>
      </tags>
  </entry>
  <entry>
    <title>绘制图形（非debug）</title>
    <url>/2020/05/06/%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2%EF%BC%88%E9%9D%9Edebug%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>蓝图方法DrawDebugLine（以及其他图形）的方法只能在开发者模式中使用</p>
<p>下文为了得到发布版的DrawLine之类的功能</p>
</blockquote>
<h3 id="LineBatchComponent"><a href="#LineBatchComponent" class="headerlink" title="LineBatchComponent"></a>LineBatchComponent</h3><ul>
<li>在UWorld中看到如下声明</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Line Batchers. All lines to be drawn in the world. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ULineBatchComponent</span>*					<span class="title">LineBatcher</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Persistent Line Batchers. They don&#x27;t get flushed every frame.  */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ULineBatchComponent</span>*					<span class="title">PersistentLineBatcher</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Foreground Line Batchers. This can&#x27;t be Persistent.  */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ULineBatchComponent</span>*					<span class="title">ForegroundLineBatcher</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后创建并注册组件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"><span class="keyword">if</span>(!LineBatcher)</span><br><span class="line">		&#123;</span><br><span class="line">			LineBatcher = NewObject&lt;ULineBatchComponent&gt;();</span><br><span class="line">			LineBatcher-&gt;bCalculateAccurateBounds = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!LineBatcher-&gt;<span class="built_in">IsRegistered</span>())</span><br><span class="line">		&#123;	</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">RegisterComponentWithWorld</span>(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">****</span><br></pre></td></tr></table></figure>

<ul>
<li><p>再到组件<code>LineBatchComponent.h</code></p>
</li>
<li><p>先关注组件内部申明的类<code>FLineBatcherSceneProxy : public FPrimitiveSceneProxy</code></p>
<ul>
<li>这个代理继承自<code>FPrimitiveSceneProxy</code>,这个类可以得到重要的<code>FPrimitiveDrawInterface</code>,通过这个类可以画出需要的图形（其他各类方法基本都是通过PDI来画出图形），代码如下</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写的方法，不需要自己调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FLineBatcherSceneProxy::GetDynamicMeshElements</span><span class="params">(<span class="keyword">const</span> TArray&lt;<span class="keyword">const</span> FSceneView*&gt;&amp; Views, <span class="keyword">const</span> FSceneViewFamily&amp; ViewFamily, uint32 VisibilityMap, FMeshElementCollector&amp; Collector)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>( STAT_LineBatcherSceneProxy_GetDynamicMeshElements );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (int32 ViewIndex = <span class="number">0</span>; ViewIndex &lt; Views.<span class="built_in">Num</span>(); ViewIndex++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (VisibilityMap &amp; (<span class="number">1</span> &lt;&lt; ViewIndex))</span><br><span class="line">		&#123;<span class="keyword">const</span> FSceneView* View = Views[ViewIndex];</span><br><span class="line">         <span class="comment">//得到PDI</span></span><br><span class="line">			FPrimitiveDrawInterface* PDI = Collector.<span class="built_in">GetPDI</span>(ViewIndex);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; Lines.<span class="built_in">Num</span>(); i++)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//通过PDI画线，Lines是TArray&lt;FBatchedLine&gt;私有成员</span></span><br><span class="line">				PDI-&gt;<span class="built_in">DrawLine</span>(Lines[i].Start, Lines[i].End, Lines[i].Color, Lines[i].DepthPriority, Lines[i].Thickness);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; Points.<span class="built_in">Num</span>(); i++)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//同理画点</span></span><br><span class="line">				PDI-&gt;<span class="built_in">DrawPoint</span>(Points[i].Position, Points[i].Color, Points[i].PointSize, Points[i].DepthPriority);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代理构造的时候提供<code>ULineBatchComponent</code></li>
<li> 目的是把<code>ULineBatchComponent</code>的数据传给此代理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FLineBatcherSceneProxy::<span class="built_in">FLineBatcherSceneProxy</span>(<span class="keyword">const</span> ULineBatchComponent* InComponent) :</span><br><span class="line">	<span class="built_in">FPrimitiveSceneProxy</span>(InComponent), <span class="built_in">Lines</span>(InComponent-&gt;BatchedLines), </span><br><span class="line">	<span class="built_in">Points</span>(InComponent-&gt;BatchedPoints), <span class="built_in">Meshes</span>(InComponent-&gt;BatchedMeshes)</span><br><span class="line">&#123;</span><br><span class="line">	bWillEverBeLit = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>下面到<code>ULineBatchComponent</code></li>
<li><code>::DrawLine</code>方法把<code>FBatchedLine</code>添加到数组，然后通过Tick递减时间并删除</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ULineBatchComponent::DrawLine</span><span class="params">(<span class="keyword">const</span> FVector&amp; Start, <span class="keyword">const</span> FVector&amp; End, <span class="keyword">const</span> FLinearColor&amp; Color, uint8 DepthPriority, <span class="keyword">const</span> <span class="keyword">float</span> Thickness, <span class="keyword">const</span> <span class="keyword">float</span> LifeTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造一个FBatchedLine成员</span></span><br><span class="line">	<span class="keyword">new</span>(BatchedLines) <span class="built_in">FBatchedLine</span>(Start, End, Color, LifeTime, Thickness, DepthPriority);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LineBatcher and PersistentLineBatcher components will be updated at the end of UWorld::Tick</span></span><br><span class="line">	<span class="built_in">MarkRenderStateDirty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ULineBatchComponent::TickComponent</span><span class="params">(<span class="keyword">float</span> DeltaTime, <span class="keyword">enum</span> ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> bDirty = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// Update the life time of batched lines, removing the lines which have expired.</span></span><br><span class="line">	<span class="keyword">for</span>(int32 LineIndex=<span class="number">0</span>; LineIndex &lt; BatchedLines.<span class="built_in">Num</span>(); LineIndex++)</span><br><span class="line">	&#123;</span><br><span class="line">		FBatchedLine&amp; Line = BatchedLines[LineIndex];</span><br><span class="line">		<span class="keyword">if</span> (Line.RemainingLifeTime &gt; <span class="number">0.0f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Line.RemainingLifeTime -= DeltaTime;</span><br><span class="line">			<span class="keyword">if</span>(Line.RemainingLifeTime &lt;= <span class="number">0.0f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// The line has expired, remove it.</span></span><br><span class="line">				BatchedLines.<span class="built_in">RemoveAtSwap</span>(LineIndex--);</span><br><span class="line">				bDirty = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    *************************</span><br></pre></td></tr></table></figure>

<h3 id="DrawDebug版本"><a href="#DrawDebug版本" class="headerlink" title="DrawDebug版本"></a>DrawDebug版本</h3><p>通过<code>world</code>得到相应的<code>LineBatcher</code>然后调用<code>DrawLine</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (GEngine-&gt;<span class="built_in">GetNetMode</span>(InWorld) != NM_DedicatedServer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// this means foreground lines can&#x27;t be persistent </span></span><br><span class="line">		ULineBatchComponent* <span class="keyword">const</span> LineBatcher = <span class="built_in">GetDebugLineBatcher</span>( InWorld, bPersistentLines, LifeTime, (DepthPriority == SDPG_Foreground) );</span><br><span class="line">		<span class="keyword">if</span>(LineBatcher != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> <span class="keyword">const</span> LineLifeTime = <span class="built_in">GetDebugLineLifeTime</span>(LineBatcher, LifeTime, bPersistentLines);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(LineStart, LineEnd, Color, DepthPriority, Thickness, LineLifeTime);</span><br><span class="line">		</span><br></pre></td></tr></table></figure>



<h3 id="封装蓝图函数库"><a href="#封装蓝图函数库" class="headerlink" title="封装蓝图函数库"></a>封装蓝图函数库</h3><h5 id="FlibDrawGraphics-h"><a href="#FlibDrawGraphics-h" class="headerlink" title="FlibDrawGraphics.h"></a>FlibDrawGraphics.h</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Kismet/BlueprintFunctionLibrary.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;FlibDrawGraphics.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ULineBatchComponent</span>;</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GWORLD_API</span> <span class="title">UFlibDrawGraphics</span> :</span> <span class="keyword">public</span> UBlueprintFunctionLibrary</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> ULineBatchComponent* <span class="title">GetDebugLineBatcher</span><span class="params">(<span class="keyword">const</span> UWorld* InWorld, <span class="keyword">bool</span> bPersistentLines, <span class="keyword">float</span> LifeTime, <span class="keyword">bool</span> bDepthIsForeground)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">G_DrawLine</span><span class="params">(UObject* context, FVector Start, FVector End, FLinearColor Color, uint8 DepthPriority, <span class="keyword">float</span> Thickness, <span class="keyword">float</span> Duration, <span class="keyword">bool</span> bPersistent = <span class="literal">false</span>)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">G_DrawBox</span><span class="params">(UObject* context, FVector  Center, FVector  Box, FLinearColor Color, uint8 DepthPriority, <span class="keyword">float</span> Thickness, <span class="keyword">float</span> Duration, <span class="keyword">bool</span> bPersistent = <span class="literal">false</span>)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (context = <span class="string">&quot;WorldContextObject&quot;</span>))</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">G_DrawSoildBox</span><span class="params">(UObject* context, FVector  Center, FVector  Extent, FLinearColor  Color, uint8 DepthPriority, <span class="keyword">float</span> Duration, <span class="keyword">bool</span> bPersistent = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="FlibDrawGraphics-cpp"><a href="#FlibDrawGraphics-cpp" class="headerlink" title="FlibDrawGraphics.cpp"></a>FlibDrawGraphics.cpp</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;FlibDrawGraphics.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/LineBatchComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Engine/World.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ULineBatchComponent* <span class="title">ULibGameFunc::GetDebugLineBatcher</span><span class="params">(<span class="keyword">const</span> UWorld* InWorld, <span class="keyword">bool</span> bPersistentLines, <span class="keyword">float</span> LifeTime, <span class="keyword">bool</span> bDepthIsForeground)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (InWorld ? (bDepthIsForeground ? InWorld-&gt;ForegroundLineBatcher : ((bPersistentLines || (LifeTime &gt; <span class="number">0.f</span>)) ? InWorld-&gt;PersistentLineBatcher : InWorld-&gt;LineBatcher)) : <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//画线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ULibGameFunc::BP_DrawLine</span><span class="params">(UObject* context, FVector Start, FVector End, FLinearColor Color, uint8 DepthPriority, <span class="keyword">float</span> Thickness, <span class="keyword">float</span> Duration, <span class="keyword">bool</span> bPersistent <span class="comment">/*= false*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UWorld* world = context-&gt;<span class="built_in">GetWorld</span>();</span><br><span class="line">	<span class="keyword">if</span> (world)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//通过优先级得到对应的组件</span></span><br><span class="line">		ULineBatchComponent* <span class="keyword">const</span> LineBatcher = <span class="built_in">GetDebugLineBatcher</span>(world, bPersistent, Duration, DepthPriority == SDPG_Foreground);</span><br><span class="line">        <span class="comment">//如果是永久的设置时间-1</span></span><br><span class="line">		<span class="keyword">float</span> <span class="keyword">const</span> ActualLifetime = bPersistent ? <span class="number">-1.0f</span> : ((Duration &gt; <span class="number">0.f</span>) ? Duration : LineBatcher-&gt;DefaultLifeTime);</span><br><span class="line">		LineBatcher-&gt;<span class="built_in">DrawLine</span>(Start, End, Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//画盒子边框，通过8个点然后DrawLine得到</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ULibGameFunc::BP_DrawBox</span><span class="params">(UObject* context, FVector Center, FVector Box, FLinearColor Color, uint8 DepthPriority, <span class="keyword">float</span> Thickness, <span class="keyword">float</span> Duration, <span class="keyword">bool</span> bPersistent <span class="comment">/*= false*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	UWorld* world = context-&gt;<span class="built_in">GetWorld</span>();</span><br><span class="line">	<span class="keyword">if</span> (world)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		ULineBatchComponent* <span class="keyword">const</span> LineBatcher = <span class="built_in">GetDebugLineBatcher</span>(world, bPersistent, Duration, DepthPriority == SDPG_Foreground);</span><br><span class="line">		<span class="keyword">float</span> <span class="keyword">const</span> ActualLifetime = bPersistent ? <span class="number">-1.0f</span> : ((Duration &gt; <span class="number">0.f</span>) ? Duration : LineBatcher-&gt;DefaultLifeTime);</span><br><span class="line">		<span class="keyword">if</span> (LineBatcher)</span><br><span class="line">		&#123;		LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(Box.X, Box.Y, Box.Z), Center + <span class="built_in">FVector</span>(Box.X, -Box.Y, Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(Box.X, -Box.Y, Box.Z), Center + <span class="built_in">FVector</span>(-Box.X, -Box.Y, Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(-Box.X, -Box.Y, Box.Z), Center + <span class="built_in">FVector</span>(-Box.X, Box.Y, Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(-Box.X, Box.Y, Box.Z), Center + <span class="built_in">FVector</span>(Box.X, Box.Y, Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(Box.X, Box.Y, -Box.Z), Center + <span class="built_in">FVector</span>(Box.X, -Box.Y, -Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(Box.X, -Box.Y, -Box.Z), Center + <span class="built_in">FVector</span>(-Box.X, -Box.Y, -Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(-Box.X, -Box.Y, -Box.Z), Center + <span class="built_in">FVector</span>(-Box.X, Box.Y, -Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(-Box.X, Box.Y, -Box.Z), Center + <span class="built_in">FVector</span>(Box.X, Box.Y, -Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(Box.X, Box.Y, Box.Z), Center + <span class="built_in">FVector</span>(Box.X, Box.Y, -Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(Box.X, -Box.Y, Box.Z), Center + <span class="built_in">FVector</span>(Box.X, -Box.Y, -Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(-Box.X, -Box.Y, Box.Z), Center + <span class="built_in">FVector</span>(-Box.X, -Box.Y, -Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line">			LineBatcher-&gt;<span class="built_in">DrawLine</span>(Center + <span class="built_in">FVector</span>(-Box.X, Box.Y, Box.Z), Center + <span class="built_in">FVector</span>(-Box.X, Box.Y, -Box.Z), Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, Thickness, ActualLifetime);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画实体的盒子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ULibGameFunc::DrawSoildBox</span><span class="params">(UObject* context, FVector Center, FVector Extent, FLinearColor Color, uint8 DepthPriority, <span class="keyword">float</span> Duration, <span class="keyword">bool</span> bPersistent<span class="comment">/*=false*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FBox Box = FBox::<span class="built_in">BuildAABB</span>(Center, Extent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (context)</span><br><span class="line">	&#123;</span><br><span class="line">		UWorld* World = context-&gt;<span class="built_in">GetWorld</span>();</span><br><span class="line">		<span class="keyword">if</span> (World)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			ULineBatchComponent* <span class="keyword">const</span> LineBatcher = <span class="built_in">GetDebugLineBatcher</span>(World, bPersistent, Duration, DepthPriority == SDPG_Foreground);</span><br><span class="line">			<span class="keyword">if</span> (LineBatcher != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">float</span> <span class="keyword">const</span> ActualLifetime = bPersistent ? <span class="number">-1.0f</span> : ((Duration &gt; <span class="number">0.f</span>) ? Duration : LineBatcher-&gt;DefaultLifeTime);</span><br><span class="line">				LineBatcher-&gt;<span class="built_in">DrawSolidBox</span>(Box, FTransform::Identity, Color.<span class="built_in">ToFColor</span>(<span class="literal">true</span>), DepthPriority, ActualLifetime);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="蓝图测试"><a href="#蓝图测试" class="headerlink" title="蓝图测试"></a>蓝图测试</h3><p><img src="https://img.supervj.top/imgdrawGraphics_1.png"></p>
<p><img src="https://img.supervj.top/imgdrawGraphics_2.png"></p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>图形</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器扩展：插槽编辑器</title>
    <url>/2021/08/19/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%EF%BC%9A%E6%8F%92%E6%A7%BD%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img.supervj.top//img/image-20210819103621100.png" alt="image-20210819103621100"></p>
<p>一个简易的插槽编辑器插件</p>
<span id="more"></span>



<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>先看<a href="https://supervj.top/2021/08/19/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A2%84%E8%A7%88%E8%AF%95%E5%9B%BE/">编辑器扩展：自定义预览试图</a>, 我们已经完成了插件和预览试图的创建, 本文将进行插槽编辑相关功能的添加和扩展</p>
<h2 id="插槽编辑类"><a href="#插槽编辑类" class="headerlink" title="插槽编辑类"></a>插槽编辑类</h2><p>参考<code>UnrealEd</code>模块的<code>SSocketManager</code>类, 我们自己模仿着写一个类出来作为编辑插槽的<code>Slate</code>类</p>
<blockquote>
<p>为什么不直接用? 首先方便我们自己修改, 另外, 该对象是private. private.. private…, 不过我们还是可以继承<code>ISocketManager</code>接口来省掉一部分工作(不继承也没关系, 自己声明类似的函数即可)</p>
</blockquote>
<p>代码较多, 多数是参考<code>SSocketManager</code>类的实现, 不过由于我们没有用到<code>StaticMeshEditor</code>类, 所以于此相关的代码都需要替换成我们自己的代码, 我这里把类似的代码都放到了我们的顶层UI对象里, 即我们的<code>SSHud_SimpleSocket</code>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SSocketEdit</span> :</span> <span class="keyword">public</span> ISocketManager, <span class="keyword">public</span> FNotifyHook</span><br></pre></td></tr></table></figure>



<p>同样的, 有两个数据结构也是模仿着抄写一遍, 名字改一下而已, 比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SocketListItem_SimpleSocketEdit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SocketListItem_SimpleSocketEdit</span>(UStaticMeshSocket* InSocket)</span><br><span class="line">        : <span class="built_in">Socket</span>(InSocket)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The static mesh socket this represents */</span></span><br><span class="line">    UStaticMeshSocket* Socket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegate for when the context menu requests a rename */</span></span><br><span class="line">    <span class="built_in">DECLARE_DELEGATE</span>(FOnRenameRequested);</span><br><span class="line">    FOnRenameRequested OnRenameRequested;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后在顶层UI类里面添加进去这个<code>slate</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+ SSplitter::<span class="built_in">Slot</span>()</span><br><span class="line">    .<span class="built_in">Value</span>(<span class="number">0.9f</span>)</span><br><span class="line">    [</span><br><span class="line">    <span class="built_in">SNew</span>(SSplitter)</span><br><span class="line">    .<span class="built_in">Orientation</span>(EOrientation::Orient_Horizontal)</span><br><span class="line">    + SSplitter::<span class="built_in">Slot</span>()</span><br><span class="line">    .<span class="built_in">Value</span>(<span class="number">0.7f</span>)</span><br><span class="line">    [</span><br><span class="line">        <span class="built_in">SAssignNew</span>(ViewPort, SEditorViewport_SimpleSocket)</span><br><span class="line">        .<span class="built_in">HUD</span>(<span class="built_in">SharedThis</span>(<span class="keyword">this</span>))</span><br><span class="line">        .<span class="built_in">PreviewMesh</span>(EditMesh)</span><br><span class="line">    ]</span><br><span class="line">    + SSplitter::<span class="built_in">Slot</span>()</span><br><span class="line">    .<span class="built_in">Value</span>(<span class="number">0.3f</span>)</span><br><span class="line">    [</span><br><span class="line">        <span class="built_in">SAssignNew</span>(SocketEditor, SSocketEdit)</span><br><span class="line">        .<span class="built_in">StaticMesh</span>(EditMesh)</span><br><span class="line">        .<span class="built_in">HUD</span>(<span class="built_in">SharedThis</span>(<span class="keyword">this</span>))</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用的是<code>SSplitter</code> 而非<code>SHorizontalBox</code>之类的, 毕竟<code>SSplitter</code>可以自由缩放窗口</p>
</blockquote>
<h2 id="FEditorViewportClient-SimpleSocket"><a href="#FEditorViewportClient-SimpleSocket" class="headerlink" title="FEditorViewportClient_SimpleSocket"></a>FEditorViewportClient_SimpleSocket</h2><p>视图<code>Slate</code>类负责渲染, 那么还需要一个与此对应的类来负责交互和数据管理, 那么就是这个类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FEditorViewportClient_SimpleSocket</span> :</span> <span class="keyword">public</span> FEditorViewportClient, <span class="keyword">public</span> TSharedFromThis&lt;FEditorViewportClient_SimpleSocket&gt;</span><br></pre></td></tr></table></figure>

<p>另外有了插槽编辑类, 那么<code>FEditorViewportClient</code>需要与其进行数据交互, 我们通过<code>hud</code>类来作为上层管理来对这两个对象进行数据交互, 比如在<code>FEditorViewportClient</code>中选中了某个插槽, 那么需要同步更新至插槽编辑类中, 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FEditorViewportClient_SimpleSocket::ProcessClick</span><span class="params">(class FSceneView&amp; View, class HHitProxy* HitProxy, FKey Key, EInputEvent Event, uint32 HitX, uint32 HitY)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bCtrlDown = Viewport-&gt;<span class="built_in">KeyState</span>(EKeys::LeftControl) || Viewport-&gt;<span class="built_in">KeyState</span>(EKeys::RightControl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> ClearSelectedSockets = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (HitProxy)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (HitProxy-&gt;<span class="built_in">IsA</span>(HSMESocketProxy_SimpleSocket::<span class="built_in">StaticGetType</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">			HSMESocketProxy_SimpleSocket* SocketProxy = (HSMESocketProxy_SimpleSocket*)HitProxy;</span><br><span class="line"></span><br><span class="line">			UStaticMeshSocket* Socket = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (SocketProxy-&gt;SocketIndex &lt; StaticMesh-&gt;Sockets.<span class="built_in">Num</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				Socket = StaticMesh-&gt;Sockets[SocketProxy-&gt;SocketIndex];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (Socket)</span><br><span class="line">			&#123;</span><br><span class="line">				HudPtr.<span class="built_in">Pin</span>()-&gt;<span class="built_in">SetSelectedSocket</span>(Socket);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ClearSelectedSockets = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ClearSelectedSockets &amp;&amp; HudPtr.<span class="built_in">Pin</span>()-&gt;<span class="built_in">GetSelectedSocket</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		HudPtr.<span class="built_in">Pin</span>()-&gt;<span class="built_in">SetSelectedSocket</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">Invalidate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数实现了点击的逻辑,  我们视图中出现的像钻石形状的插槽物体其实是该类绘制出来的一个代理, 可以点击交互, 选中以后我们通知<code>hud</code>我们选中了插槽</p>
<hr>
<p>另外, 该类有很多功能函数, 比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听按键输入, 可以监听Delete来实现删除插槽等等</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">InputKey</span><span class="params">(FViewport* Viewport, int32 ControllerId, FKey Key, EInputEvent Event, <span class="keyword">float</span> AmountDepressed = <span class="number">1.f</span>, <span class="keyword">bool</span> bGamepad = <span class="literal">false</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//可以绘制插槽的名称和移动数据等</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawCanvas</span><span class="params">(FViewport&amp; InViewport, FSceneView&amp; View, FCanvas&amp; Canvas)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//绘制移动旋转的UI</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">InputWidgetDelta</span><span class="params">(FViewport* Viewport, EAxisList::Type CurrentAxis, FVector&amp; Drag, FRotator&amp; Rot, FVector&amp; Scale)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//下面两个函数用于检测对插槽代理的控制,如位移旋转等</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TrackingStarted</span><span class="params">(<span class="keyword">const</span> struct FInputEventState&amp; InInputState, <span class="keyword">bool</span> bIsDragging, <span class="keyword">bool</span> bNudge)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TrackingStopped</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p>还有一堆名字上带<code>WidgetMode</code>的函数, 用于控制切换移动/旋转/缩放的不同操控UI</p>
<p>最后通过<code>void FEditorViewportClient_SimpleSocket::Draw(const FSceneView* View, FPrimitiveDrawInterface* PDI)</code>函数来完成实时绘制插槽代理的任务,  我这里修改了一下代码, 让选中的插槽显示不同的颜色</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//........</span></span><br><span class="line">FColor SocketColor = (Socket == HudPtr.<span class="built_in">Pin</span>()-&gt;<span class="built_in">GetSelectedSocket</span>()? SocketColor_Selected : SocketColor_Default);</span><br><span class="line">FMatrix SocketTM;</span><br><span class="line">Socket-&gt;<span class="built_in">GetSocketMatrix</span>(SocketTM, StaticMeshComponent);</span><br><span class="line">PDI-&gt;<span class="built_in">SetHitProxy</span>(<span class="keyword">new</span> <span class="built_in">HSMESocketProxy_SimpleSocket</span>(i));</span><br><span class="line"><span class="built_in">DrawWireDiamond</span>(PDI, SocketTM, <span class="number">5.f</span>, SocketColor, SDPG_Foreground);</span><br><span class="line">PDI-&gt;<span class="built_in">SetHitProxy</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>



<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_08_19_11_20_31_986.gif" alt="录制_2021_08_19_11_20_31_986"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol>
<li>场景内的模型, 包括插槽预览模型都是作为<code>Component</code>添加到场景对象<code>PreviewScene</code>内的</li>
<li>换模型从<code>hud</code>对象中发起, 分别要通知到插槽编辑类<code>SSocketEdit</code>和视图对象<code>SEditorViewport_SimpleSocket</code>,  然后视图类再刷新场景内的模型组件,再通知到视图管理类<code>FEditorViewportClient_SimpleSocket</code></li>
<li><code>StaticMeshEditor</code>的所有命令都是从<code>Editor</code>对象发起, 我这里直接各自去绑定命令和输入了, 比如插槽编辑类右键插槽名字弹出的菜单是自己绑定的命令</li>
<li>模型的选择可以参考文章<a href="https://supervj.top/2021/08/09/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E7%95%8C%E9%9D%A2/?highlight=entry">编辑器扩展：自定义属性界面</a>, 用的是<code>SObjectPropertyEntryBox</code></li>
<li>最近一次编辑过的模型对象保存在一个编辑器subsystem中, 其实也可以用其他方式保存</li>
</ol>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器扩展：消息窗口</title>
    <url>/2021/08/09/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%EF%BC%9A%E6%B6%88%E6%81%AF%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自定义和扩展消息窗口</p>
<p><img src="https://img.supervj.top//img/image-20210809102920800.png" alt="image-20210809102920800"></p>
<p><img src="https://img.supervj.top//img/image-20210108110520787.png" alt="image-20210108110520787"></p>
<span id="more"></span>



<h2 id="消息窗口"><a href="#消息窗口" class="headerlink" title="消息窗口"></a>消息窗口</h2><p>先看两个枚举</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> EAppMsgType</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Enumerates supported message dialog button types.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">Type</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		Ok,</span><br><span class="line">		YesNo,</span><br><span class="line">		OkCancel,</span><br><span class="line">		YesNoCancel,</span><br><span class="line">		CancelRetryContinue,</span><br><span class="line">		YesNoYesAllNoAll,</span><br><span class="line">		YesNoYesAllNoAllCancel,</span><br><span class="line">		YesNoYesAll,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> EAppReturnType</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Enumerates message dialog return types.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">Type</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		No,</span><br><span class="line">		Yes,</span><br><span class="line">		YesAll,</span><br><span class="line">		NoAll,</span><br><span class="line">		Cancel,</span><br><span class="line">		Ok,</span><br><span class="line">		Retry,</span><br><span class="line">		Continue,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前者为输入,后者会返回</p>
<p>可以通过返回类型的不同来做不同的逻辑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">EAppReturnType::Type ReturnType = FMessageDialog::<span class="built_in">Open</span>(EAppMsgType::OkCancel, DialogText);</span><br></pre></td></tr></table></figure>

<ul>
<li>强行封装蓝图库</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">EMsgType</span> :</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">	Ok,</span><br><span class="line">	YesNo,</span><br><span class="line">	OkCancel,</span><br><span class="line">	YesNoCancel,</span><br><span class="line">	CancelRetryContinue,</span><br><span class="line">	YesNoYesAllNoAll,</span><br><span class="line">	YesNoYesAllNoAllCancel,</span><br><span class="line">	YesNoYesAll,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">EMsgRetType</span> :</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">	No,</span><br><span class="line">	Yes,</span><br><span class="line">	YesAll,</span><br><span class="line">	NoAll,</span><br><span class="line">	Cancel,</span><br><span class="line">	Ok,</span><br><span class="line">	Retry,</span><br><span class="line">	Continue,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">EMsgRetType <span class="title">UFlib_IO::OpenMessageWindow</span><span class="params">(EMsgType Type, FText Msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EAppMsgType::Type  tp;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (Type)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> EMsgType::Ok:</span><br><span class="line">	tp = EAppMsgType::Ok; </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EMsgType::YesNo:</span><br><span class="line">		tp = EAppMsgType::YesNo;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EMsgType::OkCancel:</span><br><span class="line">		tp = EAppMsgType::OkCancel;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EMsgType::YesNoCancel:</span><br><span class="line">		tp = EAppMsgType::YesNoCancel;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EMsgType::CancelRetryContinue:</span><br><span class="line">		tp = EAppMsgType::CancelRetryContinue;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EMsgType::YesNoYesAllNoAll:</span><br><span class="line">		tp = EAppMsgType::YesNoYesAllNoAll;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EMsgType::YesNoYesAllNoAllCancel:</span><br><span class="line">		tp = EAppMsgType::YesNoYesAllNoAllCancel;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EMsgType::YesNoYesAll:</span><br><span class="line">		tp = EAppMsgType::YesNoYesAll;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	EAppReturnType::Type retType = FMessageDialog::<span class="built_in">Open</span>(tp, Msg);</span><br><span class="line">	EMsgRetType returnType = EMsgRetType::Ok;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (retType)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> EAppReturnType::No:</span><br><span class="line">		returnType = EMsgRetType::No;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EAppReturnType::Yes:</span><br><span class="line">		returnType = EMsgRetType::Yes;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EAppReturnType::YesAll:</span><br><span class="line">		returnType = EMsgRetType::YesAll;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EAppReturnType::NoAll:</span><br><span class="line">		returnType = EMsgRetType::NoAll;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EAppReturnType::Cancel:</span><br><span class="line">		returnType = EMsgRetType::Cancel;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EAppReturnType::Ok:</span><br><span class="line">		returnType = EMsgRetType::Ok;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EAppReturnType::Retry:</span><br><span class="line">		returnType = EMsgRetType::Retry;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EAppReturnType::Continue:</span><br><span class="line">		returnType = EMsgRetType::Continue;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> returnType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210108110520787.png" alt="image-20210108110520787"></p>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>Slate</tag>
        <tag>编辑器扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器扩展:自定义PlaceActors</title>
    <url>/2021/08/13/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89PlaceActors/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img.supervj.top//img/image-20210813111004071.png" alt="image-20210813111004071"></p>
<p>有的时候, 为了方便项目需求, 我们需要自定义PlaceActors标签以及对应的类</p>
<p>本文记录如何实现这一扩展</p>
<span id="more"></span>



<h2 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h2><p>开始之前我们需要了解一下UE4编辑器模块的启动顺序, 可以参考之前的一篇文章 <a href="https://supervj.top/2021/08/12/%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8/">UE4模块启动顺序</a></p>
<p>关键的一点是, 我们对编辑器添加新的PlaceActors标签需要在编辑器初始化之后,  因为<code>IPlacementModeModule::Get()</code>会启动<code>PlacementMode</code>模块, 而该模块启动时需要构造<code>FPlaceableItem</code>对象, <code>FPlaceableItem</code>对象构造时需要依赖<code>GEditor-&gt;FindActorFactoryByClass()</code>函数, 该函数实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UActorFactory* <span class="title">UEditorEngine::FindActorFactoryByClass</span><span class="params">( <span class="keyword">const</span> UClass* InClass )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( int32 i = <span class="number">0</span> ; i &lt; ActorFactories.<span class="built_in">Num</span>() ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        UActorFactory* Factory = ActorFactories[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( Factory != <span class="literal">NULL</span> &amp;&amp; Factory-&gt;<span class="built_in">GetClass</span>() == InClass )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Factory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ActorFactories</code>数组会在<code>UEditorEngine::InitEditor()</code>时完成, 意味着我们注册标签必须在编辑器初始化完成之后.</p>
<p>所以我们实现自定义PlaceActors标签的插件模块必须是<code>PostEngineInit</code>, 或者我们还有一个更安全的办法, 即通过监听编辑器初始化完成的回调事件来实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FCoreDelegates::OnPostEngineInit.<span class="built_in">AddRaw</span>(<span class="keyword">this</span>, &amp;FAdvancedFrameworkEditorModule::RegisterPlaceActors);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAdvancedFrameworkEditorModule::RegisterPlaceActors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FPlacementCategoryInfo <span class="title">MyCategoryInfo</span><span class="params">(FText::FromString(<span class="string">&quot;AdvancedFramework&quot;</span>), <span class="string">&quot;AdvancedFrameworkActors&quot;</span>, <span class="string">&quot;AdvancedFrameworkTags&quot;</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (IPlacementModeModule::<span class="built_in">Get</span>().<span class="built_in">IsAvailable</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        IPlacementModeModule::<span class="built_in">Get</span>().<span class="built_in">RegisterPlacementCategory</span>(MyCategoryInfo);	IPlacementModeModule::<span class="built_in">Get</span>().<span class="built_in">RegisterPlaceableItem</span>(MyCategoryInfo.UniqueHandle, <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryEmptyActor::<span class="built_in">StaticClass</span>())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先添加一个叫<code>AdvancedFrameworkActors</code>的标签, 然后使用引擎默认的<code>EmptyActor</code>来先添加一个对象</p>
<p>先看一下数据结构<code>FPlacementCategoryInfo</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FPlacementCategoryInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">FPlacementCategoryInfo</span>(FText InDisplayName, FName InHandle, FString InTag, int32 InSortOrder = <span class="number">0</span>, <span class="keyword">bool</span> bInSortable = <span class="literal">true</span>)</span><br><span class="line">		: <span class="built_in">DisplayName</span>(InDisplayName), <span class="built_in">UniqueHandle</span>(InHandle), <span class="built_in">SortOrder</span>(InSortOrder), <span class="built_in">TagMetaData</span>(<span class="built_in">MoveTemp</span>(InTag)), <span class="built_in">bSortable</span>(bInSortable)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** This category&#x27;s display name */</span></span><br><span class="line">	FText DisplayName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** A unique name for this category */</span></span><br><span class="line">	FName UniqueHandle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Sort order for the category tab (lowest first) */</span></span><br><span class="line">	int32 SortOrder;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Optional tag meta data for the tab widget */</span></span><br><span class="line">	FString TagMetaData;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Optional generator function used to construct this category&#x27;s tab content. Called when the tab is activated. */</span></span><br><span class="line">	TFunction&lt;TSharedRef&lt;SWidget&gt;()&gt; CustomGenerator;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Whether the items in this category are automatically sortable by name. False if the items are already sorted. */</span></span><br><span class="line">	<span class="keyword">bool</span> bSortable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们显示的名称是构造函数的第二个字符串, 然后第4个参数决定我们的排序优先级, 我们打算放到最下面所以设置成了99</p>
<h2 id="添加对象"><a href="#添加对象" class="headerlink" title="添加对象"></a>添加对象</h2><p>接下来要看的是<code>RegisterPlaceableItem()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TOptional&lt;FPlacementModeID&gt; <span class="title">FPlacementModeModule::RegisterPlaceableItem</span><span class="params">(FName CategoryName, <span class="keyword">const</span> TSharedRef&lt;FPlaceableItem&gt;&amp; InItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FPlacementCategory* Category = Categories.<span class="built_in">Find</span>(CategoryName);</span><br><span class="line">	<span class="keyword">if</span> (Category &amp;&amp; !Category-&gt;CustomGenerator)</span><br><span class="line">	&#123;</span><br><span class="line">		FPlacementModeID ID = <span class="built_in">CreateID</span>(CategoryName);</span><br><span class="line">		Category-&gt;Items.<span class="built_in">Add</span>(ID.UniqueID, InItem);</span><br><span class="line">		<span class="keyword">return</span> ID;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TOptional&lt;FPlacementModeID&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要传入一个<code>FPlaceableItem</code>对象, 再来看<code>FPlaceableItem</code>的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">FPlaceableItem</span>(UActorFactory* InFactory, <span class="keyword">const</span> FAssetData&amp; InAssetData, TOptional&lt;int32&gt; InSortOrder = TOptional&lt;int32&gt;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">FPlaceableItem</span>(UClass&amp; InAssetClass, TOptional&lt;int32&gt; InSortOrder = TOptional&lt;int32&gt;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">FPlaceableItem</span>(</span><br><span class="line">    UClass&amp; InAssetClass,</span><br><span class="line">    <span class="keyword">const</span> FAssetData&amp; InAssetData,</span><br><span class="line">    FName InClassThumbnailBrushOverride = NAME_None,</span><br><span class="line">    TOptional&lt;FLinearColor&gt; InAssetTypeColorOverride = TOptional&lt;FLinearColor&gt;(),</span><br><span class="line">    TOptional&lt;int32&gt; InSortOrder = TOptional&lt;int32&gt;(),</span><br><span class="line">    TOptional&lt;FText&gt; InDisplayName = TOptional&lt;FText&gt;()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>理论上讲上述构造函数都可以使用, 但是我们本着能方便就方便, 能偷懒就偷懒的原则, 先去看一看引擎自己咋使用的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PlacementModeModule.cpp  L123</span></span><br><span class="line">FPlacementCategory* Category = Categories.<span class="built_in">Find</span>(CategoryName);</span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryEmptyActor::<span class="built_in">StaticClass</span>(), SortOrder += <span class="number">10</span>)));</span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryCharacter::<span class="built_in">StaticClass</span>(), SortOrder += <span class="number">10</span>)));</span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryPawn::<span class="built_in">StaticClass</span>(), SortOrder += <span class="number">10</span>)));</span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryPointLight::<span class="built_in">StaticClass</span>(), SortOrder += <span class="number">10</span>)));</span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryPlayerStart::<span class="built_in">StaticClass</span>(), SortOrder += <span class="number">10</span>)));</span><br><span class="line"><span class="comment">// Cube</span></span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryBasicShape::<span class="built_in">StaticClass</span>(), <span class="built_in">FAssetData</span>(LoadObject&lt;UStaticMesh&gt;(<span class="literal">nullptr</span>, *UActorFactoryBasicShape::BasicCube.<span class="built_in">ToString</span>())), <span class="built_in">FName</span>(<span class="string">&quot;ClassThumbnail.Cube&quot;</span>), BasicShapeColorOverride, SortOrder += <span class="number">10</span>, <span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;PlacementMode&quot;</span>, <span class="string">&quot;Cube&quot;</span>, <span class="string">&quot;Cube&quot;</span>))));</span><br><span class="line"><span class="comment">// Sphere</span></span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryBasicShape::<span class="built_in">StaticClass</span>(), <span class="built_in">FAssetData</span>(LoadObject&lt;UStaticMesh&gt;(<span class="literal">nullptr</span>, *UActorFactoryBasicShape::BasicSphere.<span class="built_in">ToString</span>())), <span class="built_in">FName</span>(<span class="string">&quot;ClassThumbnail.Sphere&quot;</span>), BasicShapeColorOverride, SortOrder += <span class="number">10</span>, <span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;PlacementMode&quot;</span>, <span class="string">&quot;Sphere&quot;</span>, <span class="string">&quot;Sphere&quot;</span>))));</span><br><span class="line"><span class="comment">// Cylinder</span></span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryBasicShape::<span class="built_in">StaticClass</span>(), <span class="built_in">FAssetData</span>(LoadObject&lt;UStaticMesh&gt;(<span class="literal">nullptr</span>, *UActorFactoryBasicShape::BasicCylinder.<span class="built_in">ToString</span>())), <span class="built_in">FName</span>(<span class="string">&quot;ClassThumbnail.Cylinder&quot;</span>), BasicShapeColorOverride, SortOrder += <span class="number">10</span>, <span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;PlacementMode&quot;</span>, <span class="string">&quot;Cylinder&quot;</span>, <span class="string">&quot;Cylinder&quot;</span>))));</span><br><span class="line"><span class="comment">// Cone</span></span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryBasicShape::<span class="built_in">StaticClass</span>(), <span class="built_in">FAssetData</span>(LoadObject&lt;UStaticMesh&gt;(<span class="literal">nullptr</span>, *UActorFactoryBasicShape::BasicCone.<span class="built_in">ToString</span>())), <span class="built_in">FName</span>(<span class="string">&quot;ClassThumbnail.Cone&quot;</span>), BasicShapeColorOverride, SortOrder += <span class="number">10</span>, <span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;PlacementMode&quot;</span>, <span class="string">&quot;Cone&quot;</span>, <span class="string">&quot;Cone&quot;</span>))));</span><br><span class="line"><span class="comment">// Plane</span></span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryBasicShape::<span class="built_in">StaticClass</span>(), <span class="built_in">FAssetData</span>(LoadObject&lt;UStaticMesh&gt;(<span class="literal">nullptr</span>, *UActorFactoryBasicShape::BasicPlane.<span class="built_in">ToString</span>())), <span class="built_in">FName</span>(<span class="string">&quot;ClassThumbnail.Plane&quot;</span>), BasicShapeColorOverride, SortOrder += <span class="number">10</span>, <span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;PlacementMode&quot;</span>, <span class="string">&quot;Plane&quot;</span>, <span class="string">&quot;Plane&quot;</span>))));</span><br><span class="line"></span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryTriggerBox::<span class="built_in">StaticClass</span>(), SortOrder += <span class="number">10</span>)));</span><br><span class="line">Category-&gt;Items.<span class="built_in">Add</span>(<span class="built_in">CreateID</span>(), <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UActorFactoryTriggerSphere::<span class="built_in">StaticClass</span>(), SortOrder += <span class="number">10</span>)));</span><br></pre></td></tr></table></figure>

<p>看上述代码, 所以引擎自己都使用一个<code>UActorFactory</code>对象, 观察这个类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(collapsecategories, hidecategories=Object, editinlinenew, config=Editor, abstract, transient)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNREALED_API</span> <span class="title">UActorFactory</span> :</span> <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_UCLASS_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Name used as basis for &#x27;New Actor&#x27; menu. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FText DisplayName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Indicates how far up the menu item should be. The higher the number, the higher up the list.*/</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config)</span><br><span class="line">	int32 MenuPriority;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** name of actor subclass this actorfactory creates - dynamically loaded.  Overrides NewActorClass. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config)</span><br><span class="line">	FString NewActorClassName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**  AActor  subclass this ActorFactory creates. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">AActor</span>&gt;</span>  NewActorClass;</span><br><span class="line"><span class="comment">//...........</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看了一些引擎的实现, 重点就是上面这些成员变量, 以及部分虚函数的实现, 比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CanCreateActorFrom</span><span class="params">( <span class="keyword">const</span> FAssetData&amp; AssetData, FText&amp; OutErrorMsg )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AActor* <span class="title">SpawnActor</span><span class="params">( UObject* Asset, ULevel* InLevel, <span class="keyword">const</span> FTransform&amp; Transform, EObjectFlags ObjectFlags, <span class="keyword">const</span> FName Name )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其实一些类比如骨骼模型SkeletalMesh, 直接拖拽到编辑器世界空间中他会创建一个Actor来完成骨骼模型的显示, 而我们其实可以不需要这一步骤(如果我们的对象本身就是一个普通的actor)</p>
<p>所以可以这样添加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">IPlacementModeModule::<span class="built_in">Get</span>().<span class="built_in">RegisterPlaceableItem</span>(MyCategoryInfo.UniqueHandle, <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(<span class="literal">nullptr</span>, <span class="built_in">FAssetData</span>(XXX:<span class="built_in">StaticClass</span>()))));</span><br></pre></td></tr></table></figure>

<p>我这边在项目设置里丢进去一个数组<code>TArray&lt;TSubclassOf&lt;AActor&gt;&gt; PlacementActors;</code></p>
<p>那就可以动态的扩展这一个标签下的显示对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(UAF_GameSetting_Default* st = UAF_BlueprintLibrary::<span class="built_in">GetDefaultSetting</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;PlacementActors.<span class="built_in">Num</span>()&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : st-&gt;PlacementActors)</span><br><span class="line">        &#123;</span><br><span class="line">            IPlacementModeModule::<span class="built_in">Get</span>().<span class="built_in">RegisterPlaceableItem</span>(MyCategoryInfo.UniqueHandle, <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(<span class="literal">nullptr</span>, <span class="built_in">FAssetData</span>(i))));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	IPlacementModeModule::<span class="built_in">Get</span>().<span class="built_in">RegisterPlaceableItem</span>(MyCategoryInfo.UniqueHandle, <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPlaceableItem</span>(*UAF_ActorFactory::<span class="built_in">StaticClass</span>())));</span><br></pre></td></tr></table></figure>

<p>最后实现效果如下</p>
<p><img src="https://img.supervj.top//img/image-20210813110941324.png" alt="image-20210813110941324"></p>
<p><img src="https://img.supervj.top//img/image-20210813111004071.png" alt="image-20210813111004071"></p>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>PlacementActors</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器扩展：自定义属性界面</title>
    <url>/2021/08/09/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编辑器扩展：自定义属性界面,</p>
<p>未完待续…</p>
<span id="more"></span>

<h3 id="SObjectPropertyEntryBox"><a href="#SObjectPropertyEntryBox" class="headerlink" title="SObjectPropertyEntryBox"></a>SObjectPropertyEntryBox</h3><p>用于选择资源的界面控件</p>
<p><img src="https://img.supervj.top//img/image-20210106105801136.png" alt="image-20210106105801136"></p>
<!-- more -->

<p>直接上代码</p>
<ul>
<li>.h</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">TSharedPtr&lt;FAssetThumbnailPool&gt; AssetThumbnailPool;</span><br><span class="line">UObject* SelectObject;</span><br><span class="line">TSharedPtr&lt;SObjectPropertyEntryBox&gt; EditWidgetBox;</span><br></pre></td></tr></table></figure>

<ul>
<li>cpp</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SOVR_Hud::Construct</span><span class="params">(<span class="keyword">const</span> FArguments&amp; InArgs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AssetThumbnailPool = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FAssetThumbnailPool</span>(<span class="number">24</span>));</span><br><span class="line">    ................................</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SAssignNew</span>(EditWidgetBox,SObjectPropertyEntryBox)</span><br><span class="line">		.<span class="built_in">AllowedClass</span>(UWidgetBlueprint::<span class="built_in">StaticClass</span>())</span><br><span class="line">		.<span class="built_in">OnObjectChanged</span>(<span class="keyword">this</span>, &amp;SOVR_Hud::OnSetObject)</span><br><span class="line">		.<span class="built_in">ObjectPath</span>(<span class="keyword">this</span>,&amp;SOVR_Hud::GetPathName)</span><br><span class="line">		.<span class="built_in">OnShouldFilterAsset</span>(<span class="keyword">this</span>,&amp;SOVR_Hud::ShouldFilterAsset)</span><br><span class="line">		.<span class="built_in">ThumbnailPool</span>(AssetThumbnailPool)</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SOVR_Hud::OnSetObject</span><span class="params">(<span class="keyword">const</span> FAssetData&amp; AssetData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SelectObject = AssetData.<span class="built_in">GetAsset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FString <span class="title">SOVR_Hud::GetPathName</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> SelectObject ? SelectObject-&gt;<span class="built_in">GetPathName</span>() : <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>AllowedClass : Class类型, 这个是资源的类型</li>
<li>OnObjectChanged : 选择改变以后的代理</li>
<li>ObjectPath : 提供资源的路径名称</li>
<li>OnShouldFilterAsset : 过滤选项, 非必须</li>
<li>ThumbnailPool: Icon的对象池, 如果不设置就没有Icon</li>
</ul>
<blockquote>
<p>注意:</p>
<p><code>GetPathName()</code>必须要返回真实的<code>PathName</code>,否则会导致界面显示还是<code>None</code>,如果没有正确的资源那么需要返回空或者<code>None</code>,否则会导致启动插件一次性卡顿并报警告</p>
</blockquote>
<h3 id="SClassPropertyEntryBox"><a href="#SClassPropertyEntryBox" class="headerlink" title="SClassPropertyEntryBox"></a>SClassPropertyEntryBox</h3><p>类似的, 用于选择<code>Class</code>的界面控件</p>
<p><img src="https://img.supervj.top//img/image-20210106110849937.png" alt="image-20210106110849937"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SAssignNew</span>(ClassBox, SClassPropertyEntryBox)</span><br><span class="line">			.<span class="built_in">MetaClass</span>(AActor::<span class="built_in">StaticClass</span>())</span><br><span class="line">		<span class="comment">//.RequiredInterface(UStaticMesh::StaticClass())</span></span><br><span class="line">		.<span class="built_in">IsBlueprintBaseOnly</span>(<span class="literal">false</span>)</span><br><span class="line">		.<span class="built_in">ShowTreeView</span>(<span class="literal">true</span>)</span><br><span class="line">		.<span class="built_in">SelectedClass</span>(<span class="keyword">this</span>, &amp;SOVR_Hud::OnGetClass)</span><br><span class="line">		.<span class="built_in">OnSetClass</span>(<span class="keyword">this</span>, &amp;SOVR_Hud::OnSetClass)</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> UClass* <span class="title">SOVR_Hud::OnGetClass</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> SelectedClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SOVR_Hud::OnSetClass</span><span class="params">(<span class="keyword">const</span> UClass* SetClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SelectedClass = SetClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>Slate</tag>
        <tag>编辑器扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器扩展：自定义预览试图</title>
    <url>/2021/08/18/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A2%84%E8%A7%88%E8%AF%95%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img.supervj.top//img/image-20210819094640216.png" alt="image-20210819094640216"></p>
<p>最近因为项目需要打算做一个简易的插槽编辑器, 因为传统的插槽编辑都需要打开每个静态模型单独编辑, 操作相对比较麻烦, 那么首先需要创建一个自定义的预览试图, 本文先从这个开始</p>
<span id="more"></span>



<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首选创建一个插件， 类型随意， 如果先效率高一点简易选择 <code>Editor Toolbar Button</code>, 这样就直接可以通过一个工具栏按钮启动插件</p>
<p>关于这个按钮， 我个人习惯还是把他放到工具栏最前面，也就是要重写默认模块文件<code>RegisterMenus()</code>方法里的内容， 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工具栏</span></span><br><span class="line">TSharedPtr&lt;FExtender&gt; ToolBarExtender = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FExtender</span>());</span><br><span class="line">ToolBarExtender-&gt;<span class="built_in">AddToolBarExtension</span>(<span class="string">&quot;File&quot;</span>,</span><br><span class="line">                                     EExtensionHook::Before, PluginCommands, FToolBarExtensionDelegate::<span class="built_in">CreateLambda</span>(</span><br><span class="line">                                         [<span class="keyword">this</span>](FToolBarBuilder&amp; Builder)</span><br><span class="line">                                         &#123;</span><br><span class="line">                                             Builder.<span class="built_in">AddToolBarButton</span>(FSimpleSocketEditorCommands::<span class="built_in">Get</span>().PluginAction);</span><br><span class="line">                                         &#125;</span><br><span class="line">                                     ));</span><br><span class="line"></span><br><span class="line">LevelEditorModule.<span class="built_in">GetToolBarExtensibilityManager</span>()-&gt;<span class="built_in">AddExtender</span>(ToolBarExtender);</span><br></pre></td></tr></table></figure>

<p>这样就把按钮放到了<code>File</code>类型的前面, 即最靠前的地方</p>
<p><img src="https://img.supervj.top//img/image-20210819095058833.png" alt="image-20210819095058833"></p>
<h2 id="编辑器创建"><a href="#编辑器创建" class="headerlink" title="编辑器创建"></a>编辑器创建</h2><p>这样默认点击插件按钮出来的就是一个消息窗口， 我们需要参考<code>Standeralone</code>模式的插件来创建一个窗口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSimpleSocketEditorModule::MapActions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PluginCommands = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> FUICommandList);</span><br><span class="line">    PluginCommands-&gt;<span class="built_in">MapAction</span>(</span><br><span class="line">        FSimpleSocketEditorCommands::<span class="built_in">Get</span>().PluginAction,</span><br><span class="line">        FExecuteAction::<span class="built_in">CreateRaw</span>(<span class="keyword">this</span>, &amp;FSimpleSocketEditorModule::PluginButtonClicked),</span><br><span class="line">        <span class="built_in">FCanExecuteAction</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSimpleSocketEditorModule::PluginButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FGlobalTabmanager::<span class="built_in">Get</span>()-&gt;<span class="built_in">TryInvokeTab</span>(SimpleSocketEditorTabName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FGlobalTabmanager::<span class="built_in">Get</span>()-&gt;<span class="built_in">RegisterNomadTabSpawner</span>(SimpleSocketEditorTabName, FOnSpawnTab::<span class="built_in">CreateRaw</span>(<span class="keyword">this</span>, &amp;FSimpleSocketEditorModule::OnSpawnPluginTab))</span><br><span class="line">		.<span class="built_in">SetDisplayName</span>(<span class="built_in">LOCTEXT</span>(<span class="string">&quot;SocketEditorTitil&quot;</span>, <span class="string">&quot;Socket Editor&quot;</span>))</span><br><span class="line">		.<span class="built_in">SetMenuType</span>(ETabSpawnerMenuType::Hidden);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TSharedRef&lt;SDockTab&gt; <span class="title">FSimpleSocketEditorModule::OnSpawnPluginTab</span><span class="params">(<span class="keyword">const</span> FSpawnTabArgs&amp; SpawnTabArgs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">SNew</span>(SDockTab)</span><br><span class="line">		.<span class="built_in">TabRole</span>(ETabRole::NomadTab)</span><br><span class="line">		[</span><br><span class="line">			<span class="built_in">SNew</span>(SSHud_SimpleSocket)</span><br><span class="line">		];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层层相关, 最后打开一个我们自定义的<code>Slate</code>控件</p>
<blockquote>
<p>其实一般情况会创建一个类似资源编辑器的类来作为编辑器视图类, 比如<code>FStaticMeshEditor</code>, 或者如我之前文章<a href="https://supervj.top/2021/04/21/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8/?highlight=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8">创建自定义编辑器</a>写的那种资源编辑器, 但是这里我们就任性一次, 用<code>Slate</code>的方式硬怼出来一个编辑器</p>
</blockquote>
<h2 id="视图类"><a href="#视图类" class="headerlink" title="视图类"></a>视图类</h2><p>然后就是视图相关的类了,  这里有好几个类可以扩展,  虽然都不是必须的, 我们先从最主要的类开始扩展,这个继承自<code>SEditorViewport</code>的类, 他就是我们视图界面的<code>Slate</code>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SEditorViewport_SimpleSocket</span> :</span> <span class="keyword">public</span> SEditorViewport, <span class="keyword">public</span> FGCObject, <span class="keyword">public</span> ICommonEditorViewportToolbarInfoProvider</span><br><span class="line">&#123;<span class="comment">//.....&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们又额外继承了<code>FGCObject</code>(用于GC管理), <code>ICommonEditorViewportToolbarInfoProvider</code>(界面扩展)</p>
<p>接下来重写几个重要函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnFocusViewportToSelection</span><span class="params">()</span><span class="keyword">override</span></span>;<span class="comment">//按键F的实现, 就是聚焦的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> TSharedRef&lt;FEditorViewportClient&gt; <span class="title">MakeEditorViewportClient</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">//界面视图UI的</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;SWidget&gt; <span class="title">MakeViewportToolbar</span><span class="params">()</span><span class="keyword">override</span></span>;<span class="comment">//工具栏UI</span></span><br></pre></td></tr></table></figure>

<p>如果想简单的看到视图效果, 我们可以大致像下面一样实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TSharedRef&lt;FEditorViewportClient&gt; <span class="title">SEditorViewport_SimpleSocket::MakeEditorViewportClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FPreviewScene PreviewScene =  <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FPreviewScene</span>());</span><br><span class="line">EditorViewportClient = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FEditorViewportClient</span>(<span class="literal">nullptr</span>, PreviewScene));</span><br><span class="line">	<span class="keyword">return</span> EditorViewportClient.<span class="built_in">ToSharedRef</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面有两个类我们使用了默认类型, 分别是<code>FPreviewScene</code>和<code>FEditorViewportClient</code></p>
<p>同样的,工具栏也使用默认类型实现即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TSharedPtr&lt;SWidget&gt; <span class="title">SEditorViewport_SimpleSocket::MakeViewportToolbar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">SNew</span>(SCommonEditorViewportToolbarBase, <span class="built_in">SharedThis</span>(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样场景中是黑漆漆一片, 没有任何物体</p>
<p>所以我们需要对<code>PreviewScene</code>对象添加物体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UStaticMesh* mesh =  LoadObject&lt;UStaticMesh&gt;(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;StaticMesh&#x27;/Engine/EngineMeshes/Cube.Cube&#x27;&quot;</span>), <span class="literal">NULL</span>, LOAD_None, <span class="literal">NULL</span>);;</span><br><span class="line">FTransform Transform = FTransform::Identity;</span><br><span class="line">PreviewScene-&gt;<span class="built_in">AddComponent</span>(PreviewMeshComp, Transform);</span><br></pre></td></tr></table></figure>

<p>这样<code>PreviewScene</code>内就有了一个默认的<code>Cube</code>物体了</p>
<h2 id="FAdvancedPreviewScene"><a href="#FAdvancedPreviewScene" class="headerlink" title="FAdvancedPreviewScene"></a>FAdvancedPreviewScene</h2><p>至此场景里虽然能对物体进行光照, 但是还是黑漆漆的, 引擎给了我们一个高级的场景类, 多数的预览试图也是用的该类, 即<code>FAdvancedPreviewScene</code></p>
<p>该对象内有很多参数可以设置, 比如我们可以这样使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line">TSharedPtr&lt;<span class="class"><span class="keyword">class</span> <span class="title">FAdvancedPreviewScene</span>&gt;</span> AdvancedScene;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line">FAdvancedPreviewScene::ConstructionValues ConstructValues;	<span class="comment">//预览场景参数</span></span><br><span class="line">ConstructValues.<span class="built_in">SetCreatePhysicsScene</span>(<span class="literal">false</span>);				<span class="comment">//关闭物理场景</span></span><br><span class="line">ConstructValues.<span class="built_in">ShouldSimulatePhysics</span>(<span class="literal">false</span>);				<span class="comment">//关闭物理模拟</span></span><br><span class="line">ConstructValues.LightBrightness = <span class="number">3</span>;						<span class="comment">//设置光照强度</span></span><br><span class="line">ConstructValues.SkyBrightness = <span class="number">1</span>;							<span class="comment">//设置天空光强度</span></span><br><span class="line">ConstructValues.bEditor = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">AdvancedScene = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FAdvancedPreviewScene</span>(ConstructValues));</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加天空光组件</span></span><br><span class="line">USkyLightComponent* Skylight = NewObject&lt;USkyLightComponent&gt;();</span><br><span class="line">AdvancedScene-&gt;<span class="built_in">AddComponent</span>(Skylight, FTransform::Identity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置地面</span></span><br><span class="line">AdvancedScene-&gt;<span class="built_in">SetFloorVisibility</span>(<span class="literal">false</span>);		<span class="comment">//显示地面，默认就是显示</span></span><br><span class="line">AdvancedScene-&gt;<span class="built_in">SetFloorOffset</span>(<span class="number">100.f</span>);		<span class="comment">//设置地面高度偏移，正数是往下偏移</span></span><br><span class="line"><span class="comment">//设置方向光</span></span><br><span class="line">AdvancedScene-&gt;DirectionalLight-&gt;<span class="built_in">SetMobility</span>(EComponentMobility::Movable);</span><br><span class="line">AdvancedScene-&gt;DirectionalLight-&gt;CastShadows = <span class="literal">true</span>;				<span class="comment">//启用阴影</span></span><br><span class="line">AdvancedScene-&gt;DirectionalLight-&gt;CastStaticShadows = <span class="literal">true</span>;</span><br><span class="line">AdvancedScene-&gt;DirectionalLight-&gt;CastDynamicShadows = <span class="literal">true</span>;</span><br><span class="line">AdvancedScene-&gt;DirectionalLight-&gt;<span class="built_in">SetIntensity</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>



<p>这样就能完成指定图片那种光照效果了</p>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
  </entry>
  <entry>
    <title>编辑器扩展：自定义菜单栏</title>
    <url>/2021/08/09/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E6%A0%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>常见的自定义编辑器菜单类的内容有  菜单(Menu), 菜单栏(MenuBar), 工具栏(ToolBar)</p>
<p>效果如下</p>
<p><img src="https://img.supervj.top//img/image-20210809100140206.png" alt="image-20210809100140206"></p>
<p><img src="https://img.supervj.top//img/image-20210809100206177.png" alt="image-20210809100206177"></p>
<p><img src="https://img.supervj.top//img/image-20210809100220457.png" alt="image-20210809100220457"></p>
<span id="more"></span>



<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>这里主要分为两种方式扩展</p>
<ul>
<li>FExtender</li>
<li>UToolMenu</li>
</ul>
<p>后者为较为新的方式,在老版本和多数博客资料里都没有这个方式</p>
<p>FExtender可以实现3种类型的扩展, 而UToolMenu对于部分扩展比如新的菜单栏添加这种并不支持(4.26)</p>
<h3 id="菜单栏-MenuBar"><a href="#菜单栏-MenuBar" class="headerlink" title="菜单栏 MenuBar"></a>菜单栏 MenuBar</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FLevelEditorModule&amp; LevelEditorModule = FModuleManager::LoadModuleChecked&lt;FLevelEditorModule&gt;(<span class="string">&quot;LevelEditor&quot;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顶部菜单</span></span><br><span class="line">TSharedPtr&lt;FExtender&gt; MenuBarExtender = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FExtender</span>());</span><br><span class="line">MenuBarExtender-&gt;<span class="built_in">AddMenuBarExtension</span>(<span class="string">&quot;Help&quot;</span>, </span><br><span class="line">                                     EExtensionHook::After, PluginCommands, FMenuBarExtensionDelegate::<span class="built_in">CreateRaw</span>(<span class="keyword">this</span>, &amp;FAdvancedFrameworkEditorModule::AddMenuBarExtension));</span><br><span class="line">LevelEditorModule.<span class="built_in">GetMenuExtensibilityManager</span>()-&gt;<span class="built_in">AddExtender</span>(MenuBarExtender);</span><br></pre></td></tr></table></figure>



<p>上述代码的意思即为在<code>Help</code>栏后面添加一个新的菜单栏分类, 然后我们通过函数<code>AddMenuBarExtension</code>来实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAdvancedFrameworkEditorModule::AddMenuBarExtension</span><span class="params">(FMenuBarBuilder&amp; Builder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Builder.<span class="built_in">AddPullDownMenu</span>(</span><br><span class="line">        <span class="built_in">LOCTEXT</span>(<span class="string">&quot;PullMenu&quot;</span>, <span class="string">&quot;AdvancedFramework&quot;</span>),</span><br><span class="line">        <span class="built_in">LOCTEXT</span>(<span class="string">&quot;PullMenu Tips&quot;</span>, <span class="string">&quot;AdvancedFramework Menu&quot;</span>),</span><br><span class="line">        FNewMenuDelegate::<span class="built_in">CreateRaw</span>(<span class="keyword">this</span>, &amp;FAdvancedFrameworkEditorModule::MenuBarPullDown)</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAdvancedFrameworkEditorModule::MenuBarPullDown</span><span class="params">( FMenuBuilder&amp; Builder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Builder.<span class="built_in">AddMenuEntry</span>(FAFE_Commands::<span class="built_in">Get</span>().LoginMap);</span><br><span class="line">	Builder.<span class="built_in">AddMenuEntry</span>(FAFE_Commands::<span class="built_in">Get</span>().TransitionMap);</span><br><span class="line">	Builder.<span class="built_in">AddMenuEntry</span>(FAFE_Commands::<span class="built_in">Get</span>().MapInfoSetup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img.supervj.top//img/image-20210809100206177.png" alt="image-20210809100206177"></p>
<h3 id="菜单-Menu"><a href="#菜单-Menu" class="headerlink" title="菜单 Menu"></a>菜单 Menu</h3><p>菜单就是上述菜单栏内添加的一个MenuEntry, 我们注意到我们用的方式是<code>Builder.AddMenuEntry(FAFE_Commands::Get().LoginMap);</code></p>
<p>这里就要稍微提一下<code>Commands</code>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UI_COMMAND</span>(LoginMap, <span class="string">&quot;Open Login Map&quot;</span>, <span class="string">&quot;Open Login Map&quot;</span>, EUserInterfaceActionType::Button, <span class="built_in">FInputGesture</span>());</span><br></pre></td></tr></table></figure>

<p>在该类里需要声明并用宏定义这个<code>FUICommandInfo</code>对象,  还要注意的是, 如果使用了自定义图标, 那么在<code>Style</code>类里的名称要与这个<code>FUICommandInfo</code>对象的名称要匹配, 比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Style-&gt;<span class="built_in">Set</span>(<span class="string">&quot;AFE.LoginMap&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Map_40x&quot;</span>), Icon40x40));</span><br><span class="line">Style-&gt;<span class="built_in">Set</span>(<span class="string">&quot;AFE.LoginMap.Small&quot;</span>, <span class="keyword">new</span> <span class="built_in">IMAGE_BRUSH</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Map_16x&quot;</span>), Icon16x16));</span><br></pre></td></tr></table></figure>



<p>我们在<code>Windows</code>菜单栏里添加我们的几个测试按钮</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UToolMenu* Menu =  UToolMenus::<span class="built_in">Get</span>()-&gt;<span class="built_in">ExtendMenu</span>(<span class="string">&quot;LevelEditor.MainMenu.Window&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">    FToolMenuSection&amp; Section = Menu-&gt;<span class="built_in">FindOrAddSection</span>(<span class="string">&quot;AdvancedFramework&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        Section.<span class="built_in">AddMenuEntryWithCommandList</span>(FAFE_Commands::<span class="built_in">Get</span>().LoginMap, PluginCommands);</span><br><span class="line">        Section.<span class="built_in">AddMenuEntryWithCommandList</span>(FAFE_Commands::<span class="built_in">Get</span>().TransitionMap, PluginCommands);</span><br><span class="line">        Section.<span class="built_in">AddMenuEntryWithCommandList</span>(FAFE_Commands::<span class="built_in">Get</span>().MapInfoSetup, PluginCommands);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要<code>UToolMenu</code>比较方便, 当然也可以用<code>FExtender</code>来添加, 方法类似于菜单栏的使用</p>
<h3 id="工具栏-ToolBar"><a href="#工具栏-ToolBar" class="headerlink" title="工具栏 ToolBar"></a>工具栏 ToolBar</h3><p>默认创建一个独立窗口插件就会自动生成一个工具栏的插件按钮, 当然我们也可以参考他的实现方式, 用<code>UToolMenu</code>来添加一个<code>Button</code>的方式.</p>
<p>这里我们用传统的<code>FExtender</code>来添加一个下来菜单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工具栏</span></span><br><span class="line">TSharedPtr&lt;FExtender&gt; ToolBarExtender = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FExtender</span>());</span><br><span class="line">ToolBarExtender-&gt;<span class="built_in">AddToolBarExtension</span>(<span class="string">&quot;File&quot;</span>,</span><br><span class="line">                                     EExtensionHook::Before, PluginCommands, FToolBarExtensionDelegate::<span class="built_in">CreateRaw</span>(<span class="keyword">this</span>, &amp;FAdvancedFrameworkEditorModule::AddToolBarExtension));</span><br><span class="line"></span><br><span class="line">LevelEditorModule.<span class="built_in">GetToolBarExtensibilityManager</span>()-&gt;<span class="built_in">AddExtender</span>(ToolBarExtender);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAdvancedFrameworkEditorModule::AddToolBarExtension</span><span class="params">(FToolBarBuilder&amp; Builder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ContextMenu = []()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SNew</span>(SAFE_Hud);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Builder.<span class="built_in">AddSeparator</span>(<span class="string">&quot;AdvancedFramework&quot;</span>);</span><br><span class="line">    Builder.<span class="built_in">AddComboButton</span>(<span class="built_in">FUIAction</span>(), FOnGetContent::<span class="built_in">CreateLambda</span>(ContextMenu),</span><br><span class="line">                           TAttribute&lt;FText&gt;(FText::<span class="built_in">FromString</span>(<span class="string">&quot;AdvancedFramework&quot;</span>)),</span><br><span class="line">                           TAttribute&lt;FText&gt;(FText::<span class="built_in">FromString</span>(<span class="string">&quot;AdvancedFramework Menu&quot;</span>)),</span><br><span class="line">                           <span class="built_in">FSlateIcon</span>(FAFE_Style::<span class="built_in">GetStyleSetName</span>(), <span class="string">&quot;AFE.OpenPluginWindow&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里稍微复杂一点,  通过添加一个<code>ComboButton</code>, 同时返回一个Slate对象来实现</p>
<p><img src="https://img.supervj.top//img/image-20210809102049841.png" alt="image-20210809102049841"></p>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>Slate</tag>
        <tag>编辑器扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4运行时修改按键的解决方案</title>
    <url>/2020/12/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于很多情况下, 我们都希望我们可以在游戏运行状态下自定义UE4的按键映射, 目前的UE已经支持多数平台的按键在蓝图中实时的更改按键设置, 直接保存到 <code>EngineInput.ini</code>文件</p>
<p>写了一个案例插件,提供了几个解决方案的Demo和几个方便蓝图使用的库函数</p>
<a name= "插件">

<p><a href="https://github.com/VJien/RuntimeInputMapping">RuntimeInputMapping</a></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>我们项目设置里的<code>Input</code>栏的内容其实是封装在一个<code>UObject</code>类<code>UInputSettings</code>中, 他其实就是一个配置类,  有一个静态方法可以直接获取该类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> UInputSettings* <span class="title">GetInputSettings</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>蓝图中亦可</p>
<p><img src="https://img.supervj.top//img/image-20201210111434638.png" alt="image-20201210111434638"></p>
<p>看该类的头文件发现, 所有属性几乎都是蓝图不可访问的, 在多数情况下, 我们只需要找到修改按键的API即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = Settings)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddActionMapping</span><span class="params">(<span class="keyword">const</span> FInputActionKeyMapping&amp; KeyMapping, <span class="keyword">bool</span> bForceRebuildKeymaps = <span class="literal">true</span>)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintPure, Category = Settings)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetActionMappingByName</span><span class="params">(<span class="keyword">const</span> FName InActionName, TArray&lt;FInputActionKeyMapping&gt;&amp; OutMappings)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = Settings)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveActionMapping</span><span class="params">(<span class="keyword">const</span> FInputActionKeyMapping&amp; KeyMapping, <span class="keyword">bool</span> bForceRebuildKeymaps = <span class="literal">true</span>)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = Settings)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddAxisMapping</span><span class="params">(<span class="keyword">const</span> FInputAxisKeyMapping&amp; KeyMapping, <span class="keyword">bool</span> bForceRebuildKeymaps = <span class="literal">true</span>)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintPure, Category = Settings)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetAxisMappingByName</span><span class="params">(<span class="keyword">const</span> FName InAxisName, TArray&lt;FInputAxisKeyMapping&gt;&amp; OutMappings)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = Settings)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveAxisMapping</span><span class="params">(<span class="keyword">const</span> FInputAxisKeyMapping&amp; KeyMapping, <span class="keyword">bool</span> bForceRebuildKeymaps = <span class="literal">true</span>)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=Settings)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SaveKeyMappings</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = Settings)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetActionNames</span><span class="params">(TArray&lt;FName&gt;&amp; ActionNames)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = Settings)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetAxisNames</span><span class="params">(TArray&lt;FName&gt;&amp; AxisNames)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = Settings)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ForceRebuildKeymaps</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>还有几个有用的<code>cpp</code>方法,比如<code>void EKeys::GetAllKeys(TArray&lt;FKey&gt;&amp; OutKeys) </code></p>
<p>这里就不过多讲述了</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>为了方便使用, 我们直接封装到一个蓝图库插件里(为什么不是纯蓝图, 因为后面要用到cpp)</p>
<p>在某些时候我们的事件和按键是一对一就足以的(拳皇?), 有时候需要多个按键(第一/三人称模板),所以我们应对PC平台就设计了一个基础UMG,分为两个模式</p>
<p><img src="https://img.supervj.top//img/image-20201212151604993.png" alt="image-20201212151604993"></p>
<p><img src="https://img.supervj.top//img/image-20201212151713192.png" alt="image-20201212151713192"></p>
<p>由主UI根据现有按键映射创建对应数量的控件UI,然后控件UI根据自身的状态修改实时的按键映射</p>
<p>然后封装几个蓝图库函数,方便使用</p>
<p><img src="https://img.supervj.top//img/image-20201212151937655.png" alt="image-20201212151937655"></p>
<p>然后PC端就有了基本解决方案了</p>
<hr>
<p>然后是VR了, 我这里有现成的<code>HTC Vive</code>,  发现<code>4.26.0</code>目前版本<code>FKey</code>内的<code>Vive</code>类型的变量都是蓝图不可访问的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//InputCoreTypes.cpp L799</span></span><br><span class="line">	<span class="built_in">AddKey</span>(<span class="built_in">FKeyDetails</span>(EKeys::Vive_Left_System_Click, <span class="built_in">LOCTEXT</span>(<span class="string">&quot;Vive_Left_System_Click&quot;</span>, <span class="string">&quot;Vive (L) System&quot;</span>), FKeyDetails::GamepadKey | FKeyDetails::NotBlueprintBindableKey, <span class="string">&quot;Vive&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>那么为了图个方便, 设置按键就干脆采用<code>ComboBox</code>的下拉列表的方式来修改按键;那么发现这个方案也使用于PC或者其他各个平台(不需要靠手动按键来设置按键映射)</p>
<p><img src="https://img.supervj.top//img/image-20201212152518034.png" alt="image-20201212152518034"></p>
<p>关键就是给<code>ComboBox</code>提供我们其他平台蓝图看不到的按键</p>
<p>先声明一个对应所有类型(<code>Category</code>)的枚举</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">ERIMKeyCategory</span> :</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">	None,</span><br><span class="line">	Key,</span><br><span class="line">	Mouse,</span><br><span class="line">	Gamepad,</span><br><span class="line">	Motion,</span><br><span class="line">	Touch,</span><br><span class="line">	Gesture,</span><br><span class="line">	PS4,</span><br><span class="line">	Steam,</span><br><span class="line">	XBoxOne,</span><br><span class="line">	Android,</span><br><span class="line">	Daydream,</span><br><span class="line">	Vive,</span><br><span class="line">	MixedReality,</span><br><span class="line">	OculusGo,</span><br><span class="line">	OculusTouch,</span><br><span class="line">	ValveIndex,</span><br><span class="line">	MagicLeap,</span><br><span class="line">	OculusRemote,</span><br><span class="line">	Cosmos</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后整几个库函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable,BlueprintPure ,Category = <span class="string">&quot;RuntimeInputMapping&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetAllKeys</span><span class="params">(TArray&lt;FKey&gt;&amp; OutKeys)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;RuntimeInputMapping&quot;</span>, meta = (AutoCreateRefTerm = <span class="string">&quot;Categories&quot;</span>))</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetAllKeysWithCategories</span><span class="params">(TArray&lt;ERIMKeyCategory&gt; Categories, TArray&lt;FKey&gt;&amp; OutKeys)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;RuntimeInputMapping&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> FName <span class="title">GetKeyFName</span><span class="params">(FKey key)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;RuntimeInputMapping&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> FKey <span class="title">GetKeyByFName</span><span class="params">(FName name)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;RuntimeInputMapping&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> FKey <span class="title">GetKeyByDisplayName</span><span class="params">(FText name)</span></span>;</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;RuntimeInputMapping&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> FName <span class="title">GetKeyMenuCategory</span><span class="params">(FKey key)</span></span>;</span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintPure, Category = <span class="string">&quot;RuntimeInputMapping&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> FString <span class="title">GetKeyCategoryEnumString</span><span class="params">(ERIMKeyCategory category = ERIMKeyCategory::None, <span class="keyword">bool</span> bShortName = <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后蓝图里就可以创建控件UI了</p>
<p><img src="https://img.supervj.top//img/image-20201212153047135.png" alt="image-20201212153047135"></p>
<p><img src="https://img.supervj.top//img/image-20201212153108452.png" alt="image-20201212153108452"></p>
<p>稍微注意点的就是 <code>FKey</code>有两个名字, 一个是<code>FName</code>,一个是<code>DisplayName</code>,需要区分开.</p>
<p>如</p>
<ul>
<li><code>FName</code>:  <code>Vive_Left_System_Click</code></li>
<li><code>DisplayName</code>: <code>Vive (L) System</code></li>
</ul>
<p>具体参考<code>InputCoreTypes.cpp</code>文件中茫茫多的<code>AddKey()</code></p>
<p>演示一下</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_12_15_33_54_468.gif" alt="录制_2020_12_12_15_33_54_468"></p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_12_15_34_45_13.gif" alt="录制_2020_12_12_15_34_45_13"></p>
<p>VR道理相同, 无非就是要用到<code>WidgetInteraction</code>来模拟点击</p>
<blockquote>
<p>这里有个小问题, 如果默认情况下没有任何<code>Vive</code>的按键, 蓝图中的<code>AnyKey</code>无法接收到手柄事件,如果给了一个比如是<code>Vive(R) Trigger</code>的按键, 那么就可以有了.</p>
<p>应对这个,那么建议默认还是给上对应的设备按键事件, 后期运行后(打包后)只需要修改就行</p>
</blockquote>
<p>具体实现方法可以参考插件内容 <a href="#%E6%8F%92%E4%BB%B6">↑</a></p>
]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>按键</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的自定义视图和节点</title>
    <url>/2020/08/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%E5%92%8C%E8%8A%82%E7%82%B91/</url>
    <content><![CDATA[<blockquote>
<p>本文描述了如何简单的创建自定义的视图和节点</p>
<p>后续补充具体功能开发</p>
</blockquote>
<img src="https://img.supervj.top/img/other/image-20200805140828530.png" alt="image-20200805140828530" style="zoom:50%;" />

<h5 id="插件模块"><a href="#插件模块" class="headerlink" title="插件模块"></a>插件模块</h5><p>创建插件<code>TestGraph</code></p>
<ul>
<li>包含如下模块</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Projects&quot;,</span><br><span class="line">&quot;InputCore&quot;,</span><br><span class="line">&quot;UnrealEd&quot;,</span><br><span class="line">&quot;LevelEditor&quot;,</span><br><span class="line">&quot;CoreUObject&quot;,</span><br><span class="line">&quot;Engine&quot;,</span><br><span class="line">&quot;Slate&quot;,</span><br><span class="line">&quot;SlateCore&quot;,</span><br><span class="line">&quot;ToolMenus&quot;,</span><br><span class="line">&quot;GraphEditor&quot;,</span><br><span class="line">&quot;EditorStyle&quot;</span><br></pre></td></tr></table></figure>

<p>在模块类里声明2个变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UEdGraph</span>* <span class="title">GraphObj</span>;</span><span class="comment">//图表实例的类型，定义了该图表的行为（例如保存图表</span></span><br><span class="line">TSharedPtr&lt;<span class="class"><span class="keyword">class</span> <span class="title">SGraphEditor</span>&gt;</span> GraphEdSlate;<span class="comment">//图表编辑器的Slate类型</span></span><br></pre></td></tr></table></figure>

<p>构造<code>GraphObj</code>，指定<code>GraphObj</code>内的<code>Schema</code></p>
<p>创建<code>GraphEdSlate</code>，同时把<code>GraphObj</code>指定给<code>GraphEdSlate</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GraphObj=NewObject&lt;UEdGraph&gt;();</span><br><span class="line">GraphObj-&gt;<span class="built_in">AddToRoot</span>();</span><br><span class="line">GraphObj-&gt;Schema=UTestGraphSchema::<span class="built_in">StaticClass</span>();<span class="comment">//自定义的schema类，刚开始可以先使用默认的UGraphSchema即可显示基础图表</span></span><br><span class="line">GraphEdSlate=<span class="built_in">SNew</span>(SGraphEditor)</span><br><span class="line">    .<span class="built_in">GraphToEdit</span>(GraphObj);</span><br></pre></td></tr></table></figure>

<p>在返回中添加次<code>Slate</code>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">SNew</span>(SDockTab)</span><br><span class="line">		.<span class="built_in">TabRole</span>(ETabRole::NomadTab)</span><br><span class="line">		[</span><br><span class="line">			<span class="comment">// Put your tab content here!</span></span><br><span class="line">			<span class="built_in">SNew</span>(SBox)</span><br><span class="line">			.<span class="built_in">HAlign</span>(HAlign_Fill)</span><br><span class="line">			.<span class="built_in">VAlign</span>(VAlign_Fill)</span><br><span class="line">			[</span><br><span class="line">				GraphEdSlate.<span class="built_in">ToSharedRef</span>()<span class="comment">//需要转成ref</span></span><br><span class="line">			]</span><br><span class="line">		];</span><br></pre></td></tr></table></figure>

<h5 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h5><ol>
<li><code>EdGraphSchema</code>里定义了图表操作的大部分全局行为</li>
<li>在<code>FBlueprintEditorUtils::CreateNewGraph</code>中将<code>UEdGraph</code>和<code>EdGraphSchema</code>建立映射</li>
<li><code>FEdGraphSchemaAction</code>类主要执行了一个<code>PerformAction</code>，用于生成<code>UEdGraphNode</code></li>
</ol>
<h6 id="FEdGraphSchemaAction"><a href="#FEdGraphSchemaAction" class="headerlink" title="FEdGraphSchemaAction"></a>FEdGraphSchemaAction</h6><ul>
<li>PerformAction</li>
</ul>
<p>生成节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UEdGraphNode* <span class="title">FTestGraphSchemaAction::PerformAction</span><span class="params">(class UEdGraph* ParentGraph, UEdGraphPin* FromPin, <span class="keyword">const</span> FVector2D Location, <span class="keyword">bool</span> bSelectNewNode <span class="comment">/* = true */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UEdGraphNode* resNode=<span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (NodeHello)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="keyword">const</span> FScopedTransaction <span class="title">Trans</span><span class="params">(LOCTEXT(<span class="string">&quot;FF&quot;</span>,<span class="string">&quot;Hello:NewNode&quot;</span>))</span></span>;</span><br><span class="line">		ParentGraph-&gt;<span class="built_in">Modify</span>();</span><br><span class="line">		<span class="keyword">if</span> (FromPin!=<span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			FromPin-&gt;<span class="built_in">Modify</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		NodeHello-&gt;<span class="built_in">Rename</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;TEST&quot;</span>),ParentGraph);</span><br><span class="line">		ParentGraph-&gt;<span class="built_in">AddNode</span>(NodeHello,<span class="literal">true</span>,bSelectNewNode);</span><br><span class="line"></span><br><span class="line">		NodeHello-&gt;<span class="built_in">CreateNewGuid</span>();<span class="comment">//唯一标识</span></span><br><span class="line">		NodeHello-&gt;<span class="built_in">PostPlacedNewNode</span>();<span class="comment">//初始化</span></span><br><span class="line">		NodeHello-&gt;<span class="built_in">AllocateDefaultPins</span>();<span class="comment">//针脚</span></span><br><span class="line">		NodeHello-&gt;<span class="built_in">AutowireNewNode</span>(FromPin);<span class="comment">//自动创建节点</span></span><br><span class="line"></span><br><span class="line">		NodeHello-&gt;NodePosX=Location.X;</span><br><span class="line">		NodeHello-&gt;NodePosY = Location.Y;</span><br><span class="line"></span><br><span class="line">		NodeHello-&gt;<span class="built_in">SetFlags</span>(RF_Transactional);</span><br><span class="line"></span><br><span class="line">		resNode=NodeHello;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> resNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="UEdGraphSchema"><a href="#UEdGraphSchema" class="headerlink" title="UEdGraphSchema"></a>UEdGraphSchema</h6><ul>
<li>GetGraphContextActions</li>
</ul>
<p>右键点击空白页面，用于创建选择节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UTestGraphSchema::GetGraphContextActions</span><span class="params">(FGraphContextMenuBuilder&amp; ContextMenuBuilder)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">TSharedPtr&lt;FTestGraphSchemaAction&gt; <span class="title">NewNodeAction</span><span class="params">(<span class="keyword">new</span> </span></span></span><br><span class="line"><span class="params"><span class="function">	FTestGraphSchemaAction(LOCTEXT(<span class="string">&quot;11&quot;</span>,<span class="string">&quot;GraphNode&quot;</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">	LOCTEXT(<span class="string">&quot;Desc&quot;</span>,<span class="string">&quot;TestNodeDesc&quot;</span>), <span class="comment">//desc</span></span></span></span><br><span class="line"><span class="params"><span class="function">	LOCTEXT(<span class="string">&quot;NewGraphText&quot;</span>,<span class="string">&quot;Add Hello Node&quot;</span>),<span class="comment">//hover</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">	NewNodeAction-&gt;NodeHello=NewObject&lt;UTestNode_Hello&gt;(ContextMenuBuilder.OwnerOfTemporaries<span class="comment">/*存储节点*/</span>);</span><br><span class="line">	ContextMenuBuilder.<span class="built_in">AddAction</span>(NewNodeAction);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top/img/other/image-20200805110906761.png" alt="image-20200805110906761"></p>
<p>如上图，显示3个对应的名称</p>
<ul>
<li>GetContextMenuActions</li>
</ul>
<p>右键点击节点后的效果，产生例如<code>BreakLink</code>之类的效果</p>
<blockquote>
<p>此方法在4.24版本(不确定之前哪个版本开始)有更改如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetContextMenuActions</span><span class="params">(class UToolMenu* Menu, class UGraphNodeContextMenuContext* Context)</span><span class="keyword">const</span><span class="comment">//新版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetContextMenuActions</span><span class="params">(<span class="keyword">const</span> UEdGraph* CurrentGraph, <span class="keyword">const</span> UEdGraphNode* InGraphNode, <span class="keyword">const</span> UEdGraphPin* InGraphPin, class FMenuBuilder* MenuBuilder, <span class="keyword">bool</span> bIsDebugging)</span> <span class="keyword">const</span></span>; <span class="comment">//旧版本   </span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UTestGraphSchema::GetContextMenuActions</span><span class="params">(class UToolMenu* Menu, class UGraphNodeContextMenuContext* Context)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Context-&gt;Pin)</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			FToolMenuSection&amp; Section = Menu-&gt;<span class="built_in">AddSection</span>(<span class="string">&quot;TestGraphSchemaNodeActions&quot;</span>, <span class="built_in">LOCTEXT</span>(<span class="string">&quot;PinActionsMenuHeader&quot;</span>, <span class="string">&quot;Pin Actions ___&quot;</span>));</span><br><span class="line">			<span class="comment">// Only display the &#x27;Break Links&#x27; option if there is a link to break!</span></span><br><span class="line">			<span class="keyword">if</span> (Context-&gt;Pin-&gt;LinkedTo.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Section.<span class="built_in">AddMenuEntry</span>(FGraphEditorCommands::<span class="built_in">Get</span>().BreakPinLinks);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// add sub menu for break link to</span></span><br><span class="line">				<span class="keyword">if</span> (Context-&gt;Pin-&gt;LinkedTo.<span class="built_in">Num</span>() &gt; <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					Section.<span class="built_in">AddSubMenu</span>(</span><br><span class="line">						<span class="string">&quot;BreakLinkTo&quot;</span>,</span><br><span class="line">						<span class="built_in">LOCTEXT</span>(<span class="string">&quot;BreakLinkTo&quot;</span>, <span class="string">&quot;Break Link To...&quot;</span>),</span><br><span class="line">						<span class="built_in">LOCTEXT</span>(<span class="string">&quot;BreakSpecificLinks&quot;</span>, <span class="string">&quot;Break a specific link...&quot;</span>),		</span><br><span class="line">						&#123;&#125;</span><br><span class="line">						);</span><br><span class="line">				&#125;				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="keyword">if</span> (Context-&gt;Node)</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			FToolMenuSection&amp; Section = Menu-&gt;<span class="built_in">AddSection</span>(<span class="string">&quot;TestGraphSchemaNodeActions&quot;</span>, <span class="built_in">LOCTEXT</span>(<span class="string">&quot;ClassActionsMenuHeader&quot;</span>, <span class="string">&quot;Node Actions&quot;</span>));</span><br><span class="line">			Section.<span class="built_in">AddMenuEntry</span>(FGenericCommands::<span class="built_in">Get</span>().Delete);</span><br><span class="line">			Section.<span class="built_in">AddMenuEntry</span>(FGenericCommands::<span class="built_in">Get</span>().Cut);</span><br><span class="line">			Section.<span class="built_in">AddMenuEntry</span>(FGenericCommands::<span class="built_in">Get</span>().Copy);</span><br><span class="line">			Section.<span class="built_in">AddMenuEntry</span>(FGenericCommands::<span class="built_in">Get</span>().Duplicate);</span><br><span class="line"></span><br><span class="line">			Section.<span class="built_in">AddMenuEntry</span>(FGraphEditorCommands::<span class="built_in">Get</span>().BreakNodeLinks);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Super::<span class="built_in">GetContextMenuActions</span>(Menu, Context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top/img/other/image-20200805111804599.png" alt="image-20200805111804599"></p>
<h6 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>()</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ECanCreateConnectionResponse</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/** 多对多 */</span></span><br><span class="line">	CONNECT_RESPONSE_MAKE,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*不能连接，默认 */</span></span><br><span class="line">	CONNECT_RESPONSE_DISALLOW,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 多对一 */</span></span><br><span class="line">	CONNECT_RESPONSE_BREAK_OTHERS_A,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 一对多 */</span></span><br><span class="line">	CONNECT_RESPONSE_BREAK_OTHERS_B,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 一对一 */</span></span><br><span class="line">	CONNECT_RESPONSE_BREAK_OTHERS_AB,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Make the connection via an intermediate cast node, or some other conversion node. */</span></span><br><span class="line">	CONNECT_RESPONSE_MAKE_WITH_CONVERSION_NODE,</span><br><span class="line"></span><br><span class="line">	CONNECT_RESPONSE_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重写<code>CanCreateConnection</code>设置节点的连接方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> FPinConnectionResponse <span class="title">CanCreateConnection</span><span class="params">(<span class="keyword">const</span> UEdGraphPin* A, <span class="keyword">const</span> UEdGraphPin* B)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FPinConnectionResponse</span>(CONNECT_RESPONSE_BREAK_OTHERS_A, <span class="built_in">TEXT</span>(<span class="string">&quot;Not 2 by this schema&quot;</span>));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建连接方式</li>
</ul>
<p>使用自定义的类<code>FTestConnectionDrawingPolicy</code>来定义连接方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">class FConnectionDrawingPolicy* <span class="title">UTestGraphSchema::CreateConnectionDrawingPolicy</span><span class="params">(int32 InBackLayerID, int32 InFrontLayerID, <span class="keyword">float</span> InZoomFactor, <span class="keyword">const</span> FSlateRect&amp; InClippingRect, class FSlateWindowElementList&amp; InDrawElements, class UEdGraph* InGraphObj)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">FTestConnectionDrawingPolicy</span>(InBackLayerID,InFrontLayerID,InZoomFactor,InClippingRect,InDrawElements, InGraphObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="自定义节点"><a href="#自定义节点" class="headerlink" title="自定义节点"></a>自定义节点</h5><h6 id="UEdGraphNode"><a href="#UEdGraphNode" class="headerlink" title="UEdGraphNode"></a>UEdGraphNode</h6><ol>
<li><code>EdGraphNode</code>是图表节点实例的类型，定义了节点的行为</li>
<li><code>AutowireNewNode</code>定义了节点的自动连接行为( 参考上述在schema创建的时候调用)</li>
</ol>
<p><code>class UTestNode_Hello :public UEdGraphNode</code></p>
<p>重写2个方法</p>
<p><code>AllocateDefaultPins</code>：用于创建节点</p>
<p><code>GetNodeTitle</code>：标题</p>
<blockquote>
<p>可以参考系统的节点</p>
<p>目录大多在 <code>\Engine\Source\Editor\GraphEditor\Public\KismetPins\</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UTestNode_Hello::AllocateDefaultPins</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input,<span class="string">&quot;HelloNodeInput_Bool&quot;</span>,<span class="built_in">FName</span>(),<span class="built_in">TEXT</span>(<span class="string">&quot;bool&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, <span class="string">&quot;HelloNodeInput_Color&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;color&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, <span class="string">&quot;HelloNodeInput_Enum&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;enum&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, <span class="string">&quot;HelloNodeInput_Exec&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;exec&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, <span class="string">&quot;HelloNodeInput_NameList&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;namelist&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, <span class="string">&quot;HelloNodeInput_Object&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;obj&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, <span class="string">&quot;HelloNodeInput_String&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;str&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, <span class="string">&quot;HelloNodeInput_Vector4&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;v4&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, <span class="string">&quot;HelloNodeInput_Integer&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;int&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, <span class="string">&quot;HelloNodeInput_Vector2&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;v2&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Output, <span class="string">&quot;HelloNodeInput_1&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Output, <span class="string">&quot;HelloNodeInput_2&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Output, <span class="string">&quot;HelloNodeInput_3&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Output, <span class="string">&quot;HelloNodeInput_4&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;4&quot;</span>));</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Output, <span class="string">&quot;HelloNodeInput_5&quot;</span>, <span class="built_in">FName</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;5&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FText <span class="title">UTestNode_Hello::GetNodeTitle</span><span class="params">(ENodeTitleType::Type TitleType)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="string">&quot;Hello !&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="SGraphNode"><a href="#SGraphNode" class="headerlink" title="SGraphNode"></a>SGraphNode</h6><p>此类是用于显示具体效果的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Construct</span><span class="params">(<span class="keyword">const</span> FArguments&amp; InArgs, UEdGraphNode* InNode)</span></span>;<span class="comment">//构造跟默认slate不一样</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">UpdateGraphNode</span><span class="params">()</span><span class="keyword">override</span></span>;<span class="comment">//刷新节点</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreatePinWidgets</span><span class="params">()</span><span class="keyword">override</span></span>;<span class="comment">//创建pin的ui显示</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddPin</span><span class="params">( <span class="keyword">const</span> TSharedRef&lt;SGraphPin&gt;&amp; PinToAdd )</span><span class="keyword">override</span></span>;<span class="comment">//添加pin，不重写就使用默认的(一个圆点)</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	TSharedPtr&lt;<span class="class"><span class="keyword">class</span> <span class="title">SBox</span>&gt;</span> PinBox;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GraphNode= InNode;<span class="comment">//自带的变量,存储对应的UEdGraphNode</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">SetCursor</span>(EMouseCursor::GrabHand);<span class="comment">//鼠标样式</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">UpdateGraphNode</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>刷新节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STestNode::UpdateGraphNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//清空所有的Pin和box</span></span><br><span class="line">	InputPins.<span class="built_in">Empty</span>();</span><br><span class="line">	OutputPins.<span class="built_in">Empty</span>();</span><br><span class="line">	RightNodeBox.<span class="built_in">Reset</span>();</span><br><span class="line">	LeftNodeBox.<span class="built_in">Reset</span>();</span><br><span class="line">	<span class="comment">//从style得到icon</span></span><br><span class="line">	<span class="keyword">const</span> FSlateBrush* nodeIcon=FEditorStyle::<span class="built_in">GetBrush</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Graph.StateNode.Icon&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//用此方法创建一个视图</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">GetOrAddSlot</span>(ENodeZone::Center)</span><br><span class="line">		.<span class="built_in">HAlign</span>(HAlign_Center)</span><br><span class="line">		.<span class="built_in">VAlign</span>(VAlign_Center)</span><br><span class="line">		[</span><br><span class="line">			<span class="built_in">SAssignNew</span>(PinBox,SBox)</span><br><span class="line">			.<span class="built_in">VAlign</span>(VAlign_Fill)</span><br><span class="line">			.<span class="built_in">HAlign</span>(HAlign_Fill)</span><br><span class="line">			[</span><br><span class="line">				<span class="built_in">SNew</span>(SBorder)</span><br><span class="line">				.<span class="built_in">BorderBackgroundColor_Lambda</span>([&amp;]()</span><br><span class="line">			&#123;</span><br><span class="line">				FSlateColor <span class="built_in">color</span>(<span class="built_in">FLinearColor</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">				<span class="keyword">return</span> color;</span><br><span class="line">			&#125;)</span><br><span class="line">        <span class="comment">//注释代码可以手动设置图片</span></span><br><span class="line">		<span class="comment">//.BorderImage_Lambda([&amp;]()</span></span><br><span class="line">		<span class="comment">//	&#123;</span></span><br><span class="line">		<span class="comment">//	const FVector2D iconSize(64.0,64.0);</span></span><br><span class="line">		<span class="comment">//	return FTestGraphStyle::GetImageBrush(TEXT(&quot;ButtonIcon_40x&quot;),iconSize);</span></span><br><span class="line">		<span class="comment">//	&#125;)	</span></span><br><span class="line">			[</span><br><span class="line">                <span class="comment">//添加2个自带的NodeBox，注意顺序需要先左后右</span></span><br><span class="line">				<span class="built_in">SNew</span>(SHorizontalBox)</span><br><span class="line">				+SHorizontalBox::<span class="built_in">Slot</span>()</span><br><span class="line">				.<span class="built_in">HAlign</span>(HAlign_Fill)</span><br><span class="line">				.<span class="built_in">VAlign</span>(VAlign_Fill)</span><br><span class="line">				.<span class="built_in">AutoWidth</span>()</span><br><span class="line">				[</span><br><span class="line">					<span class="built_in">SAssignNew</span>(LeftNodeBox,SVerticalBox)</span><br><span class="line">				]</span><br><span class="line">			+ SHorizontalBox::<span class="built_in">Slot</span>()</span><br><span class="line">				.<span class="built_in">HAlign</span>(HAlign_Fill)</span><br><span class="line">				.<span class="built_in">VAlign</span>(VAlign_Fill)</span><br><span class="line">				.<span class="built_in">AutoWidth</span>()</span><br><span class="line">				[</span><br><span class="line">					<span class="built_in">SAssignNew</span>(RightNodeBox,SVerticalBox)</span><br><span class="line">				]</span><br><span class="line"></span><br><span class="line">			]</span><br><span class="line"></span><br><span class="line">			]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置顶层box尺寸</span></span><br><span class="line">		PinBox-&gt;<span class="built_in">SetWidthOverride</span>(<span class="number">400</span>);</span><br><span class="line">		PinBox-&gt;<span class="built_in">SetHeightOverride</span>(<span class="number">600</span>);</span><br><span class="line"><span class="comment">//创建PinWidget</span></span><br><span class="line">		<span class="built_in">CreatePinWidgets</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建Pin的图形</li>
</ul>
<p>2种方式，可以手动指定Pin，也可以使用系统的Pin</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动指定所有Pin</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STestNode::CreatePinWidgets</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UTestNode_Hello* helloNode=CastChecked&lt;UTestNode_Hello&gt;(GraphNode);</span><br><span class="line">	<span class="keyword">if</span> (helloNode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//全部的Pin都指定为STestPin</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : helloNode-&gt;Pins)</span><br><span class="line">		&#123;</span><br><span class="line">			TSharedPtr&lt;SGraphPin&gt; pin = <span class="built_in">SNew</span>(STestPin, p);</span><br><span class="line">			pin-&gt;<span class="built_in">SetIsEditable</span>(IsEditable);<span class="comment">//把Node的可编辑性赋予Pin</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">AddPin</span>(pin.<span class="built_in">ToSharedRef</span>());<span class="comment">//添加pin</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用系统的Pin</span></span><br><span class="line"><span class="comment">//用一个宏快速定义</span></span><br><span class="line"><span class="comment">//注意宏里的newPin对应的是第15行创建的指针变量</span></span><br><span class="line"><span class="comment">//顺序对应的是UEdGraphNode中创建的Pin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET_PIN(STestPin,GraphPinObj,...)\</span></span><br><span class="line"><span class="meta">		newPin = SNew(STestPin,GraphPinObj,__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">		newPin-&gt;SetIsEditable(IsEditable);\</span></span><br><span class="line"><span class="meta">		this-&gt;AddPin(newPin.ToSharedRef());</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STestNode::CreatePinWidgets</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> TArray&lt;TSharedPtr&lt;FName&gt;&gt; nameList;</span><br><span class="line">	nameList.<span class="built_in">Add</span>(<span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FName</span>(<span class="string">&quot;player&quot;</span>)));</span><br><span class="line">	nameList.<span class="built_in">Add</span>(<span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FName</span>(<span class="string">&quot;monster&quot;</span>)));</span><br><span class="line">	nameList.<span class="built_in">Add</span>(<span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FName</span>(<span class="string">&quot;ai&quot;</span>)));</span><br><span class="line"></span><br><span class="line">	TSharedPtr&lt;SGraphPin&gt; newPin=<span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinBool,helloNode-&gt;Pins[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinColor, helloNode-&gt;Pins[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinEnum, helloNode-&gt;Pins[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinExec, helloNode-&gt;Pins[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinNameList, helloNode-&gt;Pins[<span class="number">4</span>],nameList);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinObject, helloNode-&gt;Pins[<span class="number">5</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinString, helloNode-&gt;Pins[<span class="number">6</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinVector4, helloNode-&gt;Pins[<span class="number">7</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinInteger, helloNode-&gt;Pins[<span class="number">8</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinVector2D, helloNode-&gt;Pins[<span class="number">9</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(SGraphPinClass, helloNode-&gt;Pins[<span class="number">10</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(STestPin, helloNode-&gt;Pins[<span class="number">11</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(STestPin, helloNode-&gt;Pins[<span class="number">12</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(STestPin, helloNode-&gt;Pins[<span class="number">13</span>]);</span><br><span class="line">	<span class="built_in">RESET_PIN</span>(STestPin, helloNode-&gt;Pins[<span class="number">14</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>AddPin</li>
</ul>
<p>用来设置Pin的显示和布局</p>
<p>如果不重写，就使用系统自带的Pin（非常的小）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STestNode::AddPin</span><span class="params">(<span class="keyword">const</span> TSharedRef&lt;SGraphPin&gt;&amp; PinToAdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置owner</span></span><br><span class="line">	PinToAdd-&gt;<span class="built_in">SetOwner</span>(<span class="built_in">SharedThis</span>(<span class="keyword">this</span>));</span><br><span class="line">	<span class="comment">//得到对应的Obj</span></span><br><span class="line">	<span class="keyword">const</span> UEdGraphPin* PinObj = PinToAdd-&gt;<span class="built_in">GetPinObj</span>();</span><br><span class="line">    <span class="comment">//设置可见性</span></span><br><span class="line">	<span class="keyword">if</span> (PinObj&amp;&amp;PinObj-&gt;bAdvancedView)</span><br><span class="line">	&#123;</span><br><span class="line">		PinToAdd-&gt;<span class="built_in">SetVisibility</span>(TAttribute&lt;EVisibility&gt;(PinToAdd, &amp;SGraphPin::IsPinVisibleAsAdvanced));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CUSTOM_PIN</span></span><br><span class="line">    <span class="comment">//如果是自定义的Pin就设置缩放，用系统自带的就不需要了</span></span><br><span class="line">	PinToAdd-&gt;<span class="built_in">SetDesiredSizeScale</span>(<span class="built_in">FVector2D</span>(<span class="number">16</span>, <span class="number">16</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是输入和是输出节点</span></span><br><span class="line">	<span class="keyword">if</span> (PinToAdd-&gt;<span class="built_in">GetDirection</span>() == EEdGraphPinDirection::EGPD_Input)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//添加到左边盒子里</span></span><br><span class="line">		LeftNodeBox-&gt;<span class="built_in">AddSlot</span>()</span><br><span class="line">			.<span class="built_in">HAlign</span>(HAlign_Fill)</span><br><span class="line">			.<span class="built_in">VAlign</span>(VAlign_Fill)</span><br><span class="line">			.<span class="built_in">FillHeight</span>(<span class="number">1.0f</span>)</span><br><span class="line">			.<span class="built_in">Padding</span>(<span class="number">20.0f</span>, <span class="number">0</span>)</span><br><span class="line">			[</span><br><span class="line">				PinToAdd</span><br><span class="line">			];</span><br><span class="line">        <span class="comment">//添加到InputPins数组里</span></span><br><span class="line">		InputPins.<span class="built_in">Add</span>(PinToAdd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (PinToAdd-&gt;<span class="built_in">GetDirection</span>() == EEdGraphPinDirection::EGPD_Output)</span><br><span class="line">	&#123;</span><br><span class="line">		RightNodeBox-&gt;<span class="built_in">AddSlot</span>()</span><br><span class="line">			.<span class="built_in">HAlign</span>(HAlign_Right)</span><br><span class="line">			.<span class="built_in">VAlign</span>(VAlign_Center)</span><br><span class="line">			.<span class="built_in">FillHeight</span>(<span class="number">1.0f</span>)</span><br><span class="line">			.<span class="built_in">Padding</span>(<span class="number">-30.0f</span>, <span class="number">0.f</span>)</span><br><span class="line">			[</span><br><span class="line">				PinToAdd</span><br><span class="line">			];</span><br><span class="line">		OutputPins.<span class="built_in">Add</span>(PinToAdd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h5 id="自定义连线"><a href="#自定义连线" class="headerlink" title="自定义连线"></a>自定义连线</h5><p>继承自<code>FConnectionDrawingPolicy</code></p>
<ul>
<li>构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="built_in">FTestConnectionDrawingPolicy</span>(int32 InBackLayerID, <span class="comment">//线ID</span></span><br><span class="line">	int32 InFrontLayerID, <span class="comment">//箭头ID</span></span><br><span class="line">	<span class="keyword">float</span> InZoomFactor, <span class="comment">//缩放</span></span><br><span class="line">	<span class="keyword">const</span> FSlateRect&amp; InClippingRect,<span class="comment">//视口裁剪 </span></span><br><span class="line">	FSlateWindowElementList&amp; InDrawElements,<span class="comment">//绘制元素</span></span><br><span class="line">	UEdGraph* InGraphObj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protected:</span></span><br><span class="line"><span class="comment">	UEdGraph* EdGraphObj;</span></span><br><span class="line"><span class="comment">	TMap&lt;UEdGraph*, int32&gt;EdNodeWidgetMap;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cpp</span></span><br><span class="line">FTestConnectionDrawingPolicy::<span class="built_in">FTestConnectionDrawingPolicy</span>(int32 InBackLayerID, int32 InFrontLayerID, <span class="keyword">float</span> InZoomFactor, <span class="keyword">const</span> FSlateRect&amp; InClippingRect, FSlateWindowElementList&amp; InDrawElements , UEdGraph* InGraphObj)</span><br><span class="line">:<span class="built_in">FConnectionDrawingPolicy</span>(InBackLayerID,InFrontLayerID,InZoomFactor,InClippingRect,InDrawElements),<span class="built_in">EdGraphObj</span>(InGraphObj)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置样式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FTestConnectionDrawingPolicy::DetermineWiringStyle</span><span class="params">(UEdGraphPin* OutputPin, UEdGraphPin* InputPin, <span class="comment">/*inout*/</span> FConnectionParams&amp; Params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Params.WireThickness=<span class="number">3</span>;<span class="comment">//宽度</span></span><br><span class="line">	Params.WireColor=FLinearColor::Green;<span class="comment">//颜色</span></span><br><span class="line">	<span class="keyword">if</span> (HoveredPins.<span class="built_in">Num</span>()&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ApplyHoverDeemphasis</span>(OutputPin,InputPin, Params.WireThickness = <span class="number">3</span>, Params.WireColor);<span class="comment">//此方法显示拖动效果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>绘制连接</li>
</ul>
<p>如果不重写就使用默认的贝塞尔曲线</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绘制直线+流动的泡泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FTestConnectionDrawingPolicy::DrawConnection</span><span class="params">(int32 LayerId, <span class="keyword">const</span> FVector2D&amp; Start, <span class="keyword">const</span> FVector2D&amp; End, <span class="keyword">const</span> FConnectionParams&amp; Params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> FVector2D delta=End-Start;</span><br><span class="line">	<span class="keyword">const</span> FVector2D DirDelta=delta.<span class="built_in">GetSafeNormal</span>();</span><br><span class="line">	<span class="comment">//变成直线</span></span><br><span class="line">	FSlateDrawElement::<span class="built_in">MakeDrawSpaceSpline</span>(</span><br><span class="line">	DrawElementsList,</span><br><span class="line">	LayerId,</span><br><span class="line">	Start,DirDelta,</span><br><span class="line">	End,DirDelta,</span><br><span class="line">	Params.WireThickness,</span><br><span class="line">	ESlateDrawEffect::None,</span><br><span class="line">	Params.WireColor</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">//使用气泡</span></span><br><span class="line">    <span class="comment">//底线一堆算法就是为了MakeBox</span></span><br><span class="line">	<span class="keyword">if</span> (bUseBubble)</span><br><span class="line">	&#123;</span><br><span class="line">		FInterpCurve&lt;<span class="keyword">float</span>&gt; SplineCurve;</span><br><span class="line">		<span class="keyword">float</span> splineLength=<span class="built_in">MakeSplineReparamTable</span>(Start,DirDelta,End,DirDelta,SplineCurve);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">float</span> BubbleSpacing=<span class="number">32</span>*ZoomFactor;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">float</span> BubbleSpeed=<span class="number">64</span>*ZoomFactor;</span><br><span class="line">		<span class="keyword">const</span> FVector2D BubbleSize=BubbleImage-&gt;ImageSize*ZoomFactor*<span class="number">0.1</span>*Params.WireThickness;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> deltaTime=FPlatformTime::<span class="built_in">Seconds</span>()-GStartTime;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">float</span> BubbleOffset=FMath::<span class="built_in">Fmod</span>(deltaTime*BubbleSpeed,BubbleSpacing);</span><br><span class="line">		<span class="keyword">const</span> int32 num=FMath::<span class="built_in">CeilToInt</span>(splineLength-BubbleSpacing);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (int32 i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">float</span> dis = <span class="built_in"><span class="keyword">float</span></span>(i)*BubbleSpacing+BubbleOffset;</span><br><span class="line">			<span class="keyword">if</span> (dis&lt;splineLength)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">float</span> alpha=SplineCurve.<span class="built_in">Eval</span>(dis,<span class="number">0</span>);</span><br><span class="line">				FVector2D bubblePos=FMath::<span class="built_in">CubicInterp</span>(Start,DirDelta,End,DirDelta,alpha);</span><br><span class="line">				bubblePos-= BubbleSize*<span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">				FSlateDrawElement::<span class="built_in">MakeBox</span>(DrawElementsList,LayerId,</span><br><span class="line">				<span class="built_in">FPaintGeometry</span>(bubblePos,BubbleSize,ZoomFactor),</span><br><span class="line">				BubbleImage,</span><br><span class="line">				ESlateDrawEffect::None,</span><br><span class="line">				Params.WireColor</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h5 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h5><p>可以用工厂类来注册Node,Pin,ConnectionPolicy</p>
<p>重写如下方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;class SGraphNode&gt; <span class="title">CreateNode</span><span class="params">(class UEdGraphNode* Node)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;class SGraphPin&gt; <span class="title">CreatePin</span><span class="params">(class UEdGraphPin* Pin)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> class FConnectionDrawingPolicy* <span class="title">CreateConnectionPolicy</span><span class="params">(<span class="keyword">const</span> class UEdGraphSchema* Schema, int32 InBackLayerID, int32 InFrontLayerID, <span class="keyword">float</span> ZoomFactor, <span class="keyword">const</span> class FSlateRect&amp; InClippingRect, class FSlateWindowElementList&amp; InDrawElements, class UEdGraph* InGraphObj)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TSharedPtr&lt;class SGraphNode&gt; <span class="title">FTestNodeFactory::CreateNode</span><span class="params">(class UEdGraphNode* Node)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (UTestNode_Hello* nd=Cast&lt;UTestNode_Hello&gt;(Node))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SNew</span>(STestNode,nd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TSharedPtr&lt;class SGraphPin&gt; <span class="title">FTestNodePinFactory::CreatePin</span><span class="params">(class UEdGraphPin* Pin)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (UTestNode_Hello* nd=Cast&lt;UTestNode_Hello&gt;(Pin-&gt;<span class="built_in">GetOuter</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SNew</span>(STestPin,Pin);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">class FConnectionDrawingPolicy* <span class="title">FTestConnectionFactory::CreateConnectionPolicy</span><span class="params">(<span class="keyword">const</span> class UEdGraphSchema* Schema, int32 InBackLayerID, int32 InFrontLayerID, <span class="keyword">float</span> ZoomFactor, <span class="keyword">const</span> class FSlateRect&amp; InClippingRect, class FSlateWindowElementList&amp; InDrawElements, class UEdGraph* InGraphObj)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Schema-&gt;<span class="built_in">IsA</span>(UTestGraphSchema::<span class="built_in">StaticClass</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">FTestConnectionDrawingPolicy</span>(InBackLayerID,InFrontLayerID,ZoomFactor,InClippingRect,InDrawElements, InGraphObj);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在模块加载的时候注册，这样就可以去掉在schema内的内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FEdGraphUtilities::<span class="built_in">RegisterVisualNodeFactory</span>(<span class="built_in">MakeShareable</span>(<span class="keyword">new</span> FTestNodeFactory));</span><br><span class="line">FEdGraphUtilities::<span class="built_in">RegisterVisualPinConnectionFactory</span>(<span class="built_in">MakeShareable</span>(<span class="keyword">new</span> FTestConnectionFactory));</span><br><span class="line">FEdGraphUtilities::<span class="built_in">RegisterVisualPinFactory</span>(<span class="built_in">MakeShareable</span>(<span class="keyword">new</span> FTestNodePinFactory));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//virtual class FConnectionDrawingPolicy* CreateConnectionDrawingPolicy(int32 InBackLayerID, int32 InFrontLayerID, float InZoomFactor, const FSlateRect&amp; InClippingRect, class FSlateWindowElementList&amp; InDrawElements, class UEdGraph* InGraphObj)const override;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>节点</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义动画节点AnimGraphNode</title>
    <url>/2021/08/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BB%E8%8A%82%E7%82%B9AnimGraphNode/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_08_03_16_45_57_443.gif" alt="录制_2021_08_03_16_45_57_443"></p>
<span id="more"></span>



<p>首先要准备两个类, 一个继承自<code>UAnimGraphNode_Base</code>为蓝图节点类, 还有一个是数据类<code>FAnimNode_Base</code></p>
<h2 id="UAnimGraphNode-Base"><a href="#UAnimGraphNode-Base" class="headerlink" title="UAnimGraphNode_Base"></a>UAnimGraphNode_Base</h2><p>这个类定义了节点的显示方式,分类以及引脚连接方式等操作,  然后最主要的是要在头文件申明一个数据类, 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UTILITY_API</span> <span class="title">UMyAnimGraphNode_T01</span> :</span> <span class="keyword">public</span> UAnimGraphNode_Base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Category = Settings)</span><br><span class="line">	FAnimNode_Test01 Node;</span><br><span class="line">    <span class="comment">//..................</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 不需要对这个数据类做任何操作</p>
</blockquote>
<h2 id="FAnimNode-Base"><a href="#FAnimNode-Base" class="headerlink" title="FAnimNode_Base"></a>FAnimNode_Base</h2><p>我们在动画蓝图里点击节点以后显示的所有变量都是申明在这个类里面</p>
<p>比如我们申明这么一个数据类, 打算做一个简单的Blend操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintInternalUseOnly)</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">UTILITY_API</span> <span class="title">FAnimNode_Test01</span> :</span> <span class="keyword">public</span> FAnimNode_Base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = Links)</span><br><span class="line">		FPoseLink Pose;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = Links)</span><br><span class="line">		FPoseLink OtherPose;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = Alpha, meta = (PinShownByDefault))</span><br><span class="line">		<span class="keyword">float</span> Alpha = <span class="number">1.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后就显示如下</p>
<p><img src="https://img.supervj.top//img/image-20210803160905680.png" alt="image-20210803160905680"></p>
<p>我们重写下面几个虚函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FAnimNode_Base interface</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Initialize_AnyThread</span><span class="params">(<span class="keyword">const</span> FAnimationInitializeContext&amp; Context)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CacheBones_AnyThread</span><span class="params">(<span class="keyword">const</span> FAnimationCacheBonesContext&amp; Context)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update_AnyThread</span><span class="params">(<span class="keyword">const</span> FAnimationUpdateContext&amp; Context)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Evaluate_AnyThread</span><span class="params">(FPoseContext&amp; Output)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">// End of FAnimNode_Base interface</span></span><br></pre></td></tr></table></figure>

<p>其中<code>Initialize_AnyThread</code>和<code>CacheBones_AnyThread</code>会在初始化(编译)的时候先后调用,  每次调用2次</p>
<p>这俩函数就模仿其他基础的节点做一个基础的操作即可</p>
<blockquote>
<p>CacheBones_AnyThread用于刷新该节点所引用的骨骼索引</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAnimNode_Test01::Initialize_AnyThread</span><span class="params">(<span class="keyword">const</span> FAnimationInitializeContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DECLARE_SCOPE_HIERARCHICAL_COUNTER_ANIMNODE</span>(Initialize_AnyThread)</span><br><span class="line">	FAnimNode_Base::<span class="built_in">Initialize_AnyThread</span>(Context);</span><br><span class="line"></span><br><span class="line">	Pose.<span class="built_in">Initialize</span>(Context);</span><br><span class="line">	OtherPose.<span class="built_in">Initialize</span>(Context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAnimNode_Test01::CacheBones_AnyThread</span><span class="params">(<span class="keyword">const</span> FAnimationCacheBonesContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DECLARE_SCOPE_HIERARCHICAL_COUNTER_ANIMNODE</span>(CacheBones_AnyThread)</span><br><span class="line"></span><br><span class="line">	Pose.<span class="built_in">CacheBones</span>(Context);</span><br><span class="line">	OtherPose.<span class="built_in">CacheBones</span>(Context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后就是两个Tick函数, 也是按照先后顺序调用, 看下图</p>
<p><img src="https://img.supervj.top//img/image-20210803145311983.png" alt="image-20210803145311983"></p>
<p>起点分别是上图中红色框部分, <code>TickPose</code>最后执行的是<code>Update_AnyThread</code></p>
<p><strong>调用该函数来更新当前状态(比如更新播放时间或混合权重)。该函数取入一个FAnimationUpdateContext，它知道更新的DeltaTime和当前的节点混合权重。</strong></p>
<p><img src="https://img.supervj.top//img/image-20210803163309807.png" alt="image-20210803163309807"></p>
<p>比如我们的节点有<code>Alpha</code>的存在, 就可以在<code>Update</code>中通过这个<code>Alpha</code>做一些预处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAnimNode_Test01::Update_AnyThread</span><span class="params">(<span class="keyword">const</span> FAnimationUpdateContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DECLARE_SCOPE_HIERARCHICAL_COUNTER_ANIMNODE</span>(Update_AnyThread);</span><br><span class="line">	<span class="built_in">GetEvaluateGraphExposedInputs</span>().<span class="built_in">Execute</span>(Context);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> InternalBlendAlpha = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(Alpha, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FAnimWeight::<span class="built_in">IsRelevant</span>(InternalBlendAlpha))</span><br><span class="line">	&#123;</span><br><span class="line">		Pose.<span class="built_in">Update</span>(Context.<span class="built_in">FractionalWeight</span>(<span class="number">1.0f</span> - InternalBlendAlpha));</span><br><span class="line">		OtherPose.<span class="built_in">Update</span>(Context.<span class="built_in">FractionalWeight</span>(InternalBlendAlpha));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Pose.<span class="built_in">Update</span>(Context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再执行<code>Evaluate_AnyThread</code></p>
<p>也就是在执行<code>Evaluate_AnyThread</code>之前, 用到的Pose的数据已经经过了权重计算了</p>
<p><strong>调用该函数来生成一个‘姿势’（一系列的骨骼变换）。当动画图表节点的输出是FPoseLink时，执行的是该函数， 如果是FComponetSpacePoseLink，执行的应该是EvaluateComponentSpace_AnyThread</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAnimNode_Test01::Evaluate_AnyThread</span><span class="params">(FPoseContext&amp; Output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DECLARE_SCOPE_HIERARCHICAL_COUNTER_ANIMNODE</span>(Evaluate_AnyThread)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> InternalBlendAlpha = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(Alpha, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FAnimWeight::<span class="built_in">IsRelevant</span>(InternalBlendAlpha))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">FPoseContext <span class="title">Pose1</span><span class="params">(Output)</span></span>;<span class="comment">//创建上下文</span></span><br><span class="line">		<span class="function">FPoseContext <span class="title">Pose2</span><span class="params">(Output)</span></span>;</span><br><span class="line"></span><br><span class="line">		Pose.<span class="built_in">Evaluate</span>(Pose1);<span class="comment">//将当前的Pose数据写入到上下文对象中</span></span><br><span class="line">		OtherPose.<span class="built_in">Evaluate</span>(Pose2);</span><br><span class="line"></span><br><span class="line">		<span class="function">FAnimationPoseData <span class="title">BlendedAnimationPoseData</span><span class="params">(Output)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">const</span> FAnimationPoseData <span class="title">AnimationPoseOneData</span><span class="params">(Pose1)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">const</span> FAnimationPoseData <span class="title">AnimationPoseTwoData</span><span class="params">(Pose2)</span></span>;</span><br><span class="line">		FAnimationRuntime::<span class="built_in">BlendTwoPosesTogether</span>(AnimationPoseOneData, AnimationPoseTwoData, (<span class="number">1.0f</span> - InternalBlendAlpha), BlendedAnimationPoseData);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Pose.<span class="built_in">Evaluate</span>(Output);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要特别说明一下,  <code>FAnimationRuntime</code>类里面基本包含动画蓝图里面绝大多数的动画计算函数库,比如Blend, Additive等, 如下图</p>
<p><img src="https://img.supervj.top//img/image-20210803163704137.png" alt="image-20210803163704137"></p>
<p>所以我们就直接调用里面的方法<code>FAnimationRuntime::BlendTwoPosesTogether</code>即可</p>
<hr>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_08_03_16_41_48_971.gif" alt="录制_2021_08_03_16_41_48_971"></p>
<h2 id="再来一个"><a href="#再来一个" class="headerlink" title="再来一个"></a>再来一个</h2><p>再扩展一个稍微复杂一点的, 一个基础Pose, 然后再提供2个Pose,  我们把后两个Pose的插值叠加到基础Pose上.</p>
<p>主要代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAnimNode_Test02::Update_AnyThread</span><span class="params">(<span class="keyword">const</span> FAnimationUpdateContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DECLARE_SCOPE_HIERARCHICAL_COUNTER_ANIMNODE</span>(Update_AnyThread);</span><br><span class="line">	<span class="built_in">GetEvaluateGraphExposedInputs</span>().<span class="built_in">Execute</span>(Context);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> InternalBlendAlpha = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(AdditiveAlpha, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">	<span class="keyword">float</span> SourceAlpha = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(AlphaSource, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">	<span class="keyword">float</span> TargetAlpha = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(AlphaTarget, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FAnimWeight::<span class="built_in">IsRelevant</span>(InternalBlendAlpha) &amp;&amp; </span><br><span class="line">		FAnimWeight::<span class="built_in">IsRelevant</span>(SourceAlpha) &amp;&amp;</span><br><span class="line">		FAnimWeight::<span class="built_in">IsRelevant</span>(TargetAlpha))</span><br><span class="line">	&#123;</span><br><span class="line">		Pose.<span class="built_in">Update</span>(Context.<span class="built_in">FractionalWeight</span>(<span class="number">1.0f</span> - InternalBlendAlpha));</span><br><span class="line">		SubSource.<span class="built_in">Update</span>(Context.<span class="built_in">FractionalWeight</span>(SourceAlpha));</span><br><span class="line">		SubTarget.<span class="built_in">Update</span>(Context.<span class="built_in">FractionalWeight</span>(TargetAlpha));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Pose.<span class="built_in">Update</span>(Context);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAnimNode_Test02::Evaluate_AnyThread</span><span class="params">(FPoseContext&amp; Output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DECLARE_SCOPE_HIERARCHICAL_COUNTER_ANIMNODE</span>(Evaluate_AnyThread)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> InternalBlendAlpha = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(AdditiveAlpha, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">	<span class="keyword">float</span> SourceAlpha = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(AlphaSource, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">	<span class="keyword">float</span> TargetAlpha = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(AlphaTarget, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FAnimWeight::<span class="built_in">IsRelevant</span>(InternalBlendAlpha) &amp;&amp;</span><br><span class="line">		FAnimWeight::<span class="built_in">IsRelevant</span>(SourceAlpha) &amp;&amp;</span><br><span class="line">		FAnimWeight::<span class="built_in">IsRelevant</span>(TargetAlpha))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">FPoseContext <span class="title">PoseS</span><span class="params">(Output)</span></span>;</span><br><span class="line">		<span class="function">FPoseContext <span class="title">PoseT</span><span class="params">(Output)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Pose.<span class="built_in">Evaluate</span>(Output);</span><br><span class="line">		SubSource.<span class="built_in">Evaluate</span>(PoseS);</span><br><span class="line">		SubTarget.<span class="built_in">Evaluate</span>(PoseT);</span><br><span class="line"></span><br><span class="line">		FAnimationRuntime::<span class="built_in">ConvertPoseToAdditive</span>(PoseT.Pose, PoseS.Pose);</span><br><span class="line">		PoseT.Curve.<span class="built_in">ConvertToAdditive</span>(PoseS.Curve);</span><br><span class="line">		FCustomAttributesRuntime::<span class="built_in">SubtractAttributes</span>(PoseS.CustomAttributes, PoseT.CustomAttributes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="function">FAnimationPoseData <span class="title">OutAnimationPoseData</span><span class="params">(Output)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">const</span> FAnimationPoseData <span class="title">AdditiveAnimationPoseData</span><span class="params">(PoseT)</span></span>;</span><br><span class="line"></span><br><span class="line">		FAnimationRuntime::<span class="built_in">AccumulateAdditivePose</span>(OutAnimationPoseData, AdditiveAnimationPoseData, AdditiveAlpha, AAT_LocalSpaceBase);</span><br><span class="line">		Output.Pose.<span class="built_in">NormalizeRotations</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Pose.<span class="built_in">Evaluate</span>(Output);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先看效果</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_08_03_16_45_57_443.gif" alt="录制_2021_08_03_16_45_57_443"></p>
<p>这个节点实现了,  先计算 <strong>Walk 减去 Idle</strong>, 然后把这个插值叠加到 <strong>JumpLoop</strong>动画上</p>
<blockquote>
<p>ps: 实际上上面的内容就是把2个节点合并成了一个节点, 即ApplyAdditive + MakeDynamicAdditive</p>
</blockquote>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>Animation</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义资源</title>
    <url>/2020/07/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h3 id="自定义资源"><a href="#自定义资源" class="headerlink" title="自定义资源"></a>自定义资源</h3><p>新建插件<code>StateMachine</code>,然后手动拷贝一份<code>StateMachineEditor</code>用于编辑器模块 ，把里面的所有名称改为后缀为Editor版本</p>
<p>然后在<code>Editor</code>版本的<code>Build.cs </code>的Private部分中加入如下模块<code>    &quot;UnrealEd&quot;, &quot;AssetTools&quot;</code>,Public部分加入<code> &quot;StateMachine&quot;</code>模块</p>
<h5 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h5><p>创建随意<code>UObject</code> 资源，可以保持默认，本例中为<code>UStateMachineAsset</code></p>
<h5 id="行为类"><a href="#行为类" class="headerlink" title="行为类"></a>行为类</h5><p>创建<code>FAssetTypeActions_StateMachine</code>类继承自<code>FAssetTypeActions_Base</code>，此类可以接管资源双击打开编辑器的动作，这个类需要在<strong>模块启动</strong>时注册，稍微会讲</p>
<blockquote>
<p>此类建议创建在Editor模块</p>
</blockquote>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Developer/AssetTools/Public/AssetTypeActions_Base.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FAssetTypeActions_StateMachine</span>:</span> <span class="keyword">public</span> FAssetTypeActions_Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FAssetTypeActions_StateMachine</span>(EAssetTypeCategories::Type AsstCategory);</span><br><span class="line">	~<span class="built_in">FAssetTypeActions_StateMachine</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// IAssetTypeActions Implementation</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetName</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FColor <span class="title">GetTypeColor</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UClass* <span class="title">GetSupportedClass</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OpenAssetEditor</span><span class="params">(<span class="keyword">const</span> TArray&lt;UObject*&gt;&amp; InObjects, TSharedPtr&lt;class IToolkitHost&gt; EditWithInLevelEditor = TSharedPtr&lt;IToolkitHost&gt;())</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UThumbnailInfo* <span class="title">GetThumbnailInfo</span><span class="params">(UObject* Asset)</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> uint32 <span class="title">GetCategories</span><span class="params">()</span><span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_AssetCategory; &#125;<span class="comment">//自定义的标签，可以用系统自带的EAssetTypeCategories::Type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EAssetTypeCategories::Type m_AssetCategory;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AssetTypeActions_StateMachine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BlueprintEditorUtils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AssetRegistryModule.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StateMachineAsset.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ThumbnailRendering/SceneThumbnailInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCTEXT_NAMESPACE <span class="meta-string">&quot;AssetTypeActions&quot;</span></span></span><br><span class="line"></span><br><span class="line">FAssetTypeActions_StateMachine::<span class="built_in">FAssetTypeActions_StateMachine</span>(EAssetTypeCategories::Type AssetCategory)</span><br><span class="line">	:<span class="built_in">m_AssetCategory</span>(AssetCategory)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FAssetTypeActions_StateMachine::~<span class="built_in">FAssetTypeActions_StateMachine</span>()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FText <span class="title">FAssetTypeActions_StateMachine::GetName</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Content里右键菜单创建的显示的可创建类型的名字</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;AssetTypeActions&quot;</span>, <span class="string">&quot;AssetTypeActions_StateMachine&quot;</span>, <span class="string">&quot;StateMachine Blueprint&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FColor <span class="title">FAssetTypeActions_StateMachine::GetTypeColor</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FColor::Emerald;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UClass* <span class="title">FAssetTypeActions_StateMachine::GetSupportedClass</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UStateMachineAsset::<span class="built_in">StaticClass</span>();<span class="comment">//创建的资源，即之前定义的UObject</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开资源行为，通过这个方法可以打开其他视图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FAssetTypeActions_StateMachine::OpenAssetEditor</span><span class="params">(<span class="keyword">const</span> TArray&lt;UObject*&gt;&amp; InObjects, TSharedPtr&lt;class IToolkitHost&gt; EditWithInLevelEditor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;FAssetTypeActions_StateMachine::OpenAssetEditor&quot;</span>));</span><br><span class="line"><span class="comment">//内容暂无</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UThumbnailInfo* <span class="title">FAssetTypeActions_StateMachine::GetThumbnailInfo</span><span class="params">(UObject* Asset)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LOCTEXT_NAMESPACE</span></span><br></pre></td></tr></table></figure>



<h5 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h5><blockquote>
<p>此类最好创建在Editor模块</p>
</blockquote>
<p>此类是让引擎认识我们创建的这个资源和自定义标签，似乎定义了以后引擎就自动会识别，即上述两个类的功能</p>
<p>不创建的话连对应的自定义的标签也无法显示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StateMachineAsset.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Engine/Blueprint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Factories/Factory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UObject/Object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UObject/ObjectMacros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UObject/ScriptMacros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StateMachineFactory.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(HideCategories = Object,MinimalAPI)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UStateMachineFactory</span> :</span> <span class="keyword">public</span> UFactory</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UStateMachineFactory</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer);</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">UStateMachineFactory</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;StateMachineFactory&quot;</span>)</span><br><span class="line">		TEnumAsByte&lt;EBlueprintType&gt; mBlueprintType;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;StateMachineFactory&quot;</span>)</span><br><span class="line">		TSubclassOf&lt;UStateMachineAsset&gt; mSupportedClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// override UFactory function</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ConfigureProperties</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UObject* <span class="title">FactoryCreateNew</span><span class="params">(UClass* InClass, UObject* InParent, FName InName, EObjectFlags InFlags, UObject* InContext, FFeedbackContext* InWarn,FName InCallingContext)</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UObject* <span class="title">FactoryCreateNew</span><span class="params">(UClass* InClass, UObject* InParent, FName InName, EObjectFlags InFlags, UObject* InContext, FFeedbackContext* InWarn)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StateMachineFactory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StateMachineAsset.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">UStateMachineFactory::<span class="built_in">UStateMachineFactory</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">	:<span class="built_in">Super</span>(ObjectInitializer), <span class="built_in">mSupportedClass</span>(UStateMachineAsset::<span class="built_in">StaticClass</span>())</span><br><span class="line">&#123;</span><br><span class="line">	bCreateNew = <span class="literal">true</span>;</span><br><span class="line">	bEditAfterNew = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个Factory托管的类型</span></span><br><span class="line">	SupportedClass = mSupportedClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UStateMachineFactory::~<span class="built_in">UStateMachineFactory</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UStateMachineFactory::ConfigureProperties</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UObject* <span class="title">UStateMachineFactory::FactoryCreateNew</span><span class="params">(UClass* InClass, UObject* InParent, FName InName, EObjectFlags InFlags, UObject* InContext, FFeedbackContext* InWarn,FName InCallingContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">FactoryCreateNew</span>(InClass, InParent, InName, InFlags, InContext, InWarn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UObject* <span class="title">UStateMachineFactory::FactoryCreateNew</span><span class="params">(UClass* InClass,UObject* InParent,FName InName,EObjectFlags InFlags,UObject* InContext,FFeedbackContext* InWarn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UStateMachineAsset* NewStateMachineAssetItem = NewObject&lt;UStateMachineAsset&gt;(InParent, InClass, InName, InFlags);</span><br><span class="line">	<span class="keyword">return</span> NewStateMachineAssetItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>用于注册自定义标签以及我们之前创建的<code>FAssetTypeActions_StateMachine</code>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AssetTypeCategories.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AssetToolsModule.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Modules/ModuleManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FStateMachineEditorModule</span> :</span> <span class="keyword">public</span> IModuleInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** IModuleInterface implementation */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StartupModule</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShutdownModule</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RegisterAssetType</span><span class="params">(IAssetTools&amp; AssetTools)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RegisterSetting</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UnRegisterSetting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EAssetTypeCategories::Type m_StateMachineCategoryType;<span class="comment">//自定义标签</span></span><br><span class="line">	TArray&lt;TSharedPtr&lt;IAssetTypeActions&gt;&gt; m_CreatedAssetTypeActions;<span class="comment">//Action数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StateMachineEditor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AssetTypeActions_StateMachine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ISettingsModule.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCTEXT_NAMESPACE <span class="meta-string">&quot;FStateMachineEditorModule&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FStateMachineEditorModule::StartupModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module</span></span><br><span class="line">	IAssetTools&amp; AssetToolsInstance = FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;(<span class="string">&quot;AssetTools&quot;</span>).<span class="built_in">Get</span>();</span><br><span class="line">    <span class="comment">//创建自定义标签，可以本地化翻译</span></span><br><span class="line">	m_StateMachineCategoryType= AssetToolsInstance.<span class="built_in">RegisterAdvancedAssetCategory</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;StateMachine&quot;</span>), <span class="built_in">LOCTEXT</span>(<span class="string">&quot;StateMachineAssetCategory&quot;</span>, <span class="string">&quot;StateMachine&quot;</span>));</span><br><span class="line">	<span class="built_in">RegisterAssetType</span>(AssetToolsInstance);</span><br><span class="line">	<span class="built_in">RegisterSetting</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FStateMachineEditorModule::ShutdownModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,</span></span><br><span class="line">	<span class="comment">// we call this function before unloading the module.</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">UnRegisterSetting</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FStateMachineEditorModule::RegisterAssetType</span><span class="params">(IAssetTools&amp; AssetTools)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TSharedRef&lt;IAssetTypeActions&gt; StateMachineBlueprint = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FAssetTypeActions_StateMachine</span>(m_StateMachineCategoryType));</span><br><span class="line">    <span class="comment">//注册资源行为类</span></span><br><span class="line">	AssetTools.<span class="built_in">RegisterAssetTypeActions</span>(StateMachineBlueprint);</span><br><span class="line">	m_CreatedAssetTypeActions.<span class="built_in">Add</span>(StateMachineBlueprint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FStateMachineEditorModule::RegisterSetting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//暂时为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FStateMachineEditorModule::UnRegisterSetting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//暂时为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LOCTEXT_NAMESPACE</span></span><br><span class="line">	</span><br><span class="line"><span class="built_in">IMPLEMENT_MODULE</span>(FStateMachineEditorModule, StateMachineEditor)</span><br></pre></td></tr></table></figure>



<p>然后我们在引擎<code>Content</code>目录下右键点击就出现我们要的效果</p>
<p><img src="https://img.supervj.top/img/other/image-20200710105049753.png" alt="image-20200710105049753"></p>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>编辑器开发</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4获取硬件信息</title>
    <url>/2021/01/11/%E8%8E%B7%E5%8F%96%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录UE4获取硬件信息和地址等常用方法</p>
<h2 id="Mac地址"><a href="#Mac地址" class="headerlink" title="Mac地址"></a>Mac地址</h2><p><code>GetMacAddressString()</code>方法已经在4.15版本后被彻底废弃, 所以UE目前(4.26)版本无法获取Mac地址</p>
<p>我们之前<a href="https://supervj.top/2021/01/09/UE4%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/">UE4获取第三方库</a>文章中有用到使用自己用原生cpp获取到mac地址, 然后导出成动态或者静态库到UE4再封装成插件的形式来获取mac地址, 此方法也是目前比较快捷的一个方法</p>
<span id="more"></span>

<p>下面贴DLL/Lib的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllexport)	<span class="comment">//shortens __declspec(dllexport) to DLL_EXPORT</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus		<span class="comment">//if C++ is used convert it to C to prevent C++&#x27;s name mangling of method names</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> DLL_EXPORT <span class="title">GetMac</span><span class="params">(<span class="keyword">char</span> * mac)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ThirdPartyDLL.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wincon.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Nb30.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;netapi32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">GetMac</span><span class="params">(<span class="keyword">char</span> * mac)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NCB ncb;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ASTAT_</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ADAPTER_STATUS   adapt;</span><br><span class="line">		NAME_BUFFER   NameBuff[<span class="number">30</span>];</span><br><span class="line">	&#125;ASTAT, *PASTAT;</span><br><span class="line"></span><br><span class="line">	ASTAT Adapter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LANA_ENUM</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		UCHAR   length;</span><br><span class="line">		UCHAR   lana[MAX_LANA];</span><br><span class="line">	&#125;LANA_ENUM;</span><br><span class="line"></span><br><span class="line">	LANA_ENUM lana_enum;</span><br><span class="line">	UCHAR uRetCode;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;ncb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ncb));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;lana_enum, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(lana_enum));</span><br><span class="line">	ncb.ncb_command = NCBENUM;</span><br><span class="line">	ncb.ncb_buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;lana_enum;</span><br><span class="line">	ncb.ncb_length = <span class="built_in"><span class="keyword">sizeof</span></span>(LANA_ENUM);</span><br><span class="line">	uRetCode = <span class="built_in">Netbios</span>(&amp;ncb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uRetCode != NRC_GOODRET)</span><br><span class="line">		<span class="keyword">return</span> uRetCode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> lana = <span class="number">0</span>; lana &lt; lana_enum.length; lana++)</span><br><span class="line">	&#123;</span><br><span class="line">		ncb.ncb_command = NCBRESET;</span><br><span class="line">		ncb.ncb_lana_num = lana_enum.lana[lana];</span><br><span class="line">		uRetCode = <span class="built_in">Netbios</span>(&amp;ncb);</span><br><span class="line">		<span class="keyword">if</span> (uRetCode == NRC_GOODRET)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uRetCode != NRC_GOODRET)</span><br><span class="line">		<span class="keyword">return</span> uRetCode;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;ncb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ncb));</span><br><span class="line">	ncb.ncb_command = NCBASTAT;</span><br><span class="line">	ncb.ncb_lana_num = lana_enum.lana[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="keyword">char</span>*)ncb.ncb_callname, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">	ncb.ncb_buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;Adapter;</span><br><span class="line">	ncb.ncb_length = <span class="built_in"><span class="keyword">sizeof</span></span>(Adapter);</span><br><span class="line">	uRetCode = <span class="built_in">Netbios</span>(&amp;ncb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uRetCode != NRC_GOODRET)</span><br><span class="line">		<span class="keyword">return</span> uRetCode;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sprintf</span>(mac, <span class="string">&quot;%02X-%02X-%02X-%02X-%02X-%02X&quot;</span>,</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">0</span>],</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">1</span>],</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">2</span>],</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">3</span>],</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">4</span>],</span><br><span class="line">		Adapter.adapt.adapter_address[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h2><p>最常用的方法是获取CPU的品牌信息, 即用如下方法即可获取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Brand = FPlatformMisc::<span class="built_in">GetCPUBrand</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://img.supervj.top//img/image-20210112105554105.png" alt="image-20210112105554105"></p>
<p>对比cmd中的信息</p>
<p><img src="https://img.supervj.top//img/image-20210112105643034.png" alt="image-20210112105643034"></p>
<p>另外UE中还封装了其他一些CPU信息, 比如供应商等, 分别可以用如下方法去获取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Chipset = FPlatformMisc::<span class="built_in">GetCPUChipset</span>();</span><br><span class="line">Info = FPlatformMisc::<span class="built_in">GetCPUInfo</span>();</span><br><span class="line">Vendor = FPlatformMisc::<span class="built_in">GetCPUVendor</span>();</span><br></pre></td></tr></table></figure>



<h2 id="GPU信息"><a href="#GPU信息" class="headerlink" title="GPU信息"></a>GPU信息</h2><p>GPU信息相比就多一些, 通过两个方法来获取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Brand = FPlatformMisc::<span class="built_in">GetPrimaryGPUBrand</span>();<span class="comment">//获取品牌信息,我这边获取的就是NVIDIA</span></span><br><span class="line"><span class="comment">//通过品牌信息获取其他设备信息,如供应商,驱动版本等</span></span><br><span class="line">FGPUDriverInfo info = FPlatformMisc::<span class="built_in">GetGPUDriverInfo</span>(Brand);</span><br><span class="line">ProviderName = info.ProviderName;</span><br><span class="line">VendorID = info.VendorId;</span><br><span class="line">InternalDriverVersion = info.InternalDriverVersion;</span><br><span class="line">UserDriverVersion = info.UserDriverVersion;</span><br><span class="line">DriverDate = info.DriverDate;</span><br><span class="line">RHIName = info.RHIName;</span><br></pre></td></tr></table></figure>

<p>统统打印出来是如下</p>
<p><img src="https://img.supervj.top//img/image-20210112110026385.png" alt="image-20210112110026385"></p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>需要包含库<code>Sockets</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SocketSubsystem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">UFlib_DeviceInfo::GetIpAddress</span><span class="params">(<span class="keyword">bool</span> bHasPort <span class="comment">/*= true*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FString <span class="title">IpAddr</span><span class="params">(<span class="string">&quot;NONE&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> canBind = <span class="literal">false</span>;</span><br><span class="line">	TSharedRef&lt;FInternetAddr&gt;LocalIp = ISocketSubsystem::<span class="built_in">Get</span>(PLATFORM_SOCKETSUBSYSTEM)-&gt;<span class="built_in">GetLocalHostAddr</span>(*GLog, canBind);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (LocalIp-&gt;<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		IpAddr = LocalIp-&gt;<span class="built_in">ToString</span>(bHasPort); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> IpAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>设备信息</tag>
      </tags>
  </entry>
  <entry>
    <title>K2Node深入探索及蓝图泛型节点</title>
    <url>/2021/03/24/%E8%93%9D%E5%9B%BE%E6%B3%9B%E5%9E%8B%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录一下蓝图泛型节点的实现, 主要分为<code>CustomThunk</code>方式和<code>K2Node</code>的方式</p>
<p>对比一下两者的优点</p>
<p>CustomThunk: 代码少, 调试方便</p>
<p>UK2Node: 动态的节点数量, 更灵活的动态类型</p>
<p><img src="https://img.supervj.top//img/UE4Editor_OO8h1IPyH8.png" alt="UE4Editor_OO8h1IPyH8"></p>
<span id="more"></span>





<p>本文代码在如下项目中</p>
<p><a href="https://github.com/VJien/BlueprintLibraryUtility">BlueprintLibraryUtility</a></p>
<h2 id="CustomThunk"><a href="#CustomThunk" class="headerlink" title="CustomThunk"></a>CustomThunk</h2><p>此函数分为3部分</p>
<ol>
<li>带有<code>UFUNCTION</code>宏的函数声明；</li>
<li>自定义<code>Thunk</code>函数体<code>DECLARE_FUNCTION(execFunctionName)</code>；</li>
<li>真正执行泛型逻辑的<code>Generic_FunctionName()</code>泛型函数。</li>
</ol>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><ol>
<li>需要加入字段<code>CustomThunk</code></li>
<li>meta数据内指定哪些参数为泛型类型,如普通便变量的<code>meta = (CustomStructureParam = &quot;Value1,Value2,Value&quot;)</code></li>
</ol>
<p>特殊情况</p>
<ul>
<li>普通变量</li>
</ul>
<p>用<code>CustomStructureParam  = &quot;变量1,变量2&quot;</code>的方式</p>
<p>只能用符号<code>&quot;,&quot;</code></p>
<ul>
<li>TArray</li>
</ul>
<p><code>meta = (ArrayParm = &quot;Array1,Array2,Array3&quot;, ArrayTypeDependentParams = &quot;Array1,Array2,Array3&quot;)</code></p>
<p><code>ArrayTypeDependentParams</code>表示多个类型的相互依赖, 参考引擎文件<code>KismetArrayLibrary.h</code></p>
<ul>
<li>TMap</li>
</ul>
<p><code> meta = (MapParam = &quot;TargetMap&quot;, MapKeyParam = &quot;Key&quot;, MapValueParam = &quot;Value&quot;)</code></p>
<p>Map只能指定一个<code>TMap</code>类型的泛型类型,多个泛型无法正常工作</p>
<ul>
<li>TSet</li>
</ul>
<p><code>meta = (SetParam = &quot;Set1|Set2,Set3&quot;)</code></p>
<p><code>TSet</code>比较特殊, 用<code>&quot;,&quot;</code>分隔多个泛型, 用<code>&quot;|&quot;</code>表示类型依赖</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>用<code>DECLARE_FUNCTION</code>来手动定义函数实现(取代的*.\Intermediate\Build\Win64\UE4Editor\Inc**.gen.cpp内的代码), 一般需要声明前缀为<code>Generic</code>的同名函数(参数可以不同)</p>
<p>如我们实现一个结构体转<code>Json</code>的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintPure, CustomThunk, meta = (CustomStructureParam = <span class="string">&quot;StructReference&quot;</span>, DisplayName = <span class="string">&quot;Struct to JSON String&quot;</span>), Category = <span class="string">&quot;File|Json&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UStructToJsonObjectString</span><span class="params">(<span class="keyword">const</span> int32&amp; StructReference, FString&amp; JSONString)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GenericUStructToJsonObjectString</span><span class="params">(<span class="keyword">const</span> UStruct* StructDefinition, <span class="keyword">const</span> <span class="keyword">void</span>* Struct, FString&amp; OutJsonString, int64 CheckFlags, </span></span></span><br><span class="line"><span class="params"><span class="function">int64 SkipFlags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_FUNCTION</span>(execUStructToJsonObjectString)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	Stack.StepCompiledIn&lt;FStructProperty&gt;(<span class="literal">NULL</span>);</span><br><span class="line">	FStructProperty* StructProperty = CastField&lt;FStructProperty&gt;(Stack.MostRecentProperty);</span><br><span class="line">	<span class="keyword">void</span>* StructPtr = Stack.MostRecentPropertyAddress;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">P_GET_PROPERTY_REF</span>(FStrProperty, JSONString);</span><br><span class="line"></span><br><span class="line">	P_FINISH;</span><br><span class="line"></span><br><span class="line">	P_NATIVE_BEGIN;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GenericUStructToJsonObjectString</span>(StructProperty-&gt;Struct,StructPtr,JSONString,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	P_NATIVE_END;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>P_FINISH;</code>之前是获取属性</p>
<p><strong>获取属性的先后次序应与函数声明时变量在参数列表中出现的次序保持一致</strong></p>
<p><code>P_NATIVE_BEGIN;</code>与<code>P_NATIVE_END;</code>之间是定义函数的实现</p>
<h4 id="获取属性的方式"><a href="#获取属性的方式" class="headerlink" title="获取属性的方式"></a>获取属性的方式</h4><ul>
<li>普通变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Stack.StepCompiledIn&lt;UStructProperty&gt;(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">void</span>* SrcPropertyAddr = Stack.MostRecentPropertyAddress;</span><br><span class="line">UProperty* SrcProperty = Cast&lt;UProperty&gt;(Stack.MostRecentProperty);</span><br></pre></td></tr></table></figure>

<ul>
<li>Array</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Stack.StepCompiledIn&lt;UArrayProperty&gt;(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">void</span>* SrcArrayAddr = Stack.MostRecentPropertyAddress;</span><br><span class="line">UArrayProperty* SrcArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty);</span><br></pre></td></tr></table></figure>

<ul>
<li>Map</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Stack.MostRecentProperty = <span class="literal">nullptr</span>;</span><br><span class="line">Stack.StepCompiledIn&lt;UMapProperty&gt;(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">void</span>* SrcMapAddr = Stack.MostRecentPropertyAddress;</span><br><span class="line">UMapProperty* SrcMapProperty = Cast&lt;UMapProperty&gt;(Stack.MostRecentProperty);</span><br></pre></td></tr></table></figure>

<ul>
<li>Set</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Stack.MostRecentProperty = <span class="literal">nullptr</span>;</span><br><span class="line">Stack.StepCompiledIn&lt;USetProperty&gt;(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">void</span>* SetAddr = Stack.MostRecentPropertyAddress;</span><br><span class="line">USetProperty* SetProperty = Cast&lt;USetProperty&gt;(Stack.MostRecentProperty);</span><br></pre></td></tr></table></figure>





<h2 id="K2Node"><a href="#K2Node" class="headerlink" title="K2Node"></a>K2Node</h2><p>继承于<code>UK2Node</code></p>
<p>一般会重写如下几个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//鼠标放到上面的说明/注释</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> FText <span class="title">GetTooltipText</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//节点名称</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> FText <span class="title">GetNodeTitle</span><span class="params">(ENodeTitleType::Type TitleType)</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//将节点添加到蓝图视图</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetMenuActions</span><span class="params">(FBlueprintActionDatabaseRegistrar&amp; ActionRegister)</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//蓝图节点的标签</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> FText <span class="title">GetMenuCategory</span><span class="params">()</span><span class="keyword">const</span> </span>;</span><br><span class="line"><span class="comment">//展开节点</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ExpandNode</span><span class="params">(FKismetCompilerContext&amp; CompilerContext, UEdGraph* SourceGraph)</span><span class="keyword">override</span> </span>;</span><br><span class="line"><span class="comment">//分配默认引脚</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AllocateDefaultPins</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//引脚更改时会调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PinDefaultValueChanged</span><span class="params">(UEdGraphPin* ChangedPin)</span><span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//连接情况更改以后</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">NotifyPinConnectionListChanged</span><span class="params">(UEdGraphPin* Pin)</span><span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p> 还有一些特殊情况会需要重写的函数, 比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 创建一个可视小部件来在图形编辑器或图形面板中表示这个节点。如果没有实现，则将使用默认的节点工厂 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;SGraphNode&gt; <span class="title">CreateVisualWidget</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TSharedPtr&lt;SGraphNode&gt;(); &#125;</span><br><span class="line"><span class="comment">/** 为表示此节点的小部件创建背景图像 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;SWidget&gt; <span class="title">CreateNodeImage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> TSharedPtr&lt;SWidget&gt;(); &#125;</span><br><span class="line"><span class="comment">//右键菜单, 比如添加RemovePin</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetNodeContextMenuActions</span><span class="params">(class UToolMenu* Menu, class UGraphNodeContextMenuContext* Context)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多请参考 <code>EdGraphNode.h</code>和<code>K2Node.h</code></p>
</blockquote>
<p>下面我们创建几个K2Node</p>
<h3 id="K2Node-Print"><a href="#K2Node-Print" class="headerlink" title="K2Node_Print"></a>K2Node_Print</h3><p><img src="https://img.supervj.top//img/UE4Editor_6iO5ybXnXh.png" alt="UE4Editor_6iO5ybXnXh"></p>
<p>由于平时用蓝图的<code>PrintString</code>打印字符串经常需要输入<code>Append</code>,不方便, 那么我们就借此尝试做一个<code>K2Node</code>版本的可以动态添加引脚的<code>Print</code></p>
<p>直接上代码,重点加注释</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;K2Node.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;K2Node_CallFunction.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KismetCompiler.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BlueprintActionDatabaseRegistrar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BlueprintNodeSpawner.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Kismet2/BlueprintEditorUtils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;K2Node_Print.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BLUEPRINTLIBRARYUTILITYEDITOR_API</span> <span class="title">UK2Node_Print</span> :</span> <span class="keyword">public</span> UK2Node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetTooltipText</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="string">&quot;Printf&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetNodeTitle</span><span class="params">(ENodeTitleType::Type TitleType)</span><span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Printf&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetMenuActions</span><span class="params">(FBlueprintActionDatabaseRegistrar&amp; ActionRegister)</span><span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		UClass* ActionKey = <span class="built_in">GetClass</span>();</span><br><span class="line">		<span class="keyword">if</span> (ActionRegister.<span class="built_in">IsOpenForRegistration</span>(ActionKey))</span><br><span class="line">		&#123;</span><br><span class="line">			UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::<span class="built_in">Create</span>(<span class="built_in">GetClass</span>());</span><br><span class="line">			<span class="built_in">check</span>(NodeSpawner);</span><br><span class="line">			ActionRegister.<span class="built_in">AddBlueprintAction</span>(ActionKey, NodeSpawner);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetNodeContextMenuActions</span><span class="params">(class UToolMenu* Menu, class UGraphNodeContextMenuContext* Context)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetMenuCategory</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;BlueprintLibraryUtility|IO&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">UEdGraphPin* <span class="title">GetThenPin</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		UEdGraphPin* Pin = <span class="built_in">FindPin</span>(UEdGraphSchema_K2::PN_Then);</span><br><span class="line">		<span class="built_in">check</span>(Pin == <span class="literal">nullptr</span> || Pin-&gt;Direction == EGPD_Output); <span class="comment">// If pin exists, it must be output</span></span><br><span class="line">		<span class="keyword">return</span> Pin;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ExpandNode</span><span class="params">(FKismetCompilerContext&amp; CompilerContext, UEdGraph* SourceGraph)</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AllocateDefaultPins</span><span class="params">()</span><span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PinDefaultValueChanged</span><span class="params">(UEdGraphPin* ChangedPin)</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddPinToNode</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveInputPin</span><span class="params">(UEdGraphPin* Pin)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = ( CallableWithoutWorldContext = <span class="literal">true</span>, WorldContext = <span class="string">&quot;context&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TSharedPtr&lt;SGraphNode&gt; <span class="title">CreateVisualWidget</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">		TArray&lt;FName&gt; ArgPinNames;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">static</span> FName PN_PrintToSreen;</span><br><span class="line">		<span class="keyword">static</span> FName PN_PrintToLog;</span><br><span class="line">		<span class="keyword">static</span> FName PN_Color;</span><br><span class="line">		<span class="keyword">static</span> FName PN_Duration;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cpp</span></span><br><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Node/K2Node_Print.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Kismet/KismetStringLibrary.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Kismet/KismetSystemLibrary.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;K2Node_MakeArray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Node/GraphNode_Printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ToolMenu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ToolMenuSection.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCTEXT_NAMESPACE <span class="meta-string">&quot;K2Node_Print&quot;</span></span></span><br><span class="line"></span><br><span class="line">FName UK2Node_Print::PN_Color = <span class="built_in">TEXT</span>(<span class="string">&quot;Color&quot;</span>);</span><br><span class="line">FName UK2Node_Print::PN_PrintToLog = <span class="built_in">TEXT</span>(<span class="string">&quot;PrintToLog&quot;</span>);</span><br><span class="line">FName UK2Node_Print::PN_PrintToSreen = <span class="built_in">TEXT</span>(<span class="string">&quot;PrintToScreen&quot;</span>);</span><br><span class="line">FName UK2Node_Print::PN_Duration = <span class="built_in">TEXT</span>(<span class="string">&quot;Duration&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_Print::GetNodeContextMenuActions</span><span class="params">(class UToolMenu* Menu, class UGraphNodeContextMenuContext* Context)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">GetNodeContextMenuActions</span>(Menu,Context);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Context-&gt;bIsDebugging)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Context-&gt;Pin != <span class="built_in">FindPin</span>(UK2Node_Print::PN_PrintToSreen) &amp;&amp; </span><br><span class="line">			Context-&gt;Pin != <span class="built_in">FindPin</span>(UK2Node_Print::PN_Color) &amp;&amp;</span><br><span class="line">			Context-&gt;Pin != <span class="built_in">FindPin</span>(UK2Node_Print::PN_PrintToLog) &amp;&amp;</span><br><span class="line">			Context-&gt;Pin != <span class="built_in">FindPin</span>(UK2Node_Print::PN_Duration))</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//添加移除节点的右键功能,否则无法移除变量会很尴尬</span></span><br><span class="line">			FToolMenuSection&amp; Section = Menu-&gt;<span class="built_in">AddSection</span>(<span class="built_in">FName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;UK2Node_Print&quot;</span>)), <span class="built_in">LOCTEXT</span>(<span class="string">&quot;UK2Node_Print&quot;</span>,<span class="string">&quot;Action&quot;</span>));</span><br><span class="line">			Section.<span class="built_in">AddMenuEntry</span>(</span><br><span class="line">				<span class="string">&quot;RemovePin&quot;</span>,</span><br><span class="line">				<span class="built_in">LOCTEXT</span>(<span class="string">&quot;RemovePin&quot;</span>, <span class="string">&quot;Remove pin&quot;</span>),</span><br><span class="line">				<span class="built_in">LOCTEXT</span>(<span class="string">&quot;RemovePinTooltip&quot;</span>, <span class="string">&quot;Remove this input pin&quot;</span>),</span><br><span class="line">				<span class="built_in">FSlateIcon</span>(),</span><br><span class="line">				<span class="built_in">FUIAction</span>(</span><br><span class="line">					FExecuteAction::<span class="built_in">CreateUObject</span>(<span class="keyword">const_cast</span>&lt;UK2Node_Print*&gt;(<span class="keyword">this</span>), &amp;UK2Node_Print::RemoveInputPin, <span class="keyword">const_cast</span>&lt;UEdGraphPin*&gt;(Context-&gt;Pin))</span><br><span class="line">				)</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_Print::ExpandNode</span><span class="params">(FKismetCompilerContext&amp; CompilerContext, UEdGraph* SourceGraph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UEdGraphPin* ExecPin = <span class="built_in">GetExecPin</span>();</span><br><span class="line">	UEdGraphPin* ThenPin = <span class="built_in">GetThenPin</span>();</span><br><span class="line">	<span class="keyword">if</span> (ExecPin &amp;&amp; ThenPin) </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//获取函数库的函数, 不能使用自己的函数,否则非编辑器模式运行崩溃</span></span><br><span class="line">		UFunction* Function = UFlib_IO::<span class="built_in">StaticClass</span>()-&gt;<span class="built_in">FindFunctionByName</span>(<span class="built_in">FName</span>(<span class="string">&quot;PrintArray&quot;</span>));</span><br><span class="line">		<span class="keyword">if</span> (Function == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			CompilerContext.MessageLog.<span class="built_in">Error</span>(*<span class="built_in">LOCTEXT</span>(<span class="string">&quot;InvalidFunctionName&quot;</span>, <span class="string">&quot;BaseAsyncTask: Type not supported or not initialized. @@&quot;</span>).<span class="built_in">ToString</span>(), <span class="keyword">this</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		UK2Node_CallFunction* CallFuncNode = CompilerContext.SpawnIntermediateNode&lt;UK2Node_CallFunction&gt;(<span class="keyword">this</span>, SourceGraph);</span><br><span class="line"></span><br><span class="line">		CallFuncNode-&gt;<span class="built_in">SetFromFunction</span>(Function);</span><br><span class="line">		CallFuncNode-&gt;<span class="built_in">AllocateDefaultPins</span>();</span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*ExecPin, *(CallFuncNode-&gt;<span class="built_in">GetExecPin</span>()));</span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*ThenPin, *(CallFuncNode-&gt;<span class="built_in">GetThenPin</span>()));</span><br><span class="line"></span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*<span class="built_in">FindPin</span>(UK2Node_Print::PN_PrintToSreen), *CallFuncNode-&gt;<span class="built_in">FindPin</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;bScreen&quot;</span>)));</span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*<span class="built_in">FindPin</span>(UK2Node_Print::PN_PrintToLog), *CallFuncNode-&gt;<span class="built_in">FindPin</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;bLog&quot;</span>)));</span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*<span class="built_in">FindPin</span>(UK2Node_Print::PN_Color), *CallFuncNode-&gt;<span class="built_in">FindPin</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Color&quot;</span>)));</span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*<span class="built_in">FindPin</span>(UK2Node_Print::PN_Duration), *CallFuncNode-&gt;<span class="built_in">FindPin</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Duration&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//如下添加一个特殊的节点, 用于动态添加Pin</span></span><br><span class="line">		UK2Node_MakeArray* MakeArrayNode = CompilerContext.SpawnIntermediateNode&lt;UK2Node_MakeArray&gt;(<span class="keyword">this</span>, SourceGraph);</span><br><span class="line">		MakeArrayNode-&gt;<span class="built_in">AllocateDefaultPins</span>();</span><br><span class="line"></span><br><span class="line">		UEdGraphPin* ArrayOut = MakeArrayNode-&gt;<span class="built_in">GetOutputPin</span>();</span><br><span class="line">		UEdGraphPin* FuncArgPin = CallFuncNode-&gt;<span class="built_in">FindPinChecked</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;InStrings&quot;</span>));</span><br><span class="line">		ArrayOut-&gt;<span class="built_in">MakeLinkTo</span>(FuncArgPin);</span><br><span class="line"></span><br><span class="line">		MakeArrayNode-&gt;<span class="built_in">PinConnectionListChanged</span>(ArrayOut);</span><br><span class="line">		<span class="comment">// connect all arg pin to Make Array input</span></span><br><span class="line">		<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; ArgPinNames.<span class="built_in">Num</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Make Array node has one input by default</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">				MakeArrayNode-&gt;<span class="built_in">AddInputPin</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// find the input pin on the &quot;Make Array&quot; node by index.</span></span><br><span class="line">			<span class="keyword">const</span> FString PinName = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;[%d]&quot;</span>), i);</span><br><span class="line">			UEdGraphPin* ArrayInputPin = MakeArrayNode-&gt;<span class="built_in">FindPinChecked</span>(PinName);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// move input word to array </span></span><br><span class="line">			UEdGraphPin* MyInputPin = <span class="built_in">FindPinChecked</span>(ArgPinNames[i], EGPD_Input);</span><br><span class="line">			CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*MyInputPin, *ArrayInputPin);</span><br><span class="line">		&#125;<span class="comment">// end of for</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BreakAllNodeLinks</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_Print::AllocateDefaultPins</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">AllocateDefaultPins</span>();</span><br><span class="line">    <span class="comment">//创建默认节点, 同时指定默认值</span></span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);</span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);</span><br><span class="line">	UEdGraphPin* PinScreen = <span class="built_in">CreatePin</span>(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, UK2Node_Print::PN_PrintToSreen);</span><br><span class="line">	PinScreen-&gt;DefaultValue = <span class="string">&quot;True&quot;</span>;</span><br><span class="line">	UEdGraphPin* PinLog = <span class="built_in">CreatePin</span>(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, UK2Node_Print::PN_PrintToLog);</span><br><span class="line">	PinLog-&gt;DefaultValue = <span class="string">&quot;True&quot;</span>;</span><br><span class="line">	UScriptStruct* ColorStruct = TBaseStructure&lt;FLinearColor&gt;::<span class="built_in">Get</span>();</span><br><span class="line">	UEdGraphPin* PinColor = <span class="built_in">CreatePin</span>(EGPD_Input, UEdGraphSchema_K2::PC_Struct, ColorStruct, UK2Node_Print::PN_Color);</span><br><span class="line">	FLinearColor color = FLinearColor::Green;</span><br><span class="line">	PinColor-&gt;DefaultValue = color.<span class="built_in">ToString</span>();</span><br><span class="line"></span><br><span class="line">	UEdGraphPin* PinDuration = <span class="built_in">CreatePin</span>(EGPD_Input, UEdGraphSchema_K2::PC_Float, UK2Node_Print::PN_Duration);</span><br><span class="line">	PinDuration-&gt;DefaultValue = <span class="string">&quot;2.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> FName&amp; PinName : ArgPinNames) &#123;</span><br><span class="line">		<span class="built_in">CreatePin</span>(EGPD_Input, UEdGraphSchema_K2::PC_String, PinName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_Print::PinDefaultValueChanged</span><span class="params">(UEdGraphPin* ChangedPin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PinDefaultValueChanged</span>(ChangedPin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_Print::AddPinToNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Modify</span>();</span><br><span class="line"></span><br><span class="line">	TMap&lt;FString, FStringFormatArg&gt; FormatArgs = &#123;</span><br><span class="line">			&#123;<span class="built_in">TEXT</span>(<span class="string">&quot;Count&quot;</span>), ArgPinNames.<span class="built_in">Num</span>()&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">FName <span class="title">NewPinName</span><span class="params">(*FString::Format(TEXT(<span class="string">&quot;&#123;Count&#125;&quot;</span>), FormatArgs))</span></span>;</span><br><span class="line">	ArgPinNames.<span class="built_in">Add</span>(NewPinName);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CreatePin</span>(EGPD_Input, UEdGraphSchema_K2::PC_String, NewPinName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_Print::RemoveInputPin</span><span class="params">(UEdGraphPin* Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FScopedTransaction <span class="title">Transaction</span><span class="params">(FText::FromString(<span class="string">&quot;Printf_RemoveInputPin&quot;</span>))</span></span>;</span><br><span class="line">	<span class="built_in">Modify</span>();</span><br><span class="line"></span><br><span class="line">	ArgPinNames.<span class="built_in">Remove</span>(Pin-&gt;<span class="built_in">GetFName</span>());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RemovePin</span>(Pin);</span><br><span class="line">	FBlueprintEditorUtils::<span class="built_in">MarkBlueprintAsStructurallyModified</span>(<span class="built_in">GetBlueprint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TSharedPtr&lt;SGraphNode&gt; <span class="title">UK2Node_Print::CreateVisualWidget</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">SNew</span>(SGraphNode_Printf, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LOCTEXT_NAMESPACE</span></span><br></pre></td></tr></table></figure>



<ul>
<li>函数库</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFlib_IO::PrintArray</span><span class="params">(UObject* context,  <span class="keyword">const</span> TArray&lt;FString&gt;&amp; InStrings, <span class="keyword">bool</span> bScreen, <span class="keyword">bool</span> bLog, FLinearColor Color, <span class="keyword">float</span> Duration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FString <span class="title">OutString</span><span class="params">(TEXT(<span class="string">&quot;&quot;</span>))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; Word : InStrings)</span><br><span class="line">		OutString += Word;</span><br><span class="line">	UKismetSystemLibrary::<span class="built_in">PrintString</span>(context,OutString,bScreen,bLog,Color,Duration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h4 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h4><p>我们还需要一个继承于<code>SGraphNodeK2Base</code>的辅助类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KismetNodes/SGraphNodeK2Base.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;GraphNode_Printf.generated.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UK2Node_Print</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVerticalBox</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BLUEPRINTLIBRARYUTILITYEDITOR_API</span> <span class="title">SGraphNode_Printf</span> :</span> <span class="keyword">public</span> SGraphNodeK2Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SLATE_BEGIN_ARGS</span>(SGraphNode_Printf) &#123;&#125;</span><br><span class="line">	<span class="built_in">SLATE_END_ARGS</span>()</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Construct</span><span class="params">(<span class="keyword">const</span> FArguments&amp; InArgs, UEdGraphNode* InNode)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateInputSideAddButton</span><span class="params">(TSharedPtr&lt;SVerticalBox&gt; InputBox)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FReply <span class="title">OnAddPin</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Node/GraphNode_Printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GraphEditorSettings.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SGraphNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Node/K2Node_Print.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SGraphNode_Printf::Construct</span><span class="params">(<span class="keyword">const</span> FArguments&amp; InArgs, UEdGraphNode* InNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;GraphNode = InNode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">SetCursor</span>(EMouseCursor::CardinalCross);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">UpdateGraphNode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SGraphNode_Printf::CreateInputSideAddButton</span><span class="params">(TSharedPtr&lt;SVerticalBox&gt; InputBox)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FText AddPinName = FText::<span class="built_in">FromString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Add Pin&quot;</span>));</span><br><span class="line">	FText RemovePinName = FText::<span class="built_in">FromString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Remove Pin&quot;</span>));</span><br><span class="line">	TSharedRef&lt;SWidget&gt; AddPinButton = <span class="built_in">AddPinButtonContent</span>(AddPinName, AddPinName);</span><br><span class="line">	TSharedRef&lt;SWidget&gt; RemovePinButton = <span class="built_in">AddPinButtonContent</span>(RemovePinName, RemovePinName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	FMargin AddPinPadding = Settings-&gt;<span class="built_in">GetInputPinPadding</span>();</span><br><span class="line">	AddPinPadding.Top += <span class="number">6.0f</span>;</span><br><span class="line"></span><br><span class="line">	InputBox-&gt;<span class="built_in">AddSlot</span>()</span><br><span class="line">		.<span class="built_in">AutoHeight</span>()</span><br><span class="line">		.<span class="built_in">VAlign</span>(VAlign_Center)</span><br><span class="line">		.<span class="built_in">Padding</span>(AddPinPadding)</span><br><span class="line">		[</span><br><span class="line">			AddPinButton</span><br><span class="line">		];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FReply <span class="title">SGraphNode_Printf::OnAddPin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UK2Node_Print* BPNode = CastChecked&lt;UK2Node_Print&gt;(GraphNode);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> FScopedTransaction <span class="title">Transaction</span><span class="params">(NSLOCTEXT(<span class="string">&quot;Kismet&quot;</span>, <span class="string">&quot;AddArgumentPin&quot;</span>, <span class="string">&quot;Add Argument Pin&quot;</span>))</span></span>;</span><br><span class="line">	BPNode-&gt;<span class="built_in">Modify</span>();</span><br><span class="line"></span><br><span class="line">	BPNode-&gt;<span class="built_in">AddPinToNode</span>();</span><br><span class="line">	FBlueprintEditorUtils::<span class="built_in">MarkBlueprintAsModified</span>(BPNode-&gt;<span class="built_in">GetBlueprint</span>());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UpdateGraphNode</span>();</span><br><span class="line">	GraphNode-&gt;<span class="built_in">GetGraph</span>()-&gt;<span class="built_in">NotifyGraphChanged</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FReply::<span class="built_in">Handled</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="K2Node-GetMatProperty"><a href="#K2Node-GetMatProperty" class="headerlink" title="K2Node_GetMatProperty"></a>K2Node_GetMatProperty</h3><p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_03_22_10_06_11_380.gif" alt="录制_2021_03_22_10_06_11_380"></p>
<p>这个是基于<code>assimp</code>开源库制作的从外部文件获取模型材质球的节点, 关于<code>assimp</code>库的内容参考 <a href="https://supervj.top/2021/03/21/%E5%BC%80%E6%BA%90%E5%9B%BE%E5%BD%A2%E5%BA%93Assimp/">开源图形库Assimp</a></p>
<p>此节点特殊点有几个</p>
<ul>
<li>输入参数根据枚举的变化, 会动态增加/删除输入引脚</li>
<li>返回参数类型是动态的,根据输入枚举</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_GetMatProperty::ExpandNode</span><span class="params">(FKismetCompilerContext&amp; CompilerContext, UEdGraph* SourceGraph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">ExpandNode</span>(CompilerContext, SourceGraph);</span><br><span class="line"></span><br><span class="line">	UEdGraphPin* ExecPin = <span class="built_in">GetExecPin</span>();</span><br><span class="line">	UEdGraphPin* ThenPin = <span class="built_in">GetThenPin</span>();</span><br><span class="line">	<span class="keyword">if</span> (ExecPin &amp;&amp; ThenPin) &#123;</span><br><span class="line"></span><br><span class="line">		UFunction* Function = UFlib_IO::<span class="built_in">StaticClass</span>()-&gt;<span class="built_in">FindFunctionByName</span>(FunctionName);</span><br><span class="line">		<span class="keyword">if</span> (Function == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			CompilerContext.MessageLog.<span class="built_in">Error</span>(*<span class="built_in">LOCTEXT</span>(<span class="string">&quot;InvalidFunctionName&quot;</span>, <span class="string">&quot;BaseAsyncTask: Type not supported or not initialized. @@&quot;</span>).<span class="built_in">ToString</span>(), <span class="keyword">this</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		UK2Node_CallFunction* CallFuncNode = CompilerContext.SpawnIntermediateNode&lt;UK2Node_CallFunction&gt;(<span class="keyword">this</span>, SourceGraph);</span><br><span class="line"></span><br><span class="line">		CallFuncNode-&gt;<span class="built_in">SetFromFunction</span>(Function);</span><br><span class="line">		CallFuncNode-&gt;<span class="built_in">AllocateDefaultPins</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// move pins</span></span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*ExecPin, *(CallFuncNode-&gt;<span class="built_in">GetExecPin</span>()));</span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*ThenPin, *(CallFuncNode-&gt;<span class="built_in">GetThenPin</span>()));</span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*<span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_File), *(CallFuncNode-&gt;<span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_File)));</span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*<span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_Key), *(CallFuncNode-&gt;<span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_Key)));</span><br><span class="line">		CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*<span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_Return), *(CallFuncNode-&gt;<span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_Return)));</span><br><span class="line">		UEdGraphPin* tPin = <span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_T);</span><br><span class="line">		<span class="comment">//这里对2个扩展Pin选择是否连接</span></span><br><span class="line">        <span class="keyword">if</span> (tPin &amp;&amp; !tPin-&gt;bHidden)</span><br><span class="line">		&#123;</span><br><span class="line">			CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*<span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_T), *(CallFuncNode-&gt;<span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_T)));</span><br><span class="line">		&#125;</span><br><span class="line">		UEdGraphPin* nPin = <span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_N);</span><br><span class="line">		<span class="keyword">if</span> (nPin &amp;&amp; !nPin-&gt;bHidden)</span><br><span class="line">		&#123;</span><br><span class="line">			CompilerContext.<span class="built_in">MovePinLinksToIntermediate</span>(*<span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_N), *(CallFuncNode-&gt;<span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_N)));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// break any links to the expanded node</span></span><br><span class="line">	<span class="built_in">BreakAllNodeLinks</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_GetMatProperty::RefreshExtraPin</span><span class="params">(EMatPropertyKeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> bHasExtraPin =  key == EMatPropertyKeyType::TEXTURE || key == EMatPropertyKeyType::TEXBLEND || key == EMatPropertyKeyType::TEXOP ||</span><br><span class="line">		key == EMatPropertyKeyType::MAPPING || key == EMatPropertyKeyType::UVWSRC || key == EMatPropertyKeyType::MAPPINGMODE_U || </span><br><span class="line">		key == EMatPropertyKeyType::MAPPINGMODE_V || key == EMatPropertyKeyType::TEXMAP_AXIS || key == EMatPropertyKeyType::TEXFLAGS;</span><br><span class="line"></span><br><span class="line">		UEdGraphPin* typePin = <span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_T);</span><br><span class="line">		UEdGraphPin* nPin = <span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_N);</span><br><span class="line">		<span class="keyword">if</span> (typePin)</span><br><span class="line">		&#123;</span><br><span class="line">			typePin-&gt;bHidden = !bHasExtraPin;</span><br><span class="line">			<span class="keyword">if</span> (!bHasExtraPin)</span><br><span class="line">			&#123;</span><br><span class="line">				typePin-&gt;<span class="built_in">BreakAllPinLinks</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nPin)</span><br><span class="line">		&#123;</span><br><span class="line">			nPin-&gt;bHidden = !bHasExtraPin;</span><br><span class="line">			<span class="keyword">if</span> (!bHasExtraPin)</span><br><span class="line">			&#123;</span><br><span class="line">				nPin-&gt;<span class="built_in">BreakAllPinLinks</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数根据枚举类型来选择是否隐藏/显示对应的Pin</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_GetMatProperty::ExpandNode</span><span class="params">(FKismetCompilerContext&amp; CompilerContext, UEdGraph* SourceGraph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...................</span><br><span class="line">	UFunction* Function = UFlib_IO::<span class="built_in">StaticClass</span>()-&gt;<span class="built_in">FindFunctionByName</span>(FunctionName);</span><br><span class="line">    ...................</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_GetMatProperty::RefreshReturnPin</span><span class="params">(EReturnType newType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UEdGraph* Graph = <span class="built_in">GetGraph</span>();</span><br><span class="line">	<span class="keyword">if</span> (Graph)</span><br><span class="line">	&#123;</span><br><span class="line">		UEdGraphPin* oldRetPin = <span class="built_in">FindPin</span>(UK2Node_GetMatProperty::PinName_Return);</span><br><span class="line">		<span class="keyword">if</span> (oldRetPin)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">RemovePin</span>(oldRetPin);</span><br><span class="line">			Graph-&gt;<span class="built_in">NotifyGraphChanged</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		Graph-&gt;<span class="built_in">NotifyGraphChanged</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (newType)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> EReturnType::Color:</span><br><span class="line">	&#123;</span><br><span class="line">		FunctionName = <span class="built_in">GetFunctionName</span>(EReturnType::Color);</span><br><span class="line">		<span class="built_in">CreatePin</span>(EGPD_Output, UEdGraphSchema_K2::PC_Struct, ColorStruct, UK2Node_GetMatProperty::PinName_Return);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> EReturnType::Vector:</span><br><span class="line">	&#123;</span><br><span class="line">		FunctionName = <span class="built_in">GetFunctionName</span>(EReturnType::Vector);</span><br><span class="line">		<span class="built_in">CreatePin</span>(EGPD_Output, UEdGraphSchema_K2::PC_Struct, VectorStruct, UK2Node_GetMatProperty::PinName_Return);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> EReturnType::Int:</span><br><span class="line">	&#123;</span><br><span class="line">		FunctionName = <span class="built_in">GetFunctionName</span>(EReturnType::Int);</span><br><span class="line">		<span class="built_in">CreatePin</span>(EGPD_Output, UEdGraphSchema_K2::PC_Int, UK2Node_GetMatProperty::PinName_Return);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> EReturnType::Float:</span><br><span class="line">	&#123;</span><br><span class="line">		FunctionName = <span class="built_in">GetFunctionName</span>(EReturnType::Float);</span><br><span class="line">		<span class="built_in">CreatePin</span>(EGPD_Output, UEdGraphSchema_K2::PC_Float, UK2Node_GetMatProperty::PinName_Return);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> EReturnType::String:</span><br><span class="line">	&#123;</span><br><span class="line">		FunctionName = <span class="built_in">GetFunctionName</span>(EReturnType::String);</span><br><span class="line">		<span class="built_in">CreatePin</span>(EGPD_Output, UEdGraphSchema_K2::PC_String, UK2Node_GetMatProperty::PinName_Return);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		FunctionName = <span class="built_in">GetFunctionName</span>(EReturnType::String);</span><br><span class="line">		<span class="built_in">CreatePin</span>(EGPD_Output, UEdGraphSchema_K2::PC_String, UK2Node_GetMatProperty::PinName_Return);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据类型设置不同的<code>FunctionName</code>然后来获取函数指针</p>
<h3 id="K2Node的泛型"><a href="#K2Node的泛型" class="headerlink" title="K2Node的泛型"></a>K2Node的泛型</h3><p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2021_03_25_10_51_28_192.gif" alt="录制_2021_03_25_10_51_28_192"></p>
<p>我们顺路在上面节点加入一个泛型的输入变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_GetMatProperty::AllocateDefaultPins</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ..............</span><br><span class="line">UEdGraphPin* testPin = <span class="built_in">CreatePin</span>(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, <span class="built_in">TEXT</span>(<span class="string">&quot;TEST&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重写<code>virtual void PinTypeChanged(UEdGraphPin* Pin) override;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_GetMatProperty::PinTypeChanged</span><span class="params">(UEdGraphPin* Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Pin-&gt;PinName == <span class="built_in">TEXT</span>(<span class="string">&quot;TEST&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		UEdGraphPin* testPin = <span class="built_in">FindPin</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;TEST&quot;</span>));</span><br><span class="line">		<span class="keyword">if</span> (Pin-&gt;LinkedTo.<span class="built_in">Num</span>()&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			UEdGraphPin* InstigatorPin = Pin-&gt;LinkedTo[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">if</span> (testPin-&gt;PinType != InstigatorPin-&gt;PinType)</span><br><span class="line">			&#123;</span><br><span class="line">				testPin-&gt;PinType = InstigatorPin-&gt;PinType;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			testPin-&gt;PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;</span><br><span class="line">			testPin-&gt;PinType.PinSubCategory = NAME_None;</span><br><span class="line">			testPin-&gt;PinType.PinSubCategoryObject = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">GetGraph</span>()-&gt;<span class="built_in">NotifyGraphChanged</span>();</span><br><span class="line"></span><br><span class="line">		UBlueprint* Blueprint = <span class="built_in">GetBlueprint</span>();</span><br><span class="line">		<span class="keyword">if</span> (!Blueprint-&gt;bBeingCompiled)</span><br><span class="line">		&#123;</span><br><span class="line">			FBlueprintEditorUtils::<span class="built_in">MarkBlueprintAsModified</span>(Blueprint);</span><br><span class="line">			Blueprint-&gt;<span class="built_in">BroadcastChanged</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Super::<span class="built_in">PinTypeChanged</span>(Pin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>Pin</code>链接改变以后就调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UK2Node_GetMatProperty::NotifyPinConnectionListChanged</span><span class="params">(UEdGraphPin* Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">NotifyPinConnectionListChanged</span>(Pin);</span><br><span class="line">	<span class="built_in">PinTypeChanged</span>(Pin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>节点</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟相机的简单使用</title>
    <url>/2022/09/15/%E8%99%9A%E6%8B%9F%E7%9B%B8%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于LiveLink和UDP的像素流传输,</p>
<p>简单展示效果, 下面视频是通过TakeRecorder录制的过场动画</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/6c75015652957ebcb9661c7815d96ccd8479f369/imgnormal%20video.gif" alt="normal video"></p>
<span id="more"></span>

<p>官方文档 <a href="https://docs.unrealengine.com/5.0/zh-CN/virtual-cameras-in-unreal-engine/">https://docs.unrealengine.com/5.0/zh-CN/virtual-cameras-in-unreal-engine/</a></p>
<p>友情提示, <strong>官方文档的配置流程有大坑</strong></p>
<p>所以本文着重记录一下配置流程</p>
<h2 id="1-项目设置"><a href="#1-项目设置" class="headerlink" title="1.项目设置"></a>1.项目设置</h2><p>先确保引擎版本是否大于等于4.26, UE5也可以</p>
<p>然后开启下面几个插件</p>
<ol>
<li>VirtualCamera</li>
<li>RemoteSession</li>
<li>LiveLink</li>
<li>Apple ARKit(这个不确定, 官方没说, 其他资料有说要开启)</li>
</ol>
<p>然后找到项目设置中的 UDPMessaging</p>
<p>输入IP</p>
<p><img src="https://github.com/VJien/img/blob/master/imgimage-20220916103840211.png?raw=true" alt="image-20220916103840211"></p>
<p>如果像我这边不是同一网段的, 需要一些网络技术支持, 这里不展开</p>
<p>这里官网说的端口用0, 但是实际操作完了发现还是6666靠谱</p>
<p>然后渲染里面设置一下Frame Buffer, 如下图</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20220916103856704.png" alt="image-20220916103856704"></p>
<p> 重启</p>
<h2 id="2-手机端"><a href="#2-手机端" class="headerlink" title="2. 手机端"></a>2. 手机端</h2><p>下载Live Link VCam, 下载好了打开进入一个简单界面, 输入PC的IP地址 , 然后</p>
<p>不要点连接,</p>
<p>不要点连接,</p>
<p>不要点连接</p>
<h2 id="3-UE端"><a href="#3-UE端" class="headerlink" title="3. UE端"></a>3. UE端</h2><p>然后的步骤需要严格按照顺序</p>
<ol>
<li>拖一个VirtualCamera2Actor到场景</li>
<li>选择这个Actor里面的VCam组件</li>
<li>勾上组件的Enabled</li>
<li>勾上组件OutPutProviders[0].Output.IsActive</li>
</ol>
<p><img src="https://github.com/VJien/img/blob/master/imgimage-20220916103913988.png?raw=true" alt="image-20220916103913988"></p>
<ol start="5">
<li>打开LiveLink, 添加source, 如果你正确操作了手机端, 那么手机会一直发送UDP消息给UE, 这个能正确的看到一个类似下图的窗口, 选中手机连接</li>
</ol>
<p><img src="https://github.com/VJien/img/blob/master/imgimage-20220916104027513.png?raw=true" alt="image-20220916104027513"></p>
<ol start="6">
<li>回到VCam组件, 也选中这个手机, 那么两者就同步了</li>
</ol>
<p><img src="https://github.com/VJien/img/blob/master/imgimage-20220916104044591.png?raw=true" alt="image-20220916104044591"></p>
<ol start="7">
<li>手机端偶尔会连接失败, 尝试多次如果还是不行, 那么可能需要重启编辑器重新LiveLink一次一般都能解决</li>
</ol>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>虚拟相机</tag>
      </tags>
  </entry>
  <entry>
    <title>资源注册模块AssetRegistry分析</title>
    <url>/2020/11/27/%E8%B5%84%E6%BA%90%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>有的时候我们需要对当前工程下的特定资源进行一些操作,比如找到所有图片资源或者所有静态模型资源,然后把这些资源信息发到某个UI上进行操作等等</p>
<p>本文对UE4资源注册模块<code>AssetRegistry</code>进行简单的分析</p>
<p><em>目前蓝图已经封装了相应的库,可以非常方便的调用</em></p>
</blockquote>
<p><code>Asset Registry</code>模块负责处理引擎下的资源信息(收集/检索<code>*.uasset</code>),从这个模块中可以读取到所有资源信息(<code>FAssetData</code>)</p>
<h3 id="FAssetData"><a href="#FAssetData" class="headerlink" title="FAssetData"></a>FAssetData</h3><p>主要参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Obj的具体路径,比如 /Game/ThirdPersonCPP/Blueprints/ThirdPersonCharacter.ThirdPersonCharacter*/</span></span><br><span class="line">	FName ObjectPath;</span><br><span class="line"><span class="comment">//比如/Game/ThirdPersonCPP/Blueprints/ThirdPersonCharacter</span></span><br><span class="line">	FName PackageName;</span><br><span class="line"><span class="comment">//比如: /Game/ThirdPersonCPP/Blueprints/</span></span><br><span class="line">	FName PackagePath;</span><br><span class="line"><span class="comment">//资源名称</span></span><br><span class="line">	FName AssetName;</span><br><span class="line"><span class="comment">//资源class的名称,如果是蓝图则是Blueprint</span></span><br><span class="line">	FName AssetClass;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UProperty的名称和值的键值对</span></span><br><span class="line"><span class="comment">可以从此获取一些描述信息,比如蓝图资源的BlueprintType等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	FAssetDataTagMapSharedView TagsAndValues;</span><br><span class="line"><span class="comment">//ChunkID</span></span><br><span class="line">	TArray&lt;int32&gt; ChunkIDs;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在获取<code>Asset</code>的时候需要填充一个结构体参数<code>FARFilter</code>,里面的参数部分类似上述参数,之后再看</p>
</blockquote>
<h3 id="FARFilter"><a href="#FARFilter" class="headerlink" title="FARFilter"></a>FARFilter</h3><p>对资源进行检索的时候的过滤参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参考FAssetData</span></span><br><span class="line">	TArray&lt;FName&gt; PackageNames;</span><br><span class="line"><span class="comment">//参考FAssetData</span></span><br><span class="line">	TArray&lt;FName&gt; PackagePaths;</span><br><span class="line"><span class="comment">//参考FAssetData</span></span><br><span class="line">	TArray&lt;FName&gt; ObjectPaths;</span><br><span class="line"><span class="comment">//参考FAssetData</span></span><br><span class="line">	TArray&lt;FName&gt; ClassNames;</span><br><span class="line"><span class="comment">//白名单,蓝图不可见</span></span><br><span class="line">	TMultiMap&lt;FName, TOptional&lt;FString&gt;&gt; TagsAndValues;</span><br><span class="line"><span class="comment">//黑名单</span></span><br><span class="line">	RecursiveClassesExclusionSet;</span><br><span class="line"><span class="comment">//是否递归查找路径</span></span><br><span class="line">	<span class="keyword">bool</span> bRecursivePaths;</span><br><span class="line"><span class="comment">//是否递归查找类继承</span></span><br><span class="line">	<span class="keyword">bool</span> bRecursiveClasses;</span><br><span class="line"><span class="comment">//是否只查询磁盘上的资源</span></span><br><span class="line">	<span class="keyword">bool</span> bIncludeOnlyOnDiskAssets;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>比较需要注意的是<code>ClassNames</code>这个参数,这个类型并不是我们场景中对象的类型,打个比方,我们场景里的玩家一般是<code>ACharacter</code>,但是我们的资源其实就是<code>Blueprint</code>,所以在填充这个结构体的时候并不能用<code>*.::StaticClass()</code>来给与<code>Class</code>类型</p>
<p>一般情况资源的创建类型就是用右键创建出来的名称或类似的名称,并且都是继承自<code>Object</code></p>
<h3 id="FAssetRegistryState"><a href="#FAssetRegistryState" class="headerlink" title="FAssetRegistryState"></a>FAssetRegistryState</h3><p>储存了读取asset后的相关信息，用作磁盘内容的cache数据，用于描述asset registry当前的状态，可以由IAssetRegistry进行使用和维护。把这些数据单独组成一个FAssetRegistryState类，是为了减少耦合性，因为引擎中除asset registry外的其他模块 也需要用到这些数据。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>我们可以通过<code>static TScriptInterface&lt;IAssetRegistry&gt; GetAssetRegistry();</code>获取单例</p>
<p>蓝图亦可以</p>
<p><img src="https://img.supervj.top//img/image-20201127165818065.png" alt="image-20201127165818065"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> UObject* <span class="title">GetAsset</span><span class="params">(<span class="keyword">const</span> FAssetData&amp; InAssetData)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过上述方法可以自定义的根据<code>FARFliter</code>参数来获取所需的资源数据</p>
<p>如果不清楚每个参数的含义,可以反向的通过下面方法来查看</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> FAssetData <span class="title">CreateAssetData</span><span class="params">(<span class="keyword">const</span> UObject* InAsset, <span class="keyword">bool</span> bAllowBlueprintClass = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetAssetsByPackageName</span><span class="params">(FName PackageName, TArray&lt;FAssetData&gt;&amp; OutAssetData, <span class="keyword">bool</span> bIncludeOnlyOnDiskAssets = <span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetAssetsByPath</span><span class="params">(FName PackagePath, TArray&lt;FAssetData&gt;&amp; OutAssetData, <span class="keyword">bool</span> bRecursive = <span class="literal">false</span>, <span class="keyword">bool</span> bIncludeOnlyOnDiskAssets = <span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetAssetsByClass</span><span class="params">(FName ClassName, TArray&lt;FAssetData&gt;&amp; OutAssetData, <span class="keyword">bool</span> bSearchSubClasses = <span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面三个方法根据不同方式来获取对应的资源</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetSubPaths</span><span class="params">(<span class="keyword">const</span> FString&amp; InBasePath, TArray&lt;FString&gt;&amp; OutPathList, <span class="keyword">bool</span> bInRecurse)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>基于一个基础路径获取子路径,比较有用</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetReferencers</span><span class="params">(FName PackageName, TArray&lt;FName&gt;&amp; OutReferencers, EAssetRegistryDependencyType::Type InReferenceType = EAssetRegistryDependencyType::Packages)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetDependencies</span><span class="params">(FName PackageName, TArray&lt;FName&gt;&amp; OutDependencies, EAssetRegistryDependencyType::Type InDependencyType = EAssetRegistryDependencyType::Packages)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>获取引用和依赖关系,也很有用</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SearchAllAssets</span><span class="params">(<span class="keyword">bool</span> bSynchronousSearch)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ScanFilesSynchronous</span><span class="params">(<span class="keyword">const</span> TArray&lt;FString&gt;&amp; InFilePaths, <span class="keyword">bool</span> bForceRescan = <span class="literal">false</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ScanPathsSynchronous</span><span class="params">(<span class="keyword">const</span> TArray&lt;FString&gt;&amp; InPaths, <span class="keyword">bool</span> bForceRescan = <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="comment">//等等</span></span><br></pre></td></tr></table></figure>

<p>扫描/搜索文件,不需要返回值,因为扫描以后文件就保存在<code>FAssetRegistryState</code>内了</p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>模块分析</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>《Multiplayer RPG Template》说明文档</title>
    <url>/2020/05/19/%E8%B6%854%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3CH/</url>
    <content><![CDATA[<blockquote>
<p> 这是一份<a href="https://www.unrealengine.com/marketplace/zh-CN/product/multiplayer-rpg-template">Multiplayer RPG Template</a>的说明文档,内容包含其中主要系统的配置和制作方法</p>
<p>此案例是基于UE4的<strong>ListerServer</strong>建立的局域网联机游戏demo，参考作品WOW</p>
<p>基于UE4版本4.25</p>
<p>demo尚且有未完善的地方，后续会跟进优化和修复</p>
</blockquote>
<h3 id="技能系统"><a href="#技能系统" class="headerlink" title="技能系统"></a>技能系统</h3><p><img src="https://img.supervj.top/imgchao4_skill1.jpg"></p>
<p>如上图所示，此图为技能表的配置信息，下面简述其中重要的参数</p>
<ul>
<li>Action: 这个变量代表这个行为的唯一ID，原则上跟表格的RowName相同，很多逻辑中需要通过这个ID查找关于这个技能的所有信息，或者通过这个ID执行这个技能等</li>
<li>Display(struct)：3个参数用来显示这个技能一般信息，比如名字或者说明还有图标的显示，在UMG上有相关的体现，当然你也可以用来自定义<ul>
<li><img src="https://img.supervj.top/imgchao4_skill4.jpg"></li>
<li><img src="https://img.supervj.top/imgchao4_skill5.jpg"></li>
</ul>
</li>
<li>CastData(struct)：这个是一个施法的结构体，主要设置的是施法的方式和条件<ul>
<li>Type:比如默认的读条施法，持续施法，攻击叠加类的施法等方式</li>
<li>Time:施法所需要的时长，0意味着瞬发</li>
<li>Duration:如果是持续施法，那么这个参数意味着引导时间</li>
<li>KeepAttackStat:施法完以后会继续进行普通攻击</li>
<li>MotionCast:移动施法，设置为否的话必须站立施法，一旦移动就打断施法</li>
<li>NotTargetCast:不需要目标的施法，一般用于范围技能比如火雨之类</li>
</ul>
</li>
<li>Mp:消耗魔法值，战士为怒气值</li>
<li>CD:冷却时间</li>
<li>MaxRange：最大释放范围，按照虚幻单位计算，0意味着无限制</li>
<li>LearnGold/Level:学习该技能的前置条件，0意味着无要求</li>
<li>RangeSelectRange:如果是范围选择的技能，此参数表示作用的半径</li>
<li>TargetType:目标类型，作用地方还是友方等</li>
<li>SkillClass:技能实例的类，无需手动创建</li>
</ul>
<h5 id="SkillRef"><a href="#SkillRef" class="headerlink" title="SkillRef"></a>SkillRef</h5><blockquote>
<p>这个是通过表格配置的SkillClass创建的，无需手动创建，你只需要制作这个类的逻辑和效果</p>
<p>这个类是继承自<code>BP_BaseSkill</code>,里面有一些乱七八糟的蓝图逻辑，不过并不是全部都是必须使用的，这个类很多情况下你可以自由发挥，反正技能释放了以后就通过这个类来控制这个技能实例的运行</p>
<p>下面就通过<code>IceBullet</code>这个技能类来说明一下</p>
</blockquote>
<p><img src="https://img.supervj.top/imgchao4_skill2.jpg"></p>
<p><code>IceBullet</code>继承于<code>ProjectileBase</code>，如上图所示，这是这个类的基本参数类型</p>
<ul>
<li>speed:飞行速度，依赖<code>ProjectileComponent</code></li>
<li>StopDistance:停止的距离，因为这个类是追踪目标飞行的，所以会总有接近并且到达目标的时候，到达目标并停止以后会产生一段逻辑</li>
<li>Duration:持续时间，如果没有命中到达时间以后也会摧毁自己</li>
<li>Sound/FX:相关的特效配置，Start可以用于产生的时候播放，Hit可以用于打中目标以后播放，但都需要手动释放，<ul>
<li>在<code>ProjectileBase</code>已经实现了<code>BeginPlay</code>以后调用Start的效果</li>
<li>在打中目标后已经实现播放Hit的效果</li>
</ul>
</li>
<li>BuffData：如果这个技能有buff/debuff可以设置这个类，需要手动调用方法来创建并运行buff类,如下图</li>
</ul>
<p><img src="https://img.supervj.top/imgchao4_skill3.jpg"></p>
<h5 id="BuffRef"><a href="#BuffRef" class="headerlink" title="BuffRef"></a>BuffRef</h5><blockquote>
<p>这是Buff的实例类，通过SkillRef内部调用<code>CreateBuff</code>方法创建</p>
<p>通过重写<code>BuffInit</code>和<code>BuffEnd</code>方法来实现自定义的逻辑，如果是拥有持续效果，那么你可以重写<code>BuffDelta</code> 方法来制作持续调用的逻辑</p>
</blockquote>
<h3 id="装备系统"><a href="#装备系统" class="headerlink" title="装备系统"></a>装备系统</h3><p><img src="https://img.supervj.top/imgchao4_equp1.jpg"></p>
<blockquote>
<p>如上图所示，这个是装备信息的配置表，下面简单介绍其中主要参数的作用</p>
</blockquote>
<ul>
<li>BodyPart：装备对应的位置</li>
<li>Mesh/Mat:用于显示这个装备实体的模型，装备在人物上或者丢弃到世界中的显示</li>
<li>Property:如字面意思就是2种属性，其中Adv属性会随着Base的更改而变化</li>
</ul>
<h3 id="道具系统"><a href="#道具系统" class="headerlink" title="道具系统"></a>道具系统</h3><p><img src="https://img.supervj.top/imgchao4_prop1.jpg"></p>
<blockquote>
<p>道具系统类似于装备系统</p>
</blockquote>
<ul>
<li>EffectType:作用类型，本案例只制作了治疗效果和增加魔法的效果</li>
<li>Value: 可以设置作用效果的范围值，当然这个不是必须的，具体是下面的道具类内部实现</li>
<li>CanBeStacked:如果是否那么一个道具占据背包栏的一格，否则么可以堆放到一起</li>
<li>ActionClass:道具类实现逻辑的类，参考Skill的实例实现，具体逻辑可以写到这个类里面</li>
</ul>
<h3 id="掉落系统"><a href="#掉落系统" class="headerlink" title="掉落系统"></a>掉落系统</h3><p><img src="https://img.supervj.top/imgchao4_drop1.jpg"></p>
<blockquote>
<p>如上图所示，掉落系统的配置放在<code>DataSystem</code> 这个类里面，为什么没有配置表格呢？O(∩_∩)O</p>
<p>当然也可以，你可以自己创建一个类似的表格然后替换其中的逻辑，这个很简单</p>
</blockquote>
<p>这个配置信息是一个Map键值对，键对应的是角色的类，值即是掉落信息数组</p>
<ul>
<li>Action:选择装备/道具等的Action名称</li>
<li>Type:选择是装备/道具，当然你要是想掉落技能的话理论上也可以，请自由发挥</li>
<li>Amount:掉落数量</li>
<li>Probability:概率，这个概率计算是在角色创建的时候就完成的，非击杀的时候</li>
</ul>
<h3 id="任务系统"><a href="#任务系统" class="headerlink" title="任务系统"></a>任务系统</h3><p><img src="https://img.supervj.top/imgchao4_task1.jpg"></p>
<blockquote>
<p> 如上图所示，这是任务表格的配置信息</p>
</blockquote>
<ul>
<li>Titile：任务的标题，会显示在任务栏内的抬头标题部分</li>
<li>Target：任务的目标</li>
<li>DynamicTargetStat:这个会动态的刷新，具体实现的逻辑在下面的TaskClass内</li>
<li>Descripion:任务描述</li>
<li>Reward：奖励</li>
</ul>
<h5 id="TaskRef"><a href="#TaskRef" class="headerlink" title="TaskRef"></a>TaskRef</h5><p><img src="https://img.supervj.top/imgchao4_task2.jpg"></p>
<p><img src="https://img.supervj.top/imgchao4_task3.jpg"></p>
<blockquote>
<p>如上图所示，每接受一个任务以后就会产生一个任务类来作为该任务的观察者(代理)</p>
<p>具体这个任务是干什么的你可以通过实现这个类内的逻辑来管理，同时设置任务目标里的动态信息</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h5 id="怪物刷新"><a href="#怪物刷新" class="headerlink" title="怪物刷新"></a>怪物刷新</h5><p><img src="https://img.supervj.top/imgchao4_aigenerat1.jpg"></p>
<blockquote>
<p>怪物刷新是在场景里放置一个<code>BP_AIGenerator</code>管理类来完成的</p>
</blockquote>
<ul>
<li>MaxNum:刷新的最大数量</li>
<li>AIClass:设置刷新角色的类，超过1个的时候就随机从中刷新</li>
<li>Range:以该管理类的位置为中心的半径内刷新怪物</li>
</ul>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>资源汇总</title>
    <url>/2022/09/24/%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网盘查找太过于繁琐，  不如记录到文档中</p>
<p>密码私聊</p>
<span id="more"></span>



<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="人形角色"><a href="#人形角色" class="headerlink" title="人形角色"></a>人形角色</h3><h4 id="Etasphera85"><a href="#Etasphera85" class="headerlink" title="Etasphera85"></a>Etasphera85</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925111034410.png" alt="image-20220925111034410"></p>
<h3 id="Sci-fi-Samurai-Robot"><a href="#Sci-fi-Samurai-Robot" class="headerlink" title="Sci-fi Samurai Robot"></a>Sci-fi Samurai Robot</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926105502841.png" alt="image-20220926105502841"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-samurai-robot?sessionInvalidated=true">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-samurai-robot?sessionInvalidated=true</a></p>
<p>链接：<a href="https://pan.baidu.com/s/14SIDNoIM8oVVPBDdeN0Baw">https://pan.baidu.com/s/14SIDNoIM8oVVPBDdeN0Baw</a> </p>
<h4 id="Sci-Fi-Space-Soldier-Female"><a href="#Sci-Fi-Space-Soldier-Female" class="headerlink" title="Sci Fi Space Soldier Female"></a>Sci Fi Space Soldier Female</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925114932161.png" alt="image-20220925114932161"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-space-soldier-female">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-space-soldier-female</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1X8rHBXM5TqhuAwm53EEOHQ">https://pan.baidu.com/s/1X8rHBXM5TqhuAwm53EEOHQ</a> </p>
<h4 id="Modular-Soldier"><a href="#Modular-Soldier" class="headerlink" title="Modular Soldier"></a>Modular Soldier</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925115047478.png" alt="image-20220925115047478"></p>
<p>链接：<a href="https://pan.baidu.com/s/1hAAVh16DZdkFTV-pehwHGg">https://pan.baidu.com/s/1hAAVh16DZdkFTV-pehwHGg</a> </p>
<h4 id="Crash-Test-Robot-Dummy"><a href="#Crash-Test-Robot-Dummy" class="headerlink" title="Crash Test Robot Dummy"></a>Crash Test Robot Dummy</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925115212219.png" alt="image-20220925115212219"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/crash-test-robot-dummy">https://www.unrealengine.com/marketplace/zh-CN/product/crash-test-robot-dummy</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1rF3C7Egv8424vsAS8Ue1LQ">https://pan.baidu.com/s/1rF3C7Egv8424vsAS8Ue1LQ</a> </p>
<h4 id="Military-Character-Dark"><a href="#Military-Character-Dark" class="headerlink" title="Military Character Dark"></a>Military Character Dark</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925115337432.png" alt="image-20220925115337432"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/military-character-dark">https://www.unrealengine.com/marketplace/zh-CN/product/military-character-dark</a></p>
<p>免费</p>
<h4 id="Shirtless-Zombies-Pack"><a href="#Shirtless-Zombies-Pack" class="headerlink" title="Shirtless Zombies Pack"></a>Shirtless Zombies Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925115818846.png" alt="image-20220925115818846"></p>
<p>链接：<a href="https://pan.baidu.com/s/1JP5Mhu7mn4wkYJ3HXBZsnA">https://pan.baidu.com/s/1JP5Mhu7mn4wkYJ3HXBZsnA</a> </p>
<h4 id="Sci-Fi-Robot-Character-Pack"><a href="#Sci-Fi-Robot-Character-Pack" class="headerlink" title="Sci-Fi Robot Character Pack"></a>Sci-Fi Robot Character Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925214603906.png" alt="image-20220925214603906"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-robot-character-pack">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-robot-character-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1mZYuGkh05mYaqTgHVb3_kw">https://pan.baidu.com/s/1mZYuGkh05mYaqTgHVb3_kw</a> </p>
<h4 id="Ariana-Character"><a href="#Ariana-Character" class="headerlink" title="Ariana Character"></a>Ariana Character</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925214714736.png" alt="image-20220925214714736"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/ariana-character">https://www.unrealengine.com/marketplace/zh-CN/product/ariana-character</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1K0Z0tNXVy5Lv4V8OLNXTyQ">https://pan.baidu.com/s/1K0Z0tNXVy5Lv4V8OLNXTyQ</a> </p>
<h4 id="14-Orcs-Pack"><a href="#14-Orcs-Pack" class="headerlink" title="14 Orcs Pack"></a>14 Orcs Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925214849586.png" alt="image-20220925214849586"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/orcs-pack">https://www.unrealengine.com/marketplace/zh-CN/product/orcs-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1rF89KLybtz0urWF_z_WWQQ">https://pan.baidu.com/s/1rF89KLybtz0urWF_z_WWQQ</a> </p>
<h4 id="Biotech-Rogue"><a href="#Biotech-Rogue" class="headerlink" title="Biotech - Rogue"></a>Biotech - Rogue</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925215003767.png" alt="image-20220925215003767"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/biotech-rogue">https://www.unrealengine.com/marketplace/zh-CN/product/biotech-rogue</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1VWtAoGYrb4b0wYgK4YpQ9A">https://pan.baidu.com/s/1VWtAoGYrb4b0wYgK4YpQ9A</a> </p>
<h4 id="SciF-Space-Soldier"><a href="#SciF-Space-Soldier" class="headerlink" title="SciF Space Soldier"></a>SciF Space Soldier</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925215151501.png" alt="image-20220925215151501"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-space-soldier">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-space-soldier</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1zU4f_PZPigmfL67NySLf4g">https://pan.baidu.com/s/1zU4f_PZPigmfL67NySLf4g</a> </p>
<h4 id="RK-Sci-Fi-Soldier"><a href="#RK-Sci-Fi-Soldier" class="headerlink" title="RK Sci Fi Soldier"></a>RK Sci Fi Soldier</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925215255070.png" alt="image-20220925215255070"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/rk-sci-fi-soldier">https://www.unrealengine.com/marketplace/zh-CN/product/rk-sci-fi-soldier</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1GqG1tFe8bgJyHEPDAHAOhg">https://pan.baidu.com/s/1GqG1tFe8bgJyHEPDAHAOhg</a> </p>
<h4 id="Sci-Fi-Alien-Soldier"><a href="#Sci-Fi-Alien-Soldier" class="headerlink" title="Sci Fi Alien Soldier"></a>Sci Fi Alien Soldier</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925215342762.png" alt="image-20220925215342762"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-alien-soldier">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-alien-soldier</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1QwuFuJRxEGK899sdQgfTDw">https://pan.baidu.com/s/1QwuFuJRxEGK899sdQgfTDw</a> </p>
<h4 id="Cyborg-Soldier-V1"><a href="#Cyborg-Soldier-V1" class="headerlink" title="Cyborg Soldier V1"></a>Cyborg Soldier V1</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925215458150.png" alt="image-20220925215458150"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/cyborg-soldier-v1">https://www.unrealengine.com/marketplace/zh-CN/product/cyborg-soldier-v1</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1sB8PISfhvBnUDeNRkkggAw">https://pan.baidu.com/s/1sB8PISfhvBnUDeNRkkggAw</a> </p>
<h4 id="Elite-Soldiers"><a href="#Elite-Soldiers" class="headerlink" title="Elite Soldiers"></a>Elite Soldiers</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925215530512.png" alt="image-20220925215530512"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/elite-soldiers">https://www.unrealengine.com/marketplace/zh-CN/product/elite-soldiers</a></p>
<p>链接：<a href="https://pan.baidu.com/s/13kKocDKCb-OUQiiPw2c_Sg">https://pan.baidu.com/s/13kKocDKCb-OUQiiPw2c_Sg</a> </p>
<h4 id="SCI-FI-Light-Biped-Mech"><a href="#SCI-FI-Light-Biped-Mech" class="headerlink" title="SCI FI: Light Biped Mech"></a>SCI FI: Light Biped Mech</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925220949341.png" alt="image-20220925220949341"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-light-biped-mech">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-light-biped-mech</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1QoaUB4cl15b9L8TgKREoFg">https://pan.baidu.com/s/1QoaUB4cl15b9L8TgKREoFg</a> </p>
<h4 id="SCI-FI-ADVANCED-COMBAT-DROID"><a href="#SCI-FI-ADVANCED-COMBAT-DROID" class="headerlink" title="SCI FI ADVANCED COMBAT DROID"></a>SCI FI ADVANCED COMBAT DROID</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925221111788.png" alt="image-20220925221111788"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-advanced-combat-droid">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-advanced-combat-droid</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1RsEK7HpvROMzs1QKvL_MAg">https://pan.baidu.com/s/1RsEK7HpvROMzs1QKvL_MAg</a> </p>
<h4 id="Sci-Fi-Characters-Pack"><a href="#Sci-Fi-Characters-Pack" class="headerlink" title="Sci-Fi Characters (Pack)"></a>Sci-Fi Characters (Pack)</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925221332030.png" alt="image-20220925221332030"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-characters-pack">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-characters-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1FT4H6VfQ6kBVcfVAJaTMCg">https://pan.baidu.com/s/1FT4H6VfQ6kBVcfVAJaTMCg</a> </p>
<h4 id="SCI-FI-ELITE-TROOPER"><a href="#SCI-FI-ELITE-TROOPER" class="headerlink" title="SCI FI: ELITE TROOPER"></a>SCI FI: ELITE TROOPER</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926102455932.png" alt="image-20220926102455932"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-elite-trooper">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-elite-trooper</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1P8ty5fGIiJFcvto0Ep17AA">https://pan.baidu.com/s/1P8ty5fGIiJFcvto0Ep17AA</a> </p>
<h4 id="Spider-Queen"><a href="#Spider-Queen" class="headerlink" title="Spider Queen"></a>Spider Queen</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208194551610.png" alt="image-20230208194551610"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/spider-queen-01">https://www.unrealengine.com/marketplace/zh-CN/product/spider-queen-01</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1O-dI6PtPTOjwzoseaMZ_ow">https://pan.baidu.com/s/1O-dI6PtPTOjwzoseaMZ_ow</a> </p>
<h4 id="Girl-Anastasia"><a href="#Girl-Anastasia" class="headerlink" title="Girl Anastasia"></a>Girl Anastasia</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208195300215.png" alt="image-20230208195300215"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/anastasia">https://www.unrealengine.com/marketplace/zh-CN/product/anastasia</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1UTZrpFCl5B6HszErGcNViw">https://pan.baidu.com/s/1UTZrpFCl5B6HszErGcNViw</a> </p>
<h4 id="Kind-Witch"><a href="#Kind-Witch" class="headerlink" title="Kind Witch"></a>Kind Witch</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208195619893.png" alt="image-20230208195619893"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/kind-witch">https://www.unrealengine.com/marketplace/zh-CN/product/kind-witch</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1GtVDAy-7e7I5EE-8jPhxag">https://pan.baidu.com/s/1GtVDAy-7e7I5EE-8jPhxag</a> </p>
<h4 id="Vampire-Lady"><a href="#Vampire-Lady" class="headerlink" title="Vampire Lady"></a>Vampire Lady</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208195755130.png" alt="image-20230208195755130"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/vampire-01">https://www.unrealengine.com/marketplace/zh-CN/product/vampire-01</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1hh4WX82aVbfwUx7FsHj9ng">https://pan.baidu.com/s/1hh4WX82aVbfwUx7FsHj9ng</a> </p>
<h4 id="Vampire-Girl-Modular"><a href="#Vampire-Girl-Modular" class="headerlink" title="Vampire Girl Modular"></a>Vampire Girl Modular</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208200001469.png" alt="image-20230208200001469"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/vampire-girl-modular">https://www.unrealengine.com/marketplace/zh-CN/product/vampire-girl-modular</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1-ZNpn7AuttMIV3BVR4o3Qg">https://pan.baidu.com/s/1-ZNpn7AuttMIV3BVR4o3Qg</a> </p>
<h4 id="Modular-Elf-Archer-Girl"><a href="#Modular-Elf-Archer-Girl" class="headerlink" title="Modular Elf Archer Girl"></a>Modular Elf Archer Girl</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208200507302.png" alt="image-20230208200507302"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/modular-elf-archer-girl">https://www.unrealengine.com/marketplace/zh-CN/product/modular-elf-archer-girl</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1yo6nIZIVUfBVBqUX4DKFUQ">https://pan.baidu.com/s/1yo6nIZIVUfBVBqUX4DKFUQ</a> </p>
<h4 id="Assassin-Girl"><a href="#Assassin-Girl" class="headerlink" title="Assassin Girl"></a>Assassin Girl</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208200618448.png" alt="image-20230208200618448"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/assassin-girl-modular">https://www.unrealengine.com/marketplace/zh-CN/product/assassin-girl-modular</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1WJ3hJ2FTcVtvNea6kceFxw">https://pan.baidu.com/s/1WJ3hJ2FTcVtvNea6kceFxw</a> </p>
<h4 id="Techwear-Girls"><a href="#Techwear-Girls" class="headerlink" title="Techwear Girls"></a>Techwear Girls</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208200725453.png" alt="image-20230208200725453"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/techwear-girls">https://www.unrealengine.com/marketplace/zh-CN/product/techwear-girls</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Poi0ATvnINP4ASnPZfrF5Q">https://pan.baidu.com/s/1Poi0ATvnINP4ASnPZfrF5Q</a> </p>
<h4 id="Angelica"><a href="#Angelica" class="headerlink" title="Angelica"></a>Angelica</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208200931592.png" alt="image-20230208200931592"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/angelica">https://www.unrealengine.com/marketplace/zh-CN/product/angelica</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1E2my8wz2JthFa22jUpsBSw">https://pan.baidu.com/s/1E2my8wz2JthFa22jUpsBSw</a> </p>
<h4 id="Cosmo-Bunny-Girl"><a href="#Cosmo-Bunny-Girl" class="headerlink" title="Cosmo Bunny Girl"></a>Cosmo Bunny Girl</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208201143384.png" alt="image-20230208201143384"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/cosmo-bunny-girl">https://www.unrealengine.com/marketplace/zh-CN/product/cosmo-bunny-girl</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1ddYoh1EDJzDAk0hZQrgejg">https://pan.baidu.com/s/1ddYoh1EDJzDAk0hZQrgejg</a> </p>
<h4 id="Cosmo-Cat-Girl"><a href="#Cosmo-Cat-Girl" class="headerlink" title="Cosmo Cat Girl"></a>Cosmo Cat Girl</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208201231964.png" alt="image-20230208201231964"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/cosmo-cat-girl">https://www.unrealengine.com/marketplace/zh-CN/product/cosmo-cat-girl</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1BCJO8PavLq3ZMWUE0jc22g">https://pan.baidu.com/s/1BCJO8PavLq3ZMWUE0jc22g</a> </p>
<h4 id="Cosmo-Fox-Girl-Sci-fi-Kitsune"><a href="#Cosmo-Fox-Girl-Sci-fi-Kitsune" class="headerlink" title="Cosmo Fox Girl / Sci-fi Kitsune"></a>Cosmo Fox Girl / Sci-fi Kitsune</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208201342778.png" alt="image-20230208201342778"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/cosmo-fox-girl-sci-fi-kitsune">https://www.unrealengine.com/marketplace/zh-CN/product/cosmo-fox-girl-sci-fi-kitsune</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1nBp7SdzRtRyTMkyrIwOE-g">https://pan.baidu.com/s/1nBp7SdzRtRyTMkyrIwOE-g</a> </p>
<h4 id="Egypt-Girl"><a href="#Egypt-Girl" class="headerlink" title="Egypt Girl"></a>Egypt Girl</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208201438440.png" alt="image-20230208201438440"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/egypt-girl">https://www.unrealengine.com/marketplace/zh-CN/product/egypt-girl</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1nFukpTJfcUtnIdGYZEbcoA">https://pan.baidu.com/s/1nFukpTJfcUtnIdGYZEbcoA</a> </p>
<h4 id="Kitsune"><a href="#Kitsune" class="headerlink" title="Kitsune"></a>Kitsune</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208201616665.png" alt="image-20230208201616665"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/kitsune">https://www.unrealengine.com/marketplace/zh-CN/product/kitsune</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Ub-7sCPlO0vV-q6CmC2xFg">https://pan.baidu.com/s/1Ub-7sCPlO0vV-q6CmC2xFg</a> </p>
<h4 id="Mechanic-Girl"><a href="#Mechanic-Girl" class="headerlink" title="Mechanic Girl"></a>Mechanic Girl</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208201655147.png" alt="image-20230208201655147"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/mechanic-girl">https://www.unrealengine.com/marketplace/zh-CN/product/mechanic-girl</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1FsZaIsSxv6uosHoaF3ZfkQ">https://pan.baidu.com/s/1FsZaIsSxv6uosHoaF3ZfkQ</a> </p>
<h4 id="Medieval-Girl"><a href="#Medieval-Girl" class="headerlink" title="Medieval Girl"></a>Medieval Girl</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208201735445.png" alt="image-20230208201735445"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/medieval-girl">https://www.unrealengine.com/marketplace/zh-CN/product/medieval-girl</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1bG-mWnH6CA51BBm8SgemVA">https://pan.baidu.com/s/1bG-mWnH6CA51BBm8SgemVA</a> </p>
<h4 id="Shaman-Girl-Modular"><a href="#Shaman-Girl-Modular" class="headerlink" title="Shaman Girl Modular"></a>Shaman Girl Modular</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208201823221.png" alt="image-20230208201823221"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/shaman-girl-modular">https://www.unrealengine.com/marketplace/zh-CN/product/shaman-girl-modular</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1gJw2B5OPMVvXJ1__dS7TlA">https://pan.baidu.com/s/1gJw2B5OPMVvXJ1__dS7TlA</a> </p>
<h4 id="Succubus-Lucia"><a href="#Succubus-Lucia" class="headerlink" title="Succubus Lucia"></a>Succubus Lucia</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208201857321.png" alt="image-20230208201857321"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/succubus-lucia">https://www.unrealengine.com/marketplace/zh-CN/product/succubus-lucia</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1j9G5_eFbBAQJ7Bcq-Zb86Q">https://pan.baidu.com/s/1j9G5_eFbBAQJ7Bcq-Zb86Q</a> </p>
<h4 id="Succubus-Lily"><a href="#Succubus-Lily" class="headerlink" title="Succubus Lily"></a>Succubus Lily</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208201947772.png" alt="image-20230208201947772"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/succubus-lily">https://www.unrealengine.com/marketplace/zh-CN/product/succubus-lily</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1iLXIqwHESDZfch63tyiOiQ">https://pan.baidu.com/s/1iLXIqwHESDZfch63tyiOiQ</a> </p>
<h4 id="Sword-Elf"><a href="#Sword-Elf" class="headerlink" title="Sword Elf"></a>Sword Elf</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208202033967.png" alt="image-20230208202033967"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sword-elf">https://www.unrealengine.com/marketplace/zh-CN/product/sword-elf</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1bplIPhcFVdcOx2w534_7Ow">https://pan.baidu.com/s/1bplIPhcFVdcOx2w534_7Ow</a> </p>
<h4 id="Skeleton-Lightweight"><a href="#Skeleton-Lightweight" class="headerlink" title="Skeleton Lightweight"></a>Skeleton Lightweight</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225120742053.png" alt="image-20230225120742053"></p>
<p>就一个骷髅， 带不少动画， 质量还行</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/skeleton-lightweight">https://www.unrealengine.com/marketplace/zh-CN/product/skeleton-lightweight</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1BdEBvcttKfGCIEHNv65Dhg">https://pan.baidu.com/s/1BdEBvcttKfGCIEHNv65Dhg</a> </p>
<h4 id="Demons-Full-Pack"><a href="#Demons-Full-Pack" class="headerlink" title="Demons Full Pack"></a>Demons Full Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225120853870.png" alt="image-20230225120853870"></p>
<p>10种写实风恶魔， 质量非常高， 标准骨架</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/demons-full-pack">https://www.unrealengine.com/marketplace/zh-CN/product/demons-full-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1MmD2MvXFM-_yvcHYSv0Aow">https://pan.baidu.com/s/1MmD2MvXFM-_yvcHYSv0Aow</a> </p>
<h4 id="Super-pack-of-skeletons"><a href="#Super-pack-of-skeletons" class="headerlink" title="Super pack of skeletons"></a>Super pack of skeletons</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225121007373.png" alt="image-20230225121007373"></p>
<p>6个高精骷髅，  质量很不错， 标准骨架，不知道为什么商城打了2星</p>
<blockquote>
<p>有两个材质贴图丢失， 需要自己调整</p>
</blockquote>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/super-pack-of-skeletons">https://www.unrealengine.com/marketplace/zh-CN/product/super-pack-of-skeletons</a></p>
<h4 id="Samurai-Remastered"><a href="#Samurai-Remastered" class="headerlink" title="Samurai Remastered"></a>Samurai Remastered</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225121144093.png" alt="image-20230225121144093"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/samurai-remastered">https://www.unrealengine.com/marketplace/zh-CN/product/samurai-remastered</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1wyAksXqX2dqSALqCbAV5FQ">https://pan.baidu.com/s/1wyAksXqX2dqSALqCbAV5FQ</a> </p>
<h4 id="Ancient-Undead-Pack"><a href="#Ancient-Undead-Pack" class="headerlink" title="Ancient Undead Pack"></a>Ancient Undead Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225121226694.png" alt="image-20230225121226694"></p>
<p>5个高精 木乃伊战士， 标准骨架， 质量很高</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/ancient-undead-pack">https://www.unrealengine.com/marketplace/zh-CN/product/ancient-undead-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1AVToCSsPkwcuJBSQylOo6g">https://pan.baidu.com/s/1AVToCSsPkwcuJBSQylOo6g</a> </p>
<h3 id="动物-野兽"><a href="#动物-野兽" class="headerlink" title="动物/野兽"></a>动物/野兽</h3><h4 id="Dragons-Pack-PBR"><a href="#Dragons-Pack-PBR" class="headerlink" title="Dragons Pack PBR"></a>Dragons Pack PBR</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225123126630.png" alt="image-20230225123126630"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/dragons-pack-pbr">https://www.unrealengine.com/marketplace/zh-CN/product/dragons-pack-pbr</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1l7w4ZNoOke9TPqSQ3MiYRw">https://pan.baidu.com/s/1l7w4ZNoOke9TPqSQ3MiYRw</a> </p>
<h4 id="Elemental-Dragons"><a href="#Elemental-Dragons" class="headerlink" title="Elemental Dragons"></a>Elemental Dragons</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225123629094.png" alt="image-20230225123629094"></p>
<p>7条元素龙， 带动画</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/elemental-dragons-pack">https://www.unrealengine.com/marketplace/zh-CN/product/elemental-dragons-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1ONQRzWLJBOGO5OnY9IeimA">https://pan.baidu.com/s/1ONQRzWLJBOGO5OnY9IeimA</a> </p>
<h4 id="Monster-Beetle-Pack"><a href="#Monster-Beetle-Pack" class="headerlink" title="Monster_Beetle_Pack"></a>Monster_Beetle_Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225124319649.png" alt="image-20230225124319649"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/monster-beetle-pack">https://www.unrealengine.com/marketplace/zh-CN/product/monster-beetle-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Q2pPr-aAKejeKmpTbXPLZQ">https://pan.baidu.com/s/1Q2pPr-aAKejeKmpTbXPLZQ</a> </p>
<h3 id="武器"><a href="#武器" class="headerlink" title="武器"></a>武器</h3><h4 id="Advance-Weapon-Pack"><a href="#Advance-Weapon-Pack" class="headerlink" title="Advance Weapon Pack"></a>Advance Weapon Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//img1664068521250.png" alt="1664068521250"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/advance-weapon-pack">商城链接</a></p>
<p>百度链接：<a href="https://pan.baidu.com/s/130XEZ-UTsDVxF_gyOsXoGg">https://pan.baidu.com/s/130XEZ-UTsDVxF_gyOsXoGg</a><br>提取码：g5j8 </p>
<h4 id="Sci-fi-Arsenal-Vol-2-0"><a href="#Sci-fi-Arsenal-Vol-2-0" class="headerlink" title="Sci-fi Arsenal Vol 2.0"></a>Sci-fi Arsenal Vol 2.0</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925100832760.png" alt="image-20220925100832760"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-arsenal-vol-2">商城链接</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1XT2EHuOSOF-bwnt0Sv9kKg">https://pan.baidu.com/s/1XT2EHuOSOF-bwnt0Sv9kKg</a> </p>
<h4 id="Ten-Stylish-Staffs-and-Wands"><a href="#Ten-Stylish-Staffs-and-Wands" class="headerlink" title="Ten Stylish Staffs and Wands"></a>Ten Stylish Staffs and Wands</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925122914772.png" alt="image-20220925122914772"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/ten-stylish-staffs-and-wands">https://www.unrealengine.com/marketplace/zh-CN/product/ten-stylish-staffs-and-wands</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1tPsk3nTC7dMDFYplXWQcbA">https://pan.baidu.com/s/1tPsk3nTC7dMDFYplXWQcbA</a> </p>
<h4 id="Customizable-Weapon-Pack"><a href="#Customizable-Weapon-Pack" class="headerlink" title="Customizable Weapon Pack"></a>Customizable Weapon Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925215929847.png" alt="image-20220925215929847"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/customizable-weapon-pack">https://www.unrealengine.com/marketplace/zh-CN/product/customizable-weapon-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1e1dEyDTOu9SB8uuty8NTKA">https://pan.baidu.com/s/1e1dEyDTOu9SB8uuty8NTKA</a> </p>
<h4 id="Ammo-amp-Bullets-Pack"><a href="#Ammo-amp-Bullets-Pack" class="headerlink" title="Ammo &amp; Bullets Pack"></a>Ammo &amp; Bullets Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925220148948.png" alt="image-20220925220148948"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/ammo-bullets-pack">https://www.unrealengine.com/marketplace/zh-CN/product/ammo-bullets-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1lTHeSiGOH2GsXiLrbkPggA">https://pan.baidu.com/s/1lTHeSiGOH2GsXiLrbkPggA</a> </p>
<h4 id="Animated-Sharpshooter-Variety-Pack"><a href="#Animated-Sharpshooter-Variety-Pack" class="headerlink" title="Animated Sharpshooter Variety Pack"></a>Animated Sharpshooter Variety Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925220745246.png" alt="image-20220925220745246"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/animated-marksman-variety-pack">https://www.unrealengine.com/marketplace/zh-CN/product/animated-marksman-variety-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1IXJn14eDlpKWiQtOa_lvhg">https://pan.baidu.com/s/1IXJn14eDlpKWiQtOa_lvhg</a> </p>
<h3 id="道具"><a href="#道具" class="headerlink" title="道具"></a>道具</h3><h4 id="Animated-Modern-Civilian-Hands-Pack"><a href="#Animated-Modern-Civilian-Hands-Pack" class="headerlink" title="Animated Modern Civilian Hands Pack"></a>Animated Modern Civilian Hands Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209172101978.png" alt="image-20230209172101978"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/animated-modern-civilian-hands-pack">https://www.unrealengine.com/marketplace/zh-CN/product/animated-modern-civilian-hands-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1YoNEmDfIgejfRiQCA07ojQ">https://pan.baidu.com/s/1YoNEmDfIgejfRiQCA07ojQ</a> </p>
<h2 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h2><h3 id="Frank-RPG-系列"><a href="#Frank-RPG-系列" class="headerlink" title="Frank RPG 系列"></a>Frank RPG 系列</h3><p>质量算是中上的ARPG动作, 其实个人认为更倾向于ACT动作, 部分连招动作比较酷炫</p>
<h4 id="Frank-RPG-Fighter"><a href="#Frank-RPG-Fighter" class="headerlink" title="Frank RPG Fighter"></a>Frank RPG Fighter</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926105636776.png" alt="image-20220926105636776"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-fighter">https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-fighter</a></p>
<p>链接：<a href="https://pan.baidu.com/s/14QQcRikiid482Qgz8Z1aPw">https://pan.baidu.com/s/14QQcRikiid482Qgz8Z1aPw</a> </p>
<h4 id="Frank-Action-RPG-Sword-1-Basic-Set"><a href="#Frank-Action-RPG-Sword-1-Basic-Set" class="headerlink" title="Frank Action RPG Sword 1 (Basic Set)"></a>Frank Action RPG Sword 1 (Basic Set)</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926105854281.png" alt="image-20220926105854281"></p>
<p>早期作品, 质量一般</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-action-rpg-sword-1-basic-set">https://www.unrealengine.com/marketplace/zh-CN/product/frank-action-rpg-sword-1-basic-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/14MS_lAw9w-YXj_bTPVgHbw">https://pan.baidu.com/s/14MS_lAw9w-YXj_bTPVgHbw</a> </p>
<h4 id="Frank-Stealth-Kill"><a href="#Frank-Stealth-Kill" class="headerlink" title="Frank Stealth Kill"></a>Frank Stealth Kill</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926111036452.png" alt="image-20220926111036452"></p>
<p>处决动画, 自讨腰包买的 o(╥﹏╥)o</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-stealth-kill">https://www.unrealengine.com/marketplace/zh-CN/product/frank-stealth-kill</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Ll9hLGhcFbM0eeX99yB6fQ">https://pan.baidu.com/s/1Ll9hLGhcFbM0eeX99yB6fQ</a> </p>
<h4 id="Frank-RPG-Archer-Combo-Set"><a href="#Frank-RPG-Archer-Combo-Set" class="headerlink" title="Frank RPG Archer Combo Set"></a>Frank RPG Archer Combo Set</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926111145716.png" alt="image-20220926111145716"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-archer-combo-set">https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-archer-combo-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1ezsy-7PImwUFKHITMBZofw">https://pan.baidu.com/s/1ezsy-7PImwUFKHITMBZofw</a> </p>
<h4 id="Frank-RPG-Gunslinger"><a href="#Frank-RPG-Gunslinger" class="headerlink" title="Frank RPG Gunslinger"></a>Frank RPG Gunslinger</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926133141926.png" alt="image-20220926133141926"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-gunslinger">https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-gunslinger</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1G5LojY1QUqbHpCQ2WHM5Vg">https://pan.baidu.com/s/1G5LojY1QUqbHpCQ2WHM5Vg</a> </p>
<h4 id="Frank-RPG-2-Handed-Combo"><a href="#Frank-RPG-2-Handed-Combo" class="headerlink" title="Frank RPG 2 Handed (Combo)"></a>Frank RPG 2 Handed (Combo)</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926133231223.png" alt="image-20220926133231223"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-2-handed">https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-2-handed</a></p>
<p>链接：<a href="https://pan.baidu.com/s/11CX8rF6pub7U2j5Gh93KzQ">https://pan.baidu.com/s/11CX8rF6pub7U2j5Gh93KzQ</a> </p>
<h4 id="Frank-RPG-Warrior-Male"><a href="#Frank-RPG-Warrior-Male" class="headerlink" title="Frank RPG Warrior Male"></a>Frank RPG Warrior Male</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209160015068.png" alt="image-20230209160015068"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-warrior-male">https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-warrior-male</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1jISECJcI-qtPy6m9Vu-m5w">https://pan.baidu.com/s/1jISECJcI-qtPy6m9Vu-m5w</a> </p>
<h4 id="Frank-RPG-Spear"><a href="#Frank-RPG-Spear" class="headerlink" title="Frank RPG Spear"></a>Frank RPG Spear</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209160056755.png" alt="image-20230209160056755"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-spear">https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-spear</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1vhNUK9bEuCxYVNZf5u_iVg">https://pan.baidu.com/s/1vhNUK9bEuCxYVNZf5u_iVg</a> </p>
<h4 id="Frank-RPG-Mage"><a href="#Frank-RPG-Mage" class="headerlink" title="Frank RPG Mage"></a>Frank RPG Mage</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209160146517.png" alt="image-20230209160146517"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-mage">https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-mage</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1QKe6iVQ4l6WGsUlmNAMq6g">https://pan.baidu.com/s/1QKe6iVQ4l6WGsUlmNAMq6g</a> </p>
<h4 id="Frank-RPG-Dual"><a href="#Frank-RPG-Dual" class="headerlink" title="Frank RPG Dual"></a>Frank RPG Dual</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209160248751.png" alt="image-20230209160248751"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-dual">https://www.unrealengine.com/marketplace/zh-CN/product/frank-rpg-dual</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Zdeu13QywNe6QUB-uK0WJg">https://pan.baidu.com/s/1Zdeu13QywNe6QUB-uK0WJg</a> </p>
<h4 id="Frank-climax’s-Katana"><a href="#Frank-climax’s-Katana" class="headerlink" title="Frank climax’s Katana"></a>Frank climax’s Katana</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209160508834.png" alt="image-20230209160508834"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-climax-s-katana">https://www.unrealengine.com/marketplace/zh-CN/product/frank-climax-s-katana</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1oAuC_g_uq0hOp02ubJ_RFw">https://pan.baidu.com/s/1oAuC_g_uq0hOp02ubJ_RFw</a> </p>
<h4 id="Frank-Assassin-Ninja"><a href="#Frank-Assassin-Ninja" class="headerlink" title="Frank Assassin (Ninja)"></a>Frank Assassin (Ninja)</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209160549442.png" alt="image-20230209160549442"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/frank-assassin">https://www.unrealengine.com/marketplace/zh-CN/product/frank-assassin</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1HJZ1Lv50LGJSor8wcsqkZA">https://pan.baidu.com/s/1HJZ1Lv50LGJSor8wcsqkZA</a> </p>
<h3 id="Mocap系列"><a href="#Mocap系列" class="headerlink" title="Mocap系列"></a>Mocap系列</h3><p>质量非常高的一个系列,  基本是动捕动画</p>
<h4 id="Rifle-Pro-MoCap-Pack"><a href="#Rifle-Pro-MoCap-Pack" class="headerlink" title="Rifle Pro - MoCap Pack"></a>Rifle Pro - MoCap Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209101214595.png" alt="image-20230209101214595"></p>
<p>质量最高的步枪动画集,  站蹲趴, 放松和警戒姿势齐全</p>
<p>有一个基础版的, 动画少很多, 忽略</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/military-rifle-mocap-pack">https://www.unrealengine.com/marketplace/zh-CN/product/military-rifle-mocap-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1C2XoGKLVDq2RpZhHU7b9jg">https://pan.baidu.com/s/1C2XoGKLVDq2RpZhHU7b9jg</a> </p>
<h4 id="Scared-MoCap-Pack"><a href="#Scared-MoCap-Pack" class="headerlink" title="Scared! - MoCap Pack"></a>Scared! - MoCap Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208205923331.png" alt="image-20230208205923331"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/scared-mocap-pack">https://www.unrealengine.com/marketplace/zh-CN/product/scared-mocap-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/11a3JBs5YEfJFriPOnxmDdg">https://pan.baidu.com/s/11a3JBs5YEfJFriPOnxmDdg</a> </p>
<h4 id="Zombie-Starter-MoCap-Pack"><a href="#Zombie-Starter-MoCap-Pack" class="headerlink" title="Zombie Starter MoCap Pack"></a>Zombie Starter MoCap Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926153057931.png" alt="image-20220926153057931"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/zombie-starter-mocap-pack">https://www.unrealengine.com/marketplace/zh-CN/product/zombie-starter-mocap-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1ubmXsHWjPruoAEW8WII1TA">https://pan.baidu.com/s/1ubmXsHWjPruoAEW8WII1TA</a> </p>
<h4 id="Zombie-Pro-MoCap-Pack"><a href="#Zombie-Pro-MoCap-Pack" class="headerlink" title="Zombie Pro - MoCap Pack"></a>Zombie Pro - MoCap Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208202723067.png" alt="image-20230208202723067"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/zombie-pro-mocap-pack">https://www.unrealengine.com/marketplace/zh-CN/product/zombie-pro-mocap-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1esY6MDox8kEXVVSPJNDIYw">https://pan.baidu.com/s/1esY6MDox8kEXVVSPJNDIYw</a> </p>
<h4 id="Pistol-Pro-MoCap-Pack"><a href="#Pistol-Pro-MoCap-Pack" class="headerlink" title="Pistol Pro - MoCap Pack"></a>Pistol Pro - MoCap Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209103830951.png" alt="image-20230209103830951"></p>
<p>RootMotion动画有问题, 移动的是Pelvis, 而Root没有移动</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/military-pistol-mocap-pack">https://www.unrealengine.com/marketplace/zh-CN/product/military-pistol-mocap-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1ASBmpjPJ3sApPzBTA3biiA">https://pan.baidu.com/s/1ASBmpjPJ3sApPzBTA3biiA</a> </p>
<h4 id="Pedestrian-Walks"><a href="#Pedestrian-Walks" class="headerlink" title="Pedestrian Walks"></a>Pedestrian Walks</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209104346279.png" alt="image-20230209104346279"></p>
<p>各类姿势的走路动画</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/pedestrian-walks-mocap-pack">https://www.unrealengine.com/marketplace/zh-CN/product/pedestrian-walks-mocap-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1nXLj-AR0F9ZmtfK7iCYCww">https://pan.baidu.com/s/1nXLj-AR0F9ZmtfK7iCYCww</a> </p>
<h4 id="Ninja-Pro-MoCap-Pack"><a href="#Ninja-Pro-MoCap-Pack" class="headerlink" title="Ninja Pro - MoCap Pack"></a>Ninja Pro - MoCap Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209104959423.png" alt="image-20230209104959423"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/ninja-mocap-pack">https://www.unrealengine.com/marketplace/zh-CN/product/ninja-mocap-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1-ozK7uV5l1BFzWco2n9fng">https://pan.baidu.com/s/1-ozK7uV5l1BFzWco2n9fng</a> </p>
<h4 id="Mobility-Pro-MoCap-Pack"><a href="#Mobility-Pro-MoCap-Pack" class="headerlink" title="Mobility Pro  MoCap Pack"></a>Mobility Pro  MoCap Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209110153368.png" alt="image-20230209110153368"></p>
<p>非常详细的200+空手Locomotion动画</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/mobility-mocap-pack">https://www.unrealengine.com/marketplace/zh-CN/product/mobility-mocap-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1A6_WIcE14ZNk_vV8GK9Ndg">https://pan.baidu.com/s/1A6_WIcE14ZNk_vV8GK9Ndg</a> </p>
<h4 id="Death-Animations"><a href="#Death-Animations" class="headerlink" title="Death Animations"></a>Death Animations</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209165051903.png" alt="image-20230209165051903"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/death-animations-mocap-pack">https://www.unrealengine.com/marketplace/zh-CN/product/death-animations-mocap-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1UfFtOwyNz2OhqAcyPNY7lw">https://pan.baidu.com/s/1UfFtOwyNz2OhqAcyPNY7lw</a> </p>
<h4 id="Character-Conversation"><a href="#Character-Conversation" class="headerlink" title="Character Conversation"></a>Character Conversation</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209171619054.png" alt="image-20230209171619054"></p>
<p>NPC谈话动作</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/pedestrian-conversations-mocap-pack">https://www.unrealengine.com/marketplace/zh-CN/product/pedestrian-conversations-mocap-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1WVwvwcaAFDDuDM1QzsxfFw">https://pan.baidu.com/s/1WVwvwcaAFDDuDM1QzsxfFw</a> </p>
<h3 id="魔法"><a href="#魔法" class="headerlink" title="魔法"></a>魔法</h3><h4 id="Mage-Animset"><a href="#Mage-Animset" class="headerlink" title="Mage Animset"></a>Mage Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209110853027.png" alt="image-20230209110853027"></p>
<p>写实魔法动画,  似乎已经下架</p>
<p>链接：<a href="https://pan.baidu.com/s/1x6A4OwFGOc6NicwOx_nJgw">https://pan.baidu.com/s/1x6A4OwFGOc6NicwOx_nJgw</a> </p>
<h4 id="Witch-Animation-Set"><a href="#Witch-Animation-Set" class="headerlink" title="Witch Animation Set"></a>Witch Animation Set</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208202808852.png" alt="image-20230208202808852"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/witch-animation-set">https://www.unrealengine.com/marketplace/zh-CN/product/witch-animation-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1FrLQCTHw0JjhsRb5Q0zxaQ">https://pan.baidu.com/s/1FrLQCTHw0JjhsRb5Q0zxaQ</a> </p>
<h4 id="Flying-Mage-AnimSet"><a href="#Flying-Mage-AnimSet" class="headerlink" title="Flying Mage AnimSet"></a>Flying Mage AnimSet</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209160933883.png" alt="image-20230209160933883"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/flyingmageset">https://www.unrealengine.com/marketplace/zh-CN/product/flyingmageset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1cJaM8snPa5Lq6zt0k_F3Hw">https://pan.baidu.com/s/1cJaM8snPa5Lq6zt0k_F3Hw</a> </p>
<h3 id="近战"><a href="#近战" class="headerlink" title="近战"></a>近战</h3><h4 id="Brutal-Double-Axe-AnimSet"><a href="#Brutal-Double-Axe-AnimSet" class="headerlink" title="Brutal Double Axe AnimSet"></a>Brutal Double Axe AnimSet</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209171728804.png" alt="image-20230209171728804"></p>
<p>100+双持动作, 还不错</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/brutal-double-axe-set">https://www.unrealengine.com/marketplace/zh-CN/product/brutal-double-axe-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1MKYKvb83_V6NOS78uEqlaw">https://pan.baidu.com/s/1MKYKvb83_V6NOS78uEqlaw</a> </p>
<h4 id="Longsword-Animset-Pro"><a href="#Longsword-Animset-Pro" class="headerlink" title="Longsword Animset Pro"></a>Longsword Animset Pro</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926152014894.png" alt="image-20220926152014894"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/longsword-animset-pro">https://www.unrealengine.com/marketplace/zh-CN/product/longsword-animset-pro</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1EQrUpJJ4lXTxYX598XqONA">https://pan.baidu.com/s/1EQrUpJJ4lXTxYX598XqONA</a> </p>
<h4 id="Rogue-Volume-2"><a href="#Rogue-Volume-2" class="headerlink" title="Rogue Volume 2"></a>Rogue Volume 2</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926152212758.png" alt="image-20220926152212758"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/rogue-animation-set">https://www.unrealengine.com/marketplace/zh-CN/product/rogue-animation-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1RkSiuP5kAnNn8-1dSe24zA">https://pan.baidu.com/s/1RkSiuP5kAnNn8-1dSe24zA</a> </p>
<h4 id="Dynamic-Sword-Animset"><a href="#Dynamic-Sword-Animset" class="headerlink" title="Dynamic Sword Animset"></a>Dynamic Sword Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926152637873.png" alt="image-20220926152637873"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/dynamic-sword-animset">https://www.unrealengine.com/marketplace/zh-CN/product/dynamic-sword-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Mz3yJ-cScp-qTEJTDtM-fg">https://pan.baidu.com/s/1Mz3yJ-cScp-qTEJTDtM-fg</a> </p>
<h4 id="Fighting-Animset-Pro"><a href="#Fighting-Animset-Pro" class="headerlink" title="Fighting Animset Pro"></a>Fighting Animset Pro</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926152930970.png" alt="image-20220926152930970"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/fighting-animset-pro">https://www.unrealengine.com/marketplace/zh-CN/product/fighting-animset-pro</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1qXrsxMujRIPy-RIKHAxBUQ">https://pan.baidu.com/s/1qXrsxMujRIPy-RIKHAxBUQ</a> </p>
<h4 id="TwinSword-Animset-Base"><a href="#TwinSword-Animset-Base" class="headerlink" title="TwinSword Animset Base"></a>TwinSword Animset Base</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208204556442.png" alt="image-20230208204556442"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/twinsword-animset-base">https://www.unrealengine.com/marketplace/zh-CN/product/twinsword-animset-base</a></p>
<p>链接：<a href="https://pan.baidu.com/s/19oaaHJDu5AHpqwKjGharwg">https://pan.baidu.com/s/19oaaHJDu5AHpqwKjGharwg</a> </p>
<h4 id="Twinblades-Animset-Base"><a href="#Twinblades-Animset-Base" class="headerlink" title="Twinblades Animset Base"></a>Twinblades Animset Base</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208205004748.png" alt="image-20230208205004748"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/twinblades-animset-base">https://www.unrealengine.com/marketplace/zh-CN/product/twinblades-animset-base</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1rej6RySiIzDDE9zsl-d5IQ">https://pan.baidu.com/s/1rej6RySiIzDDE9zsl-d5IQ</a> </p>
<h4 id="Twinblades-Animset-Expansion"><a href="#Twinblades-Animset-Expansion" class="headerlink" title="Twinblades Animset Expansion"></a>Twinblades Animset Expansion</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208204754511.png" alt="image-20230208204754511"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/twinblades-animset-expansion">https://www.unrealengine.com/marketplace/zh-CN/product/twinblades-animset-expansion</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1tZHKony3NuncOw38HqVLVw">https://pan.baidu.com/s/1tZHKony3NuncOw38HqVLVw</a> </p>
<h4 id="TwinDaggers-Animset"><a href="#TwinDaggers-Animset" class="headerlink" title="TwinDaggers Animset"></a>TwinDaggers Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208204851071.png" alt="image-20230208204851071"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/twindaggers-animset">https://www.unrealengine.com/marketplace/zh-CN/product/twindaggers-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/17E_BFSCwa2OQ_BsWG240OQ">https://pan.baidu.com/s/17E_BFSCwa2OQ_BsWG240OQ</a> </p>
<h4 id="Sword-Animset-Pro"><a href="#Sword-Animset-Pro" class="headerlink" title="Sword Animset Pro"></a>Sword Animset Pro</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208205055899.png" alt="image-20230208205055899"></p>
<p>最经典的刺剑动作的单手剑动画集</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sword-animset-pro">https://www.unrealengine.com/marketplace/zh-CN/product/sword-animset-pro</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1ENkzI79kllL3F4W56wNq1w">https://pan.baidu.com/s/1ENkzI79kllL3F4W56wNq1w</a> </p>
<h4 id="Sword-amp-Shield-Animset-Pro"><a href="#Sword-amp-Shield-Animset-Pro" class="headerlink" title="Sword &amp; Shield Animset Pro"></a>Sword &amp; Shield Animset Pro</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208205233715.png" alt="image-20230208205233715"></p>
<p>经典剑盾</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sword-shield-animset-pro">https://www.unrealengine.com/marketplace/zh-CN/product/sword-shield-animset-pro</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1F8lvgZdGf_RZ_hSeLmiJ-w">https://pan.baidu.com/s/1F8lvgZdGf_RZ_hSeLmiJ-w</a> </p>
<h4 id="Stylish-Action-Combat-Animation-Pack"><a href="#Stylish-Action-Combat-Animation-Pack" class="headerlink" title="Stylish Action Combat Animation Pack"></a>Stylish Action Combat Animation Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208205601580.png" alt="image-20230208205601580"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/stylish-action-combat-animation-pack">https://www.unrealengine.com/marketplace/zh-CN/product/stylish-action-combat-animation-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1HrmWcLq8Nm6Nt-9hOdlUHA">https://pan.baidu.com/s/1HrmWcLq8Nm6Nt-9hOdlUHA</a> </p>
<h4 id="Stealth-Finishers-knife-and-hand"><a href="#Stealth-Finishers-knife-and-hand" class="headerlink" title="Stealth Finishers knife and hand"></a>Stealth Finishers knife and hand</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208205723716.png" alt="image-20230208205723716"></p>
<p>处决动画, 感觉比Frank的好</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/stealth-finishers-knife-and-hand">https://www.unrealengine.com/marketplace/zh-CN/product/stealth-finishers-knife-and-hand</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1RDDRLtAsAcN2GUqkkSchHQ">https://pan.baidu.com/s/1RDDRLtAsAcN2GUqkkSchHQ</a> </p>
<h4 id="Rapier-Anim-Set"><a href="#Rapier-Anim-Set" class="headerlink" title="Rapier Anim Set"></a>Rapier Anim Set</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209103223031.png" alt="image-20230209103223031"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/rapier-anim-set">https://www.unrealengine.com/marketplace/zh-CN/product/rapier-anim-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1EiCpwwoeATuIc2Y19d_TCA">https://pan.baidu.com/s/1EiCpwwoeATuIc2Y19d_TCA</a> </p>
<h4 id="Punch-Animation-Pack"><a href="#Punch-Animation-Pack" class="headerlink" title="Punch! Animation Pack"></a>Punch! Animation Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209103324038.png" alt="image-20230209103324038"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/punch-animation-pack">https://www.unrealengine.com/marketplace/zh-CN/product/punch-animation-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1ofxZDpU0gXb5NdgN_a8wmQ">https://pan.baidu.com/s/1ofxZDpU0gXb5NdgN_a8wmQ</a> </p>
<h4 id="Protector"><a href="#Protector" class="headerlink" title="Protector"></a>Protector</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209103430516.png" alt="image-20230209103430516"></p>
<p>防御者动画, 200+</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/protector">https://www.unrealengine.com/marketplace/zh-CN/product/protector</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1cO559IouhyewSLMyvxPqSw">https://pan.baidu.com/s/1cO559IouhyewSLMyvxPqSw</a> </p>
<h4 id="Orientalism-Dual-Blade-Anim-Set"><a href="#Orientalism-Dual-Blade-Anim-Set" class="headerlink" title="Orientalism Dual Blade Anim Set"></a>Orientalism Dual Blade Anim Set</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209104539474.png" alt="image-20230209104539474"></p>
<p>质量还可以, 可以跟Frank的双刀互补</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/orientalism-dual-blade-anim-set">https://www.unrealengine.com/marketplace/zh-CN/product/orientalism-dual-blade-anim-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1s4cPMA4dGBr1EyFJMsRINQ">https://pan.baidu.com/s/1s4cPMA4dGBr1EyFJMsRINQ</a> </p>
<h4 id="Oriental-Spear-AnimSet"><a href="#Oriental-Spear-AnimSet" class="headerlink" title="Oriental Spear AnimSet"></a>Oriental Spear AnimSet</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209104714378.png" alt="image-20230209104714378"></p>
<p>54个动画</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/oriental-spear-anim-set">https://www.unrealengine.com/marketplace/zh-CN/product/oriental-spear-anim-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1kUPCptILf0d0KRc_gtWwog">https://pan.baidu.com/s/1kUPCptILf0d0KRc_gtWwog</a> </p>
<h4 id="Martial-Arts-Fight-Game"><a href="#Martial-Arts-Fight-Game" class="headerlink" title="Martial Arts Fight Game"></a>Martial Arts Fight Game</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209110553291.png" alt="image-20230209110553291"></p>
<p>格斗动作, 偏快稍僵硬, 非写实</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/unarmed-style-set">https://www.unrealengine.com/marketplace/zh-CN/product/unarmed-style-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1f_Z7lsPDmb6m3zyE4Qc0PA">https://pan.baidu.com/s/1f_Z7lsPDmb6m3zyE4Qc0PA</a> </p>
<h4 id="Japanese-sword-action"><a href="#Japanese-sword-action" class="headerlink" title="Japanese sword action"></a>Japanese sword action</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209111029627.png" alt="image-20230209111029627"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/japanese-sword-action">https://www.unrealengine.com/marketplace/zh-CN/product/japanese-sword-action</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1sgtDXZGIF77qgeQqkSPRTw">https://pan.baidu.com/s/1sgtDXZGIF77qgeQqkSPRTw</a> </p>
<h4 id="Insane-Gun-Sword-Animset"><a href="#Insane-Gun-Sword-Animset" class="headerlink" title="Insane Gun Sword Animset"></a>Insane Gun Sword Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209111116147.png" alt="image-20230209111116147"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/insane-gun-sword-animset">https://www.unrealengine.com/marketplace/zh-CN/product/insane-gun-sword-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/11gWUC8Uq-F-5GTatjokKNA">https://pan.baidu.com/s/11gWUC8Uq-F-5GTatjokKNA</a> </p>
<h4 id="Insane-Aircombo-Set"><a href="#Insane-Aircombo-Set" class="headerlink" title="Insane Aircombo Set"></a>Insane Aircombo Set</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209111234389.png" alt="image-20230209111234389"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/insane-aircombo-set">https://www.unrealengine.com/marketplace/zh-CN/product/insane-aircombo-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1OeTSJQTO_wv2Gbwa_L7EUQ">https://pan.baidu.com/s/1OeTSJQTO_wv2Gbwa_L7EUQ</a> </p>
<h4 id="Heavy-Lancer-AnimSet"><a href="#Heavy-Lancer-AnimSet" class="headerlink" title="Heavy Lancer AnimSet"></a>Heavy Lancer AnimSet</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209112054268.png" alt="image-20230209112054268"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/heavy-lancer-set">https://www.unrealengine.com/marketplace/zh-CN/product/heavy-lancer-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/14GqJ-UHj9K4PqBDpnf8QWw">https://pan.baidu.com/s/14GqJ-UHj9K4PqBDpnf8QWw</a> </p>
<h4 id="Grim-Reaper-AnimSet"><a href="#Grim-Reaper-AnimSet" class="headerlink" title="Grim Reaper AnimSet"></a>Grim Reaper AnimSet</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209114602483.png" alt="image-20230209114602483"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/grim-reaper-set">https://www.unrealengine.com/marketplace/zh-CN/product/grim-reaper-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/19TEqi19fGE1mIdHBuEEz6A">https://pan.baidu.com/s/19TEqi19fGE1mIdHBuEEz6A</a> </p>
<h4 id="GreatSword-Animset"><a href="#GreatSword-Animset" class="headerlink" title="GreatSword Animset"></a>GreatSword Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209153115746.png" alt="image-20230209153115746"></p>
<p>120+157</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/greatsword-animset">https://www.unrealengine.com/marketplace/zh-CN/product/greatsword-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/13uAhB9X428-Bw-PAI7RBEQ">https://pan.baidu.com/s/13uAhB9X428-Bw-PAI7RBEQ</a> </p>
<h4 id="Ghost-Samurai-Bundle"><a href="#Ghost-Samurai-Bundle" class="headerlink" title="Ghost Samurai Bundle"></a>Ghost Samurai Bundle</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209154523922.png" alt="image-20230209154523922"></p>
<p>质量不错的武士动作, 有刀和弓等不同武器</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/ghostsamurai-bundle">https://www.unrealengine.com/marketplace/zh-CN/product/ghostsamurai-bundle</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1cLIvK_eAN2w3udcPamBj5A">https://pan.baidu.com/s/1cLIvK_eAN2w3udcPamBj5A</a> </p>
<h4 id="Essential-Spear-And-Shield-Animation-Pack"><a href="#Essential-Spear-And-Shield-Animation-Pack" class="headerlink" title="Essential Spear And Shield Animation Pack"></a>Essential Spear And Shield Animation Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209162937952.png" alt="image-20230209162937952"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/essential-spear-and-shield-animation-pack">https://www.unrealengine.com/marketplace/zh-CN/product/essential-spear-and-shield-animation-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1EZ6x9goKn_H3enmPyTmwQA">https://pan.baidu.com/s/1EZ6x9goKn_H3enmPyTmwQA</a> </p>
<h4 id="Conversion-Animset-TwinSword-amp-TwinBlades"><a href="#Conversion-Animset-TwinSword-amp-TwinBlades" class="headerlink" title="Conversion Animset ( TwinSword &amp; TwinBlades)"></a>Conversion Animset ( TwinSword &amp; TwinBlades)</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209165331673.png" alt="image-20230209165331673"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/conversion-animset-twinsword-twinblades">https://www.unrealengine.com/marketplace/zh-CN/product/conversion-animset-twinsword-twinblades</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1IMwaNT0_rCpExvZFuqnB4A">https://pan.baidu.com/s/1IMwaNT0_rCpExvZFuqnB4A</a> </p>
<h4 id="Close-Combat-Animset"><a href="#Close-Combat-Animset" class="headerlink" title="Close Combat Animset"></a>Close Combat Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209171023839.png" alt="image-20230209171023839"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/close-combat-animset">https://www.unrealengine.com/marketplace/zh-CN/product/close-combat-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/11yzZn1ALRwnhi5lZxsRVdQ">https://pan.baidu.com/s/11yzZn1ALRwnhi5lZxsRVdQ</a> </p>
<h4 id="2Handed-Hammer-AnimSet"><a href="#2Handed-Hammer-AnimSet" class="headerlink" title="2Handed Hammer AnimSet"></a>2Handed Hammer AnimSet</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209172643899.png" alt="image-20230209172643899"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/2handed-hammer-set">https://www.unrealengine.com/marketplace/zh-CN/product/2handed-hammer-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/18I05OtIgXDw91ByrF3aAhg">https://pan.baidu.com/s/18I05OtIgXDw91ByrF3aAhg</a> </p>
<h3 id="枪械射击"><a href="#枪械射击" class="headerlink" title="枪械射击"></a>枪械射击</h3><h4 id="Rifle-Animset-Pro"><a href="#Rifle-Animset-Pro" class="headerlink" title="Rifle Animset Pro"></a>Rifle Animset Pro</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209102559679.png" alt="image-20230209102559679"></p>
<p>相比较与Mocap版本稍次, 缺少部分动作</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/rifle-animset-pro">https://www.unrealengine.com/marketplace/zh-CN/product/rifle-animset-pro</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1ssTvAsrdNvk3eqo4s-AVeg">https://pan.baidu.com/s/1ssTvAsrdNvk3eqo4s-AVeg</a> </p>
<h4 id="Pistol-Animset-Pro"><a href="#Pistol-Animset-Pro" class="headerlink" title="Pistol Animset Pro"></a>Pistol Animset Pro</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209104022321.png" alt="image-20230209104022321"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/pistol-animset-pro">https://www.unrealengine.com/marketplace/zh-CN/product/pistol-animset-pro</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Epul89YeZc4H1tDi58S8Aw">https://pan.baidu.com/s/1Epul89YeZc4H1tDi58S8Aw</a> </p>
<h4 id="GunFu-Pistol-Attacks"><a href="#GunFu-Pistol-Attacks" class="headerlink" title="GunFu Pistol Attacks"></a>GunFu Pistol Attacks</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209114328612.png" alt="image-20230209114328612"></p>
<p>40+个手枪动画</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/gunfu-pistol-attacks">https://www.unrealengine.com/marketplace/zh-CN/product/gunfu-pistol-attacks</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1XZAS1bHMctnIKbK1zKTCqQ">https://pan.baidu.com/s/1XZAS1bHMctnIKbK1zKTCqQ</a> </p>
<h3 id="弓-弩"><a href="#弓-弩" class="headerlink" title="弓/弩"></a>弓/弩</h3><h4 id="Archer-Animset-Pro"><a href="#Archer-Animset-Pro" class="headerlink" title="Archer Animset Pro"></a>Archer Animset Pro</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209171933670.png" alt="image-20230209171933670"></p>
<p>似乎下架了</p>
<p>链接：<a href="https://pan.baidu.com/s/1pAb7KMorNbozB2M1HNyFJQ">https://pan.baidu.com/s/1pAb7KMorNbozB2M1HNyFJQ</a> </p>
<h4 id="Modern-Crossbow-Animation-Kit"><a href="#Modern-Crossbow-Animation-Kit" class="headerlink" title="Modern Crossbow Animation Kit"></a>Modern Crossbow Animation Kit</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209105419805.png" alt="image-20230209105419805"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/modern-crossbow-animation-kit">https://www.unrealengine.com/marketplace/zh-CN/product/modern-crossbow-animation-kit</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1vSOyCBI-oFl_DRTkG2C4NQ">https://pan.baidu.com/s/1vSOyCBI-oFl_DRTkG2C4NQ</a> </p>
<h4 id="Dynamic-Archer-Set"><a href="#Dynamic-Archer-Set" class="headerlink" title="Dynamic Archer Set"></a>Dynamic Archer Set</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209163044358.png" alt="image-20230209163044358"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/dynamic-archer-set">https://www.unrealengine.com/marketplace/zh-CN/product/dynamic-archer-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Beby6PL_yPF7icA8qdVH2w">https://pan.baidu.com/s/1Beby6PL_yPF7icA8qdVH2w</a> </p>
<h3 id="交互-NPC"><a href="#交互-NPC" class="headerlink" title="交互/NPC"></a>交互/NPC</h3><h4 id="Crafting-Animations"><a href="#Crafting-Animations" class="headerlink" title="Crafting Animations"></a>Crafting Animations</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209165157469.png" alt="image-20230209165157469"></p>
<p>制作东西的动画</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/crafting-animations">https://www.unrealengine.com/marketplace/zh-CN/product/crafting-animations</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1YfF6fCuOzwuGYR8s7rNAqg">https://pan.baidu.com/s/1YfF6fCuOzwuGYR8s7rNAqg</a> </p>
<h4 id="Generic-NPC-Anim-Pack"><a href="#Generic-NPC-Anim-Pack" class="headerlink" title="Generic NPC Anim Pack"></a>Generic NPC Anim Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926133723558.png" alt="image-20220926133723558"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/generic-npc-anim-pack">https://www.unrealengine.com/marketplace/zh-CN/product/generic-npc-anim-pack</a></p>
<p>月免费</p>
<p>链接：<a href="https://pan.baidu.com/s/1yyBMdr2tTcAdrPsGDDK2pA">https://pan.baidu.com/s/1yyBMdr2tTcAdrPsGDDK2pA</a> </p>
<h4 id="Mega-Taunt-Animation-Pack"><a href="#Mega-Taunt-Animation-Pack" class="headerlink" title="Mega Taunt Animation Pack"></a>Mega Taunt Animation Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209110357574.png" alt="image-20230209110357574"></p>
<p>100个嘲讽动画</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/mega-taunt-animation-pack">https://www.unrealengine.com/marketplace/zh-CN/product/mega-taunt-animation-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/18aUbMGr8UwJapyKXY_YEuA">https://pan.baidu.com/s/18aUbMGr8UwJapyKXY_YEuA</a> </p>
<h4 id="Supporter-Motions"><a href="#Supporter-Motions" class="headerlink" title="Supporter Motions"></a>Supporter Motions</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208205418567.png" alt="image-20230208205418567"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/supporter-motions">https://www.unrealengine.com/marketplace/zh-CN/product/supporter-motions</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1k2wjjPkIJO9RTRoH_oflAg">https://pan.baidu.com/s/1k2wjjPkIJO9RTRoH_oflAg</a> </p>
<h4 id="Resource-Gathering-Animation-Pack"><a href="#Resource-Gathering-Animation-Pack" class="headerlink" title="Resource Gathering Animation Pack"></a>Resource Gathering Animation Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209102915468.png" alt="image-20230209102915468"></p>
<p>主要是一些交互动作, 质量一般</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/resource-gathering-animation-pack">https://www.unrealengine.com/marketplace/zh-CN/product/resource-gathering-animation-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1X0pa4Jxl-B8rC5r2NN9BRw">https://pan.baidu.com/s/1X0pa4Jxl-B8rC5r2NN9BRw</a> </p>
<h4 id="Phoenyx-Anim-Pack-3"><a href="#Phoenyx-Anim-Pack-3" class="headerlink" title="Phoenyx Anim Pack 3"></a>Phoenyx Anim Pack 3</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209104203629.png" alt="image-20230209104203629"></p>
<p>主要是一些休闲动作</p>
<p>跟凤凰没啥关系, 这个是作者名称…..</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/phoenyx-anim-pack-02">https://www.unrealengine.com/marketplace/zh-CN/product/phoenyx-anim-pack-02</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1lUQivXNu0g8MaMY_Sz0fbA">https://pan.baidu.com/s/1lUQivXNu0g8MaMY_Sz0fbA</a> </p>
<h4 id="Have-A-Sit-Animation-Pack"><a href="#Have-A-Sit-Animation-Pack" class="headerlink" title="Have A Sit Animation Pack"></a>Have A Sit Animation Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209113858732.png" alt="image-20230209113858732"></p>
<p>似乎下架了</p>
<p>链接：<a href="https://pan.baidu.com/s/1-TTUZSVvj9tj5B9HPEUP0Q">https://pan.baidu.com/s/1-TTUZSVvj9tj5B9HPEUP0Q</a> </p>
<h4 id="Female-Interaction-Animation-Pack"><a href="#Female-Interaction-Animation-Pack" class="headerlink" title="Female Interaction Animation Pack"></a>Female Interaction Animation Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209162733974.png" alt="image-20230209162733974"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/female-interaction-animation-pack">https://www.unrealengine.com/marketplace/zh-CN/product/female-interaction-animation-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Iod1RgSffXntifnvt-_oMQ">https://pan.baidu.com/s/1Iod1RgSffXntifnvt-_oMQ</a> </p>
<h4 id="Dialog-Animations"><a href="#Dialog-Animations" class="headerlink" title="Dialog Animations"></a>Dialog Animations</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209163120897.png" alt="image-20230209163120897"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/dialog-animations">https://www.unrealengine.com/marketplace/zh-CN/product/dialog-animations</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1atjSW16S4Q_soQiCT6DEmg">https://pan.baidu.com/s/1atjSW16S4Q_soQiCT6DEmg</a> </p>
<h4 id="City-Animation-of-People-Pack-1"><a href="#City-Animation-of-People-Pack-1" class="headerlink" title="City Animation of People Pack 1"></a>City Animation of People Pack 1</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209171246172.png" alt="image-20230209171246172"></p>
<p>20个生活动画</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/city-animation-of-people-pack">https://www.unrealengine.com/marketplace/zh-CN/product/city-animation-of-people-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1WjgdzvMHywiXDmUUyoa8jg">https://pan.baidu.com/s/1WjgdzvMHywiXDmUUyoa8jg</a> </p>
<h4 id="Character-Interaction-Add-On-Vol-01"><a href="#Character-Interaction-Add-On-Vol-01" class="headerlink" title="Character Interaction Add On Vol 01"></a>Character Interaction Add On Vol 01</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209171455387.png" alt="image-20230209171455387"></p>
<p>基础交互动作, 包含一些武器的拾取</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/character-interaction-add-on-vol">https://www.unrealengine.com/marketplace/zh-CN/product/character-interaction-add-on-vol</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1_alLV8HITowG-8NqQ60Z_A">https://pan.baidu.com/s/1_alLV8HITowG-8NqQ60Z_A</a> </p>
<h3 id="第一人称"><a href="#第一人称" class="headerlink" title="第一人称"></a>第一人称</h3><h4 id="FPP-Melee-Animset"><a href="#FPP-Melee-Animset" class="headerlink" title="FPP Melee Animset"></a>FPP Melee Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209160804612.png" alt="image-20230209160804612"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/fpp-melee-animset">https://www.unrealengine.com/marketplace/zh-CN/product/fpp-melee-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1wB0ogwSTil4KlpJhh_h_SA">https://pan.baidu.com/s/1wB0ogwSTil4KlpJhh_h_SA</a> </p>
<h4 id="Combat-Knife-Animation-Kit"><a href="#Combat-Knife-Animation-Kit" class="headerlink" title="Combat Knife Animation Kit"></a>Combat Knife Animation Kit</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209165413432.png" alt="image-20230209165413432"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/combat-knife-animation-kit">https://www.unrealengine.com/marketplace/zh-CN/product/combat-knife-animation-kit</a></p>
<p>链接：<a href="https://pan.baidu.com/s/10q7XsH2SbLrfy_kUUCTiuw">https://pan.baidu.com/s/10q7XsH2SbLrfy_kUUCTiuw</a> </p>
<h3 id="移动-运动"><a href="#移动-运动" class="headerlink" title="移动/运动"></a>移动/运动</h3><h4 id="Cover-Animset-Pro"><a href="#Cover-Animset-Pro" class="headerlink" title="Cover Animset Pro"></a>Cover Animset Pro</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209165240188.png" alt="image-20230209165240188"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/cover-animset-pro">https://www.unrealengine.com/marketplace/zh-CN/product/cover-animset-pro</a></p>
<p>链接：<a href="https://pan.baidu.com/s/11CZXOGuEUgIo6Jj4tdYZlA">https://pan.baidu.com/s/11CZXOGuEUgIo6Jj4tdYZlA</a> </p>
<h4 id="Ladders-and-Ledges-Animset"><a href="#Ladders-and-Ledges-Animset" class="headerlink" title="Ladders and Ledges Animset"></a>Ladders and Ledges Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209110937373.png" alt="image-20230209110937373"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/ladder-and-ledges-animset">https://www.unrealengine.com/marketplace/zh-CN/product/ladder-and-ledges-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1d0XkSDuFQ2rdGsV-jhgDeA">https://pan.baidu.com/s/1d0XkSDuFQ2rdGsV-jhgDeA</a> </p>
<h4 id="Swimming-Animation-Set"><a href="#Swimming-Animation-Set" class="headerlink" title="Swimming Animation Set"></a>Swimming Animation Set</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208205329985.png" alt="image-20230208205329985"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/swimming-animation-set">https://www.unrealengine.com/marketplace/zh-CN/product/swimming-animation-set</a></p>
<p>4.22 链接：<a href="https://pan.baidu.com/s/1TXdWVH5V3ZPPlekKzutZLg">https://pan.baidu.com/s/1TXdWVH5V3ZPPlekKzutZLg</a> </p>
<h4 id="Skydive-and-Parachute-Kit"><a href="#Skydive-and-Parachute-Kit" class="headerlink" title="Skydive and Parachute Kit"></a>Skydive and Parachute Kit</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208205839812.png" alt="image-20230208205839812"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/skydive-and-parachute-kit">https://www.unrealengine.com/marketplace/zh-CN/product/skydive-and-parachute-kit</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Lohw06GHjLH8PltPEdbdyg">https://pan.baidu.com/s/1Lohw06GHjLH8PltPEdbdyg</a> </p>
<h4 id="Rope-Swing-amp-Climb"><a href="#Rope-Swing-amp-Climb" class="headerlink" title="Rope Swing &amp; Climb"></a>Rope Swing &amp; Climb</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209091529851.png" alt="image-20230209091529851"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/rope-swing-climb">https://www.unrealengine.com/marketplace/zh-CN/product/rope-swing-climb</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1suztu1W5Jzst-eOK4m-Lkw">https://pan.baidu.com/s/1suztu1W5Jzst-eOK4m-Lkw</a> </p>
<h4 id="Rolls-and-Dodges-Animation"><a href="#Rolls-and-Dodges-Animation" class="headerlink" title="Rolls and Dodges Animation"></a>Rolls and Dodges Animation</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209100332371.png" alt="image-20230209100332371"></p>
<p>动作偏快, 非写实</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/rolls-and-dodges-animation-set">https://www.unrealengine.com/marketplace/zh-CN/product/rolls-and-dodges-animation-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1MaRpvQsknKoiDR2BXD8vQg">https://pan.baidu.com/s/1MaRpvQsknKoiDR2BXD8vQg</a> </p>
<h4 id="Open-World-Animset"><a href="#Open-World-Animset" class="headerlink" title="Open World Animset"></a>Open World Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209104821469.png" alt="image-20230209104821469"></p>
<p>500+各类运动类动画, 攀爬翻越等</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/open-world-animset">https://www.unrealengine.com/marketplace/zh-CN/product/open-world-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1biRf3Z_X7LdWiy9OY1qs5Q">https://pan.baidu.com/s/1biRf3Z_X7LdWiy9OY1qs5Q</a> </p>
<h4 id="Movement-Animset-Pro"><a href="#Movement-Animset-Pro" class="headerlink" title="Movement Animset Pro"></a>Movement Animset Pro</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209105046749.png" alt="image-20230209105046749"></p>
<p>质量很不错的基础移动动画包</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/movement-animset-pro">https://www.unrealengine.com/marketplace/zh-CN/product/movement-animset-pro</a></p>
<p>链接：<a href="https://pan.baidu.com/s/14a0o8bcq1u645jEOectgKQ">https://pan.baidu.com/s/14a0o8bcq1u645jEOectgKQ</a> </p>
<h4 id="Evil-Magician-Animations"><a href="#Evil-Magician-Animations" class="headerlink" title="Evil Magician Animations"></a>Evil Magician Animations</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209162838980.png" alt="image-20230209162838980"></p>
<p>9个动画, 似乎没啥用</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/evil-magician-animations">https://www.unrealengine.com/marketplace/zh-CN/product/evil-magician-animations</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1nduuzg456DrZaFM4m9upnw">https://pan.baidu.com/s/1nduuzg456DrZaFM4m9upnw</a> </p>
<h4 id="CLazy-Runner-Action-Pack"><a href="#CLazy-Runner-Action-Pack" class="headerlink" title="CLazy Runner Action Pack"></a>CLazy Runner Action Pack</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209171105063.png" alt="image-20230209171105063"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/clazy-runner-action-pack">https://www.unrealengine.com/marketplace/zh-CN/product/clazy-runner-action-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1ZVO7MgfoZ9yaWj1IQtduGg">https://pan.baidu.com/s/1ZVO7MgfoZ9yaWj1IQtduGg</a> </p>
<h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><h4 id="Vampire-Boss-Set"><a href="#Vampire-Boss-Set" class="headerlink" title="Vampire Boss Set"></a>Vampire Boss Set</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208204112020.png" alt="image-20230208204112020"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/vampire-boss-set">https://www.unrealengine.com/marketplace/zh-CN/product/vampire-boss-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/15Gupext_nkqfmhKr8zkyyA">https://pan.baidu.com/s/15Gupext_nkqfmhKr8zkyyA</a> </p>
<h4 id="superhero-animset"><a href="#superhero-animset" class="headerlink" title="superhero animset"></a>superhero animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208205457985.png" alt="image-20230208205457985"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/superhero-animset">https://www.unrealengine.com/marketplace/zh-CN/product/superhero-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1YMtzXa-Ex8z17DWsD55byw">https://pan.baidu.com/s/1YMtzXa-Ex8z17DWsD55byw</a> </p>
<h4 id="Horse-Animset"><a href="#Horse-Animset" class="headerlink" title="Horse Animset"></a>Horse Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209111358380.png" alt="image-20230209111358380"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/horse-animset">https://www.unrealengine.com/marketplace/zh-CN/product/horse-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1X4txM9j1uT3fo9-a8EuwlA">https://pan.baidu.com/s/1X4txM9j1uT3fo9-a8EuwlA</a> </p>
<h4 id="Giant-Monster-Animset"><a href="#Giant-Monster-Animset" class="headerlink" title="Giant Monster Animset"></a>Giant Monster Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209153325294.png" alt="image-20230209153325294"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/monster-animation-set">https://www.unrealengine.com/marketplace/zh-CN/product/monster-animation-set</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1p1w2_vWkfAv_nWYczlUULA">https://pan.baidu.com/s/1p1w2_vWkfAv_nWYczlUULA</a> </p>
<h4 id="Adventure-Game-Animset"><a href="#Adventure-Game-Animset" class="headerlink" title="Adventure Game Animset"></a>Adventure Game Animset</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209172304123.png" alt="image-20230209172304123"></p>
<p>1000+大乱炖, 啥都有</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/adventure-game-animset">https://www.unrealengine.com/marketplace/zh-CN/product/adventure-game-animset</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1KxWRzKSq-FN0Y86IoMPLog">https://pan.baidu.com/s/1KxWRzKSq-FN0Y86IoMPLog</a> </p>
<h4 id="41-Animations-For-Monsters"><a href="#41-Animations-For-Monsters" class="headerlink" title="41 Animations For Monsters"></a>41 Animations For Monsters</h4><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230209172418086.png" alt="image-20230209172418086"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/41-animations-for-monsters">https://www.unrealengine.com/marketplace/zh-CN/product/41-animations-for-monsters</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1H9-mJzA0_IwQfRSIGJG01w">https://pan.baidu.com/s/1H9-mJzA0_IwQfRSIGJG01w</a> </p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="SCIFI-TOWN"><a href="#SCIFI-TOWN" class="headerlink" title="SCIFI TOWN"></a>SCIFI TOWN</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925111357135.png" alt="image-20220925111357135"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/scifi-town">https://www.unrealengine.com/marketplace/zh-CN/product/scifi-town</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Z47r8xN1u87Q_FHaoau2fg">https://pan.baidu.com/s/1Z47r8xN1u87Q_FHaoau2fg</a> </p>
<h3 id="Ryokan-Japanese-Courtyard"><a href="#Ryokan-Japanese-Courtyard" class="headerlink" title="Ryokan [Japanese Courtyard]"></a>Ryokan [Japanese Courtyard]</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925114532259.png" alt="image-20220925114532259"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/ryokan-japanese-courtyard">https://www.unrealengine.com/marketplace/zh-CN/product/ryokan-japanese-courtyard</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1zwVbQVunZwAigOGMxprzvw">https://pan.baidu.com/s/1zwVbQVunZwAigOGMxprzvw</a> </p>
<h3 id="POLYGON-Sci-Fi-City"><a href="#POLYGON-Sci-Fi-City" class="headerlink" title="POLYGON - Sci-Fi City"></a>POLYGON - Sci-Fi City</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925123154757.png" alt="image-20220925123154757"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/polygon-sci-fi-city">https://www.unrealengine.com/marketplace/zh-CN/product/polygon-sci-fi-city</a></p>
<p>链接：<a href="https://pan.baidu.com/s/14l9L-tyf2zX7Hb6Actan6w">https://pan.baidu.com/s/14l9L-tyf2zX7Hb6Actan6w</a> </p>
<h3 id="POLYGON-Apocalypse-Pack"><a href="#POLYGON-Apocalypse-Pack" class="headerlink" title="POLYGON - Apocalypse Pack"></a>POLYGON - Apocalypse Pack</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925151631587.png" alt="image-20220925151631587"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/polygon-apocalypse-pack">https://www.unrealengine.com/marketplace/zh-CN/product/polygon-apocalypse-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1L4_zebWq4uL_zUt7GfJn9w">https://pan.baidu.com/s/1L4_zebWq4uL_zUt7GfJn9w</a> </p>
<h3 id="SCI-FI-METAVERSE-FUTURISTIC-CITY"><a href="#SCI-FI-METAVERSE-FUTURISTIC-CITY" class="headerlink" title="SCI-FI METAVERSE FUTURISTIC CITY"></a>SCI-FI METAVERSE FUTURISTIC CITY</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926102219658.png" alt="image-20220926102219658"></p>
<p>这个是个大集合, 涵盖了多个场景, 比如下图这些, 同作者内都有</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926102305333.png" alt="image-20220926102305333"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/futuristic-city">https://www.unrealengine.com/marketplace/zh-CN/product/futuristic-city</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1RJ1uk-kmtZO_XqLTRpJYDw">https://pan.baidu.com/s/1RJ1uk-kmtZO_XqLTRpJYDw</a> </p>
<h3 id="City-of-Gods"><a href="#City-of-Gods" class="headerlink" title="City of Gods"></a>City of Gods</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208091303342.png" alt="image-20230208091303342"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/city-of-gods">https://www.unrealengine.com/marketplace/zh-CN/product/city-of-gods</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1m_I8x-DDwqIzhD6FMEPnNQ">https://pan.baidu.com/s/1m_I8x-DDwqIzhD6FMEPnNQ</a> </p>
<h3 id="Dungeon-Pack"><a href="#Dungeon-Pack" class="headerlink" title="Dungeon Pack"></a>Dungeon Pack</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208202351754.png" alt="image-20230208202351754"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/polygon-dungeon-pack">https://www.unrealengine.com/marketplace/zh-CN/product/polygon-dungeon-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1of_DRh5DCYRpRFKzigkcIA">https://pan.baidu.com/s/1of_DRh5DCYRpRFKzigkcIA</a> </p>
<h3 id="Lowpoly-Style-Ultra-Pack"><a href="#Lowpoly-Style-Ultra-Pack" class="headerlink" title="Lowpoly Style Ultra Pack"></a>Lowpoly Style Ultra Pack</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208202511729.png" alt="image-20230208202511729"></p>
<p>这是个大集合, 每一个都有单卖的</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/lowpoly-style-mega-pack">https://www.unrealengine.com/marketplace/zh-CN/product/lowpoly-style-mega-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1m8TUrS3F3WPRLNQE-lb-mg">https://pan.baidu.com/s/1m8TUrS3F3WPRLNQE-lb-mg</a> </p>
<h2 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h2><h3 id="Muzzle-Flashes"><a href="#Muzzle-Flashes" class="headerlink" title="Muzzle Flashes"></a>Muzzle Flashes</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925113041499.png" alt="image-20220925113041499"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/101-muzzle-flashes">https://www.unrealengine.com/marketplace/zh-CN/product/101-muzzle-flashes</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1CGZpxBvcK6R--dg-i2oORg">https://pan.baidu.com/s/1CGZpxBvcK6R--dg-i2oORg</a> </p>
<h3 id="Niagara-Projectiles-Vol-2"><a href="#Niagara-Projectiles-Vol-2" class="headerlink" title="Niagara Projectiles Vol.2"></a>Niagara Projectiles Vol.2</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925114134004.png" alt="image-20220925114134004"></p>
<p>链接：<a href="https://pan.baidu.com/s/1Y3JDP1c5kyw_QyOZbO-00g">https://pan.baidu.com/s/1Y3JDP1c5kyw_QyOZbO-00g</a> </p>
<h3 id="Luos’s-PewPew-Particle-Pack"><a href="#Luos’s-PewPew-Particle-Pack" class="headerlink" title="Luos’s PewPew Particle Pack"></a>Luos’s PewPew Particle Pack</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925123744012.png" alt="image-20220925123744012"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/luos-s-pewpew-particle-pack">https://www.unrealengine.com/marketplace/zh-CN/product/luos-s-pewpew-particle-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Od-qhNoTLoDw4UaVIuqmCQ">https://pan.baidu.com/s/1Od-qhNoTLoDw4UaVIuqmCQ</a> </p>
<h3 id="Energy-weapon-VFX-Pack"><a href="#Energy-weapon-VFX-Pack" class="headerlink" title="Energy weapon VFX Pack"></a>Energy weapon VFX Pack</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925151041123.png" alt="image-20220925151041123"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/procedural-scifi-gunvfx-pack">https://www.unrealengine.com/marketplace/zh-CN/product/procedural-scifi-gunvfx-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1Pu_bI835SpEpnEYzSQOfyg">https://pan.baidu.com/s/1Pu_bI835SpEpnEYzSQOfyg</a> </p>
<h3 id="Hack-And-Slash-FX"><a href="#Hack-And-Slash-FX" class="headerlink" title="Hack And Slash FX"></a>Hack And Slash FX</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925152119343.png" alt="image-20220925152119343"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/hack-and-slash-fx">https://www.unrealengine.com/marketplace/zh-CN/product/hack-and-slash-fx</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1YR0T_NdkMQiHmgskdcFrzw">https://pan.baidu.com/s/1YR0T_NdkMQiHmgskdcFrzw</a> </p>
<h3 id="Ultimate-Fire-Pack-Vol-1"><a href="#Ultimate-Fire-Pack-Vol-1" class="headerlink" title="Ultimate Fire Pack Vol 1"></a>Ultimate Fire Pack Vol 1</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925200608839.png" alt="image-20220925200608839"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/ultimate-fire-pack-vol-1-by-actionvfx-and-undertone-fx-inc">https://www.unrealengine.com/marketplace/zh-CN/product/ultimate-fire-pack-vol-1-by-actionvfx-and-undertone-fx-inc</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1flqYLuVSQNe0kQQhgn8q8Q">https://pan.baidu.com/s/1flqYLuVSQNe0kQQhgn8q8Q</a> </p>
<h3 id="Niagara-Bullet-Impact-Fx-Pack"><a href="#Niagara-Bullet-Impact-Fx-Pack" class="headerlink" title="Niagara Bullet Impact Fx Pack"></a>Niagara Bullet Impact Fx Pack</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925200701792.png" alt="image-20220925200701792"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/niagara-bullet-impact-fx-pack">https://www.unrealengine.com/marketplace/zh-CN/product/niagara-bullet-impact-fx-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1-PMug1WllX60SW3lSGkvKA">https://pan.baidu.com/s/1-PMug1WllX60SW3lSGkvKA</a> </p>
<h3 id="Realistic-Starter-VFX-Pack-Vol-2"><a href="#Realistic-Starter-VFX-Pack-Vol-2" class="headerlink" title="Realistic Starter VFX Pack Vol 2"></a>Realistic Starter VFX Pack Vol 2</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925200902874.png" alt="image-20220925200902874"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/realistic-starter-vfx-pack-vol">https://www.unrealengine.com/marketplace/zh-CN/product/realistic-starter-vfx-pack-vol</a></p>
<p>免费</p>
<h3 id="Snow-Effects"><a href="#Snow-Effects" class="headerlink" title="Snow Effects"></a>Snow Effects</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925201115686.png" alt="image-20220925201115686"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/snow-effects">https://www.unrealengine.com/marketplace/zh-CN/product/snow-effects</a></p>
<p>链接：<a href="https://pan.baidu.com/s/112HAYq_00A28dmHZn4Zwqg">https://pan.baidu.com/s/112HAYq_00A28dmHZn4Zwqg</a> </p>
<h3 id="Dynamic-SciFi-Trail-Pack"><a href="#Dynamic-SciFi-Trail-Pack" class="headerlink" title="Dynamic SciFi Trail Pack"></a>Dynamic SciFi Trail Pack</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925202435438.png" alt="image-20220925202435438"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/dynamic-scifi-trail-pack">https://www.unrealengine.com/marketplace/zh-CN/product/dynamic-scifi-trail-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1hs_TgZUVV2FOTe-E3jWeUg">https://pan.baidu.com/s/1hs_TgZUVV2FOTe-E3jWeUg</a> </p>
<h3 id="Shield-FX-Niagara"><a href="#Shield-FX-Niagara" class="headerlink" title="Shield FX Niagara"></a>Shield FX Niagara</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925222526421.png" alt="image-20220925222526421"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/shield-fx-niagara">https://www.unrealengine.com/marketplace/zh-CN/product/shield-fx-niagara</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1F_CsA9CMogMWKTgJERTsPQ">https://pan.baidu.com/s/1F_CsA9CMogMWKTgJERTsPQ</a> </p>
<h3 id="Catalyst-Sci-Fi-VFX-Pack"><a href="#Catalyst-Sci-Fi-VFX-Pack" class="headerlink" title="Catalyst Sci Fi VFX Pack"></a>Catalyst Sci Fi VFX Pack</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925222855263.png" alt="image-20220925222855263"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/catalyst-sci-fi-vfx-pack">https://www.unrealengine.com/marketplace/zh-CN/product/catalyst-sci-fi-vfx-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/13wnD9xfS2cJcNoqaBxMo3Q">https://pan.baidu.com/s/13wnD9xfS2cJcNoqaBxMo3Q</a> </p>
<h3 id="Sword-FX"><a href="#Sword-FX" class="headerlink" title="Sword FX"></a>Sword FX</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225111055566.png" alt="image-20230225111055566"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sword-fx">https://www.unrealengine.com/marketplace/zh-CN/product/sword-fx</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1jA3KHy0NOLh-7qNMATvCFw">https://pan.baidu.com/s/1jA3KHy0NOLh-7qNMATvCFw</a> </p>
<h3 id="Sword-Auras"><a href="#Sword-Auras" class="headerlink" title="Sword Auras"></a>Sword Auras</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225111543193.png" alt="image-20230225111543193"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sword-auras">https://www.unrealengine.com/marketplace/zh-CN/product/sword-auras</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1n1H6SctMVm-jxihQVC4o_w">https://pan.baidu.com/s/1n1H6SctMVm-jxihQVC4o_w</a> </p>
<h3 id="Niagara-Magical-Slashes-❤❤"><a href="#Niagara-Magical-Slashes-❤❤" class="headerlink" title="Niagara Magical Slashes ❤❤"></a>Niagara Magical Slashes ❤❤</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225112635043.png" alt="image-20230225112635043"></p>
<p>有拖尾和投掷类型和范围的剑气， 质量非常高</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/niagara-magical-slashes">https://www.unrealengine.com/marketplace/zh-CN/product/niagara-magical-slashes</a></p>
<p>链接：<a href="https://pan.baidu.com/s/13XC9_l0Gc0HR16u28DfDvw">https://pan.baidu.com/s/13XC9_l0Gc0HR16u28DfDvw</a> </p>
<h3 id="M5-VFX-RPG2-Projectile-Niagara-❤"><a href="#M5-VFX-RPG2-Projectile-Niagara-❤" class="headerlink" title="M5 VFX RPG2. Projectile(Niagara) ❤"></a>M5 VFX RPG2. Projectile(Niagara) ❤</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225113337758.png" alt="image-20230225113337758"></p>
<p>投射物特效，带击中特效， 数量可观， 质量也不错</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/m5-vfx-rpg1-projectile">https://www.unrealengine.com/marketplace/zh-CN/product/m5-vfx-rpg1-projectile</a></p>
<p>链接：<a href="https://pan.baidu.com/s/169FbFApc4q4J5CCFq69OsQ">https://pan.baidu.com/s/169FbFApc4q4J5CCFq69OsQ</a> </p>
<h3 id="GOOD-FX-Beam-and-Ray-❤"><a href="#GOOD-FX-Beam-and-Ray-❤" class="headerlink" title="GOOD FX : Beam and Ray ❤"></a>GOOD FX : Beam and Ray ❤</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225115521827.png" alt="image-20230225115521827"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/good-particle-beam-and-ray">https://www.unrealengine.com/marketplace/zh-CN/product/good-particle-beam-and-ray</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1-ko12RC1G-_SMXhKRAUh0A">https://pan.baidu.com/s/1-ko12RC1G-_SMXhKRAUh0A</a> </p>
<h3 id="FantasyMagicTwo"><a href="#FantasyMagicTwo" class="headerlink" title="FantasyMagicTwo"></a>FantasyMagicTwo</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225115818895.png" alt="image-20230225115818895"></p>
<p>质量还可以，投射有爆炸， 但是数量不多</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/fantasymagictwo">https://www.unrealengine.com/marketplace/zh-CN/product/fantasymagictwo</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1q53OfhllOK5CwFSUieeVdQ">https://pan.baidu.com/s/1q53OfhllOK5CwFSUieeVdQ</a> </p>
<h3 id="Enchantment-Swords-VFX"><a href="#Enchantment-Swords-VFX" class="headerlink" title="Enchantment Swords VFX"></a>Enchantment Swords VFX</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225120135560.png" alt="image-20230225120135560"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/enchantment-swords-vfx">https://www.unrealengine.com/marketplace/zh-CN/product/enchantment-swords-vfx</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1kz9KzwTtL4xZQAqOCYYVUA">https://pan.baidu.com/s/1kz9KzwTtL4xZQAqOCYYVUA</a> </p>
<h3 id="AoE-Magic-Abilities-Vol-1"><a href="#AoE-Magic-Abilities-Vol-1" class="headerlink" title="AoE Magic Abilities Vol 1"></a>AoE Magic Abilities Vol 1</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225120422891.png" alt="image-20230225120422891"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/aoe-magic-abilities-vol">https://www.unrealengine.com/marketplace/zh-CN/product/aoe-magic-abilities-vol</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1OeTaJHznoaFRKAIuKkfYKw">https://pan.baidu.com/s/1OeTaJHznoaFRKAIuKkfYKw</a> </p>
<h3 id="Niagara-Dash-Effects"><a href="#Niagara-Dash-Effects" class="headerlink" title="Niagara Dash Effects"></a>Niagara Dash Effects</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20230225081411734.png" alt="image-20230225081411734"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/niagara-dash-effects">https://www.unrealengine.com/marketplace/zh-CN/product/niagara-dash-effects</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1LuVEuxf2pFTK77rndIyfUQ">https://pan.baidu.com/s/1LuVEuxf2pFTK77rndIyfUQ</a> </p>
<h3 id="M5-VFX-RPG1-Sword-Trails-Niagara"><a href="#M5-VFX-RPG1-Sword-Trails-Niagara" class="headerlink" title="M5 VFX RPG1. Sword Trails(Niagara)"></a>M5 VFX RPG1. Sword Trails(Niagara)</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329133235060.png" alt="image-20230329133235060"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/m5-vfx-rpg1-sword-trails">https://www.unrealengine.com/marketplace/zh-CN/product/m5-vfx-rpg1-sword-trails</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1oAnfFojlLSkm1KszjpK7ZQ">https://pan.baidu.com/s/1oAnfFojlLSkm1KszjpK7ZQ</a> </p>
<h3 id="Strike-VFX"><a href="#Strike-VFX" class="headerlink" title="Strike VFX"></a>Strike VFX</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329133209843.png" alt="image-20230329133209843">有击中 也有拖尾， 看项目demo不明显， 看油管视频感觉非常好</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/strike-vfx">https://www.unrealengine.com/marketplace/zh-CN/product/strike-vfx</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1CMLtC_cblfOS7rQva-7zDg">https://pan.baidu.com/s/1CMLtC_cblfOS7rQva-7zDg</a> </p>
<h3 id="Niagara-Magic-Projectiles"><a href="#Niagara-Magic-Projectiles" class="headerlink" title="Niagara Magic Projectiles"></a>Niagara Magic Projectiles</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329113555105.png" alt="image-20230329113555105"></p>
<p>全都是飞弹, 各类元素各种颜色的飞弹</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/niagara-magic-projectiles-sounds-included">https://www.unrealengine.com/marketplace/zh-CN/product/niagara-magic-projectiles-sounds-included</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1QjPTVQevGjVPRcWeI1_ktA">https://pan.baidu.com/s/1QjPTVQevGjVPRcWeI1_ktA</a> </p>
<h2 id="音效-音乐"><a href="#音效-音乐" class="headerlink" title="音效/音乐"></a>音效/音乐</h2><h3 id="Sci-Fi-Sounds-and-Sci-Fi-Weapons-↓"><a href="#Sci-Fi-Sounds-and-Sci-Fi-Weapons-↓" class="headerlink" title="Sci-Fi Sounds and Sci-Fi Weapons ↓"></a>Sci-Fi Sounds and Sci-Fi Weapons ↓</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925112527850.png" alt="image-20220925112527850"></p>
<p>环境音效一言难尽, 武器音效还有点用</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-sounds-and-sci-fi-weapons">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-sounds-and-sci-fi-weapons</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1NK3xoHtMtr6zX2gHziAU-Q">https://pan.baidu.com/s/1NK3xoHtMtr6zX2gHziAU-Q</a> </p>
<h3 id="Sci-Fi-User-Interface-Sounds"><a href="#Sci-Fi-User-Interface-Sounds" class="headerlink" title="Sci-Fi User Interface Sounds"></a>Sci-Fi User Interface Sounds</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926103252401.png" alt="image-20220926103252401"></p>
<p>UI音效, 质量还可以</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-ui-sounds">https://www.unrealengine.com/marketplace/zh-CN/product/sci-fi-ui-sounds</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1-wzbS1-_yqpj8cL-epTAfg">https://pan.baidu.com/s/1-wzbS1-_yqpj8cL-epTAfg</a> </p>
<h3 id="AngelOfWar❤"><a href="#AngelOfWar❤" class="headerlink" title="AngelOfWar❤"></a>AngelOfWar❤</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329112353342.png" alt="image-20230329112353342"></p>
<p>13首音乐，偏向于史诗音乐的感觉，可以做BGM</p>
<p>链接：<a href="https://pan.baidu.com/s/1qOH6PIPf1ZHlTjLtlJ9hNA">https://pan.baidu.com/s/1qOH6PIPf1ZHlTjLtlJ9hNA</a> </p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/angel-of-war">https://www.unrealengine.com/marketplace/zh-CN/product/angel-of-war</a></p>
<h3 id="Elf-Female-Voice-Pack-❤"><a href="#Elf-Female-Voice-Pack-❤" class="headerlink" title="Elf Female Voice Pack  ❤"></a>Elf Female Voice Pack  ❤</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329112422010.png" alt="image-20230329112422010"></p>
<p>女性精灵语音，非常丰富， 英语和精灵语，大致有对话，施法和状态（呼吸）声音</p>
<p>链接：<a href="https://pan.baidu.com/s/1FFkx4DJ9kEoR6v8uMlET8Q">https://pan.baidu.com/s/1FFkx4DJ9kEoR6v8uMlET8Q</a><br><a href="https://www.unrealengine.com/marketplace/zh-CN/product/elf-female-voice-pack">https://www.unrealengine.com/marketplace/zh-CN/product/elf-female-voice-pack</a></p>
<h3 id="Everything-Bundle-SFX❤❤"><a href="#Everything-Bundle-SFX❤❤" class="headerlink" title="Everything Bundle SFX❤❤"></a>Everything Bundle SFX❤❤</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329112441205.png" alt="image-20230329112441205"></p>
<p>各种类型的音乐以及音效，质量非常高</p>
<p>音乐有超过10种类型， 超过400多首</p>
<p>音效有20+种类型，7200+个，例如：武器，龙，打斗，爆炸等</p>
<p>链接：<a href="https://pan.baidu.com/s/1T9EIoglW0WOKwzDLNzDBSw">https://pan.baidu.com/s/1T9EIoglW0WOKwzDLNzDBSw</a><br><a href="https://www.unrealengine.com/marketplace/zh-CN/product/everything-bundle-sfx">https://www.unrealengine.com/marketplace/zh-CN/product/everything-bundle-sfx</a></p>
<h3 id="Halloween-Audio-Kit"><a href="#Halloween-Audio-Kit" class="headerlink" title="Halloween Audio Kit"></a>Halloween Audio Kit</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329112500886.png" alt="image-20230329112500886"></p>
<p>万圣节音效， 有部分适合做吸血鬼题材的游戏bgm</p>
<p>链接：<a href="https://pan.baidu.com/s/1D8rqmmbXTHZtDwts_Bj5Ew">https://pan.baidu.com/s/1D8rqmmbXTHZtDwts_Bj5Ew</a> </p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/halloween-audio-kit">https://www.unrealengine.com/marketplace/zh-CN/product/halloween-audio-kit</a></p>
<h3 id="Human-Vocalizations❤"><a href="#Human-Vocalizations❤" class="headerlink" title="Human Vocalizations❤"></a>Human Vocalizations❤</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329112515319.png" alt="image-20230329112515319"></p>
<p>免费， 4男3女音效，质量不错，一般的战斗和NPC应该够用</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/human-vocalizations">https://www.unrealengine.com/marketplace/zh-CN/product/human-vocalizations</a></p>
<h3 id="Magic-Sci-Fi-Sword-Sounds"><a href="#Magic-Sci-Fi-Sword-Sounds" class="headerlink" title="Magic Sci-Fi Sword Sounds"></a>Magic Sci-Fi Sword Sounds</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329112531568.png" alt="image-20230329112531568"></p>
<p>279个带魔法的剑攻击音效， 对于剑攻击的音效能满足了</p>
<p>但是没有分文件夹，比较难查找</p>
<p>链接：<a href="https://pan.baidu.com/s/1v8lgluldHH_LfwLtgwIqAw">https://pan.baidu.com/s/1v8lgluldHH_LfwLtgwIqAw</a> </p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/magic-sci-fi-sword-sounds">https://www.unrealengine.com/marketplace/zh-CN/product/magic-sci-fi-sword-sounds</a></p>
<h3 id="Magic-amp-Melee-Battle-Sounds-Library-❤"><a href="#Magic-amp-Melee-Battle-Sounds-Library-❤" class="headerlink" title="Magic &amp; Melee Battle Sounds Library ❤"></a>Magic &amp; Melee Battle Sounds Library ❤</h3><p>跟商城的似乎对应不上</p>
<p>300+近战武器音效，分成了10种元素类型， 细分为击中，爆炸，循环，准备等类型</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/medieval-battle-sounds-library">https://www.unrealengine.com/marketplace/zh-CN/product/medieval-battle-sounds-library</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1HVLFqvfUwTZcZS9cFIeJrQ">https://pan.baidu.com/s/1HVLFqvfUwTZcZS9cFIeJrQ</a> </p>
<h3 id="Magic-Spell-Sounds-PRO❤"><a href="#Magic-Spell-Sounds-PRO❤" class="headerlink" title="Magic Spell Sounds PRO❤"></a>Magic Spell Sounds PRO❤</h3><p>没找到商城对应的</p>
<p>600+魔法音效，详细的分类为start，loop，end</p>
<p>重点也有各类元素的施法，比较不错</p>
<p>链接：<a href="https://pan.baidu.com/s/1_99u_AVQKVXUEtAYM7fP6A">https://pan.baidu.com/s/1_99u_AVQKVXUEtAYM7fP6A</a> </p>
<h3 id="Fireworks-With-Sounds"><a href="#Fireworks-With-Sounds" class="headerlink" title="Fireworks With Sounds"></a>Fireworks With Sounds</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329112948451.png" alt="image-20230329112948451"></p>
<p>其实是一个蓝图项目, 15个烟花音效资源</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/fireworks-with-sounds">https://www.unrealengine.com/marketplace/zh-CN/product/fireworks-with-sounds</a></p>
<p>链接：<a href="https://pan.baidu.com/s/12TNEqB4jSgj5hxjQ8K0ccA">https://pan.baidu.com/s/12TNEqB4jSgj5hxjQ8K0ccA</a> </p>
<h3 id="Water-Sounds-Pack"><a href="#Water-Sounds-Pack" class="headerlink" title="Water Sounds Pack"></a>Water Sounds Pack</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329134612453.png" alt="image-20230329134612453"></p>
<p>水声, 算比较齐全的, 有水滴,雨,水流,浪,水下等音效</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/water-sounds-pack">https://www.unrealengine.com/marketplace/zh-CN/product/water-sounds-pack</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1zAupp4ApWiDOXE0_sn5rPg">https://pan.baidu.com/s/1zAupp4ApWiDOXE0_sn5rPg</a> </p>
<h3 id="Retro-8Bit-Sounds"><a href="#Retro-8Bit-Sounds" class="headerlink" title="Retro 8Bit Sounds"></a>Retro 8Bit Sounds</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329135209437.png" alt="image-20230329135209437"></p>
<p>月免费的红白机音效, 质量非常不错,只要合适</p>
<h3 id="Action-Music-Vol-IV"><a href="#Action-Music-Vol-IV" class="headerlink" title="Action Music Vol. IV"></a>Action Music Vol. IV</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329135446161.png" alt="image-20230329135446161"></p>
<p>44首史诗音乐, 听着略微不像游戏音乐</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/action-music-vol-iv">https://www.unrealengine.com/marketplace/zh-CN/product/action-music-vol-iv</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1FWafHodH_xXCg1eKajKCcg">https://pan.baidu.com/s/1FWafHodH_xXCg1eKajKCcg</a> </p>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><h3 id="GUI-PRO-Kit-Fantasy-RPG"><a href="#GUI-PRO-Kit-Fantasy-RPG" class="headerlink" title="GUI PRO Kit - Fantasy RPG"></a>GUI PRO Kit - Fantasy RPG</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230224100139817.png" alt="image-20230224100139817"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/gui-pro-kit-fantasy-rpg">https://www.unrealengine.com/marketplace/zh-CN/product/gui-pro-kit-fantasy-rpg</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1SMn_aiKVMN8ZU_wpZ2303g">https://pan.baidu.com/s/1SMn_aiKVMN8ZU_wpZ2303g</a> </p>
<h3 id="HUD-and-GUI-Medieval-Art-Bundle"><a href="#HUD-and-GUI-Medieval-Art-Bundle" class="headerlink" title="HUD and GUI Medieval Art Bundle"></a>HUD and GUI Medieval Art Bundle</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230224100306302.png" alt="image-20230224100306302"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/hud-and-gui-medieval-art-bundle">https://www.unrealengine.com/marketplace/zh-CN/product/hud-and-gui-medieval-art-bundle</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1rECyDwhR_tIGPz6e8ianSA">https://pan.baidu.com/s/1rECyDwhR_tIGPz6e8ianSA</a> </p>
<h3 id="Mobile-GUI-UI-Pro-Kit-Casual-MOBA-Game"><a href="#Mobile-GUI-UI-Pro-Kit-Casual-MOBA-Game" class="headerlink" title="Mobile GUI / UI Pro Kit - Casual MOBA Game"></a>Mobile GUI / UI Pro Kit - Casual MOBA Game</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230329135653817.png" alt="image-20230329135653817"></p>
<p>手游卡通风格UI</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/mobile-ui-kit-casual-moba-game">https://www.unrealengine.com/marketplace/zh-CN/product/mobile-ui-kit-casual-moba-game</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1nhAqwq8xye4IWbfFU_390w">https://pan.baidu.com/s/1nhAqwq8xye4IWbfFU_390w</a> </p>
<h2 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h2><h3 id="MP-System"><a href="#MP-System" class="headerlink" title="MP System"></a>MP System</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//imgimage-20220925220452807.png" alt="image-20220925220452807"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/mp-system">https://www.unrealengine.com/marketplace/zh-CN/product/mp-system</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1bITZBxiNT2e7lVFLbmd9NQ">https://pan.baidu.com/s/1bITZBxiNT2e7lVFLbmd9NQ</a> </p>
<h3 id="Advanced-Framework-VR-Mobile-amp-Desktop"><a href="#Advanced-Framework-VR-Mobile-amp-Desktop" class="headerlink" title="Advanced Framework - VR, Mobile &amp; Desktop"></a>Advanced Framework - VR, Mobile &amp; Desktop</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20220926103916692.png" alt="image-20220926103916692"></p>
<p>大名鼎鼎的VR交互框架, 很多VR游戏是基于此搭建的, 据说主程序新冠死了, 更新速度慢了</p>
<p>优点是基本涵盖所有VR所需要的交互, 也能扩展</p>
<p>缺点是纯蓝图, 而且不是插件</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/advanced-vr-framework">https://www.unrealengine.com/marketplace/zh-CN/product/advanced-vr-framework</a></p>
<p>链接：<a href="https://pan.baidu.com/s/13CJiTy_RrcR9PNBOxFMtJQ">https://pan.baidu.com/s/13CJiTy_RrcR9PNBOxFMtJQ</a> </p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Dungeon-Architect"><a href="#Dungeon-Architect" class="headerlink" title="Dungeon Architect"></a>Dungeon Architect</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208091139502.png" alt="image-20230208091139502"></p>
<p>随机地牢插件</p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/dungeon-architect">https://www.unrealengine.com/marketplace/zh-CN/product/dungeon-architect</a></p>
<p>5.1 链接：<a href="https://pan.baidu.com/s/13ILN8zbvF1h79umTkli8Xg">https://pan.baidu.com/s/13ILN8zbvF1h79umTkli8Xg</a> </p>
<p>4.27链接：<a href="https://pan.baidu.com/s/1uZaEbzfWbdxn4s0jd8mjLg">https://pan.baidu.com/s/1uZaEbzfWbdxn4s0jd8mjLg</a> </p>
<p>Logic Driver</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master//image-20230208202226677.png" alt="image-20230208202226677"></p>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/logic-driver-state-machine-blueprint-editor">https://www.unrealengine.com/marketplace/zh-CN/product/logic-driver-state-machine-blueprint-editor</a></p>
<p>4.27 链接：<a href="https://pan.baidu.com/s/1iZT9ZjyR0LT9zsv82pGkZQ">https://pan.baidu.com/s/1iZT9ZjyR0LT9zsv82pGkZQ</a> </p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>《Fightting Game Template》Documentation</title>
    <url>/2020/06/15/%E8%B6%855%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3EN/</url>
    <content><![CDATA[<h2 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h2><ul>
<li>It is very important that you should click the <strong>option button</strong> to set your keys ，and save it</li>
<li>Click the Multiplayer button to enter the character selection interface<ul>
<li>V1.0 has no AI so we can not click <code>SinglePlayer</code> button</li>
</ul>
</li>
<li>Use the <code>LEFT</code> and <code>RIGHT</code> buttons and <code>A</code> button in your button settings to select and confirm the role<ul>
<li>ps. <code>A</code> Key is not the keyboard <code>A</code>， but the <code>A</code> in the game, generally the default is <code>U</code> key</li>
</ul>
</li>
<li>Then player 1 can use the same operation to select the map</li>
<li>After that，let’s battle！</li>
</ul>
<h2 id="Charcater-Moves"><a href="#Charcater-Moves" class="headerlink" title="Charcater Moves"></a>Charcater Moves</h2><h3 id="WuKong"><a href="#WuKong" class="headerlink" title="WuKong"></a>WuKong</h3><h5 id="NormalMoves"><a href="#NormalMoves" class="headerlink" title="NormalMoves"></a>NormalMoves</h5><table>
<thead>
<tr>
<th>Keys</th>
<th>Moves(temp name)</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" />+A/C</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" />+A/C</td>
<td>2</td>
</tr>
<tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_L.png" style="zoom:10%;" />+B/D</td>
<td>3</td>
</tr>
<tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" />+A/C</td>
<td>4</td>
</tr>
</tbody></table>
<h5 id="SpecialMoves"><a href="#SpecialMoves" class="headerlink" title="SpecialMoves"></a>SpecialMoves</h5><table>
<thead>
<tr>
<th>Keys</th>
<th>Moves(temp name)</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" />+A/C</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_L.png" style="zoom:10%;" />+A/C</td>
<td>2</td>
</tr>
</tbody></table>
<h5 id="MaxSpecialMoves"><a href="#MaxSpecialMoves" class="headerlink" title="MaxSpecialMoves"></a>MaxSpecialMoves</h5><table>
<thead>
<tr>
<th>Keys</th>
<th>Moves(temp name)</th>
</tr>
</thead>
<tbody><tr>
<td>(<strong>In Max Stat</strong>)<img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" />+A/C</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="Aurora"><a href="#Aurora" class="headerlink" title="Aurora"></a>Aurora</h3><h5 id="NormalMoves-1"><a href="#NormalMoves-1" class="headerlink" title="NormalMoves"></a>NormalMoves</h5><table>
<thead>
<tr>
<th>Keys</th>
<th>Moves(temp name)</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" />+A/C</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_L.png" style="zoom:10%;" />+A/C</td>
<td>2</td>
</tr>
<tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_L.png" style="zoom:10%;" />+B/D</td>
<td>3</td>
</tr>
<tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_L.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" />+B/D</td>
<td>4</td>
</tr>
</tbody></table>
<h5 id="SpecialMoves-1"><a href="#SpecialMoves-1" class="headerlink" title="SpecialMoves"></a>SpecialMoves</h5><table>
<thead>
<tr>
<th>Keys</th>
<th>Moves(temp name)</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" />+A/C</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_L.png" style="zoom:10%;" />+B/D</td>
<td>2</td>
</tr>
</tbody></table>
<h5 id="MaxSpecialMoves-1"><a href="#MaxSpecialMoves-1" class="headerlink" title="MaxSpecialMoves"></a>MaxSpecialMoves</h5><table>
<thead>
<tr>
<th>Keys</th>
<th>Moves(temp name)</th>
</tr>
</thead>
<tbody><tr>
<td>(<strong>In Max Stat</strong>)<img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_D.png" style="zoom:10%;" /><img src="https://img.supervj.top/img/FighttingGamearrow_r.png" style="zoom:10%;" />+A/C</td>
<td>1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>《Multiplayer RPG Template》Documentation</title>
    <url>/2020/05/19/%E8%B6%854%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3EN/</url>
    <content><![CDATA[<blockquote>
<p>This is <a href="https://www.unrealengine.com/marketplace/zh-CN/product/multiplayer-rpg-template">Multiplayer RPG Template</a> Documentation,its about configuration and production method of the main system</p>
<p>This case is based on UE4’s  ListerServer  built-in LAN online game demo, refer to the work WOW</p>
<p>Based on UE4 version 4.25</p>
<p>There are still some imperfections in the demo, which will be followed up for optimization and repair</p>
</blockquote>
<h3 id="Skill-system"><a href="#Skill-system" class="headerlink" title="Skill system"></a>Skill system</h3><p><img src="https://img.supervj.top/imgchao4_skill1.jpg"></p>
<p>As shown in the above figure, this figure is the configuration information of the skill table. The important parameters are briefly described below</p>
<ul>
<li>Action: This variable represents the unique ID of this behavior. In principle, it is the same as the RowName of the table. In many logics, you need to use the ID to find all information about the skill, or use the ID to execute the skill</li>
<li>Display(struct)：3 parameters are used to display the general information of this skill, such as the display of the name or description and icons, which are related to the UMG, of course, you can also customize<ul>
<li><img src="https://img.supervj.top/imgchao4_skill4.jpg"></li>
<li><img src="https://img.supervj.top/imgchao4_skill5.jpg"></li>
</ul>
</li>
<li>CastData(struct)：This is a spell-casting structure, which mainly sets the method and conditions of the spell-casting<ul>
<li>Type:For example, the default reading spell casting, continuous casting, attack superimposing casting and other methods</li>
<li>Time:The time it takes to cast, 0 means instant</li>
<li>Duration:If it is a continuous cast, then this parameter means the lead time</li>
<li>KeepAttackStat:After the cast is finished, the normal attack will continue</li>
<li>MotionCast:Move cast, if set to No, you must stand cast, once you move, interrupt cast</li>
<li>NotTargetCast:Does not require target casting, and is generally used for range skills such as Fire and Rain</li>
</ul>
</li>
<li>Mp:Mana cost, Warrior Rage</li>
<li>CD:Cooling time</li>
<li>MaxRange：Maximum release range, calculated in Unreal Units, 0 means unlimited</li>
<li>LearnGold/Level:Prerequisites for learning this skill, 0 means no requirement</li>
<li>RangeSelectRange:If it is a skill selected by range, this parameter indicates the radius of the effect</li>
<li>TargetType:Target type, place of action or friend</li>
<li>SkillClass:Skill class, no need to create manually</li>
</ul>
<h5 id="SkillRef"><a href="#SkillRef" class="headerlink" title="SkillRef"></a>SkillRef</h5><blockquote>
<p>This is created by the SkillClass configured in the table, there is no need to manually create it, you only need to make the logic and effects of this class</p>
<p>This class is inherited from <code>BP_BaseSkill</code>, which has some messy blueprint logic, but not all are necessary to use. In this case, you can freely play in many cases. Anyway, after the skill is released, you can control this skill through this class Running the instance</p>
<p>Let’s explain it through the skill class of <code>IceBullet</code></p>
</blockquote>
<p><img src="https://img.supervj.top/imgchao4_skill2.jpg"></p>
<p><code>IceBullet</code>Inherit from<code>ProjectileBase</code>，As shown in the figure above, this is the basic parameter type of this class</p>
<ul>
<li>speed: flight speed, depends on <code>ProjectileComponent</code></li>
<li>StopDistance: the distance to stop, because this class is to track the target flight, so there will always be when approaching and reaching the target, a logic will be generated after reaching the target and stopping</li>
<li>Duration: Duration, if there is no hit, the time will destroy yourself</li>
<li>Sound / FX: related special effects configuration, Start can be used to play when it is generated, Hit can be used to play after hitting the target, but all need to be manually released<br>   - The effect of calling Start after <code>ProjectileBase</code> has realized<code> BeginPlay</code><br>   - The Hit effect has been achieved after hitting the target</li>
<li>BuffData: If this skill has buff / debuff, you can set this class, you need to manually call the method to create and run the buff class, as shown below</li>
</ul>
<p><img src="https://img.supervj.top/imgchao4_skill3.jpg"></p>
<h5 id="BuffRef"><a href="#BuffRef" class="headerlink" title="BuffRef"></a>BuffRef</h5><blockquote>
<p>This is an instance class of Buff, created by internally calling <code>CreateBuff</code> method of SkillRef</p>
<p>By rewriting the <code>BuffInit</code> and<code> BuffEnd</code> methods to achieve custom logic, if it has a continuous effect, then you can rewrite the <code>BuffDelta</code> method to make the logic of continuous calls</p>
</blockquote>
<h3 id="EquipSystem"><a href="#EquipSystem" class="headerlink" title="EquipSystem"></a>EquipSystem</h3><p><img src="https://img.supervj.top/imgchao4_equp1.jpg"></p>
<blockquote>
<p>As shown in the figure above, this is the configuration table of the equipment information. The following briefly introduces the role of the main parameters</p>
</blockquote>
<ul>
<li>BodyPart： the corresponding position of the equipment</li>
<li>Mesh/Mat: Used to display the model of this equipment entity, equipped on the character or discarded into the world</li>
<li>Property: literally means 2 kinds of properties, of which Adv property will change with the change of Base</li>
</ul>
<h3 id="PropSystem"><a href="#PropSystem" class="headerlink" title="PropSystem"></a>PropSystem</h3><p><img src="https://img.supervj.top/imgchao4_prop1.jpg"></p>
<blockquote>
<p>The prop system is similar to the equipment system</p>
</blockquote>
<ul>
<li>EffectType:Effect type, this case only made the healing effect and the effect of increasing magic</li>
<li>Value: You can set the range value of the effect, of course, this is not necessary, specifically the internal implementation of the following prop class</li>
<li>CanBeStacked:If one item occupies one space in the backpack bar, otherwise it can be stacked together</li>
<li>ActionClass:Prop class implement logic class, refer to Skill instance implementation, specific logic can be written into this class</li>
</ul>
<h3 id="DropSystem"><a href="#DropSystem" class="headerlink" title="DropSystem"></a>DropSystem</h3><p><img src="https://img.supervj.top/imgchao4_drop1.jpg"></p>
<blockquote>
<p>As shown in the figure above, the configuration of the drop system is placed in the <code>DataSystem</code> class. Why is there no configuration table? O (∩_∩) O</p>
<p>Of course, you can create a similar table yourself and replace the logic in it. This is very simple.</p>
</blockquote>
<p>This configuration information is a Map key-value pair, the key corresponds to the role class, and the value is the drop information array</p>
<ul>
<li>Action:Select the action name of equipment / props, etc.</li>
<li>Type:Choose equipment / props. Of course, if you want to drop skills, you can theoretically do it. Please play freely.</li>
<li>Amount:number of drops</li>
<li>Probability:Probability, this probability calculation is done when the character is created, when not kill</li>
</ul>
<h3 id="TaskSystem"><a href="#TaskSystem" class="headerlink" title="TaskSystem"></a>TaskSystem</h3><p><img src="https://img.supervj.top/imgchao4_task1.jpg"></p>
<blockquote>
<p> As shown in the figure above, this is the configuration information of the task table</p>
</blockquote>
<ul>
<li>Titile：the title of the task, which will be displayed in the header section of the task bar</li>
<li>Target：the target of the task</li>
<li>DynamicTargetStat:This will be refreshed dynamically, the specific implementation logic is in the following TaskClass</li>
</ul>
<h5 id="TaskRef"><a href="#TaskRef" class="headerlink" title="TaskRef"></a>TaskRef</h5><p><img src="https://img.supervj.top/imgchao4_task2.jpg"></p>
<p><img src="https://img.supervj.top/imgchao4_task3.jpg"></p>
<blockquote>
<p>As shown in the figure above, each time a task is accepted, a task class will be generated as an observer (agent) of the task</p>
<p>Specifically what the task is for, you can manage it by implementing the logic in this class, while setting the dynamic information in the task goal</p>
</blockquote>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><h5 id="Monster-refresh"><a href="#Monster-refresh" class="headerlink" title="Monster refresh"></a>Monster refresh</h5><p><img src="https://img.supervj.top/imgchao4_aigenerat1.jpg"></p>
<blockquote>
<p>Monster refresh is done by placing a <code>BP_AIGenerator</code> management class in the scene</p>
</blockquote>
<ul>
<li>MaxNum: the maximum number of refreshes</li>
<li>AIClass: Set the class for refreshing the character, if more than one, it will be randomly refreshed from it</li>
<li>Range: refresh monsters within a radius centered on the position of the management class</li>
</ul>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>路径点优化</title>
    <url>/2020/06/12/%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍路径点的优化方式，或者叫做多线段优化、轨迹点优化</p>
<p>根据设定阈值，去掉路径点中的部分多余点，以达到方便传输的目的</p>
<p>本文用UE4蓝图和C++蓝图函数库的2个方式解释</p>
<p><strong>注:多种方法可以叠加使用</strong></p>
</blockquote>
<p>本算法提供了基于UE4的Demo，<a href="https://xshniteducn-my.sharepoint.com/:u:/g/personal/15040920722_xs_hnit_edu_cn/EdZ7WHvq8mdHm2b0xRcJtWsBnhqVdqBx07E_Tr_s7mshDQ?e=8lhWkm">PC</a>，<a href="https://xshniteducn-my.sharepoint.com/:u:/g/personal/15040920722_xs_hnit_edu_cn/ET-Wm3V8br1PuSrS0qUnwekBLP5bGpnZqZ8cGb3tGSLK-w?e=Y7wQmT">安卓</a></p>
<p><a href="https://github.com/VJien/PathOptimazation">GitHub工程下载</a></p>
<p>Demo演示动图</p>
<p><img src="https://img.supervj.top/img/PathOptimization/pathOpt_10.gif"></p>
<span id="more"></span>



<h3 id="径向距离算法"><a href="#径向距离算法" class="headerlink" title="径向距离算法"></a>径向距离算法</h3><blockquote>
<p>又称为临近点优化，比较暴力的算法，效率高，精准度尚可</p>
<p>目的：去掉太接近的点</p>
</blockquote>
<p>如果路径点中的相邻两点的距离小于设定的阈值，则舍去其中一个点。首先，以笔迹中的第一个点为基准点，计算第二个点与第一个点之间的距离，如果此距离小于给定的阈值，则舍去第二个点；如果此距离大于给定的阈值，则保留第二个点，并以其为新的基准点。然后再拿第三个点来与基准点判断距离，如此向后循环。</p>
<p>先贴代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="comment">//径向距离优化，小于distance的点会被优化</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable,Category=<span class="string">&quot;UFlibAlgorithm|PathPointOptimization&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">RadialDistanceOptimization</span><span class="params">(<span class="keyword">const</span> TArray&lt;FVector&gt;&amp; InPath,TArray&lt;FVector&gt;&amp; OutPath, <span class="keyword">float</span> Distance=<span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UFlibAlgorithm::RadialDistanceOptimization</span><span class="params">(<span class="keyword">const</span> TArray&lt;FVector&gt;&amp; InPath,  TArray&lt;FVector&gt;&amp; OutPath, <span class="keyword">float</span> Distance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (InPath.<span class="built_in">Num</span>()&lt;<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OutPath = InPath;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	FVector vKey= InPath[<span class="number">0</span>];</span><br><span class="line">	OutPath.<span class="built_in">Add</span>(vKey);</span><br><span class="line">	<span class="keyword">for</span> (int32 i=<span class="number">1</span>;i&lt; InPath.<span class="built_in">Num</span>()<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((vKey- InPath[i]).<span class="built_in">Size</span>()&gt; Distance)</span><br><span class="line">		&#123;</span><br><span class="line">			OutPath.<span class="built_in">Add</span>(InPath[i]);</span><br><span class="line">			vKey = InPath[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((InPath.<span class="built_in">Last</span>()-vKey).<span class="built_in">Size</span>()&lt;=Distance)<span class="comment">//处理最后一个点</span></span><br><span class="line">	&#123;</span><br><span class="line">		OutPath.<span class="built_in">Pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	OutPath.<span class="built_in">Add</span>(InPath.<span class="built_in">Last</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>蓝图</p>
<p><img src="https://img.supervj.top/img/PathOptimization/pathOpt_1.jpg"></p>
<h3 id="曲率算法"><a href="#曲率算法" class="headerlink" title="曲率算法"></a>曲率算法</h3><blockquote>
<p>去除大于设定曲率阈值的角度的点</p>
<p>目的：去除角度偏移过大的线段</p>
</blockquote>
<p>设定3个点：p1,p2,p3</p>
<p>方向向量：前置向量v1=p2-p1,后置向量v2=p3-p2</p>
<p>v1和v2的夹角angle即我们需要与阈值比较的角度，如果大于阈值，那么点p2就不满足条件而被移除</p>
<p>这里带来了一个问题，即移除了p2以后，下一次计算的时候后置向量v2保持不变即当前点指向下一个点；但是前置向量怎么选择是一个问题，所以我们分别用了<code>T124,T134,T234</code>来分别3种计算方式，3种方式取前置向量的方式分别是</p>
<ul>
<li>T124：前置向量v1=p2-p1，即保持原样</li>
<li>T134：v1=p3-p1，即跳过被移除点</li>
<li>T234：v1=p3-p2，即跟后置向量保持统一节奏</li>
</ul>
<p><img src="https://img.supervj.top/img/PathOptimization/pathOpt_6.jpg"></p>
<p>三种方式计算方式大同小异，下面先贴代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">ECurvatureType</span>:</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">	T124,</span><br><span class="line">	T134,</span><br><span class="line">	T234</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//曲率优化，大于角度angle的点会被优化，分为3个模式，推荐使用T134</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;UFlibAlgorithm|PathPointOptimization&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">CurvatureOptimization</span><span class="params">(<span class="keyword">const</span> TArray&lt;FVector&gt;&amp; InPath, TArray&lt;FVector&gt;&amp; OutPath, ECurvatureType type=ECurvatureType::T134, <span class="keyword">float</span> Angle = <span class="number">90</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UFlibAlgorithm::CurvatureOptimization</span><span class="params">(<span class="keyword">const</span> TArray&lt;FVector&gt;&amp; InPath, TArray&lt;FVector&gt;&amp; OutPath, ECurvatureType type, <span class="keyword">float</span> Angle <span class="comment">/*= 90*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (InPath.<span class="built_in">Num</span>() &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OutPath = InPath;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	FVector p1 = InPath[<span class="number">0</span>];</span><br><span class="line">	OutPath.<span class="built_in">Add</span>(p1);</span><br><span class="line">	FVector p2, p3, dirFWD, dirBWD;</span><br><span class="line">	<span class="keyword">bool</span> b124Found = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (int32 i=<span class="number">1</span>;i&lt;InPath.<span class="built_in">Num</span>()<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p2 = InPath[i];</span><br><span class="line">		p3 = InPath[i + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (b124Found||type!=ECurvatureType::T124)</span><br><span class="line">		&#123;</span><br><span class="line">			dirFWD = p2 - p1;</span><br><span class="line">		&#125;</span><br><span class="line">		dirBWD = p3 - p2;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">AngleBetween</span>(dirBWD, dirFWD) &lt;= Angle)</span><br><span class="line">		&#123;</span><br><span class="line">			OutPath.<span class="built_in">Add</span>(p2);</span><br><span class="line">			p1 = p2;</span><br><span class="line">			b124Found = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			b124Found = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (type==ECurvatureType::T234)</span><br><span class="line">			&#123;</span><br><span class="line">				p1 = p2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	OutPath.<span class="built_in">Add</span>(InPath.<span class="built_in">Last</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">UFlibAlgorithm::AngleBetween</span><span class="params">(FVector A, FVector B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A.<span class="built_in">Normalize</span>();</span><br><span class="line">	B.<span class="built_in">Normalize</span>();</span><br><span class="line">	<span class="keyword">return</span> UKismetMathLibrary::<span class="built_in">DegAcos</span>(UKismetMathLibrary::<span class="built_in">Dot_VectorVector</span>(A, B));</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>蓝图</p>
<p><img src="https://img.supervj.top/img/PathOptimization/pathOpt_3_1.jpg"></p>
<p><img src="https://img.supervj.top/img/PathOptimization/pathOpt_3_1pathOpt_3_2.jpg"></p>
<blockquote>
<p>从结果测试发现，效果 T134&gt;T124&gt;T234</p>
</blockquote>
<h3 id="垂直距离算法"><a href="#垂直距离算法" class="headerlink" title="垂直距离算法"></a>垂直距离算法</h3><blockquote>
<p>将点-线段的距离作为误差判据。对于每个顶点p，需要计算它与线段[p-1， p+1]的垂直距离，距离比给定误差小的点都将被移除。</p>
<p>目的:去除垂直距离偏移过大的点</p>
</blockquote>
<p><img src="https://img.supervj.top/img/PathOptimization/pathOpt_5.jpg"></p>
<p>如图，如果蓝色线段即垂直距离大于设定阈值，则左右两天线段会被优化成红色线段</p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="comment">//垂直距离优化，大于distance的点会被优化</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;UFlibAlgorithm|PathPointOptimization&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">PerpendicularDistanceOptimization</span><span class="params">(<span class="keyword">const</span> TArray&lt;FVector&gt;&amp; InPath, TArray&lt;FVector&gt;&amp; OutPath, <span class="keyword">float</span> Distance = <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UFlibAlgorithm::PerpendicularDistanceOptimization</span><span class="params">(<span class="keyword">const</span> TArray&lt;FVector&gt;&amp; InPath, TArray&lt;FVector&gt;&amp; OutPath, <span class="keyword">float</span> Distance <span class="comment">/*= 50*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (InPath.<span class="built_in">Num</span>() &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OutPath = InPath;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	FVector vKey = InPath[<span class="number">0</span>];</span><br><span class="line">	OutPath.<span class="built_in">Add</span>(vKey);</span><br><span class="line">	FVector p1, p2, p3;</span><br><span class="line">	p1 = InPath[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (int32 i=<span class="number">1</span>;i&lt;InPath.<span class="built_in">Num</span>()<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p2 = InPath[i];</span><br><span class="line">		p3 = InPath[i + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">float</span> dis = UKismetMathLibrary::<span class="built_in">GetPointDistanceToLine</span>(p2, p1, p3 - p1);</span><br><span class="line">		<span class="keyword">if</span> (dis&lt;=Distance)</span><br><span class="line">		&#123;</span><br><span class="line">			OutPath.<span class="built_in">Add</span>(p2);</span><br><span class="line">			p1 = p2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	OutPath.<span class="built_in">Add</span>(InPath.<span class="built_in">Last</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>蓝图</p>
<p><img src="https://img.supervj.top/img/PathOptimization/pathOpt_2.jpg"></p>
<blockquote>
<p>其实参考曲率优化方式，这个方式也可以考虑3种前置向量即本代码中<code>p1</code>的选择问题，本代码种应该是类似T234的方式，有兴趣的可以自己尝试其他几个方式</p>
</blockquote>
<h3 id="道格拉斯-普克算法"><a href="#道格拉斯-普克算法" class="headerlink" title="道格拉斯-普克算法"></a>道格拉斯-普克算法</h3><blockquote>
<p> 一种迭代适应点算法，它将曲线近似表示为一系列点，并减少点的数量。</p>
<p>算法的基本思路是：对每一条曲线的首末点虚连一条直线，求所有点与直线的距离，并找出最大距离值 dmax ，用 dmax 与阈值 D 相比。若 dmax &lt; D ，这条曲线上的中间点全部舍去；若 dmax ≥ D ，则保留 dmax 对应的坐标点，并以该点为界，把曲线分为两部分，对这两部分循环使用该方法。<br>此算法在时间复杂度和空间复杂度要明显高于其它两种，但是它的效果较好</p>
</blockquote>
<p>先来一个动图</p>
<p><img src="https://img.supervj.top/img/PathOptimization/pathOpt_7.gif"></p>
<p>贴代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	达格拉斯多普优化，使用迭代计算</span></span><br><span class="line"><span class="comment">	效率相对低但是精度高</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;UFlibAlgorithm|PathPointOptimization&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">DouglasPeuckerOptimization</span><span class="params">(<span class="keyword">const</span> TArray&lt;FVector&gt;&amp; InPath, TArray&lt;FVector&gt;&amp; OutPath, <span class="keyword">float</span> Distance = <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UFlibAlgorithm::DouglasPeuckerOptimization</span><span class="params">(<span class="keyword">const</span> TArray&lt;FVector&gt;&amp; InPath, TArray&lt;FVector&gt;&amp; OutPath, <span class="keyword">float</span> Distance <span class="comment">/*= 50*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (InPath.<span class="built_in">Num</span>() &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OutPath = InPath;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	int32 idx, first, last;</span><br><span class="line">	first = idx = <span class="number">0</span>;</span><br><span class="line">	last = InPath.<span class="built_in">Num</span>() - <span class="number">1</span>;</span><br><span class="line">	TArray&lt;<span class="keyword">bool</span>&gt; Markers;</span><br><span class="line">	Markers.<span class="built_in">AddUninitialized</span>(last + <span class="number">1</span>);</span><br><span class="line">	Markers[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">	Markers.<span class="built_in">Last</span>() = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">float</span> maxDis = <span class="number">0</span>;</span><br><span class="line">	TArray&lt;int32&gt; stack;</span><br><span class="line">	<span class="keyword">while</span> (first&gt;=<span class="number">0</span> &amp;&amp; last&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		maxDis = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (int32 i=first+<span class="number">1</span>;i&lt;last;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> dis = UKismetMathLibrary::<span class="built_in">GetPointDistanceToLine</span>(InPath[i], InPath[first], InPath[last] - InPath[first]);</span><br><span class="line">			<span class="keyword">if</span> (dis&gt;maxDis)</span><br><span class="line">			&#123;</span><br><span class="line">				idx = i;</span><br><span class="line">				maxDis = dis;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (maxDis&gt;Distance)</span><br><span class="line">		&#123;</span><br><span class="line">			Markers[idx] = <span class="literal">true</span>;</span><br><span class="line">			stack.<span class="built_in">Add</span>(first);</span><br><span class="line">			stack.<span class="built_in">Add</span>(idx);</span><br><span class="line">			stack.<span class="built_in">Add</span>(idx);</span><br><span class="line">			stack.<span class="built_in">Add</span>(last);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (stack.<span class="built_in">Num</span>()&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			last = stack.<span class="built_in">Pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			last = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (stack.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			first = stack.<span class="built_in">Pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			first = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (int32 i=<span class="number">0</span>;i&lt;Markers.<span class="built_in">Num</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Markers[i])</span><br><span class="line">		&#123;</span><br><span class="line">			OutPath.<span class="built_in">Add</span>(InPath[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>蓝图</p>
<p><img src="https://img.supervj.top/img/PathOptimization/pathOpt_4.jpg"></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>边缘高光实现方案</title>
    <url>/2020/12/15/%E8%BE%B9%E7%BC%98%E9%AB%98%E5%85%89%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模型的边缘高光应该是老生常谈的话题了, 不过还是有必要详细记录一下各种主流的两个实现方案, 同样的, 这个问题也经常在TA或者客户端面试中被问到</p>
<h2 id="后期方案"><a href="#后期方案" class="headerlink" title="后期方案"></a>后期方案</h2><p>先看效果动图</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_15_16_03_11_453.gif" alt="录制_2020_12_15_16_03_11_453"></p>
<span id="more"></span>



<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>后期的方案效果上来说是比较优秀的, 主要就是丢一个后期盒子进去,可以设置成全局的,然后给上一个后期材质,不过研究材质球之前还有好几部准备工作</p>
<ul>
<li>开启自定义模板</li>
</ul>
<p><img src="https://img.supervj.top//img/image-20201215160629430.png" alt="image-20201215160629430"></p>
<p>需要在项目设置-&gt;渲染-&gt;后期-&gt;设置自定义模板通道为上图所示选项</p>
<p><img src="https://img.supervj.top//img/image-20201215161149290.png" alt="image-20201215161149290"></p>
<p>然后需要边缘发光的模型要开启自定义深度,然后给上一定模板值(一般只需要&gt;0的值即可,当然这个值可以拿来做很多效果)</p>
<p><img src="https://img.supervj.top//img/image-20201215162020252.png" alt="image-20201215162020252"></p>
<p>可以参考上图观察是否正确开启自定义模板通道</p>
<h3 id="材质球"><a href="#材质球" class="headerlink" title="材质球"></a>材质球</h3><p><img src="https://img.supervj.top//img/image-20201215161216695.png" alt="image-20201215161216695"></p>
<p>乍一看很复杂, 其实也没什么太难的地方, 主要就是对纹理像素进行一定偏移然后减去原有的蒙版值后就得到了边缘了</p>
<p><img src="https://img.supervj.top//img/image-20201215161522615.png" alt="image-20201215161522615"></p>
<p><img src="https://img.supervj.top//img/image-20201215161358241.png" alt="image-20201215161358241"></p>
<p>打算对纹理像素横纵方向的偏移设置,  这里做了一个根据时间偏移的闪烁/抖动的效果, 宽度由一个参数<code>OutlineThickness</code>控制</p>
<p><img src="https://img.supervj.top//img/image-20201215161622843.png" alt="image-20201215161622843"></p>
<p>类似上图的, 对8个方向进行偏移</p>
<p><img src="https://img.supervj.top//img/image-20201215161744379.png" alt="image-20201215161744379"></p>
<p>找到周边最大的一个模板值, 到这里的显示效果如下图</p>
<p><img src="https://img.supervj.top//img/image-20201215161846884.png" alt="image-20201215161846884"></p>
<p>上图中显示效果就是原有模板值加上之前做的偏移的效果, 因为值远大于1, 所以很亮</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_15_16_21_38_894.gif" alt="录制_2020_12_15_16_21_38_894"></p>
<p>做一个测试, 模板值就是我们的颜色值</p>
<p>为了方便处理, 我们后面加一个<code>Clamp(0-1)</code></p>
<p><img src="https://img.supervj.top//img/image-20201215162325202.png" alt="image-20201215162325202"></p>
<p>然后减去我们原有的值就得到了边缘</p>
<p>如果只需要边缘效果, 那么到此为止也可以了,再加上颜色和原有场景色就是正确的边缘发光了, 如下图</p>
<p><img src="https://img.supervj.top//img/image-20201215162508080.png" alt="image-20201215162508080"></p>
<hr>
<p>后面我们再做一个被遮挡的部分全高光显示的操作,如同最开始动图中演示的效果</p>
<p><img src="https://img.supervj.top//img/image-20201215162614708.png" alt="image-20201215162614708"></p>
<p>上图中通过<code>ceil</code>得到0即是可见部分,1为遮挡部分</p>
<p><img src="https://img.supervj.top//img/image-20201215162838246.png" alt="image-20201215162838246"></p>
<p>简单加减一下就可以让被遮挡部分也通过开关显示高光</p>
<p>完成!</p>
<p><img src="https://img.supervj.top//img/image-20201215163020243.png" alt="image-20201215163020243"></p>
<p><img src="https://img.supervj.top//img/image-20201215163045403.png" alt="image-20201215163045403"></p>
<blockquote>
<p>补充: 如果发现描边效果会异常的抖动(看上去是渲染问题的感觉), 需要设置如下图所示的材质球属性</p>
</blockquote>
<p><img src="https://img.supervj.top//img/image-20201215174137554.png" alt="image-20201215174137554"></p>
<h2 id="模型叠加方案"><a href="#模型叠加方案" class="headerlink" title="模型叠加方案"></a>模型叠加方案</h2><p><img src="https://img.supervj.top//img/image-20201215170946685.png" alt="image-20201215170946685"></p>
<p>何为模型叠加, 其实就是额外使用一个一样的模型,例用模型顶点偏移效果来模拟边缘发光效果,这个相对比较简单</p>
<p>此方案不需要前者那样设置特殊的通道和模型属性,直接开怼</p>
<h3 id="材质球-1"><a href="#材质球-1" class="headerlink" title="材质球"></a>材质球</h3><p><img src="https://img.supervj.top//img/image-20201215170616035.png" alt="image-20201215170616035"></p>
<p>解释一下<code>TwoSideSign</code></p>
<p>可以理解为,正面为1, 背面为0</p>
<p>我们做一个<code>OneMinus</code>操作就可以把双面显示部分显示为1</p>
<p>这样就得到了顶点偏移部分显示,其他部分隐藏的效果</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>后者方案材质球比较简单, 但是需要额外提供一个一样的模型, 模型渲染方面的消耗肯定有增加,而且问题是个人觉得这个效果不是真正意义上的边缘发光,在复杂的比如人物模型的时候表现的比较纠结;</p>
<p>同样的模型方案无法在遮挡的情况下显示, 算是比较遗憾的地方</p>
<p>后期方案效果比较优秀, 但是必须依赖一个后期盒子, 如果你有其他复杂的后期效果需要用到后期盒子, 需要谨慎处理</p>
<p>最后再动图对比一下</p>
<p><img src="https://img.supervj.top//img/%E5%BD%95%E5%88%B6_2020_12_15_17_14_42_648.gif" alt="录制_2020_12_15_17_14_42_648"></p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>材质</tag>
        <tag>后期</tag>
      </tags>
  </entry>
  <entry>
    <title>离线重定向源码分析</title>
    <url>/2021/11/08/%E9%87%8D%E5%AE%9A%E5%90%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UE的动画重定向(离线模式)是个非常好用的功能, 但是最近遇到了一些特殊需求, 势必需要深入研究一下这个重定向的源码</p>
<p><img src="https://img.supervj.top/img%E7%A6%BB%E7%BA%BF%E9%87%8D%E5%AE%9A%E5%90%91%E6%B5%81%E7%A8%8B.png" alt="离线重定向流程"></p>
<span id="more"></span>









<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>重定向的前提是需要创建一个Rig文件, Rig文件起到的是类似一个模板或者表的作用, 重点定义了骨骼的拓扑结构信息,即父子关系; 当然也有其他如骨骼变换的坐标系定义和骨骼名称</p>
<p>然后需要在Source骨骼和Target骨骼上都设置Rig信息, 同时也必须添加预览模型,然后就可以开始我们的重定向流程了, 下面简述一下大致流程</p>
<p><img src="https://img.supervj.top/imgimage-20211109162031935.png" alt="image-20211109162031935"></p>
<p><img src="https://img.supervj.top/imgimage-20211109164250707.png" alt="image-20211109164250707"></p>
<h3 id="FTransformBase"><a href="#FTransformBase" class="headerlink" title="FTransformBase"></a>FTransformBase</h3><p>Rig内保存的一个比较重要的数据结构, 保存了骨骼父子关系和其他重要信息</p>
<p>FTransformBase</p>
<ul>
<li>FName             Node</li>
<li>FTransformBaseConstraint[2]   //2个成员,1个保存旋转,另一个位移<ul>
<li>TArray<FRigTransformConstraint><ul>
<li>EConstraintTransform::Type&gt; TranformType //坐标系, 绝对和相对两种</li>
<li>FName   ParentSpace //父骨骼</li>
<li>float   Weight = 0.f; //权重,一般为1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="流程简要"><a href="#流程简要" class="headerlink" title="流程简要"></a>流程简要</h2><ol>
<li>入口在<code>FAssetTypeActions_AnimationAsset::RetargetAnimationHandler()</code></li>
<li>然后调用<code>EditorAnimUtils</code>中的<code>RetargetAnimations()</code></li>
<li>创建重定向非常重要的结构体<a href="#FAnimationRetargetContext">↓FAnimationRetargetContext</a></li>
<li>从UPackage复制必要信息到<code>RetargetContext</code>, 同时在编辑器中创建(拷贝)若干份动画资源, 根据需求可能拷贝所有有引用关系的动画资源或蓝图</li>
<li>调用<code>RetargetContext</code>中的成员函数<code>RetargetAnimations()</code>开始重定向<ol>
<li>刷新新旧骨骼的预览模型(所以预览模型是必须添加的)</li>
<li>处理曲线, 会移除掉UE中手动K帧的曲线</li>
<li>替换动画资源的骨骼<code>ReplaceSkeleton()</code>, 然后内部调用重点要研究的同时开销巨大的函数<a href="#RemapTracksToNewSkeleton">↓RemapTracksToNewSkeleton()</a></li>
<li>到此新的动画资源中已经保存了新的动画数据和骨架</li>
</ol>
</li>
<li>Runtime下根据骨架的重定向规则进行动画刷新 <a href="#retargetMode">↓重定向模式</a></li>
</ol>
<a name = "FAnimationRetargetContext">

<h2 id="FAnimationRetargetContext"><a href="#FAnimationRetargetContext" class="headerlink" title="FAnimationRetargetContext"></a>FAnimationRetargetContext</h2><p>重定向初期就构造的一个数据类型, 保存了如下图中重定向必要参数</p>
<p><img src="https://img.supervj.top/imgimage-20211109162253295.png" alt="image-20211109162253295"></p>
<p>同时提供了几个非常重要的计算函数, 重定向核心计算就在下图中的两个函数中</p>
<p><img src="https://img.supervj.top/imgimage-20211109162323533.png" alt="image-20211109162323533"></p>
<a name = "RemapTracksToNewSkeleton">

<h2 id="RemapTracksToNewSkeleton"><a href="#RemapTracksToNewSkeleton" class="headerlink" title="RemapTracksToNewSkeleton"></a>RemapTracksToNewSkeleton</h2><p>重定向动画序列的时候这个函数会调用2次, 在查找所有引用的时候包含了自己, 结束了以后再调用一次自己的, 是否是多余的?</p>
<ol>
<li>计算基于rig的<strong>原始动画</strong>的<strong>模型空间变换信息</strong>, <strong>骨骼空间的旋转和位移</strong>, <a href="#FillUpTransformBasedOnRig">↓FillUpTransformBasedOnRig</a></li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109113148664.png" alt="image-20211109113148664"></p>
<a name = "RemapTracksToNewSkeleton.2">

<ol start="2">
<li>计算新旧模型空间的相对变换矩阵信息数组<code>RelativeToNewSpaceBases</code> 和 新旧骨骼空间位移比值<code>OldToNewTranslationRatio</code></li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109113340561.png" alt="image-20211109113340561"></p>
<blockquote>
<p> 这个比值计算有个注意点,  如果新骨架当前骨骼到父骨骼的位移为0, 那么这个缩放比也是0, 这个会影响后面计算<a href="#%E6%AF%94%E5%80%BC%E8%AE%A1%E7%AE%97">↓请看</a></p>
</blockquote>
<blockquote>
<p>另外的, 如果新骨架的某一节骨骼没有设置rig, 那么下一级的骨骼就没有父骨骼, 在比值计算的时候会直接设置成1, 相对矩阵计算也会受影响, 这样导致的结果是很难预测的, 建议不要这样做</p>
</blockquote>
<ol start="3">
<li>把<strong>原始动画</strong>模型空间的动画数据转换成局部空间的Rig数据  <a href="#ConvertAnimationDataToRiggingData">↓ConvertAnimationDataToRiggingData</a></li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109113723188.png" alt="image-20211109113723188"></p>
<p>得到的数据结构是下图这样的</p>
<p><img src="https://img.supervj.top/imgimage-20211109134647219.png" alt="image-20211109134647219"></p>
<ol start="4">
<li><strong>2层遍历</strong>所有<strong>旧骨骼</strong>和动画帧数<ol>
<li>从当前骨骼和动画帧提取<strong>局部变换信息</strong></li>
<li>计算得到<strong>组件空间的动画信息</strong><code>TArray&lt; TArray&lt;FTransform&gt; &gt; ComponentSpaceAnimations</code>, 该变量经过了比值缩放</li>
</ol>
</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109115201264.png" alt="image-20211109115201264"></p>
<a name = "比值计算">

<blockquote>
<p>上面图中可以看到从动画中提取的局部变换信息进行了缩放, 系数是<code>OldToNewTranslationRatio[NodeIndex]</code>,所以如果系数是0, 那么这一步就相当于没有位移了</p>
</blockquote>
<ol start="5">
<li>同上2层遍历<ol>
<li>通过上<code>RelativeToNewSpaceBases * ComponentSpaceAnimations </code>得到转换过的<strong>模型空间的动画数据</strong> <code>ConvertedSpaceAnimations</code></li>
<li>填充转换过的<strong>本地空间的动画信息</strong> <code>ConvertedLocalSpaceAnimations</code></li>
</ol>
</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109133637304.png" alt="image-20211109133637304"></p>
<ol start="6">
<li>通过上面5.6.7部的数据修改<code>RiggingAnimationData</code>, 这就是新骨骼的动画数据, 即本地空间变换信息</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109134133740.png" alt="image-20211109134133740"></p>
<p><img src="https://img.supervj.top/imgimage-20211109135425130.png" alt="image-20211109135425130"></p>
<ol start="7">
<li><p>设置新骨骼</p>
</li>
<li><p>将上面最新的rig数据设置到新骨骼的动画数据</p>
</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109135705036.png" alt="image-20211109135705036"></p>
<p><img src="https://img.supervj.top/imgimage-20211109145656724.png" alt="image-20211109145656724"></p>
<a name = "ConvertAnimationDataToRiggingData">

<h2 id="ConvertAnimationDataToRiggingData"><a href="#ConvertAnimationDataToRiggingData" class="headerlink" title="ConvertAnimationDataToRiggingData"></a>ConvertAnimationDataToRiggingData</h2><ol>
<li>通过<a href="#GetSpaceBasedAnimationData"><code>↓GetSpaceBasedAnimationData</code></a>获取下图动画数据<code>FRawAnimSequenceTrack</code>, 该数据是<strong>模型空间</strong>的</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109105529625.png" alt="image-20211109105529625"></p>
<ol start="2">
<li>按序号查找Rig节点名称, 比如tag_origin, 然后去新骨架查找对应的骨骼名称和序号</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109111234463.png" alt="image-20211109111234463"></p>
<ol start="3">
<li>获取约束数据</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109110306607.png" alt="image-20211109110306607"></p>
<ol start="4">
<li>从上面的约束信息获取父骨骼名称和序号</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109111526336.png" alt="image-20211109111526336"></p>
<ol start="5">
<li>基于父骨骼的模型空间信息 计算出 每一帧的相对变换信息; 填充到结果数据的AnimTrack中, 这里的动画数据是<strong>相对空间</strong>的</li>
</ol>
<p><img src="https://img.supervj.top/imgimage-20211109110445385.png" alt="image-20211109110445385"></p>
<p><img src="https://img.supervj.top/imgimage-20211109105101355.png" alt="image-20211109105101355"></p>
<a name = "GetSpaceBasedAnimationData ">

<h2 id="GetSpaceBasedAnimationData"><a href="#GetSpaceBasedAnimationData" class="headerlink" title="GetSpaceBasedAnimationData"></a>GetSpaceBasedAnimationData</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">UAnimSequence::GetSpaceBasedAnimationData</span><span class="params">(TArray&lt; TArray&lt;FTransform&gt; &gt;&amp; AnimationDataInComponentSpace, FAnimSequenceTrackContainer * RiggingAnimationData)</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>



<p>这个函数有点奇葩, 要分为有没有传入指针变量来区分</p>
<ul>
<li>没有指针</li>
</ul>
<p>从模型中提取局部空间动画帧变换信息</p>
<p><img src="https://img.supervj.top/imgimage-20211109162904122.png" alt="image-20211109162904122"></p>
<ul>
<li>可指针</li>
</ul>
<p>从指针变量中提取</p>
<p>然后再通过 关键帧变换信息 * 父骨骼模型空间变换信息 =  当前骨骼当前帧数的<strong>模型空间</strong>变换信息</p>
<p><img src="https://img.supervj.top/imgimage-20211109163454341.png" alt="image-20211109163454341"></p>
<a name = "FillUpTransformBasedOnRig">

<h2 id="FillUpTransformBasedOnRig"><a href="#FillUpTransformBasedOnRig" class="headerlink" title="FillUpTransformBasedOnRig"></a>FillUpTransformBasedOnRig</h2><p>基于Rig获得<strong>原始动画</strong>的<strong>模型空间变换信息</strong>, <strong>骨骼空间的旋转和位移</strong></p>
<p>如果Rig匹配的骨骼是None, 那么会设置为Identity数据</p>
<p><img src="https://img.supervj.top/imgimage-20211109151720633.png" alt="image-20211109151720633"></p>
<p>同样, 也会将原本存在的模型空间数据设置为Identity数据作为输出数据</p>
<p><img src="https://img.supervj.top/imgimage-20211109153142042.png" alt="image-20211109153142042"></p>
<h2 id="FAnimSequenceTrackContainer"><a href="#FAnimSequenceTrackContainer" class="headerlink" title="FAnimSequenceTrackContainer"></a>FAnimSequenceTrackContainer</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENGINE_API</span> <span class="title">FAnimSequenceTrackContainer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">GENERATED_USTRUCT_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TArray&lt;<span class="class"><span class="keyword">struct</span> <span class="title">FRawAnimSequenceTrack</span>&gt;</span> AnimationTracks;<span class="comment">//每个骨骼对应的每一帧模型空间的transform</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TArray&lt;FName&gt;						TrackNames;  <span class="comment">//所有骨骼名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="GetSpaceBasedAnimationData-1"><a href="#GetSpaceBasedAnimationData-1" class="headerlink" title="GetSpaceBasedAnimationData"></a>GetSpaceBasedAnimationData</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">UAnimSequence::GetSpaceBasedAnimationData</span><span class="params">(TArray&lt; TArray&lt;FTransform&gt; &gt;&amp; AnimationDataInComponentSpace, FAnimSequenceTrackContainer * RiggingAnimationData)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>获取<strong>组件空间</strong>的2维数组变换数据, 在计算中经常用到</p>
<p><code>AnimationDataInComponentSpace[骨骼序号][帧]</code></p>
<h2 id="需求简述"><a href="#需求简述" class="headerlink" title="需求简述"></a>需求简述</h2><p>骨架从根骨开始大致是如下, 括号中是新骨架</p>
<p>Joints(Joints)</p>
<ul>
<li>tag_origin(Bip01)<ul>
<li>main_root(Pelvis)<ul>
<li>spine01(spine01)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>层级是一样的, 但是有这么个情况, 我用简化模型来模拟这个案例</p>
<p><img src="https://img.supervj.top/imgimage-20211109161554773.png" alt="image-20211109161554773"></p>
<p>如上图, Source骨架的第二层骨骼是跟根骨骼完全重合的, 然后main_root就放到盆骨位置</p>
<p><img src="https://img.supervj.top/imgimage-20211109161706255.png" alt="image-20211109161706255"></p>
<p>Target骨架的对应骨骼是跟盆骨重合的</p>
<p>再来看动画素材</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_11_09_16_18_59_147.gif" alt="录制_2021_11_09_16_18_59_147"></p>
<p> 盆骨是有局部空间位移的, 那么在这种情况下能否正确重定向?</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在<a href="#RemapTracksToNewSkeleton.2">↑RemapTracksToNewSkeleton第二步</a> 中计算的结果</p>
<p><img src="https://img.supervj.top/imgimage-20211109104543482.png" alt="image-20211109104543482"></p>
<p><img src="https://img.supervj.top/imgimage-20211109104551377.png" alt="image-20211109104551377"></p>
<img src="https://img.supervj.top/imgimage-20211109104921112.png" alt="image-20211109104921112" style="zoom:150%;" />



<p>这里第三个成员变量 即新骨骼的 pelvis 的 比值即Ratio=0, 这就导致在后面计算中把位移给去掉了</p>
<p><img src="https://img.supervj.top/imgimage-20211109164852530.png" alt="image-20211109164852530"></p>
<p>尝试把这行代码修改或注释掉??</p>
<p>试一下!!!!</p>
<p>我们只看第20帧</p>
<p>原版</p>
<p>joints</p>
<p><img src="https://img.supervj.top/imgimage-20211109180025098.png" alt="image-20211109180025098"></p>
<p> tag_origin</p>
<p><img src="https://img.supervj.top/imgimage-20211109180043306.png" alt="image-20211109180043306"></p>
<p>main_root</p>
<p><img src="https://img.supervj.top/imgimage-20211109180112554.png" alt="image-20211109180112554"></p>
<hr>
<p>注释掉</p>
<p>Joints</p>
<p><img src="https://img.supervj.top/imgimage-20211117095714875.png" alt="image-20211117095714875"></p>
<p>tag_origin</p>
<p><strong><img src="C:\Users\zld\AppData\Roaming\Typora\typora-user-images\image-20211117095734576.png" alt="image-20211117095734576"></strong></p>
<p>main_root</p>
<p><img src="https://img.supervj.top/imgimage-20211117095747465.png" alt="image-20211117095747465"></p>
<p>看这架势似乎没啥问题, 盆骨骨骼的相对位移也有了, 看最后成品</p>
<p><img src="https://img.supervj.top/img%E5%BD%95%E5%88%B6_2021_11_09_17_50_01_925.gif" alt="录制_2021_11_09_17_50_01_925"></p>
<p>基本效果达到预期了, 这个只是为了测试而注释的, 这段代码最终的目的是解决形态不一致的骨架的匹配问题, 必须保留, 那么可以考虑加入额外的编辑器扩展选项, 这个坑略大, 暂时不讨论了</p>
<h2 id="魔改代码"><a href="#魔改代码" class="headerlink" title="魔改代码"></a>魔改代码</h2><p>脑洞大开魔改一下相关代码, 在Rig类中的Nodes数据结构中加入两个属性, 看下图</p>
<p><img src="https://img.supervj.top/imgimage-20211110105139099.png" alt="image-20211110105139099"></p>
<p><img src="https://img.supervj.top/imgimage-20211110104850681.png" alt="image-20211110104850681"></p>
<blockquote>
<p>属性界面使用了自定义的类, 在RigDetails中</p>
</blockquote>
<p>然后在关键地方加个判断</p>
<p><img src="https://img.supervj.top/imgimage-20211110104906603.png" alt="image-20211110104906603"></p>
<p>然后就可以自定义这个缩放比例了,  虽然也没多大鸟用</p>
<a name = "retargetMode">

<h2 id="重定向模式"><a href="#重定向模式" class="headerlink" title="重定向模式"></a>重定向模式</h2><p>在FAnimationRuntime::RetargetBoneTransform中使用, 该函数在Runtime下持续调用, 此坑先留着, 以后待填</p>
<h2 id="补充要点"><a href="#补充要点" class="headerlink" title="补充要点"></a>补充要点</h2><h3 id="特殊情况讨论"><a href="#特殊情况讨论" class="headerlink" title="特殊情况讨论"></a>特殊情况讨论</h3><ol>
<li>新骨架拥有旧骨架没有的骨骼, 那么第一步获取模型空间的变换信息的时候这些新骨架旧是Identify</li>
<li>从Rig如果找不到父节点, 那么模型空间的动画数据旧直接使用局部数据</li>
</ol>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4骨骼共享插件AnimationSharingPlugin</title>
    <url>/2021/01/08/%E9%AA%A8%E9%AA%BC%E5%85%B1%E4%BA%AB%E6%8F%92%E4%BB%B6_AnimationSharingPlugin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>从遥远的2019年搬运而来, 作为记录, 不确定是否有更新</p>
</blockquote>
<p><a href="https://docs.unrealengine.com/zh-CN/Engine/Animation/AnimationSharing/index.html">官方文档</a></p>
<ul>
<li>引用文档的结构图</li>
</ul>
<p><img src="https://img.supervj.top//img/AnimSharingDiagram-1.jpg" alt="Alt text"></p>
<ul>
<li> 插件已经启用，如果关闭到插件栏启用</li>
</ul>
<span id="more"></span>

<h2 id="Setup文件"><a href="#Setup文件" class="headerlink" title="Setup文件"></a>Setup文件</h2><p><img src="https://img.supervj.top//img/AnimSharingSetup.jpg" alt="Alt text"></p>
<p><img src="https://img.supervj.top//img/NewAnimSharingAsset.jpg" alt="Alt text"></p>
<ul>
<li>简单配置以后如下图</li>
</ul>
<p><img src="https://img.supervj.top//img/image-20191223145213446.png" alt="image-20191223145213446"></p>
<ul>
<li>一个SkeltonSetup数据在UAnimationSharingManager::Register方法里会生成一个<strong>UObject&lt;UAnimationSharingInstance*&gt;</strong>,这个UObj会spawn一个场景里的<strong>单例Actor</strong>，同时存放所有实例对象以及对应的所有参数；这个Actor会根据上图中AnimationStates的数据量创建若干USkeletalMeshComponent维护动画</li>
</ul>
<h2 id="AnimationBlurprintForBlending-图中的ABP-Trans"><a href="#AnimationBlurprintForBlending-图中的ABP-Trans" class="headerlink" title="AnimationBlurprintForBlending(图中的ABP_Trans)"></a>AnimationBlurprintForBlending(图中的ABP_Trans)</h2><p><img src="https://img.supervj.top//img/image-20191223145517613.png" alt="image-20191223145517613"></p>
<ul>
<li>这个蓝图简单理解为用于动画切换，owner就是那个Actor单例</li>
<li>逻辑很简单，直接拷贝就可以<img src="https://img.supervj.top//img/image-20191223145820707.png" alt="image-20191223145820707"></li>
</ul>
<h2 id="StateProcessorClass"><a href="#StateProcessorClass" class="headerlink" title="StateProcessorClass"></a>StateProcessorClass</h2><ul>
<li><p><strong>必须配置一个枚举</strong>，对应所有状态，否则无法配置动画（AnimationStates数据）</p>
</li>
<li><p><img src="https://img.supervj.top//img/image-20191223150355965.png" alt="image-20191223150355965"></p>
</li>
<li><p>每隔场景中的实例都会拥有一个对应的Object，一直在Tick得到这个实例的状态，主要逻辑如下</p>
</li>
</ul>
<p><img src="https://img.supervj.top//img/image-20191223150033324.png" alt="image-20191223150033324"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UStatProc::ProcessActorState_Implementation</span><span class="params">(int32&amp; OutState, AActor* InActor, uint8 CurrentState, uint8 OnDemandState, <span class="keyword">bool</span>&amp; bShouldProcess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	ATestShareRole* shareRole = Cast&lt;ATestShareRole&gt;(InActor);</span><br><span class="line">	<span class="keyword">if</span> (shareRole)</span><br><span class="line">	&#123;</span><br><span class="line">		EShareEnum stat = shareRole-&gt;<span class="built_in">GetStat</span>();	</span><br><span class="line">		OutState = <span class="built_in">int32</span>(stat);</span><br><span class="line">		bShouldProcess = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	OutState =<span class="number">-1</span>;</span><br><span class="line">	bShouldProcess = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个函数可以理解为状态的起始点，这个方法决定了每个实例的具体状态枚举，从而才有动画</li>
</ul>
<h2 id="AnimationStates"><a href="#AnimationStates" class="headerlink" title="AnimationStates"></a>AnimationStates</h2><p><img src="https://img.supervj.top//img/image-20191223150551638.png" alt="image-20191223150551638"></p>
<ul>
<li>Processor配置的枚举对应的动画参数</li>
</ul>
<h2 id="AnimBlueprint"><a href="#AnimBlueprint" class="headerlink" title="AnimBlueprint"></a>AnimBlueprint</h2><ul>
<li>用于播放动画序列的简单动画蓝图，继承于AnimSharingStateInstance</li>
</ul>
<p><img src="https://img.supervj.top//img/image-20191223150729515.png" alt="image-20191223150729515"></p>
<p><img src="https://img.supervj.top//img/image-20191223150819957.png" alt="image-20191223150819957"></p>
<ul>
<li>这个ABP只负责播放动画序列，至于专门播放，可以自行扩展</li>
<li><strong>Offset参数用于控制实例动画的差异性</strong>，系统会算，对应的是<strong>NumRandomizedInstances</strong>参数</li>
<li>单例Actor会独立创建<strong>NumRandomizedInstances</strong>数量的SKMesh组件用于控制动画表现，同时设置不同的Offset参数</li>
</ul>
<h3 id="同一个状态设置多个动画"><a href="#同一个状态设置多个动画" class="headerlink" title="同一个状态设置多个动画"></a>同一个状态设置多个动画</h3><p><img src="https://img.supervj.top//img/image-20191223152554826.png" alt="image-20191223152554826"></p>
<ul>
<li>如上图，Idle设置了2个动画，同时对Run动画对应的实例数量设置了<strong>10</strong>，造成的结果是场景中大约是10比1的生成2个动画的实例，其中Run动作的偏移参数也有若干份（根据场景中的实例个数换算比例）</li>
</ul>
<h3 id="OnDemand（指令模式）"><a href="#OnDemand（指令模式）" class="headerlink" title="OnDemand（指令模式）"></a>OnDemand（指令模式）</h3><ul>
<li>简单理解<ul>
<li>如果正在播放的是普通动画，切换到指令模式的动画是瞬间切换</li>
<li>如果现在播放的是指令动画，切换到普通动画需要等指令动画播放完毕</li>
<li>如果前后都是指令动画或者普通动画，都是瞬间切换</li>
</ul>
</li>
</ul>
<h4 id="Additve"><a href="#Additve" class="headerlink" title="Additve"></a>Additve</h4><ul>
<li>基于OnDemand开启以后才能选择的模式</li>
<li>开启以后隐藏了部分Demand选项</li>
<li>开启以后上方的AdditveBlueprint可以设置</li>
</ul>
<h4 id="AddtiveABP"><a href="#AddtiveABP" class="headerlink" title="AddtiveABP"></a>AddtiveABP</h4><p><img src="https://img.supervj.top//img/image-20191223160102804.png" alt="image-20191223160102804"></p>
<p><img src="https://img.supervj.top//img/image-20191223160046344.png" alt="image-20191223160046344"></p>
<ul>
<li><p>文档给的方案是如图的连线方式，进入此状态后StateBool就设置为true，开始叠加</p>
</li>
<li><p>Add的最大数量参数如果少于实例数量，部分实例就没有叠加动画<img src="https://img.supervj.top//img/image-20191223160951498.png" alt="image-20191223160951498"></p>
</li>
<li><p>一些思考</p>
<ul>
<li><p>叠加动画多数用于受伤或者姿势上面的扩展</p>
</li>
<li><p>叠加受伤无法用这套方案执行，甚至无法用这个插件执行，ABP无法get到控制实例的状态,下面是头文件所有申明，当然可以魔改掉插件内容</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ANIMATIONSHARING_API</span> <span class="title">FAdditiveAnimationInstance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FAdditiveAnimationInstance</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Initialise</span><span class="params">(USkeletalMeshComponent* InSkeletalMeshComponent, UClass* InAnimationBP)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Setup</span><span class="params">(USkeletalMeshComponent* InBaseComponent, UAnimSequence* InAnimSequence)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateBaseComponent</span><span class="params">(USkeletalMeshComponent* InBaseComponent)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">USkeletalMeshComponent* <span class="title">GetComponent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">USkeletalMeshComponent* <span class="title">GetBaseComponent</span><span class="params">()</span> <span class="keyword">const</span></span>;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	USkeletalMeshComponent * SkeletalMeshComponent;</span><br><span class="line">	UAnimSharingAdditiveInstance* AdditiveInstance;</span><br><span class="line">	UAnimSequence* AdditiveAnimationSequence;</span><br><span class="line">	USkeletalMeshComponent* BaseComponent;</span><br><span class="line">	<span class="keyword">bool</span> bLoopingState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>姿势扩展比如Idle叠加一些额外动作可以使用这一套方案，但是，有必要用专门一个枚举来提供这个动作？？</p>
</li>
<li><p>一个的方案是提供接口可以得到控制实例的状态，但是跨度有点大，可能会有更多没想到的问题</p>
</li>
</ul>
<h2 id="Bug-缺陷"><a href="#Bug-缺陷" class="headerlink" title="Bug/缺陷"></a>Bug/缺陷</h2><ul>
<li><p>Demand动画设置了大于0的BlendTime，如果在BlendTime期间切换了，Demand动画大概率出不去；怀疑是普通动画等待Demand动画结束的通知跟动画本身结束的时间点发生时间方面的错误</p>
<ul>
<li>多次测试发现，2个动画（无所谓是否Demand）发生混合，要么都设置BlendTime=0，要么都设置非0切相等，则不会发生卡顿或者卡住；如果参数不一样，会发生切换的时候卡顿</li>
</ul>
</li>
<li><p>特殊情况，demand情况下的<strong>ReturnToPreviousStat</strong>（结束以后返回之前的状态）或者<strong>SetNextState</strong>（结束以后进入下一个指定状态）有问题;参考Processor的默认代码如下</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UStatProc::ProcessActorState_Implementation</span><span class="params">(int32&amp; OutState, AActor* InActor, uint8 CurrentState, uint8 OnDemandState, <span class="keyword">bool</span>&amp; bShouldProcess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	ATestShareRole* shareRole = Cast&lt;ATestShareRole&gt;(InActor);</span><br><span class="line">	<span class="keyword">if</span> (shareRole)</span><br><span class="line">	&#123;</span><br><span class="line">		EShareEnum stat = shareRole-&gt;<span class="built_in">GetStat</span>();</span><br><span class="line">		OutState = <span class="built_in">int32</span>(stat);</span><br><span class="line">		bShouldProcess = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	OutState =<span class="number">-1</span>;</span><br><span class="line">	bShouldProcess = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解释：</p>
<ul>
<li><p>发起点是Actor中自己维护的<strong>状态枚举</strong>，通过设置到OutState然后引起一系列的动画计算和播放，然后下一帧才会通过2个uint8反馈过来</p>
</li>
<li><p>如果用默认方案，ReturnToPreviousStat等方式在动画最后一帧确实把动画的状态设置了，但是第二帧又被Actor的状态给覆盖了</p>
</li>
<li><p>解决方案是如果是特殊情况（ReturnToPreviousStat或者SetNextState），需要反向设置Actor的状态枚举，但是默认没法得到这个特殊情况变量，而且反向设置可能会导致一系列的问题</p>
<blockquote>
<p> manager里面的有一个每个骨骼的对应的Instance数据是Protected的，也没有方法可以拿到</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AnimationSharingManager.h</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//***//</span></span><br><span class="line">	<span class="comment">/** Sharing data required for the unique Skeleton setups */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, Transient, Category = AnimationSharing)</span><br><span class="line">	TArray&lt;UAnimSharingInstance*&gt; PerSkeletonData;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这个数据里面每个UAnimaSharingInstance里有所有Setup数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Actors currently registered to be animation driven by the AnimManager using this setup */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, Transient, Category = AnimationSharing)</span><br><span class="line">	TArray&lt;AActor*&gt; RegisteredActors;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Per actor data, matches RegisteredActors*/</span></span><br><span class="line">	TArray&lt;FPerActorData&gt; PerActorData;</span><br><span class="line">	<span class="comment">/** Per component state data indexed from FPerActorData.ComponentIndices */</span></span><br><span class="line">	TArray&lt;FPerComponentData&gt; PerComponentData;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Array of unique state data */</span></span><br><span class="line">	TArray&lt;FPerStateData&gt; PerStateData;</span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>GAS调试插件：GASDebugger</title>
    <url>/2025/07/30/GASDebugger/</url>
    <content><![CDATA[<h2 id="GASDebugger-使用说明"><a href="#GASDebugger-使用说明" class="headerlink" title="GASDebugger 使用说明"></a>GASDebugger 使用说明</h2><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250730090056559.png" alt="image-20250730090056559"></p>
<p>如上图，GAS自带的DebugUI很不好用</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250730090631212.png" alt="image-20250730090631212"></p>
<p>以上是GASDebugger界面</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250730090750687.png" alt="image-20250730090750687"></p>
<p>在windows页面下的底部会有启动按钮</p>
<p>游戏运行以后，插件会尝试自动识别场景内拥有技能组件的玩家，如没有识别到或者玩家类是延迟创建的，那需要手动选择一下（可以选择所有对象包括怪物）</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250730090958728.png" alt="image-20250730090958728"></p>
<p>选中以后即可实时监听GAS数据</p>
<h3 id="游戏设置"><a href="#游戏设置" class="headerlink" title="游戏设置"></a>游戏设置</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250730113353230.png" alt="image-20250730113353230"></p>
<p>在ProjectSettings-&gt;Game中有GASDebugger的游戏设置</p>
<ul>
<li>Debugger Widget： 需要手动设置为 EU_GASDebuggerMain，这个是实际启动的蓝图EditorWidget</li>
<li>Enable Logging: 如果开启，那么会开启本地日志文件的保存功能</li>
<li>AttributeLogUpdateFrequency： 属性更新频率，如果是0那么每次更新都会记录到日志</li>
<li>AttributeLogDecimalPrecision： 属性保留小数位数</li>
</ul>
<h3 id="日志功能"><a href="#日志功能" class="headerlink" title="日志功能"></a>日志功能</h3><p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250730113824558.png" alt="image-20250730113824558"></p>
<p>通过上图按钮打开日志目录</p>
<p>每次一次在关闭PIE的时候会生成一个日志文件夹</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250730113920632.png" alt="image-20250730113920632"></p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250730113932477.png" alt="image-20250730113932477"></p>
<p>All中保存了所有其他4种类型的日志</p>
<p><img src="https://raw.githubusercontent.com/VJien/img/master/imgimage-20250730114009959.png" alt="image-20250730114009959"></p>
]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>gas</tag>
      </tags>
  </entry>
</search>
